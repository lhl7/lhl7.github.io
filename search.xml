<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>正则表达式简单笔记</title>
      <link href="/2022/01/23/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/01/23/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>python中可以通过<code>import re</code>引入re模块，用正则表达式处理字符串</p><h2 id="一、正则表达式"><a href="#一、正则表达式" class="headerlink" title="一、正则表达式"></a>一、正则表达式</h2><p><strong>在线正则表达式测试工具：<a href="https://regex101.com/">https://regex101.com/</a></strong></p><h3 id="1、限定符"><a href="#1、限定符" class="headerlink" title="1、限定符"></a>1、限定符</h3><h4 id="匹配单字符"><a href="#匹配单字符" class="headerlink" title="匹配单字符"></a>匹配单字符</h4><p><strong>? 限定符</strong>：通过<code>used？</code>可匹配<code>use</code>或<code>used</code>,等含有<code>use</code>字样，<code>d</code>可有可无；</p><p>*<strong>限定符</strong>：通过<code>ab*c</code>可以匹配 <code>ac abc abbbbc</code>等含有n个b，ac必须按照顺序有的字符串；</p><p><strong>+限定符</strong>：即*限定符除去没有b的情况，<code>ab</code>不会被匹配；</p><p><strong>{n}限定符</strong>：<code>ab&#123;6&#125;c</code>可匹配b出现次数为6的情况，或者，{2,6}为2-6次，{2,}为两次以上</p><h4 id="匹配多字符"><a href="#匹配多字符" class="headerlink" title="匹配多字符"></a>匹配多字符</h4><p>使用 **()**框选所要匹配的字符，然后正常使用限定符。</p><h3 id="2、“或”运算符"><a href="#2、“或”运算符" class="headerlink" title="2、“或”运算符"></a>2、“或”运算符</h3><p>正则表达式要匹配 <code>acat</code>或者 <code>adog</code>时，可以使用或运算符，表达式如下：</p><p><code>a(cat|dog)</code></p><h3 id="3、字符类"><a href="#3、字符类" class="headerlink" title="3、字符类"></a>3、字符类</h3><p><strong>[] 匹配符</strong>：</p><p>如果想匹配ab三个字母组成的内容，可以使用 <code>[abc]+</code>;</p><p>其中<code>[]</code>用于限制匹配的字符；</p><p>在方括号中，我们可以指定范围，语法如 <code>[a-zA-Z]</code>即大小写所有英文字符；</p><p><strong>^匹配：</strong></p><p>和方括号联用，<code>[^0-9]+</code>代表非数字</p><h3 id="4、元字符"><a href="#4、元字符" class="headerlink" title="4、元字符"></a>4、元字符</h3><p>元字符是正则表达式预先定义好的内容</p><table><thead><tr><th>符号</th><th>释义</th><th>解释</th></tr></thead><tbody><tr><td>\d+</td><td>数字字符</td><td>等同于[0-9]</td></tr><tr><td>\w+</td><td>单词字符</td><td>英文、数字、下划线</td></tr><tr><td>\s+</td><td>空白符</td><td>TAB和换行符（空格）</td></tr><tr><td>\D+</td><td>非数字字符</td><td></td></tr><tr><td>\W+</td><td>非单词字符</td><td></td></tr><tr><td>\S+</td><td>非空白字符</td><td></td></tr><tr><td>\b</td><td>单词边界</td><td>\b的前一个字符和后一个字符不全是\w</td></tr><tr><td>.*</td><td>任意字符</td><td>不包含换行符</td></tr></tbody></table><p>注：</p><p>**+**为匹配多个连接的字符，而非一个一个单独匹配</p><table><thead><tr><th>特殊字符</th><th>释义</th><th>解释</th></tr></thead><tbody><tr><td>^</td><td>匹配行首</td><td>如^a,只会匹配行首的a，而非所有a</td></tr><tr><td>$</td><td>匹配行尾</td><td>如$a,只会匹配行尾的a，而非所有a</td></tr></tbody></table><h3 id="5、贪婪与懒惰匹配"><a href="#5、贪婪与懒惰匹配" class="headerlink" title="5、贪婪与懒惰匹配"></a>5、贪婪与懒惰匹配</h3><p>正则表达式默认使用的是贪婪匹配；</p><p>即，当出现较大的字符能被一次匹配时，忽略其包含的较小的字符，优先匹配较大的字符，试举一例，当我们尝试匹配html标签，匹配内容如下：<br><code>&lt;span&gt;&lt;b&gt;this is a text&lt;/b&gt;&lt;/span&gt;</code></p><p>我们可能会使用 <code>&lt;.+&gt;</code>进行匹配：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220123111221372.png" alt="image-20220123111221372"></p><p>正则默认选择了最贪婪的匹配方法。</p><p>我们可以手动切换贪婪匹配为懒惰匹配，使用 <code>&lt;.+?&gt;</code>进行匹配：<br><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220123111350484.png" alt="image-20220123111350484"></p><h3 id="6、优秀教程"><a href="#6、优秀教程" class="headerlink" title="6、优秀教程"></a>6、优秀教程</h3><h2 id="二、正则表达式的使用"><a href="#二、正则表达式的使用" class="headerlink" title="二、正则表达式的使用"></a>二、正则表达式的使用</h2><h4 id="1、"><a href="#1、" class="headerlink" title="1、. ^ $"></a>1、. ^ $</h4><table><thead><tr><th>正则</th><th>待匹配字符</th><th>匹配结果</th><th>说明</th></tr></thead><tbody><tr><td>a.</td><td>abacad</td><td>abacad</td><td>匹配所有”a.”的字符</td></tr><tr><td>^a.</td><td>abacad</td><td>ab</td><td>只从开头匹配”a.”</td></tr><tr><td>a.$</td><td>abacad</td><td>ad</td><td>只匹配结尾的”a.$”</td></tr></tbody></table><h4 id="2、"><a href="#2、" class="headerlink" title="2、* + ? { }"></a>2、* + ? { }</h4><table><thead><tr><th>正则</th><th>待匹配字符</th><th>匹配结果</th><th>说明</th></tr></thead><tbody><tr><td>a.?</td><td>abefacgad</td><td>ab ac ad</td><td>?表示重复零次或一次，即只匹配”a”后面一个任意字符。</td></tr><tr><td>a.*</td><td>abefacgad</td><td>abefacgad</td><td>*表示重复零次或多次，即匹配”a”后面0或多个任意字符。</td></tr><tr><td>a.+</td><td>abefacgad</td><td>abefacgad</td><td>+表示重复一次或多次，即只匹配”a”后面1个或多个任意字符。</td></tr><tr><td>a.{1,2}</td><td>abefacgad</td><td>abe acg ad</td><td>{1,2}匹配1到2次任意字符。</td></tr></tbody></table><p>注意：前面的*,+,?等都是贪婪匹配，也就是尽可能匹配，后面加?号使其变成惰性匹配</p><table><thead><tr><th>正则</th><th>待匹配字符</th><th>匹配结果</th><th>说明</th></tr></thead><tbody><tr><td>a.*?</td><td>abefacgad</td><td>a a a</td><td>惰性匹配</td></tr></tbody></table><h4 id="3、字符集［］［-］"><a href="#3、字符集［］［-］" class="headerlink" title="3、字符集［］［^］"></a>3、字符集［］［^］</h4><table><thead><tr><th>正则</th><th>待匹配字符</th><th>匹配结果</th><th>说明</th></tr></thead><tbody><tr><td>a[befcgd]*</td><td>abefacgad</td><td>abef acg ad</td><td>表示匹配”a”后面[befcgd]的字符任意次`</td></tr><tr><td>a[^f]*</td><td>abefacgad</td><td>abe acgad</td><td>表示匹配一个不是”f”的字符任意次</td></tr><tr><td>[\d]</td><td>412a3bc</td><td>4 1 2 3</td><td>表示匹配任意一个数字，匹配到4个结果</td></tr><tr><td>[\d]+</td><td>412a3bc</td><td>412 3</td><td>表示匹配任意个数字，匹配到2个结果</td></tr></tbody></table><h4 id="4、分组-与-或-｜［-］"><a href="#4、分组-与-或-｜［-］" class="headerlink" title="4、分组 ()与 或 ｜［^］"></a>4、分组 ()与 或 ｜［^］</h4><p>　　身份证号码是一个长度为15或18个字符的字符串，如果是15位则全部由数字组成，首位不能为0；如果是18位，则前17位全部是数字，末位可能是数字或x，下面我们尝试用正则来表示：</p><table><thead><tr><th>正则</th><th>待匹配字符</th><th>匹配结果</th><th>说明</th></tr></thead><tbody><tr><td>^[1-9]\d{13,16}[0-9x]$</td><td>110101198001017032</td><td>110101198001017032</td><td>表示可以匹配一个正确的身份证号</td></tr><tr><td>^[1-9]\d{13,16}[0-9x]$</td><td>1101011980010170</td><td>1101011980010170</td><td>表示也可以匹配这串数字，但这并不是一个正确的身份证号码，它是一个16位的数字</td></tr><tr><td>^[1-9]\d{14}(\d{2}[0-9x])?$</td><td>1101011980010170</td><td>False</td><td>现在不会匹配错误的身份证号了()表示分组，将\d{2}[0-9x]分成一组，就可以整体约束他们出现的次数为0-1次</td></tr><tr><td>^([1-9]\d{16}[0-9x]|[1-9]\d{14})$</td><td>110105199812067023</td><td>110105199812067023</td><td>表示先匹配[1-9]\d{16}[0-9x]如果没有匹配上就匹配[1-9]\d{14}</td></tr></tbody></table><h4 id="5、转义符"><a href="#5、转义符" class="headerlink" title="5、转义符 \"></a>5、转义符 \</h4><p>　　在正则表达式中，有很多有特殊意义的是元字符，比如\n和\s等，如果要在正则中匹配正常的”\n”而不是”换行符”就需要对”&quot;进行转义，变成’\‘。</p><p>　　在python中，无论是正则表达式，还是待匹配的内容，都是以字符串的形式出现的，在字符串中\也有特殊的含义，本身还需要转义。所以如果匹配一次”\n”,字符串中要写成’\n’，那么正则里就要写成”\\n”,这样就太麻烦了。这个时候我们就用到了r’\n’这个概念，此时的正则是r’\n’就可以了。</p><table><thead><tr><th>正则</th><th>待匹配字符</th><th>匹配 结果</th><th>说明</th></tr></thead><tbody><tr><td>\n</td><td>\n</td><td>False</td><td>因为在正则表达式中\是有特殊意义的字符，所以要匹配\n本身，用表达式\n无法匹配</td></tr><tr><td>\n</td><td>\n</td><td>True</td><td>转义\之后变成\，即可匹配</td></tr><tr><td>“\\n”</td><td>‘\n’</td><td>True</td><td>如果在python中，字符串中的’&#39;也需要转义，所以每一个字符串’&#39;又需要转义一次</td></tr><tr><td>r’\n’</td><td>r’\n’</td><td>True</td><td>在字符串之前加r，让整个字符串不转义</td></tr></tbody></table><h4 id="6、贪婪匹配"><a href="#6、贪婪匹配" class="headerlink" title="6、贪婪匹配"></a>6、贪婪匹配</h4><p>贪婪匹配：在满足匹配时，匹配尽可能长的字符串，默认情况下，采用贪婪匹配</p><table><thead><tr><th>正则</th><th>待匹配字符</th><th>匹配结果</th><th>说明</th></tr></thead><tbody><tr><td>&lt;.*&gt;</td><td><script>...<script></td><td><script>...<script></td><td>默认为贪婪匹配模式，会匹配尽量长的字符串</td></tr><tr><td>&lt;.*?&gt;</td><td><script>...<script></td><td><script> <script></td><td>加上？为将贪婪匹配模式转为非贪婪匹配模式，会匹配尽量短的字符串</td></tr></tbody></table><p>几个常用的非贪婪匹配Pattern</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*? 重复任意次，但尽可能少重复</span><br><span class="line">+? 重复1次或更多次，但尽可能少重复</span><br><span class="line">?? 重复0次或1次，但尽可能少重复</span><br><span class="line">&#123;n,m&#125;? 重复n到m次，但尽可能少重复</span><br><span class="line">&#123;n,&#125;? 重复n次以上，但尽可能少重复</span><br></pre></td></tr></table></figure><p>.*?的用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">. 是任意字符</span><br><span class="line">* 是取 0 至 无限长度</span><br><span class="line">? 是非贪婪模式。</span><br><span class="line">何在一起就是 取尽量少的任意字符，一般不会这么单独写，他大多用在：</span><br><span class="line">.*?x</span><br><span class="line">就是取前面任意长度的字符，直到一个x出现</span><br></pre></td></tr></table></figure><p>本部分摘自：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界Reverse进阶区-BABYHOOK-writeup</title>
      <link href="/2022/01/22/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse%E8%BF%9B%E9%98%B6%E5%8C%BA-BABYHOOK-writeup/"/>
      <url>/2022/01/22/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse%E8%BF%9B%E9%98%B6%E5%8C%BA-BABYHOOK-writeup/</url>
      
        <content type="html"><![CDATA[<h1 id="攻防世界Reverse进阶区-流浪者-writeup"><a href="#攻防世界Reverse进阶区-流浪者-writeup" class="headerlink" title="攻防世界Reverse进阶区-流浪者-writeup"></a>攻防世界Reverse进阶区-流浪者-writeup</h1><p>本题为较为基础的Hook题，通过本writeup来整理一下思路。</p><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220122143740757.png" alt="image-20220122143740757"></p><p>进入程序，首先确定<code>flag</code>字符串长度为<strong>19</strong>；</p><p>然后发现程序会将输入内容写入文件名为文件<strong>Your_input</strong>的文件；</p><p>最后通过核验<strong>NumberOfBytesWritten</strong>变量是否为1来控制输出；</p><p>此时，若进入<strong>sub_401240</strong>函数就会中计，需手动进行测试。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220122144439005.png" alt="image-20220122144439005"></p><p>手动测试后发现输出文件中的内容和输入完全不同，推测可能在<strong>sub_401220</strong>函数中对输入进行了加密。</p><h2 id="sub-401220函数："><a href="#sub-401220函数：" class="headerlink" title="sub_401220函数："></a>sub_401220函数：</h2><p>进入<strong>sub_401220</strong>函数：（为<code>hook</code>关键函数）</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220122144907695.png" alt="image-20220122144907695"></p><p>其主要内容如下（1~14行）：</p><blockquote><p>获取当前进程号，打开进程到hprocess,libfilename为一常量kernel32.dll，procname为一常量writefile,故dword_409c4（*WriteFile_0位置)、lpaddress所存为writefile的地址，然后程序复制了lpaddress的地址到unk_40c9b4。</p></blockquote><p>然后开始hook操作（15、16行）：</p><p>可以看到第15行有一常量被存入地址<code>40C9BC</code>，H键转化为十六进制 <strong>0xE9</strong></p><p>然后在地址<code>40C9BD</code>存入了函数<code>sub_401080</code>与IpAdress的距离再减去5，即<code>sub_401080</code>与WriteFile函数的距离。</p><p>总结来说，将writeFile函数的前五个字节替换为了跳转到<code>sub_401080</code>的语句。</p><p>回到main函数后，在调用<code>WriteFile</code>函数时，实际调用的是<code>sub_401080</code>，因此进入<code>sub_401080</code>：</p><h2 id="sub-401080函数："><a href="#sub-401080函数：" class="headerlink" title="sub_401080函数："></a>sub_401080函数：</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220122152116398.png" alt="image-20220122152116398"></p><p>可以看到，此函数内容为，先调用<code>sub_401000</code>，返回值V5；</p><p>然后再在内部调用WriteFile函数；</p><p>最终根据V5的值，判断第四个指针参数<em>lpNumberOfBytesWritten的值，此处的</em>lpNumberOfBytesWritten参数，即对应main函数中的NumberOfBytesWritten关键参数。</p><p>因此，推测<code>sub_401000</code>函数为对于输入的核心判断函数，步入查看：</p><h2 id="sub-401000函数："><a href="#sub-401000函数：" class="headerlink" title="sub_401000函数："></a>sub_401000函数：</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220122153313662.png" alt="image-20220122153313662"></p><p>输入为a1；a2为固定值19；</p><p>然后下面的逻辑简单的说就是先加密a1，然后比较数组a1每一位的值和储存在 <strong>byte_40A030</strong>处每一位的值。</p><p>直接逆向分析函数思路，发现奇数位是通过本位推导，但偶数位是通过高位推导，因此第0位是无法被推导出的，而18位可以被推导出两次:</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220122164546365.png" alt="image-20220122164546365"></p><p>脚本如上：猜测第一位是<code>f</code>字符，最终正确。</p><h2 id="汇编跳转函数的总结："><a href="#汇编跳转函数的总结：" class="headerlink" title="汇编跳转函数的总结："></a>汇编跳转函数的总结：</h2><p><a href="https://lhl7.github.io/2022/01/22/%E6%B1%87%E7%BC%96%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93/">https://lhl7.github.io/2022/01/22/%E6%B1%87%E7%BC%96%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编跳转指令及其十六进制码</title>
      <link href="/2022/01/22/%E6%B1%87%E7%BC%96%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2022/01/22/%E6%B1%87%E7%BC%96%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编跳转指令及其十六进制码"><a href="#汇编跳转指令及其十六进制码" class="headerlink" title="汇编跳转指令及其十六进制码"></a>汇编跳转指令及其十六进制码</h1><p>几种跳转指令和对应的机器码：<br>0xE8 CALL后面的四个字节是地址<br>0xE9 JMP后面的四个字节是偏移<br>0xEB JMP后面的二个字节是偏移<br>0xFF15 CALL后面的四个字节是存放地址的地址<br>0xFF25 JMP后面的四个字节是存放地址的地址<br>0x68 PUSH后面的四个字节入栈<br>0x6AP USH后面的一个字节入栈</p><p>————————————————<br>版权声明：本文为CSDN博主「hincon」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/ccworm/article/details/112787439">https://blog.csdn.net/ccworm/article/details/112787439</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界Reverse进阶区-BABYRE-writeup</title>
      <link href="/2022/01/18/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse%E8%BF%9B%E9%98%B6%E5%8C%BA-BABYRE-writeup/"/>
      <url>/2022/01/18/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse%E8%BF%9B%E9%98%B6%E5%8C%BA-BABYRE-writeup/</url>
      
        <content type="html"><![CDATA[<h1 id="攻防世界Reverse进阶区-BABYRE-writeup"><a href="#攻防世界Reverse进阶区-BABYRE-writeup" class="headerlink" title="攻防世界Reverse进阶区-BABYRE-writeup"></a>攻防世界Reverse进阶区-BABYRE-writeup</h1><p>以此篇WP记录第一次使用ida解决smc（自解密）</p><p>观察反汇编代码：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220118144411257.png" alt="image-20220118144411257"></p><p>第12行调用的函数在第8行被加密了</p><p>因此，需要手动解密观察，双击judge进入：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220118144605050.png" alt="image-20220118144605050"></p><p>然后使用idapython脚本解决，右上角file、script command</p><p>如图编写代码：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220118144725867.png" alt="image-20220118144725867"></p><p>点击run，可以看到内容被改变：</p><p>选中judge函数一行，c（code），将其变成代码，这时的judge被分为三个函数，我们将其合三为1，框选地址<code>B00~BB5</code>（所有红色区域），p（重新生成function）</p><p>此时可以在左侧找到相应函数内容，F5即可</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220118145127875.png" alt="image-20220118145127875"></p><p>然后针对反汇编后的加密算法写一个脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v2=[<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="number">127</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;;&#x27;</span>,<span class="string">&#x27;V&#x27;</span>,<span class="string">&#x27;`&#x27;</span>,<span class="string">&#x27;;&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;p&#x27;</span>]</span><br><span class="line">an=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">14</span>):</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">4</span>:</span><br><span class="line">        an+=<span class="built_in">chr</span>(<span class="number">127</span>^i)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    an+=<span class="built_in">chr</span>(<span class="built_in">ord</span>(v2[i])^i)</span><br><span class="line"><span class="built_in">print</span>(an)</span><br></pre></td></tr></table></figure><p>运行结果为：flag{n1c3_j0b}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界Reverse进阶区-流浪者-writeup</title>
      <link href="/2022/01/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse%E8%BF%9B%E9%98%B6%E5%8C%BA-%E6%B5%81%E6%B5%AA%E8%80%85-writeup/"/>
      <url>/2022/01/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CReverse%E8%BF%9B%E9%98%B6%E5%8C%BA-%E6%B5%81%E6%B5%AA%E8%80%85-writeup/</url>
      
        <content type="html"><![CDATA[<h1 id="攻防世界Reverse进阶区-流浪者-writeup"><a href="#攻防世界Reverse进阶区-流浪者-writeup" class="headerlink" title="攻防世界Reverse进阶区-流浪者-writeup"></a>攻防世界Reverse进阶区-流浪者-writeup</h1><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220117123155980.png" alt="image-20220117123155980"></p><p><strong>关键函数1：sub_401890</strong></p><p>调用了另一个函数</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220117123309787.png" alt="image-20220117123309787"></p><p><strong>关键函数2：sub_4017F0</strong></p><p>先传入关键函数1进行加密，加密后进入函数2进行进一步加密，最后与<code>kanXue...</code>字符串对比查验</p><p>逆向脚本书写逻辑即可</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220117123519559.png" alt="image-20220117123519559"></p><p>最终运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220117123544490.png" alt="image-20220117123544490"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python笔记</title>
      <link href="/2022/01/16/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
      <url>/2022/01/16/python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="python笔记"><a href="#python笔记" class="headerlink" title="python笔记"></a>python笔记</h1><p>Python3 中有六个标准的数据类型：</p><ul><li>Number（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Set（集合）</li><li>Dictionary（字典）</li></ul><p>Python3 的六个标准数据类型中：</p><ul><li><p><strong>不可变数据（3 个）：</strong>Number（数字）、String（字符串）、Tuple（元组）；</p></li><li><p><strong>可变数据（3 个）：</strong>List（列表）、Dictionary（字典）、Set（集合）。</p></li><li><h2 id="Python数据类型转换"><a href="#Python数据类型转换" class="headerlink" title="Python数据类型转换"></a>Python数据类型转换</h2><p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可，在下一章节 <a href="https://www.runoob.com/python3/python3-type-conversion.html">Python3 数据类型转换</a> 会具体介绍。</p><p>以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。</p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[int(x <a href="https://www.runoob.com/python3/python-func-int.html">,base])</a></td><td align="left">将x转换为一个整数</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-float.html">float(x)</a></td><td align="left">将x转换到一个浮点数</td></tr><tr><td align="left">[complex(real <a href="https://www.runoob.com/python3/python-func-complex.html">,imag])</a></td><td align="left">创建一个复数</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-str.html">str(x)</a></td><td align="left">将对象 x 转换为字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-repr.html">repr(x)</a></td><td align="left">将对象 x 转换为表达式字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-eval.html">eval(str)</a></td><td align="left">用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-tuple.html">tuple(s)</a></td><td align="left">将序列 s 转换为一个元组</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(s)</a></td><td align="left">将序列 s 转换为一个列表</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-set.html">set(s)</a></td><td align="left">转换为可变集合</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-dict.html">dict(d)</a></td><td align="left">创建一个字典。d 必须是一个 (key, value)元组序列。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-frozenset.html">frozenset(s)</a></td><td align="left">转换为不可变集合</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-chr.html">chr(x)</a></td><td align="left">将一个整数转换为一个字符</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-ord.html">ord(x)</a></td><td align="left">将一个字符转换为它的整数值</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-hex.html">hex(x)</a></td><td align="left">将一个整数转换为一个十六进制字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-oct.html">oct(x)</a></td><td align="left">将一个整数转换为一个八进制字符串</td></tr></tbody></table></li></ul><h2 id="一、字符串"><a href="#一、字符串" class="headerlink" title="一、字符串"></a>一、字符串</h2><p>与 C 字符串不同的是，Python 字符串不能被改变。向一个索引位置赋值，比如word[0] = ‘m’会导致错误。</p><p>Python 的字符串常用内建函数如下：</p><table><thead><tr><th align="left">序号</th><th align="left">方法及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-capitalize.html">capitalize()</a> 将字符串的第一个字符转换为大写</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-center.html">center(width, fillchar)</a>返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-count.html">count(str, beg= 0,end=len(string))</a> 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-decode.html">bytes.decode(encoding=”utf-8”, errors=”strict”)</a> Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-encode.html">encode(encoding=’UTF-8’,errors=’strict’)</a> 以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-endswith.html">endswith(suffix, beg=0, end=len(string))</a> 检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-expandtabs.html">expandtabs(tabsize=8)</a> 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-find.html">find(str, beg=0, end=len(string))</a> 检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-index.html">index(str, beg=0, end=len(string))</a> 跟find()方法一样，只不过如果str不在字符串中会报一个异常。</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isalnum.html">isalnum()</a> 如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False</td></tr><tr><td align="left">11</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isalpha.html">isalpha()</a> 如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isdigit.html">isdigit()</a> 如果字符串只包含数字则返回 True 否则返回 False..</td></tr><tr><td align="left">13</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-islower.html">islower()</a> 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td></tr><tr><td align="left">14</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isnumeric.html">isnumeric()</a> 如果字符串中只包含数字字符，则返回 True，否则返回 False</td></tr><tr><td align="left">15</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isspace.html">isspace()</a> 如果字符串中只包含空白，则返回 True，否则返回 False.</td></tr><tr><td align="left">16</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-istitle.html">istitle()</a> 如果字符串是标题化的(见 title())则返回 True，否则返回 False</td></tr><tr><td align="left">17</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isupper.html">isupper()</a> 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td></tr><tr><td align="left">18</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-join.html">join(seq)</a> 以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td></tr><tr><td align="left">19</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-len.html">len(string)</a> 返回字符串长度</td></tr><tr><td align="left">20</td><td align="left">[ljust(width<a href="https://www.runoob.com/python3/python3-string-ljust.html">, fillchar])</a> 返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。</td></tr><tr><td align="left">21</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-lower.html">lower()</a> 转换字符串中所有大写字符为小写.</td></tr><tr><td align="left">22</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-lstrip.html">lstrip()</a> 截掉字符串左边的空格或指定字符。</td></tr><tr><td align="left">23</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-maketrans.html">maketrans()</a> 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</td></tr><tr><td align="left">24</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-max.html">max(str)</a> 返回字符串 str 中最大的字母。</td></tr><tr><td align="left">25</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-min.html">min(str)</a> 返回字符串 str 中最小的字母。</td></tr><tr><td align="left">26</td><td align="left">[replace(old, new <a href="https://www.runoob.com/python3/python3-string-replace.html">, max])</a> 把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。</td></tr><tr><td align="left">27</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-rfind.html">rfind(str, beg=0,end=len(string))</a> 类似于 find()函数，不过是从右边开始查找.</td></tr><tr><td align="left">28</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-rindex.html">rindex( str, beg=0, end=len(string))</a> 类似于 index()，不过是从右边开始.</td></tr><tr><td align="left">29</td><td align="left">[rjust(width,<a href="https://www.runoob.com/python3/python3-string-rjust.html">, fillchar])</a> 返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串</td></tr><tr><td align="left">30</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-rstrip.html">rstrip()</a> 删除字符串末尾的空格或指定字符。</td></tr><tr><td align="left">31</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-split.html">split(str=””, num=string.count(str))</a> 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串</td></tr><tr><td align="left">32</td><td align="left">[splitlines(<a href="https://www.runoob.com/python3/python3-string-splitlines.html">keepends])</a> 按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</td></tr><tr><td align="left">33</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-startswith.html">startswith(substr, beg=0,end=len(string))</a> 检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。</td></tr><tr><td align="left">34</td><td align="left">[strip(<a href="https://www.runoob.com/python3/python3-string-strip.html">chars])</a> 在字符串上执行 lstrip()和 rstrip()</td></tr><tr><td align="left">35</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-swapcase.html">swapcase()</a> 将字符串中大写转换为小写，小写转换为大写</td></tr><tr><td align="left">36</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-title.html">title()</a> 返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td></tr><tr><td align="left">37</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-translate.html">translate(table, deletechars=””)</a> 根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中</td></tr><tr><td align="left">38</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-upper.html">upper()</a> 转换字符串中的小写字母为大写</td></tr><tr><td align="left">39</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-zfill.html">zfill (width)</a> 返回长度为 width 的字符串，原字符串右对齐，前面填充0</td></tr><tr><td align="left">40</td><td align="left"><a href="https://www.runoob.com/python3/python3-string-isdecimal.html">isdecimal()</a> 检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。</td></tr></tbody></table><h2 id="二、列表"><a href="#二、列表" class="headerlink" title="二、列表"></a>二、列表</h2><p>与Python字符串不一样的是，列表中的元素是可以改变的，如 a[2:5] = [13, 14, 15]。</p><p>Python包含以下函数:</p><table><thead><tr><th align="left">序号</th><th align="left">函数</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-len.html">len(list)</a> 列表元素个数</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-max.html">max(list)</a> 返回列表元素最大值</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-min.html">min(list)</a> 返回列表元素最小值</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(seq)</a> 将元组转换为列表</td></tr></tbody></table><p>Python包含以下方法:</p><table><thead><tr><th align="left">序号</th><th align="left">方法</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-append.html">list.append(obj)</a> 在列表末尾添加新的对象</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-count.html">list.count(obj)</a> 统计某个元素在列表中出现的次数</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-extend.html">list.extend(seq)</a> 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-index.html">list.index(obj)</a> 从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-insert.html">list.insert(index, obj)</a> 将对象插入列表</td></tr><tr><td align="left">6</td><td align="left">[list.pop(<a href="https://www.runoob.com/python3/python3-att-list-pop.html">index=-1])</a> 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-remove.html">list.remove(obj)</a> 移除列表中某个值的第一个匹配项</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-reverse.html">list.reverse()</a> 反向列表中元素</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-sort.html">list.sort( key=None, reverse=False)</a> 对原列表进行排序</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-clear.html">list.clear()</a> 清空列表</td></tr><tr><td align="left">11</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-copy.html">list.copy()</a> 复制列表</td></tr></tbody></table><h2 id="三、字典"><a href="#三、字典" class="headerlink" title="三、字典"></a>三、字典</h2><p>Python字典包含了以下内置函数：</p><table><thead><tr><th align="left">序号</th><th align="left">函数及描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">len(dict) 计算字典元素个数，即键的总数。</td><td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; len(tinydict) 3</code></td></tr><tr><td align="left">2</td><td align="left">str(dict) 输出字典，可以打印的字符串表示。</td><td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; str(tinydict) &quot;&#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Class&#39;: &#39;First&#39;, &#39;Age&#39;: 7&#125;&quot;</code></td></tr><tr><td align="left">3</td><td align="left">type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。</td><td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; type(tinydict) &lt;class &#39;dict&#39;&gt;</code></td></tr></tbody></table><p>Python字典包含了以下内置方法：</p><table><thead><tr><th align="left">序号</th><th align="left">函数及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-clear.html">radiansdict.clear()</a> 删除字典内所有元素</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-copy.html">radiansdict.copy()</a> 返回一个字典的浅复制</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-fromkeys.html">radiansdict.fromkeys()</a> 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-get.html">radiansdict.get(key, default=None)</a> 返回指定键的值，如果键不在字典中返回 default 设置的默认值</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-in.html">key in dict</a> 如果键在字典dict里返回true，否则返回false</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-items.html">radiansdict.items()</a> 以列表返回一个视图对象</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-keys.html">radiansdict.keys()</a> 返回一个视图对象</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-setdefault.html">radiansdict.setdefault(key, default=None)</a> 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-update.html">radiansdict.update(dict2)</a> 把字典dict2的键/值对更新到dict里</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-values.html">radiansdict.values()</a> 返回一个视图对象</td></tr><tr><td align="left">11</td><td align="left">pop(key[<a href="https://www.runoob.com/python3/python3-att-dictionary-pop.html">,default])</a> 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-popitem.html">popitem()</a> 返回并删除字典中的最后一对键和值。</td></tr></tbody></table><p>摘抄自：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于编码方式的总结</title>
      <link href="/2022/01/14/%E5%85%B3%E4%BA%8E%E7%BC%96%E7%A0%81/"/>
      <url>/2022/01/14/%E5%85%B3%E4%BA%8E%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="各类编码总结"><a href="#各类编码总结" class="headerlink" title="各类编码总结"></a>各类编码总结</h1><h2 id="一、ascii、UTF-8、gbk"><a href="#一、ascii、UTF-8、gbk" class="headerlink" title="一、ascii、UTF-8、gbk"></a>一、ascii、UTF-8、gbk</h2><h3 id="1、ascii码"><a href="#1、ascii码" class="headerlink" title="1、ascii码"></a>1、ascii码</h3><p>ASCII 码一共规定了128个字符的编码：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/v2-976d8be2a77238a37736be97bac66497_r.jpg" alt="preview"></p><h3 id="2、UTF-8、UTF-16、UTF-32"><a href="#2、UTF-8、UTF-16、UTF-32" class="headerlink" title="2、UTF-8、UTF-16、UTF-32"></a>2、UTF-8、UTF-16、UTF-32</h3><p><em>utf（Unicode Transformation Format）</em></p><h4 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8:"></a>UTF-8:</h4><p>​    utf-8是unicode的实现方法。其编码规则如下：</p><blockquote><p>1）对于单字节的符号：字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的；</p><p>2）对于n字节的符号（n &gt; 1）：第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/v2-6c143515986d542f67de787d85131ea9_r.jpg" alt="preview"></p><p><strong>举例说明：</strong></p><p>选择汉字“鲁”，在<code>unicode</code>官网查询其编码为<code>U+9C81</code></p><p>转换为二级制数字即为：1001 1100 1000 0001，大小两字节。</p><p>​    根据上表，“鲁”字在第三个范围内，其表示即为1110xxxx 10xxxxxx 10xxxxxx，故将前文中的二进制数字填入，即为：11101001 10110010 10000001，再转换为十六进制，即为E9B281。</p><p><strong>特征码：</strong></p><p><em>BOM（byte order mark）</em></p><p>​    在较早的Windows环境下，系统为了能够识别UTF-8这一编码格式，为UTF-8添加了<u>代表其格式的EF BB BF三位特征码（BOM）</u>，而后较高的Windows版本中，系统默认使用UTF-8这一编码格式，不再添加特征码(BOM)。经实验，若将XP环境下创建的、带有BOM的文件在Win10下打开，右下角会显示“带有BOM的UTF-8”字样，文件依然可以正常操作。</p><p><strong>优点、缺点</strong></p><p>缺点：</p><pre><code> 1. 英语国家用起来省空间，其他国家（语言）反而更费空间（汉字有可能需要三个字节） 2. 变长的储存方式导致执行索引效率低，有时需要转化为`UTF-16`或者`UTF-32`</code></pre><p>优点：</p><pre><code>1. 字符空间大于UTF-16；1. 不存在大小端序；1. 容错率高，容易检查出错误；</code></pre><h4 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16:"></a>UTF-16:</h4><p>即，使用两字节表示unicode的编码方法，有以下几个问题：</p><ol><li>大小端序的设置容易导致乱码；</li><li>两字节只能表示六万多个字符，不够用；</li><li>容错低，一处出错，后面全错；</li></ol><p><strong>端序：</strong></p><p>指字符按照什么顺序储存，与编码后内容一样即大端序，相反则小端序。</p><p>试举一例，一个“奎”的Unicode编码是594E，“乙”的Unicode编码是4E59。如果我们收到UTF-16字节流“594E”，那么这是“奎”还是“乙”？如果BOM是大端序，那么代码点就应该是594E，那么就是“奎”，如果BOM是小端序，那么代码点就应该是4E59，就是“乙”了。</p><h4 id="UTF-32："><a href="#UTF-32：" class="headerlink" title="UTF-32："></a>UTF-32：</h4><p>使用四字节表示Unicode的编码方式，占空间比较大。</p><h4 id="特征码（附）："><a href="#特征码（附）：" class="headerlink" title="特征码（附）："></a>特征码（附）：</h4><blockquote><p>有编码对应的开头标志：</p><p><code>EF BB BF　　　 UTF-8 FE FF　　　　 　UTF-16/UCS-2, little endian FF FE　　　　 　UTF-16/UCS-2, big endian FF FE 00 00　　UTF-32/UCS-4, little endian. 00 00 FE FF　　UTF-32/UCS-4, big-endian.</code></p></blockquote><h3 id="3、GBK-GB2312"><a href="#3、GBK-GB2312" class="headerlink" title="3、GBK/GB2312"></a>3、GBK/GB2312</h3><blockquote><p>​    GB全称GuoBiao国标，GBK全称GuoBiaoKuozhan国标扩展。GB18030编码兼容GBK，GBK兼容GB2312，其实这三种编码有着非常深厚的渊源，我们放在一起进行比较。 【GB2312】最早一版的中文编码，每个字占据2bytes。由于要和ASCII兼容，那这2bytes最高位不可以为0了(否则和ASCII会有冲突)。在GB2312中收录了6763个汉字以及682个特殊符号，已经囊括了生活中最常用的所有汉字。</p></blockquote><p>​    总结来说，GBK就是两个字节组成的汉字字符集，同时其通过不让第一个字节为0的方式来兼容ascii码。实际上，有很多比较生僻的名字打不出来就是由于未被GB2312收录的原因。</p><p><strong>全角&amp;半角</strong>：</p><p>在GBK中，也收录了一些数字和字母，即ascii表中有的字母和数字，被GBK又收录了一遍。</p><p><u>那么，当我们直接使用ASCII码，用一个字节来表示数字和字母，就称之为<strong>半角</strong>；</u></p><p><u>若使用GBK中收录的那份数字和字母，用两个字节来表示数字和字母，就称之为<strong>全角</strong>；</u></p><p>通常我们使用半角，因为全角可能在编程过程中导致编译器不认识。</p><p><strong>big5</strong></p><p>big5是台湾搞出来的一种包括繁体的编码方式，与GBK不兼容。</p><p><strong>GB18030</strong></p><p>为了收录比GBK还多的汉字，使用四个字节来表示一个汉字，越来越复杂。</p><p>​    由于汉字编码方式不断迭代，迭代的同时又要保持兼容，GBK和GB2312比ASCII多出来的字都是2bytes，GB18030比GBK多出来的字都是4bytes，而ASCII、GB2312、GBK、GB18030直接有需要保持兼容性，最终就形成了被人诟病的国标汉字编码形式，具体可以参考下图：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/20645acf6cdf2aa38922bcfbeb676922.png" alt="20645acf6cdf2aa38922bcfbeb676922.png"></p><h2 id="二、乱码的来源"><a href="#二、乱码的来源" class="headerlink" title="二、乱码的来源"></a>二、乱码的来源</h2><h3 id="1、Unicode与国标的不兼容性"><a href="#1、Unicode与国标的不兼容性" class="headerlink" title="1、Unicode与国标的不兼容性"></a>1、Unicode与国标的不兼容性</h3><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/a74eccea4783314561c09e8b3100eb65.png" alt="a74eccea4783314561c09e8b3100eb65.png"></p><p>只兼容ASCII部分。</p><h3 id="2、锟斤拷"><a href="#2、锟斤拷" class="headerlink" title="2、锟斤拷"></a>2、锟斤拷</h3><p>虽然<code>Unicode</code>号称万国码，但是依然有未收录的字符，同时每个地区或操作系统对字符的支持程度也是不同的，因此在<code>Unicode</code>中就有一个特殊字符来代表未知字符：�</p><p>它的<code>Unicode</code>编码为<code>0xFFFD</code>。</p><p>将其<code>Unicode</code>编码转化为<code>UTF-8</code>后，十六进制表示为<code>0xEF 0XBF 0XBD</code></p><p>若同时出现两个乱码符号，转化为十六进制就是<code>0xEF 0XBF 0XBD 0xEF 0XBF 0XBD</code></p><p>这时候再将其强行转码为<code>GBK</code>编码，因为GBK中用两个字节表示一个字符，那么上述的字符就成了<strong>锟</strong>（0xEFBF），<strong>斤</strong>（0xBDEF），<strong>拷</strong>（0xBFBD）。</p><h3 id="3、烫烫烫、屯屯屯、葺葺葺（qi四声）"><a href="#3、烫烫烫、屯屯屯、葺葺葺（qi四声）" class="headerlink" title="3、烫烫烫、屯屯屯、葺葺葺（qi四声）"></a>3、烫烫烫、屯屯屯、葺葺葺（qi四声）</h3><p>Visual Studio中，未初始化的栈空间（即静态分配的空间）用0xCC填充，而未初始化的堆空间（即动态分配的空间）用0xCD填充。</p><p>而0xCCCC和0xCDCD在中文GB2312编码中分别对应“烫”字和“屯”字。</p><p>如果一个字符串没有结束符’\0’，输出时就会打印出未初始化的栈或堆空间的内容，这就是大名鼎鼎的“烫烫烫”、“屯屯屯”乱码。</p><p>而分配了，又被删除的内存，使用0xDDDD来填充，对应“葺”字。</p><h2 id="三、base-XX编码是什么"><a href="#三、base-XX编码是什么" class="headerlink" title="三、base XX编码是什么"></a>三、base XX编码是什么</h2><h3 id="1、base-64、32、16编码流程"><a href="#1、base-64、32、16编码流程" class="headerlink" title="1、base 64、32、16编码流程"></a>1、base 64、32、16编码流程</h3><p>例如要被编码的字符串是：<code>ILU</code></p><ol><li><p>第一步：将 <code>ILU</code> 字符串中的每一个字符转为对应于 <code>Ascii</code> 编码表的值，I = 73, L = 76, U = 85。</p></li><li><p>第二步：将第一步中的 <code>Ascii</code> 值分别转为对应的<code>二进制</code>格式，要求必须是造成<code>8bit</code>，不足8比特位高位补0。例如：1 的二进制是 1，明显不够8位，最终应该显示为:<code>0000 0001</code>。<code>ILU</code> 的转化结果以下：</p><blockquote><p>73 = 01001001</p></blockquote><blockquote><p>76 = 01001100</p></blockquote><blockquote><p>85 = 01010101</p></blockquote></li><li><p>第三步：根据<code>base X</code>(这里的 X 表明 16，32，64等编号) 编码算法中所指定的<code>y 个 bit 位为一个字符在表格中的下标</code> 的规则，对第2步的进行划分。例如 <code>base 16</code>的规则要求，4位做为一个下标对应一个字符，即每4个位为一部分，故划分以下：</p><blockquote><p>第1部分：0100 是 (73 = 01001001，的前4个位)</p></blockquote><blockquote><p>第2部分：1001 是 (73 = 01001001，的后4个位)</p></blockquote><blockquote><p>第3部分：0100</p></blockquote><blockquote><p>第4部分：1100</p></blockquote><blockquote><p>第5部分：0101</p></blockquote><blockquote><p>第6部分：0101</p></blockquote></li><li><p>第四步：将第三步中划分出的<code>每一个部分</code>进行<code>10进制转换</code>，得出对应于10进制数的<code>下标值</code>，以下：</p><blockquote><p>0100 = 4，1001 = 9，4，12，5，5</p></blockquote></li><li><p>第五步：最后一步，将第4步中得出的<code>下标数</code>去<code>查表</code>，得出对应的字符，<code>连在一块儿，就是编码结果</code></p></li></ol><p>​    总结来说，对于16、32、64的<code>base X</code>编码，将内容转化为二进制，分别按<code>4、5、6</code>位分组，然后转化为字符形式即可，其中：</p><table><thead><tr><th align="center">名称</th><th align="left">下标数字的位个数</th><th align="left">编码表字符串</th><th align="left">位数不足是否会补全 =</th></tr></thead><tbody><tr><td align="center">base 16</td><td align="left">4</td><td align="left">数字0<del>9 和 字母 A</del>F</td><td align="left">不会，位数恰好是 4 的倍数</td></tr><tr><td align="center">base 32</td><td align="left">5</td><td align="left">大写字母A<del>Z 和 数字2</del>7</td><td align="left">会</td></tr><tr><td align="center">base 64</td><td align="left">6</td><td align="left">大写字母A<del>Z，小写字母a</del>z，数字0~9以及”+”，”/“</td><td align="left">会</td></tr></tbody></table><p>​    在编码后，base 16的字符数量会变为两倍；base 32会变为5/8倍；base 64会变为4/3倍。</p><h3 id="2、对base-2-n-编码尝试进行计算"><a href="#2、对base-2-n-编码尝试进行计算" class="headerlink" title="2、对base 2^n 编码尝试进行计算"></a>2、对base 2^n 编码尝试进行计算</h3><p>以字符串<code>Lhl_2507</code>为例：</p><p>以<code>utf-8</code>的形式编码为<code>十六进制</code>：<code>4c686c5f32353037</code>；</p><p>转化为二进制数：<code>0100 1100 0110 1000 0110 1100 0101 1111 0011 0010 0011 0101 0011 0000 0011 0111</code>；</p><p>然后分别按照4、5、6位分组：</p><p>​    其中base 16的结果就等同于<code>utf-8</code>的十六进制格式：<code>4c686c5f32353037</code>；</p><p>​    按照<code>五位</code>分组：<code>01001 10001 10100 00110 11000 10111 11001 10010 00110 10100 11000 00011 0111</code></p><p>​    按照<code>A~Z 2~7</code>分别对应<code>0~31</code>(五位二进制转十进制)，进行转化：<code>JRUGYXZSGUYD</code>为前十二位</p><p>​    最后一位需要补全，先补<code>0</code>变为二进制<code>01110</code>对应base 32中的<code>O</code></p><p>​    为了与十六进制统一，需要补充<code>=</code>作为字符数量，前面<code>5*4=20</code>的组合有三组，最后多余一组，因此补充三个<code>=</code></p><p>​    最终结果为<code>JRUGYXZSGUYDO===</code></p><p>​    base 64与base 32思路相同</p><p>​    其64位数分别对应<code> A~Z a~z 0~9 + /</code>用来对应0~63的十进制数</p><p>​    转化结果为<code>TGhsXzI1MDc=</code></p><h3 id="3、非2-n的base-XX编码"><a href="#3、非2-n的base-XX编码" class="headerlink" title="3、非2^n的base XX编码"></a>3、非2^n的base XX编码</h3><h4 id="base-58编码："><a href="#base-58编码：" class="headerlink" title="base 58编码："></a>base 58编码：</h4><blockquote><p>​    base58编码去掉了几个看起来会产生歧义的字符，如 0 (零), O (大写字母O), I (大写的字母i) and l (小写的字母L) ，和几个影响双击选择的字符，如/, +。结果字符集正好58个字符(包括9个数字，24个大写字母，25个小写字母)。</p><p>​    同时，由于58 不是2的整次幂，所以无法使用类似base64编码中使用直接截取3个字符转4个字符（3*8=4*6 , 2的6次方刚好64）的方法进行转换，而是采用我们数学上经常使用的进制转换方法——辗转相除法（本质上，base64编码是64进制，base58是58进制）。看下base58的编码表：</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/20180620000601834" alt="img"></p><p>​    试举一例，若要将<code>Lhl</code>字符在utf-8编码下转化为base 58的形式：</p><p>​    转化为十六进制：<code>4c686c</code></p><p>​    十六进制转十进制：<code>5007468</code></p><p>​    十进制转58进制：辗转相除，然后将<code>58进制数字</code>转化为上表的表示形式即可。</p><p>​    结果为：<code>E3QvX8qx</code></p><h4 id="base-91编码："><a href="#base-91编码：" class="headerlink" title="base 91编码："></a>base 91编码：</h4><blockquote><p>​    base91是一种将二进制数据编码为ASCII字符的高级方法。它类似于uuencode或base64，但效率更高。base91产生的开销取决于输入数据。它的数量最多为23%（而base64为33%），其范围可以降低到14%，这通常发生在0字节块上。这使得base91在通过电子邮件或终端线路等二进制不安全连接传输较大文件时非常有用。</p><p>​    顾名思义，base91需要91个字符来表示用ASCII编码的二进制数据。在94个可打印的ASCII字符（0x21-0x7e）中，以下三个字符被省略以构建base91字母表：</p><p>​    -（破折号，0x2d）</p><p>​    \（反斜杠，0x5C）</p><p>​    ‘（撇号，0x27）</p><p>​    翻译表由如下所示的其余字符组成。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/20190816091541986.png" alt="img"></p><p>引用（参考）：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pikachu_命令执行</title>
      <link href="/2022/01/11/PIKACHU%E9%80%9A%E5%85%B3_DAY2_%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
      <url>/2022/01/11/PIKACHU%E9%80%9A%E5%85%B3_DAY2_%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="PIKACHU通关-命令执行"><a href="#PIKACHU通关-命令执行" class="headerlink" title="PIKACHU通关_命令执行"></a>PIKACHU通关_命令执行</h1><p>一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口。<br>比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上<br>一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。 但是如果设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器。</p><h2 id="命令连接符"><a href="#命令连接符" class="headerlink" title="命令连接符"></a>命令连接符</h2><p>windows系统和<a href="https://so.csdn.net/so/search?q=linux">linux</a>系统各有4个，其中3个是共有的，各有1个是特有的：</p><ul><li>windows系统：| 、||、&amp;&amp;、&amp;</li><li>linux系统：| 、||、&amp;&amp;、;</li></ul><p>总结一下各连接符号的作用：</p><ol><li> |    管道符，用于把前一个命令的输出作为下一个命令的输入；</li><li> || 逻辑或，只有前一个命令成功，后一个就不执行，反之后一个执行；</li><li> &amp;&amp;逻辑与，只有前一个执行成功才执行后一个，否则不执行；</li><li> &amp; Windows独有，顺序执行每一条命令；</li><li> ；Linux独有，顺序执行每一条命令；</li></ol><h2 id="测试常用命令"><a href="#测试常用命令" class="headerlink" title="测试常用命令"></a>测试常用命令</h2><p><code>whoami</code>命令（Who am i），用于区分Windows和Linux环境：</p><p>（前者有两个参数，用”\“隔开，后者只显示用户名）</p><h2 id="PIKACHU-exec’ping’"><a href="#PIKACHU-exec’ping’" class="headerlink" title="PIKACHU_exec’ping’"></a>PIKACHU_exec’ping’</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111170123070.png" alt="image-20220111170123070"></p><p>没有任何过滤，随便乱杀。</p><h2 id="PIKACHU-exec’eval’"><a href="#PIKACHU-exec’eval’" class="headerlink" title="PIKACHU_exec’eval’"></a>PIKACHU_exec’eval’</h2><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111210928950.png" alt="image-20220111210928950"></p><p>一样没有任何过滤，可以直接使用<code>phpinfo();</code>进行测试，</p><p>或者构造payload<code>fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php assert($_POST[lhl_2507]);?&gt;&#39;);</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pikachu_暴力破解</title>
      <link href="/2022/01/11/PIKACHU%E9%80%9A%E5%85%B3_DAY1_%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/"/>
      <url>/2022/01/11/PIKACHU%E9%80%9A%E5%85%B3_DAY1_%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="PIKACHU通关-暴力破解"><a href="#PIKACHU通关-暴力破解" class="headerlink" title="PIKACHU通关_暴力破解"></a>PIKACHU通关_暴力破解</h1><p>暴力破解需要将表单传到 <strong>Intruder</strong>(入侵者)模块</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111100429372.png" alt="image-20220111100429372"></p><p>在这里记录一下四种四种<strong>AttackType</strong>:</p><ul><li><p><strong>Sinper</strong>（狙击手）:</p><p>输入一个字典，分别对每一个被标记的位置用此字典遍历。</p></li><li><p><strong>Battering ram</strong>（攻城槌）：</p><p>输入一个字典，同时对每一个被标记的位置用此字典遍历。</p></li><li><p><strong>Pitchfork</strong>（干草叉）</p><p>输入多个字典，按照顺序，从上到下对应遍历。（以最短的字典长度为遍历次数）</p></li><li><p><strong>Cluster bomb</strong>（集束炸弹）</p><p>输入多个字典，遍历所有可能性，排列组合。</p></li></ul><h2 id="第一关——普通爆破"><a href="#第一关——普通爆破" class="headerlink" title="第一关——普通爆破"></a>第一关——普通爆破</h2><p>回到暴力破解，我们使用<strong>Cluster bomb</strong>进行字典爆破：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111103021323.png" alt="image-20220111103021323"></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111103527752.png" alt="image-20220111103527752"></p><p>分别对用户名和密码的爆破上传字典，<strong>若用户名和密码有特殊字符需求，不勾选URL-encoding:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111103740053.png" alt="image-20220111103740053"></p><p>点击开始爆破，观察返回报文的长短即可。</p><h2 id="第二关——绕过验证码（ON-SERVER）"><a href="#第二关——绕过验证码（ON-SERVER）" class="headerlink" title="第二关——绕过验证码（ON SERVER）"></a>第二关——绕过验证码（ON SERVER）</h2><p><strong>观察：</strong></p><p>发现页面首先验证验证码的正确性，然后验证用户名和密码。</p><p>同时进行抓包，发现验证码是后端验证。</p><p>但是本关的问题在于，只要不点击网页上的login按钮，验证码就不会刷新，因此使用发包的方式一直爆破即可。</p><p><strong>源码分析：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111111050870.png" alt="image-20220111111050870"></p><p>其一，在验证后，应重置验证码。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111111359414.png" alt="image-20220111111359414"></p><p>其二，不应将验证码作为cookie返回前端</p><h2 id="第三关——绕过验证码（ON-CLIENT）"><a href="#第三关——绕过验证码（ON-CLIENT）" class="headerlink" title="第三关——绕过验证码（ON CLIENT）"></a>第三关——绕过验证码（ON CLIENT）</h2><p>右键查看源代码：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111144849999.png" alt="image-20220111144849999"></p><p>发现验证码在前端验证。</p><h2 id="第四关——token防止爆破"><a href="#第四关——token防止爆破" class="headerlink" title="第四关——token防止爆破"></a>第四关——token防止爆破</h2><p>添加了token防止爆破，抓包进行观察，可以发现返回的包中含有下一次的token值。</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111145923138.png" alt="image-20220111145923138"></p><p>因此，我们使用正则提取出token强行爆破：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111150453621.png" alt="image-20220111150453621"></p><p>使用正则表达式（Recursive grep）进行匹配，正则添加方法如下：</p><p><img src="https://cdn.jsdelivr.net/gh/lhl7/My_pics/Typora/image-20220111150832658.png" alt="image-20220111150832658"></p><p>可以使用右边的Refetch response按钮确认报文中有多少符合此正则的位置。</p><p>因此可见，使用token防爆破还是没啥用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Nmap使用笔记</title>
      <link href="/2022/01/08/Nmap%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/01/08/Nmap%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="NMAP使用笔记"><a href="#NMAP使用笔记" class="headerlink" title="NMAP使用笔记"></a>NMAP使用笔记</h1><p>NMAP的作用是在信息收集阶段进行端口扫描。</p><h2 id="一、端口扫描："><a href="#一、端口扫描：" class="headerlink" title="一、端口扫描："></a>一、端口扫描：</h2><p>要给sudo权限</p><p><code>namp xx.com -p 80 -sS</code>（syn扫描方式）</p><p>此外还有-sS/sT/sA/sW/sM 分别对应SYN/Connect()/ACK/window/Maimon</p><p>-sU对应UDP</p><p>-sN/sF/sX对应TCP null/FIN/Xmas</p><p>加 <code>-sV -O</code>可以扫描主机版本 ，操作系统等等信息</p><p><code>namp xx.com -p 80 -A</code>效果相同（推荐） </p><p>扫描所有端口：<code>namp xx.com -A -sS</code>(不讲武德，推荐) </p><p>使用<code> -iR</code>随机扫描域名</p><p>扫描五个最常见的端口 <code>nmap xx.com --top-ports 5</code></p><p>输出到文件<code>-oN [文件路径+文件名]</code></p><p>脚本扫描<code>--script=[文件路径./...+文件名]</code></p><h2 id="二、防火墙欺骗："><a href="#二、防火墙欺骗：" class="headerlink" title="二、防火墙欺骗："></a>二、防火墙欺骗：</h2><p><code>-D1.1.1.1,2.2.2.2</code>冒充其他IP发包（伪造IP）</p><p><code>-g996</code>冒充其他源端口号（伪造端口）</p><p><code>--spoof-mac [MAC地址]</code>冒充其他mac地址</p><p><code> namp -iflist</code>输出正在使用的网络信息</p><p>还可以使用空闲扫描，使用网络上其他的空闲主机进行扫描：</p><p>先发现空闲主机：<code>sudo nmap --script ipedseq -iR 1000 -oN ipidseq.txt</code>(扫描一千个主机，输出到文件)</p><p>扫描结束后，使用空闲主机的ip和端口，使用命令：</p><p><code>nmap -Pn -sI [空闲IP:空闲端口] [目标IP]</code></p><p>​    </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kali安装</title>
      <link href="/2022/01/06/kali%E8%A3%85%E6%9C%BA%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/01/06/kali%E8%A3%85%E6%9C%BA%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="kali装机过程"><a href="#kali装机过程" class="headerlink" title="kali装机过程"></a>kali装机过程</h2><p>磁盘管理</p><p>设别管理器</p><p>系统信息</p><p>下载系统iso文件 rufus 3.14 将内容刻录到u盘</p><p>关机开机后，按住F1</p><p>进入bios窗口，选Security  进入Security Boot 将Secure Boot改为Disabled</p><p>F10退出 按住F12 进入Boot Menu 选使用用来装机的USB设备，回车</p><p>进入kali界面，卡了一下，等待</p><p>图形化安装，选择语言和国家</p><p>安装完毕后，连接WIFI</p><p>磁盘分区，选择整个磁盘（前提是备份电脑中的所有内容），选择电脑（最大的）的磁盘</p><p>放在同一分区下，确定后选择“是”要更改</p><p>最后一步，直接重启，先不拔出USB</p><p>拔出USB后，需要对u盘重新分区，使用windows的diskpart命令和磁盘管理。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/04/hello-world/"/>
      <url>/2022/01/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
